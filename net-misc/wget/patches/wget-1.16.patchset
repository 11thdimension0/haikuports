From d95daf9cb193a1fad78540947f57e8737c170835 Mon Sep 17 00:00:00 2001
From: Jerome Duval <jerome.duval@gmail.com>
Date: Mon, 19 May 2014 15:38:37 +0000
Subject: apply wget-1.14.patch


diff --git a/configure.ac b/configure.ac
index 3cbe618..e617bb2 100644
--- a/configure.ac
+++ b/configure.ac
@@ -170,6 +170,7 @@ AC_HEADER_STDBOOL
 AC_CHECK_HEADERS(unistd.h sys/time.h)
 AC_CHECK_HEADERS(termios.h sys/ioctl.h sys/select.h utime.h sys/utime.h)
 AC_CHECK_HEADERS(stdint.h inttypes.h pwd.h wchar.h)
+AC_CHECK_HEADERS(arpa/inet.h)
 
 AC_CHECK_DECLS(h_errno,,,[#include <netdb.h>])
 
diff --git a/m4/wget.m4 b/m4/wget.m4
index 777e973..5a8b75d 100644
--- a/m4/wget.m4
+++ b/m4/wget.m4
@@ -88,6 +88,7 @@ AC_DEFUN([WGET_POSIX_CLOCK], [
 
 dnl Check whether we need to link with -lnsl and -lsocket, as is the
 dnl case on e.g. Solaris.
+dnl Haiku needs libnetwork
 
 AC_DEFUN([WGET_NSL_SOCKET], [
   dnl On Solaris, -lnsl is needed to use gethostbyname.  But checking
@@ -107,6 +108,8 @@ AC_DEFUN([WGET_NSL_SOCKET], [
     AC_CHECK_LIB(nsl, $wget_check_in_nsl)
   fi
   AC_CHECK_LIB(socket, socket)
+  AC_CHECK_LIB(network, gethostbyname)
+  AC_CHECK_LIB(network, socket)
 ])
 
 
diff --git a/src/config.h.in b/src/config.h.in
index 879ce64..22bd801 100644
--- a/src/config.h.in
+++ b/src/config.h.in
@@ -699,6 +699,9 @@
 /* Define to 1 if you have the <langinfo.h> header file. */
 #undef HAVE_LANGINFO_H
 
+/* Define to 1 if you have the `bind' library (-lbind). */
+#undef HAVE_LIBBIND
+
 /* Define to 1 if you have the `dl' library (-ldl). */
 #undef HAVE_LIBDL
 
@@ -711,6 +714,9 @@
 /* Define to 1 if you have the <libintl.h> header file. */
 #undef HAVE_LIBINTL_H
 
+/* Define to 1 if you have the `network' library (-lnetwork). */
+#undef HAVE_LIBNETWORK
+
 /* Define to 1 if you have the `nsl' library (-lnsl). */
 #undef HAVE_LIBNSL
 
diff --git a/src/connect.c b/src/connect.c
index 1fb1819..f2c832b 100644
--- a/src/connect.c
+++ b/src/connect.c
@@ -46,7 +46,7 @@ as that of the covered work.  */
 #  include <netdb.h>
 # endif /* def __VMS [else] */
 # include <netinet/in.h>
-# ifndef __BEOS__
+# ifdef HAVE_ARPA_INET_H
 #  include <arpa/inet.h>
 # endif
 #endif /* not WINDOWS */
diff --git a/src/host.h b/src/host.h
index 84f3d13..e664e7f 100644
--- a/src/host.h
+++ b/src/host.h
@@ -42,9 +42,9 @@ as that of the covered work.  */
 # endif /* def __VMS [else] */
 # include <sys/socket.h>
 # include <netinet/in.h>
-#ifndef __BEOS__
-# include <arpa/inet.h>
-#endif
+# ifdef HAVE_ARPA_INET_H
+#  include <arpa/inet.h>
+# endif
 #endif
 
 struct url;
-- 
1.8.3.4


From 429d0bbb2c9d1243d009df399045028cc062684e Mon Sep 17 00:00:00 2001
From: Jerome Duval <jerome.duval@gmail.com>
Date: Mon, 19 May 2014 15:47:24 +0000
Subject: apply and augment wget-1.14-build-fixes.patch


diff --git a/src/ftp-basic.c b/src/ftp-basic.c
index b6e67e2..61cf7a4 100644
--- a/src/ftp-basic.c
+++ b/src/ftp-basic.c
@@ -965,8 +965,6 @@ ftp_list (int csock, const char *file, bool avoid_list_a, bool avoid_list,
   bool ok = false;
   size_t i = 0;
 
-  *list_a_used = false;
-
   /* 2013-10-12 Andrea Urbani (matfanjol)
      For more information about LIST and "LIST -a" please look at ftp.c,
      function getftp, text "__LIST_A_EXPLANATION__".
@@ -975,7 +973,9 @@ ftp_list (int csock, const char *file, bool avoid_list_a, bool avoid_list,
      later "i" variable.  */
   const char *list_commands[] = { "LIST -a",
                                   "LIST" };
+  *list_a_used = false;
 
+  
   if (avoid_list_a)
     {
       i = countof (list_commands)- 1;
diff --git a/src/html-url.c b/src/html-url.c
index 903864e..ebeb382 100644
--- a/src/html-url.c
+++ b/src/html-url.c
@@ -790,6 +790,7 @@ get_urls_file (const char *file)
       char *url_text;
       struct urlpos *entry;
       struct url *url;
+      char *new_url;
 
       const char *line_beg = text;
       const char *line_end = memchr (text, '\n', text_end - text);
@@ -822,7 +823,7 @@ get_urls_file (const char *file)
           url_text = merged;
         }
 
-      char *new_url = rewrite_shorthand_url (url_text);
+      new_url = rewrite_shorthand_url (url_text);
       if (new_url)
         {
           xfree (url_text);
diff --git a/src/http.c b/src/http.c
index 4b99c17..5ecf43b 100644
--- a/src/http.c
+++ b/src/http.c
@@ -1532,6 +1532,7 @@ read_response_body (struct http_stat *hs, int sock, FILE *fp, wgint contlen,
   int warc_payload_offset = 0;
   FILE *warc_tmp = NULL;
   int warcerr = 0;
+  int flags;
 
   if (opt.warc_filename != NULL)
     {
@@ -1568,7 +1569,7 @@ read_response_body (struct http_stat *hs, int sock, FILE *fp, wgint contlen,
     }
 
   /* Read the response body.  */
-  int flags = 0;
+  flags = 0;
   if (contlen != -1)
     /* If content-length is present, read that much; otherwise, read
        until EOF.  The HTTP spec doesn't require the server to
@@ -1673,6 +1674,7 @@ static uerr_t
 gethttp (struct url *u, struct http_stat *hs, int *dt, struct url *proxy,
          struct iri *iri, int count)
 {
+  int warc_tmp_written;
   struct request *req;
 
   char *type;
@@ -2141,10 +2143,11 @@ gethttp (struct url *u, struct http_stat *hs, int *dt, struct url *proxy,
           if (write_error >= 0 && warc_tmp != NULL)
             {
               /* Remember end of headers / start of payload. */
+              int warc_tmp_written;
               warc_payload_offset = ftello (warc_tmp);
 
               /* Write a copy of the data to the WARC record. */
-              int warc_tmp_written = fwrite (opt.body_data, 1, body_data_size, warc_tmp);
+              warc_tmp_written = fwrite (opt.body_data, 1, body_data_size, warc_tmp);
               if (warc_tmp_written != body_data_size)
                 write_error = -2;
             }
@@ -2325,6 +2328,7 @@ read_header:
 
   if (statcode == HTTP_STATUS_UNAUTHORIZED)
     {
+      uerr_t auth_err;
       /* Authorization is required.  */
 
       /* Normally we are not interested in the response body.
@@ -2363,7 +2367,7 @@ read_header:
         }
 
       pconn.authorized = false;
-      uerr_t auth_err = RETROK;
+      auth_err = RETROK;
       if (!auth_finished && (user && passwd))
         {
           /* IIS sends multiple copies of WWW-Authenticate, one with
diff --git a/src/main.c b/src/main.c
index 1ada822..a72249d 100644
--- a/src/main.c
+++ b/src/main.c
@@ -987,13 +987,18 @@ main (int argc, char **argv)
   int i, ret, longindex;
   int nurl;
   bool append_to_log = false;
+  struct ptimer *timer;
+  double start_time;
+  int arglen;
+  int argstring_length;
+  char *p;
 
   total_downloaded_bytes = 0;
 
   program_name = argv[0];
 
-  struct ptimer *timer = ptimer_new ();
-  double start_time = ptimer_measure (timer);
+  timer = ptimer_new ();
+  start_time = ptimer_measure (timer);
 
   i18n_initialize ();
 
@@ -1015,10 +1020,10 @@ main (int argc, char **argv)
 #endif
 
   /* Construct the arguments string. */
-  int argstring_length = 1;
+  argstring_length = 1;
   for (i = 1; i < argc; i++)
     argstring_length += strlen (argv[i]) + 2 + 1;
-  char *p = program_argstring = malloc (argstring_length * sizeof (char));
+  p = program_argstring = malloc (argstring_length * sizeof (char));
   if (p == NULL)
     {
       fprintf (stderr, _("Memory allocation problem\n"));
@@ -1027,7 +1032,7 @@ main (int argc, char **argv)
   for (i = 1; i < argc; i++)
     {
       *p++ = '"';
-      int arglen = strlen (argv[i]);
+      arglen = strlen (argv[i]);
       memcpy (p, argv[i], arglen);
       p += arglen;
       *p++ = '"';
@@ -1702,10 +1707,12 @@ outputting to a regular file.\n"));
       total_downloaded_bytes != 0)
     {
       double end_time = ptimer_measure (timer);
+      char *wall_time;
+      char *download_time;
       ptimer_destroy (timer);
 
-      char *wall_time = xstrdup (secs_to_human_time (end_time - start_time));
-      char *download_time = xstrdup (secs_to_human_time (total_download_time));
+      wall_time = xstrdup (secs_to_human_time (end_time - start_time));
+      download_time = xstrdup (secs_to_human_time (total_download_time));
       logprintf (LOG_NOTQUIET,
                  _("FINISHED --%s--\nTotal wall clock time: %s\n"
                    "Downloaded: %d files, %s in %s (%s)\n"),
diff --git a/src/retr.c b/src/retr.c
index 71b5c28..0c7c29f 100644
--- a/src/retr.c
+++ b/src/retr.c
@@ -378,8 +378,9 @@ fd_read_body (const char *downloaded_filename, int fd, FILE *out, wgint toread,
 
       if (ret > 0)
         {
+          int write_res;
           sum_read += ret;
-          int write_res = write_data (out, out2, dlbuf, ret, &skip, &sum_written);
+          write_res = write_data (out, out2, dlbuf, ret, &skip, &sum_written);
           if (write_res < 0)
             {
               ret = (write_res == -3) ? -3 : -2;
diff --git a/src/utils.c b/src/utils.c
index 78c282e..6a21164 100644
--- a/src/utils.c
+++ b/src/utils.c
@@ -64,7 +64,9 @@ as that of the covered work.  */
 #include <sys/stat.h>
 
 /* For TIOCGWINSZ and friends: */
+#ifndef __HAIKU__
 #include <sys/ioctl.h>
+#endif
 #include <termios.h>
 
 /* Needed for Unix version of run_with_timeout. */
diff --git a/src/warc.c b/src/warc.c
index 46459ac..fdef2d6 100644
--- a/src/warc.c
+++ b/src/warc.c
@@ -163,10 +163,11 @@ warc_write_buffer (const char *buffer, size_t size)
 static bool
 warc_write_string (const char *str)
 {
+  size_t n;
   if (!warc_write_ok)
     return false;
 
-  size_t n = strlen (str);
+  n = strlen (str);
   if (n != warc_write_buffer (str, n))
     warc_write_ok = false;
 
@@ -254,6 +255,8 @@ static bool
 warc_write_block_from_file (FILE *data_in)
 {
   /* Add the Content-Length header. */
+  char buffer[BUFSIZ];
+  size_t s;
   char content_length[MAX_INT_TO_STRING_LEN(off_t)];
   fseeko (data_in, 0L, SEEK_END);
   number_to_string (content_length, ftello (data_in));
@@ -266,8 +269,6 @@ warc_write_block_from_file (FILE *data_in)
     warc_write_ok = false;
 
   /* Copy the data in the file to the WARC record. */
-  char buffer[BUFSIZ];
-  size_t s;
   while (warc_write_ok && (s = fread (buffer, 1, BUFSIZ, data_in)) > 0)
     {
       if (warc_write_buffer (buffer, s) < s)
@@ -292,6 +293,12 @@ warc_write_end_record (void)
   /* We start a new gzip stream for each record.  */
   if (warc_write_ok && warc_current_gzfile)
     {
+      size_t result;
+      char static_header[GZIP_STATIC_HEADER_SIZE];
+      off_t current_offset;
+      off_t uncompressed_size;
+      off_t compressed_size;
+      char extra_header[EXTRA_GZIP_HEADER_SIZE];
       if (gzclose (warc_current_gzfile) != Z_OK)
         {
           warc_write_ok = false;
@@ -317,17 +324,16 @@ warc_write_end_record (void)
       */
 
       /* Calculate the uncompressed and compressed sizes. */
-      off_t current_offset = ftello (warc_current_file);
-      off_t uncompressed_size = current_offset - warc_current_gzfile_offset;
-      off_t compressed_size = warc_current_gzfile_uncompressed_size;
+      current_offset = ftello (warc_current_file);
+      uncompressed_size = current_offset - warc_current_gzfile_offset;
+      compressed_size = warc_current_gzfile_uncompressed_size;
 
       /* Go back to the static GZIP header. */
       fseeko (warc_current_file, warc_current_gzfile_offset
               + EXTRA_GZIP_HEADER_SIZE, SEEK_SET);
 
       /* Read the header. */
-      char static_header[GZIP_STATIC_HEADER_SIZE];
-      size_t result = fread (static_header, 1, GZIP_STATIC_HEADER_SIZE,
+      result = fread (static_header, 1, GZIP_STATIC_HEADER_SIZE,
                              warc_current_file);
       if (result != GZIP_STATIC_HEADER_SIZE)
         {
@@ -344,7 +350,6 @@ warc_write_end_record (void)
       fwrite (static_header, 1, GZIP_STATIC_HEADER_SIZE, warc_current_file);
 
       /* Prepare the extra GZIP header. */
-      char extra_header[EXTRA_GZIP_HEADER_SIZE];
       /* XLEN, the length of the extra header fields.  */
       extra_header[0]  = ((EXTRA_GZIP_HEADER_SIZE - 2) & 255);
       extra_header[1]  = ((EXTRA_GZIP_HEADER_SIZE - 2) >> 8) & 255;
@@ -661,13 +666,15 @@ warc_write_warcinfo_record (char *filename)
   /* Write warc-info record as the first record of the file. */
   /* We add the record id of this info record to the other records in the
      file. */
+  char timestamp[22];
+  char *filename_copy, *filename_basename;
+  FILE *warc_tmp;
+
   warc_current_warcinfo_uuid_str = (char *) malloc (48);
   warc_uuid_str (warc_current_warcinfo_uuid_str);
 
-  char timestamp[22];
   warc_timestamp (timestamp);
 
-  char *filename_copy, *filename_basename;
   filename_copy = strdup (filename);
   filename_basename = strdup (basename (filename_copy));
 
@@ -679,7 +686,7 @@ warc_write_warcinfo_record (char *filename)
   warc_write_header ("WARC-Filename", filename_basename);
 
   /* Create content.  */
-  FILE *warc_tmp = warc_tempfile ();
+  warc_tmp = warc_tempfile ();
   if (warc_tmp == NULL)
     {
       free (filename_copy);
@@ -729,6 +736,10 @@ warc_write_warcinfo_record (char *filename)
 static bool
 warc_start_new_file (bool meta)
 {
+  int base_filename_length;
+  char *new_filename;
+  const char *extension;
+
   if (opt.warc_filename == NULL)
     return false;
 
@@ -740,9 +751,9 @@ warc_start_new_file (bool meta)
 
   warc_current_file_number++;
 
-  int base_filename_length = strlen (opt.warc_filename);
+  base_filename_length = strlen (opt.warc_filename);
   /* filename format:  base + "-" + 5 digit serial number + ".warc.gz" */
-  char *new_filename = malloc (base_filename_length + 1 + 5 + 8 + 1);
+  new_filename = malloc (base_filename_length + 1 + 5 + 8 + 1);
   warc_current_filename = new_filename;
 
 #ifdef __VMS
@@ -752,9 +763,9 @@ warc_start_new_file (bool meta)
 #endif /* def __VMS [else] */
 
 #ifdef HAVE_LIBZ
-  const char *extension = (opt.warc_compression_enabled ? WARC_GZ : "warc");
+  extension = (opt.warc_compression_enabled ? WARC_GZ : "warc");
 #else
-  const char *extension = "warc";
+  extension = "warc";
 #endif
 
   /* If max size is enabled, we add a serial number to the file names. */
@@ -828,12 +839,13 @@ static bool
 warc_parse_cdx_header (char *lineptr, int *field_num_original_url,
                        int *field_num_checksum, int *field_num_record_id)
 {
+  char *token;
+  char *save_ptr;
+
   *field_num_original_url = -1;
   *field_num_checksum = -1;
   *field_num_record_id = -1;
 
-  char *token;
-  char *save_ptr;
   token = strtok_r (lineptr, CDX_FIELDSEP, &save_ptr);
 
   if (token != NULL && strcmp (token, "CDX") == 0)
@@ -877,10 +889,12 @@ warc_process_cdx_line (char *lineptr, int field_num_original_url,
 
   char *token;
   char *save_ptr;
+  int field_num;
+
   token = strtok_r (lineptr, CDX_FIELDSEP, &save_ptr);
 
   /* Read this line to get the fields we need. */
-  int field_num = 0;
+  field_num = 0;
   while (token != NULL)
     {
       char **val;
@@ -942,10 +956,7 @@ warc_process_cdx_line (char *lineptr, int field_num_original_url,
 static bool
 warc_load_cdx_dedup_file (void)
 {
-  FILE *f = fopen (opt.warc_cdx_dedup_filename, "r");
-  if (f == NULL)
-    return false;
-
+  FILE *f;
   int field_num_original_url = -1;
   int field_num_checksum = -1;
   int field_num_record_id = -1;
@@ -954,6 +965,10 @@ warc_load_cdx_dedup_file (void)
   size_t n = 0;
   ssize_t line_length;
 
+  f = fopen (opt.warc_cdx_dedup_filename, "r");
+  if (f == NULL)
+    return false;
+
   /* The first line should contain the CDX header.
      Format:  " CDX x x x x x"
      where x are field type indicators.  For our purposes, we only
@@ -981,6 +996,7 @@ _("CDX file does not list record ids. (Missing column 'u'.)\n"));
     }
   else
     {
+      int nrecords;
       /* Initialize the table. */
       warc_cdx_dedup_table = hash_table_new (1000, warc_hash_sha1_digest,
                                              warc_cmp_sha1_digest);
@@ -998,7 +1014,7 @@ _("CDX file does not list record ids. (Missing column 'u'.)\n"));
       while (line_length != -1);
 
       /* Print results. */
-      int nrecords = hash_table_count (warc_cdx_dedup_table);
+      nrecords = hash_table_count (warc_cdx_dedup_table);
       logprintf (LOG_VERBOSE, ngettext ("Loaded %d record from CDX.\n\n",
                                         "Loaded %d records from CDX.\n\n",
                                          nrecords),
@@ -1018,10 +1034,11 @@ _("CDX file does not list record ids. (Missing column 'u'.)\n"));
 static struct warc_cdx_record *
 warc_find_duplicate_cdx_record (char *url, char *sha1_digest_payload)
 {
+  struct warc_cdx_record *rec_existing;
   if (warc_cdx_dedup_table == NULL)
     return NULL;
 
-  struct warc_cdx_record *rec_existing
+  rec_existing
     = hash_table_get (warc_cdx_dedup_table, sha1_digest_payload);
 
   if (rec_existing && strcmp (rec_existing->url, url) == 0)
@@ -1093,11 +1110,13 @@ warc_init (void)
 static void
 warc_write_metadata (void)
 {
+  char manifest_uuid [48];
+  FILE * warc_tmp_fp;
+
   /* If there are multiple WARC files, the metadata should be written to a separate file. */
   if (opt.warc_maxsize > 0)
     warc_start_new_file (true);
 
-  char manifest_uuid [48];
   warc_uuid_str (manifest_uuid);
 
   fflush (warc_manifest_fp);
@@ -1107,7 +1126,7 @@ warc_write_metadata (void)
                               warc_manifest_fp, -1);
   /* warc_write_resource_record has closed warc_manifest_fp. */
 
-  FILE * warc_tmp_fp = warc_tempfile ();
+  warc_tmp_fp = warc_tempfile ();
   if (warc_tmp_fp == NULL)
     {
       logprintf (LOG_NOTQUIET, _("Could not open temporary WARC file.\n"));
@@ -1161,6 +1180,7 @@ warc_close (void)
 FILE *
 warc_tempfile (void)
 {
+  int fd;
   char filename[100];
   if (path_search (filename, 100, opt.warc_tempdir, "wget", true) == -1)
     return NULL;
@@ -1180,7 +1200,7 @@ warc_tempfile (void)
     return fopen (tfn, "w+", "fop=tmd");    /* Create auto-delete temp file. */
   }
 #else /* def __VMS */
-  int fd = mkostemp (filename, O_TEMPORARY);
+  fd = mkostemp (filename, O_TEMPORARY);
   if (fd < 0)
     return NULL;
 
@@ -1242,8 +1262,11 @@ warc_write_cdx_record (const char *url, const char *timestamp_str,
                        off_t offset, const char *warc_filename _GL_UNUSED,
                        const char *response_uuid)
 {
-  /* Transform the timestamp. */
+  char offset_string[MAX_INT_TO_STRING_LEN(off_t)];
   char timestamp_str_cdx [15];
+  const char *checksum;
+
+  /* Transform the timestamp. */
   memcpy (timestamp_str_cdx     , timestamp_str     , 4); /* "YYYY" "-" */
   memcpy (timestamp_str_cdx +  4, timestamp_str +  5, 2); /* "mm"   "-" */
   memcpy (timestamp_str_cdx +  6, timestamp_str +  8, 2); /* "dd"   "T" */
@@ -1253,7 +1276,6 @@ warc_write_cdx_record (const char *url, const char *timestamp_str,
   timestamp_str_cdx[14] = '\0';
 
   /* Rewrite the checksum. */
-  const char *checksum;
   if (payload_digest != NULL)
     checksum = payload_digest + 5; /* Skip the "sha1:" */
   else
@@ -1264,7 +1286,6 @@ warc_write_cdx_record (const char *url, const char *timestamp_str,
   if (redirect_location == NULL || strlen(redirect_location) == 0)
     redirect_location = "-";
 
-  char offset_string[MAX_INT_TO_STRING_LEN(off_t)];
   number_to_string (offset_string, offset);
 
   /* Print the CDX line. */
@@ -1296,10 +1317,11 @@ warc_write_revisit_record (char *url, char *timestamp_str,
                            char *refers_to, ip_address *ip, FILE *body)
 {
   char revisit_uuid [48];
-  warc_uuid_str (revisit_uuid);
-
   char *block_digest = NULL;
   char sha1_res_block[SHA1_DIGEST_SIZE];
+
+  warc_uuid_str (revisit_uuid);
+
   sha1_stream (body, sha1_res_block);
   block_digest = warc_base32_sha1_digest (sha1_res_block);
 
@@ -1350,6 +1372,9 @@ warc_write_response_record (char *url, char *timestamp_str,
   char sha1_res_block[SHA1_DIGEST_SIZE];
   char sha1_res_payload[SHA1_DIGEST_SIZE];
 
+  char response_uuid [48];
+  off_t offset;
+
   if (opt.warc_digests_enabled)
     {
       /* Calculate the block and payload digests. */
@@ -1393,11 +1418,10 @@ warc_write_response_record (char *url, char *timestamp_str,
 
   /* Not a revisit, just store the record. */
 
-  char response_uuid [48];
   warc_uuid_str (response_uuid);
 
   fseeko (warc_current_file, 0L, SEEK_END);
-  off_t offset = ftello (warc_current_file);
+  offset = ftello (warc_current_file);
 
   warc_write_start_record ();
   warc_write_header ("WARC-Type", "response");
-- 
1.8.3.4


From 9c955c94b7c3c9da50351fd68bfa1a9d6dca80ba Mon Sep 17 00:00:00 2001
From: Jerome Duval <jerome.duval@gmail.com>
Date: Mon, 1 Dec 2014 18:00:02 +0000
Subject: Fix OpenSSL compile-time check for TLSv1.1 and TLSv1.2

from upstream

diff --git a/src/openssl.c b/src/openssl.c
index e24954a..3f42b8f 100644
--- a/src/openssl.c
+++ b/src/openssl.c
@@ -216,13 +216,20 @@ ssl_init (void)
     case secure_protocol_tlsv1:
       meth = TLSv1_client_method ();
       break;
-#if OPENSSL_VERSION_NUMBER >= 0x01001000
+#if OPENSSL_VERSION_NUMBER >= 0x10001000
     case secure_protocol_tlsv1_1:
       meth = TLSv1_1_client_method ();
       break;
     case secure_protocol_tlsv1_2:
       meth = TLSv1_2_client_method ();
       break;
+#else
+    case secure_protocol_tlsv1_1:
+		logprintf (LOG_NOTQUIET, _("Your OpenSSL version is too old to support TLSv1.1\n"));
+		goto error;
+    case secure_protocol_tlsv1_2:
+		logprintf (LOG_NOTQUIET, _("Your OpenSSL version is too old to support TLSv1.2\n"));
+		goto error;
 #endif
     default:
       abort ();
-- 
1.8.3.4


From 02ca916f8dddcb1c27cefa1f6ab4c99525d6bdc2 Mon Sep 17 00:00:00 2001
From: Jerome Duval <jerome.duval@gmail.com>
Date: Mon, 1 Dec 2014 18:14:50 +0000
Subject: gcc2 fixes


diff --git a/src/ftp.c b/src/ftp.c
index 054cb61..723776c 100644
--- a/src/ftp.c
+++ b/src/ftp.c
@@ -2220,9 +2220,9 @@ has_insecure_name_p (const char *s)
 static bool
 is_invalid_entry (struct fileinfo *f)
 {
+  char *f_name = f->name;
   struct fileinfo *cur;
   cur = f;
-  char *f_name = f->name;
   /* If the node we're currently checking has a duplicate later, we eliminate
    * the current node and leave the next one intact. */
   while (cur->next)
diff --git a/src/http.c b/src/http.c
index 5ecf43b..4176678 100644
--- a/src/http.c
+++ b/src/http.c
@@ -1189,8 +1189,8 @@ static bool
 parse_content_disposition (const char *hdr, char **filename)
 {
   param_token name, value;
-  *filename = NULL;
   bool is_url_encoded = false;
+  *filename = NULL;
   for ( ; extract_param (&hdr, &name, &value, ';', &is_url_encoded);
         is_url_encoded = false)
     {
diff --git a/src/main.c b/src/main.c
index a72249d..50dc562 100644
--- a/src/main.c
+++ b/src/main.c
@@ -992,6 +992,9 @@ main (int argc, char **argv)
   int arglen;
   int argstring_length;
   char *p;
+  int retconf;
+  bool use_userconfig = false;
+  bool noconfig = false;
 
   total_downloaded_bytes = 0;
 
@@ -1048,9 +1051,6 @@ main (int argc, char **argv)
   /* This separate getopt_long is needed to find the user config file
      option ("--config") and parse it before the other user options. */
   longindex = -1;
-  int retconf;
-  bool use_userconfig = false;
-  bool noconfig = false;
 
   while ((retconf = getopt_long (argc, argv,
                                 short_options, long_options, &longindex)) != -1)
diff --git a/src/openssl.c b/src/openssl.c
index 3f42b8f..c1d1f52 100644
--- a/src/openssl.c
+++ b/src/openssl.c
@@ -167,6 +167,8 @@ static int ssl_true_initialized = 0;
 bool
 ssl_init (void)
 {
+	SSL_METHOD const *meth;
+
 #if OPENSSL_VERSION_NUMBER >= 0x00907000
   if (ssl_true_initialized == 0)
     {
@@ -174,9 +176,7 @@ ssl_init (void)
       ssl_true_initialized = 1;
     }
 #endif
-
-  SSL_METHOD const *meth;
-
+  
   if (ssl_ctx)
     /* The SSL has already been initialized. */
     return true;
diff --git a/src/progress.c b/src/progress.c
index 5ba542d..f0da019 100644
--- a/src/progress.c
+++ b/src/progress.c
@@ -903,6 +903,8 @@ get_eta (int *bcd)
 static void
 create_image (struct bar_progress *bp, double dl_total_time, bool done)
 {
+  int cols_diff;
+  const char * down_size;
   const int MAX_FILENAME_COLS = bp->width / 4;
   char *p = bp->buffer;
   wgint size = bp->initial_length + bp->count;
@@ -964,6 +966,7 @@ create_image (struct bar_progress *bp, double dl_total_time, bool done)
     }
   else
     {
+      int padding;
       int offset_cols;
       int bytes_in_filename, offset_bytes, col;
       int *cols_ret = &col;
@@ -976,7 +979,7 @@ create_image (struct bar_progress *bp, double dl_total_time, bool done)
       bytes_in_filename = cols_to_bytes (bp->f_download + offset_bytes, MAX_FILENAME_COLS, cols_ret);
       memcpy (p, bp->f_download + offset_bytes, bytes_in_filename);
       p += bytes_in_filename;
-      int padding = MAX_FILENAME_COLS - *cols_ret;
+      padding = MAX_FILENAME_COLS - *cols_ret;
       for (;padding;padding--)
           *p++ = ' ';
       *p++ = ' ';
@@ -1059,8 +1062,8 @@ create_image (struct bar_progress *bp, double dl_total_time, bool done)
  ++bp->tick;
 
   /* " 234.56M" */
-  const char * down_size = human_readable (size, 1000, 2);
-  int cols_diff = 7 - count_cols (down_size);
+  down_size = human_readable (size, 1000, 2);
+  cols_diff = 7 - count_cols (down_size);
   while (cols_diff > 0)
   {
     *p++=' ';
diff --git a/src/retr.c b/src/retr.c
index 0c7c29f..cb5fa3f 100644
--- a/src/retr.c
+++ b/src/retr.c
@@ -1059,6 +1059,7 @@ retrieve_from_file (const char *file, bool html, int *count)
       int dt;
       struct iri *tmpiri = iri_dup (iri);
       struct url *parsed_url = NULL;
+      char *proxy;
 
       if (cur_url->ignore_when_downloading)
         continue;
@@ -1071,7 +1072,7 @@ retrieve_from_file (const char *file, bool html, int *count)
 
       parsed_url = url_parse (cur_url->url->url, NULL, tmpiri, true);
 
-      char *proxy = getproxy (cur_url->url);
+      proxy = getproxy (cur_url->url);
       if ((opt.recursive || opt.page_requisites)
           && (cur_url->url->scheme != SCHEME_FTP || proxy))
         {
@@ -1283,10 +1284,11 @@ getproxy (struct url *u)
 bool
 url_uses_proxy (struct url * u)
 {
+  char *proxy;
   bool ret;
   if (!u)
     return false;
-  char *proxy = getproxy (u);
+  proxy = getproxy (u);
   ret = proxy != NULL;
   free(proxy);
   return ret;
-- 
1.8.3.4


diff -rupN qt-everywhere-opensource-src-4.7.3/configure qt-everywhere-opensource-src-4.7.3_haiku/configure
--- qt-everywhere-opensource-src-4.7.3/configure	2011-03-30 05:16:21.000262144 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/configure	2011-06-13 22:33:04.768868352 +0000
@@ -187,6 +187,11 @@ fi
 PLATFORM_X11=no
 PLATFORM_MAC=no
 PLATFORM_QWS=no
+PLATFORM_HAIKU=no
+
+if [ $UNAME_SYSTEM = "Haiku" ]; then
+	PLATFORM_HAIKU=yes
+fi
 
 if [ -f "$relpath"/src/gui/kernel/qapplication_mac.mm ] && [ -d /System/Library/Frameworks/Carbon.framework ]; then
     # Qt/Mac
@@ -2742,6 +2747,9 @@ if [ -z "$PLATFORM" ]; then
      QNX:*)
         PLATFORM=unsupported/qnx-g++
         ;;
+     Haiku:*)
+        PLATFORM=haiku-g++
+        ;;        
      *)
         if [ "$OPT_HELP" != "yes" ]; then
             echo
@@ -3005,6 +3013,9 @@ if [ -z "${CFG_HOST_ARCH}" ]; then
             ;;
         esac
         ;;
+    Haiku:*:*)
+         CFG_HOST_ARCH=i386
+         ;;        
     *:*:*)
         if [ "$OPT_VERBOSE" = "yes" ]; then
             echo "    Trying '$UNAME_MACHINE'..."
@@ -3172,7 +3183,7 @@ QMAKE_CONF_COMPILER=`getQMakeConf "$XQMA
 TEST_COMPILER="$CXX"
 
 [ -z "$TEST_COMPILER" ] && TEST_COMPILER=$QMAKE_CONF_COMPILER
-if [ "$XPLATFORM" != "symbian-sbsv2" ]; then
+if [ "$XPLATFORM" != "symbian-sbsv2" ] && [ "$PLATFORM_HAIKU" = "no" ]; then
     #for Symbian we don't need this checking
     if [ -z "$TEST_COMPILER" ]; then
         echo "ERROR: Cannot set the compiler for the configuration tests"
@@ -3342,6 +3353,8 @@ if [ -z "$QT_INSTALL_PREFIX" ]; then
     elif [ -d "$EPOCROOT" ] && echo $XPLATFORM | grep symbian > /dev/null; then
         QT_INSTALL_PREFIX="$EPOCROOT/epoc32/"
         QT_INSTALL_LIBS="$EPOCROOT/epoc32/release/armv5/lib/"
+    elif [ "$PLATFORM_HAIKU" = "yes" ]; then
+   	    QT_INSTALL_PREFIX="/boot/common"        
     else
         QT_INSTALL_PREFIX="/usr/local/Trolltech/Qt-${QT_VERSION}" # the default install prefix is /usr/local/Trolltech/Qt-$QT_VERSION
     fi
@@ -3367,6 +3380,8 @@ else
         if [ "$CFG_PREFIX_INSTALL" = "no" ]; then
 	    if [ "$PLATFORM_MAC" = "yes" ]; then
 	        QT_INSTALL_DOCS="/Developer/Documentation/Qt"
+		elif [ "$PLATFORM_HAIKU" = "yes" ]; then
+		    QT_INSTALL_DOCS="/boot/common/documentation/doc/Qt"	        
             fi
         fi
         [ -z "$QT_INSTALL_DOCS" ] && QT_INSTALL_DOCS="$QT_INSTALL_PREFIX/doc" #fallback
@@ -3395,6 +3410,12 @@ else
 	        if [ "$CFG_FRAMEWORK" = "yes" ]; then
 		    QT_INSTALL_LIBS="/Libraries/Frameworks"
                 fi
+		elif [ "$PLATFORM_HAIKU" = "yes" ]; then
+			if [ -f /boot/system/lib/libsupc++.so ] ; then
+		    	QT_INSTALL_LIBS="/boot/common/lib"
+		    else
+		    	QT_INSTALL_LIBS="/boot/common/lib/gcc4"
+		    fi            
             fi
         fi
         [ -z "$QT_INSTALL_LIBS" ] && QT_INSTALL_LIBS="$QT_INSTALL_PREFIX/lib" #fallback
@@ -3418,6 +3439,8 @@ else
         if [ "$CFG_PREFIX_INSTALL" = "no" ]; then
 	    if [ "$PLATFORM_MAC" = "yes" ]; then
 	        QT_INSTALL_PLUGINS="/Developer/Applications/Qt/plugins"
+		elif [ "$PLATFORM_HAIKU" = "yes" ]; then
+		    QT_INSTALL_PLUGINS="/boot/common/add-ons/Qt/plugins"	        
             fi
         fi
         [ -z "$QT_INSTALL_PLUGINS" ] && QT_INSTALL_PLUGINS="$QT_INSTALL_PREFIX/plugins" #fallback
@@ -3429,6 +3452,8 @@ else
         if [ "$CFG_PREFIX_INSTALL" = "no" ]; then
 	    if [ "$PLATFORM_MAC" = "yes" ]; then
 	        QT_INSTALL_IMPORTS="/Developer/Applications/Qt/imports"
+		elif [ "$PLATFORM_HAIKU" = "yes" ]; then
+		    QT_INSTALL_IMPORTS="/boot/common/add-ons/Qt/imports"	        
             fi
         fi
         [ -z "$QT_INSTALL_IMPORTS" ] && QT_INSTALL_IMPORTS="$QT_INSTALL_PREFIX/imports" #fallback
@@ -3437,13 +3462,21 @@ else
 
     #data
     if [ -z "$QT_INSTALL_DATA" ]; then #default
-        QT_INSTALL_DATA="$QT_INSTALL_PREFIX"
+		if [ "$PLATFORM_HAIKU" = "yes" ] && [ "$CFG_PREFIX_INSTALL" = "no" ]; then
+		    QT_INSTALL_DATA="/boot/common/data/Qt"
+	    else
+    		QT_INSTALL_DATA="$QT_INSTALL_PREFIX"
+	    fi
     fi
     QT_INSTALL_DATA=`"$relpath/config.tests/unix/makeabs" "$QT_INSTALL_DATA"`
 
     #translations
     if [ -z "$QT_INSTALL_TRANSLATIONS" ]; then #default
-        QT_INSTALL_TRANSLATIONS="$QT_INSTALL_PREFIX/translations"
+		if [ "$PLATFORM_HAIKU" = "yes" ] && [ "$CFG_PREFIX_INSTALL" = "no" ]; then
+		    QT_INSTALL_TRANSLATIONS="/boot/common/data/Qt/translations"
+		else
+    	    QT_INSTALL_TRANSLATIONS="$QT_INSTALL_PREFIX/translations"
+	    fi        
     fi
     QT_INSTALL_TRANSLATIONS=`"$relpath/config.tests/unix/makeabs" "$QT_INSTALL_TRANSLATIONS"`
 
@@ -3451,6 +3484,8 @@ else
     if [ -z "$QT_INSTALL_SETTINGS" ]; then #default
         if [ "$PLATFORM_MAC" = "yes" ]; then
 	    QT_INSTALL_SETTINGS=/Library/Preferences/Qt
+		elif [ "$PLATFORM_HAIKU" = "yes" ] && [ "$CFG_PREFIX_INSTALL" = "no" ]; then
+		QT_INSTALL_SETTINGS="/boot/common/settings/Qt"	    
         else
 	    QT_INSTALL_SETTINGS=/etc/xdg
         fi
@@ -3462,6 +3497,8 @@ else
         if [ "$CFG_PREFIX_INSTALL" = "no" ]; then
 	    if [ "$PLATFORM_MAC" = "yes" ]; then
 	        QT_INSTALL_EXAMPLES="/Developer/Examples/Qt"
+		elif [ "$PLATFORM_HAIKU" = "yes" ]; then
+		    QT_INSTALL_EXAMPLES="/boot/apps/Qt/Examples"	        
             fi
         fi
         [ -z "$QT_INSTALL_EXAMPLES" ] && QT_INSTALL_EXAMPLES="$QT_INSTALL_PREFIX/examples" #fallback
@@ -3473,6 +3510,8 @@ else
         if [ "$CFG_PREFIX_INSTALL" = "no" ]; then
 	    if [ "$PLATFORM_MAC" = "yes" ]; then
 	        QT_INSTALL_DEMOS="/Developer/Examples/Qt/Demos"
+		elif [ "$PLATFORM_HAIKU" = "yes" ]; then
+		    QT_INSTALL_DEMOS="/boot/apps/Qt/Demos"	        
             fi
         fi
         [ -z "$QT_INSTALL_DEMOS" ] && QT_INSTALL_DEMOS="$QT_INSTALL_PREFIX/demos"
@@ -4238,6 +4277,8 @@ elif echo "$XPLATFORM" | grep "symbian" 
     Platform="Qt for Symbian"
 elif [ "$XPLATFORM_MINGW" = "yes" ]; then
     Platform="Qt for Windows"
+elif [ "$PLATFORM_HAIKU" = "yes" ]; then
+    Platform="Qt for Haiku"    
 elif [ '!' -z "`getQMakeConf \"$XQMAKESPEC\" | grep QMAKE_LIBS_X11 | awk '{print $3;}'`" ]; then
     PLATFORM_X11=yes
     Platform="Qt for Linux/X11"
@@ -5415,7 +5456,7 @@ if [ "$PLATFORM_MAC" = "yes" -a ! -z "$Q
 fi
 
 # X11/QWS
-if [ "$PLATFORM_X11" = "yes" -o "$PLATFORM_QWS" = "yes" ]; then
+if [ "$PLATFORM_X11" = "yes" -o "$PLATFORM_QWS" = "yes" -o "$PLATFORM_HAIKU" = "yes" ]; then
 
     # auto-detect Glib support
     if [ "$CFG_GLIB" != "no" ]; then
diff -rupN qt-everywhere-opensource-src-4.7.3/include/Qt/qhaikustyle.h qt-everywhere-opensource-src-4.7.3_haiku/include/Qt/qhaikustyle.h
--- qt-everywhere-opensource-src-4.7.3/include/Qt/qhaikustyle.h	1970-01-01 00:00:00.000000000 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/include/Qt/qhaikustyle.h	2011-06-02 22:56:26.000000000 +0000
@@ -0,0 +1,9 @@
+#ifndef QT_NO_QT_INCLUDE_WARN
+    #if defined(__GNUC__)
+        #warning "Inclusion of header files from include/Qt is deprecated."
+    #elif defined(_MSC_VER)
+        #pragma message("WARNING: Inclusion of header files from include/Qt is deprecated.")
+    #endif
+#endif
+
+#include "../QtGui/qhaikustyle.h"
diff -rupN qt-everywhere-opensource-src-4.7.3/include/Qt/qsystemtrayicon_haiku.h qt-everywhere-opensource-src-4.7.3_haiku/include/Qt/qsystemtrayicon_haiku.h
--- qt-everywhere-opensource-src-4.7.3/include/Qt/qsystemtrayicon_haiku.h	1970-01-01 00:00:00.000000000 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/include/Qt/qsystemtrayicon_haiku.h	2011-06-02 22:56:26.000000000 +0000
@@ -0,0 +1,9 @@
+#ifndef QT_NO_QT_INCLUDE_WARN
+    #if defined(__GNUC__)
+        #warning "Inclusion of header files from include/Qt is deprecated."
+    #elif defined(_MSC_VER)
+        #pragma message("WARNING: Inclusion of header files from include/Qt is deprecated.")
+    #endif
+#endif
+
+#include "../QtGui/qsystemtrayicon_haiku.h"
diff -rupN qt-everywhere-opensource-src-4.7.3/include/Qt/qwidget_haiku.h qt-everywhere-opensource-src-4.7.3_haiku/include/Qt/qwidget_haiku.h
--- qt-everywhere-opensource-src-4.7.3/include/Qt/qwidget_haiku.h	1970-01-01 00:00:00.000000000 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/include/Qt/qwidget_haiku.h	2011-06-02 22:56:25.000000000 +0000
@@ -0,0 +1,9 @@
+#ifndef QT_NO_QT_INCLUDE_WARN
+    #if defined(__GNUC__)
+        #warning "Inclusion of header files from include/Qt is deprecated."
+    #elif defined(_MSC_VER)
+        #pragma message("WARNING: Inclusion of header files from include/Qt is deprecated.")
+    #endif
+#endif
+
+#include "../QtGui/qwidget_haiku.h"
diff -rupN qt-everywhere-opensource-src-4.7.3/include/Qt/qwindowdefs_haiku.h qt-everywhere-opensource-src-4.7.3_haiku/include/Qt/qwindowdefs_haiku.h
--- qt-everywhere-opensource-src-4.7.3/include/Qt/qwindowdefs_haiku.h	1970-01-01 00:00:00.000000000 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/include/Qt/qwindowdefs_haiku.h	2011-06-02 22:56:25.000000000 +0000
@@ -0,0 +1,9 @@
+#ifndef QT_NO_QT_INCLUDE_WARN
+    #if defined(__GNUC__)
+        #warning "Inclusion of header files from include/Qt is deprecated."
+    #elif defined(_MSC_VER)
+        #pragma message("WARNING: Inclusion of header files from include/Qt is deprecated.")
+    #endif
+#endif
+
+#include "../QtGui/qwindowdefs_haiku.h"
diff -rupN qt-everywhere-opensource-src-4.7.3/include/QtGui/QHaikuStyle qt-everywhere-opensource-src-4.7.3_haiku/include/QtGui/QHaikuStyle
--- qt-everywhere-opensource-src-4.7.3/include/QtGui/QHaikuStyle	1970-01-01 00:00:00.000000000 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/include/QtGui/QHaikuStyle	2010-04-15 16:14:35.000000000 +0000
@@ -0,0 +1 @@
+#include "qhaikustyle.h"
diff -rupN qt-everywhere-opensource-src-4.7.3/include/QtGui/QtHaikuView qt-everywhere-opensource-src-4.7.3_haiku/include/QtGui/QtHaikuView
--- qt-everywhere-opensource-src-4.7.3/include/QtGui/QtHaikuView	1970-01-01 00:00:00.000000000 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/include/QtGui/QtHaikuView	2010-11-09 02:20:07.000000000 +0000
@@ -0,0 +1 @@
+#include "qwidget_haiku.h"
diff -rupN qt-everywhere-opensource-src-4.7.3/include/QtGui/QtHaikuWindow qt-everywhere-opensource-src-4.7.3_haiku/include/QtGui/QtHaikuWindow
--- qt-everywhere-opensource-src-4.7.3/include/QtGui/QtHaikuWindow	1970-01-01 00:00:00.000000000 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/include/QtGui/QtHaikuWindow	2010-11-09 02:20:07.000000000 +0000
@@ -0,0 +1 @@
+#include "qwidget_haiku.h"
diff -rupN qt-everywhere-opensource-src-4.7.3/include/QtGui/headers.pri qt-everywhere-opensource-src-4.7.3_haiku/include/QtGui/headers.pri
--- qt-everywhere-opensource-src-4.7.3/include/QtGui/headers.pri	2011-03-30 05:16:20.013893632 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/include/QtGui/headers.pri	2011-06-14 04:04:50.707264512 +0000
@@ -1,3 +1,3 @@
-SYNCQT.HEADER_FILES = ../gui/dialogs/qabstractpagesetupdialog.h ../gui/dialogs/qabstractprintdialog.h ../gui/dialogs/qcolordialog.h ../gui/dialogs/qdialog.h ../gui/dialogs/qerrormessage.h ../gui/dialogs/qfiledialog.h ../gui/dialogs/qfilesystemmodel.h ../gui/dialogs/qfontdialog.h ../gui/dialogs/qinputdialog.h ../gui/dialogs/qmessagebox.h ../gui/dialogs/qpagesetupdialog.h ../gui/dialogs/qprintdialog.h ../gui/dialogs/qprintpreviewdialog.h ../gui/dialogs/qprogressdialog.h ../gui/dialogs/qwizard.h ../gui/embedded/qcopchannel_qws.h ../gui/embedded/qdecoration_qws.h ../gui/embedded/qdecorationdefault_qws.h ../gui/embedded/qdecorationfactory_qws.h ../gui/embedded/qdecorationplugin_qws.h ../gui/embedded/qdecorationstyled_qws.h ../gui/embedded/qdecorationwindows_qws.h ../gui/embedded/qdirectpainter_qws.h ../gui/embedded/qkbd_qws.h ../gui/embedded/qkbddriverfactory_qws.h ../gui/embedded/qkbddriverplugin_qws.h ../gui/embedded/qkbdlinuxinput_qws.h ../gui/embedded/qkbdqnx_qws.h ../gui/embedded/qkbdtty_qws.h ../gui/embedded/qkbdum_qws.h ../gui/embedded/qkbdvfb_qws.h ../gui/embedded/qmouse_qws.h ../gui/embedded/qmousedriverfactory_qws.h ../gui/embedded/qmousedriverplugin_qws.h ../gui/embedded/qmouselinuxinput_qws.h ../gui/embedded/qmouselinuxtp_qws.h ../gui/embedded/qmousepc_qws.h ../gui/embedded/qmouseqnx_qws.h ../gui/embedded/qmousetslib_qws.h ../gui/embedded/qmousevfb_qws.h ../gui/embedded/qscreen_qws.h ../gui/embedded/qscreendriverfactory_qws.h ../gui/embedded/qscreendriverplugin_qws.h ../gui/embedded/qscreenlinuxfb_qws.h ../gui/embedded/qscreenproxy_qws.h ../gui/embedded/qscreenqnx_qws.h ../gui/embedded/qscreentransformed_qws.h ../gui/embedded/qscreenvfb_qws.h ../gui/embedded/qsoundqss_qws.h ../gui/embedded/qtransportauth_qws.h ../gui/embedded/qtransportauthdefs_qws.h ../gui/embedded/qvfbhdr.h ../gui/embedded/qwindowsystem_qws.h ../gui/embedded/qwscursor_qws.h ../gui/embedded/qwsdisplay_qws.h ../gui/embedded/qwsembedwidget.h ../gui/embedded/qwsevent_qws.h ../gui/embedded/qwsmanager_qws.h ../gui/embedded/qwsproperty_qws.h ../gui/embedded/qwsprotocolitem_qws.h ../gui/embedded/qwssocket_qws.h ../gui/embedded/qwsutils_qws.h ../gui/graphicsview/qgraphicsanchorlayout.h ../gui/graphicsview/qgraphicsgridlayout.h ../gui/graphicsview/qgraphicsitem.h ../gui/graphicsview/qgraphicsitemanimation.h ../gui/graphicsview/qgraphicslayout.h ../gui/graphicsview/qgraphicslayoutitem.h ../gui/graphicsview/qgraphicslinearlayout.h ../gui/graphicsview/qgraphicsproxywidget.h ../gui/graphicsview/qgraphicsscene.h ../gui/graphicsview/qgraphicssceneevent.h ../gui/graphicsview/qgraphicstransform.h ../gui/graphicsview/qgraphicsview.h ../gui/graphicsview/qgraphicswidget.h ../gui/kernel/qaction.h ../gui/kernel/qactiongroup.h ../gui/kernel/qapplication.h ../gui/kernel/qboxlayout.h ../gui/kernel/qclipboard.h ../gui/kernel/qcursor.h ../gui/kernel/qdesktopwidget.h ../gui/kernel/qdrag.h ../gui/kernel/qevent.h ../gui/kernel/qformlayout.h ../gui/kernel/qgesture.h ../gui/kernel/qgesturerecognizer.h ../gui/kernel/qgridlayout.h ../gui/kernel/qguifunctions_wince.h ../gui/kernel/qkeysequence.h ../gui/kernel/qlayout.h ../gui/kernel/qlayoutitem.h ../gui/kernel/qmacdefines_mac.h ../gui/kernel/qmime.h ../gui/kernel/qpalette.h ../gui/kernel/qsessionmanager.h ../gui/kernel/qshortcut.h ../gui/kernel/qsizepolicy.h ../gui/kernel/qsound.h ../gui/kernel/qstackedlayout.h ../gui/kernel/qtooltip.h ../gui/kernel/qwhatsthis.h ../gui/kernel/qwidget.h ../gui/kernel/qwidgetaction.h ../gui/kernel/qwindowdefs.h ../gui/kernel/qwindowdefs_win.h ../gui/kernel/qx11embed_x11.h ../gui/kernel/qx11info_x11.h ../gui/effects/qgraphicseffect.h ../gui/s60framework/qs60mainapplication.h ../gui/s60framework/qs60mainappui.h ../gui/s60framework/qs60maindocument.h ../gui/math3d/qgenericmatrix.h ../gui/math3d/qmatrix4x4.h ../gui/math3d/qquaternion.h ../gui/math3d/qvector2d.h ../gui/math3d/qvector3d.h ../gui/math3d/qvector4d.h ../gui/image/qbitmap.h ../gui/image/qicon.h ../gui/image/qiconengine.h ../gui/image/qiconengineplugin.h ../gui/image/qimage.h ../gui/image/qimageiohandler.h ../gui/image/qimagereader.h ../gui/image/qimagewriter.h ../gui/image/qmovie.h ../gui/image/qpicture.h ../gui/image/qpictureformatplugin.h ../gui/image/qpixmap.h ../gui/image/qpixmapcache.h ../gui/symbian/qsymbianevent.h ../gui/text/qabstractfontengine_qws.h ../gui/text/qabstracttextdocumentlayout.h ../gui/text/qfont.h ../gui/text/qfontdatabase.h ../gui/text/qfontinfo.h ../gui/text/qfontmetrics.h ../gui/text/qstatictext.h ../gui/text/qsyntaxhighlighter.h ../gui/text/qtextcursor.h ../gui/text/qtextdocument.h ../gui/text/qtextdocumentfragment.h ../gui/text/qtextdocumentwriter.h ../gui/text/qtextformat.h ../gui/text/qtextlayout.h ../gui/text/qtextlist.h ../gui/text/qtextobject.h ../gui/text/qtextoption.h ../gui/text/qtexttable.h ../gui/itemviews/qabstractitemdelegate.h ../gui/itemviews/qabstractitemview.h ../gui/itemviews/qabstractproxymodel.h ../gui/itemviews/qcolumnview.h ../gui/itemviews/qdatawidgetmapper.h ../gui/itemviews/qdirmodel.h ../gui/itemviews/qfileiconprovider.h ../gui/itemviews/qheaderview.h ../gui/itemviews/qitemdelegate.h ../gui/itemviews/qitemeditorfactory.h ../gui/itemviews/qitemselectionmodel.h ../gui/itemviews/qlistview.h ../gui/itemviews/qlistwidget.h ../gui/itemviews/qproxymodel.h ../gui/itemviews/qsortfilterproxymodel.h ../gui/itemviews/qstandarditemmodel.h ../gui/itemviews/qstringlistmodel.h ../gui/itemviews/qstyleditemdelegate.h ../gui/itemviews/qtableview.h ../gui/itemviews/qtablewidget.h ../gui/itemviews/qtreeview.h ../gui/itemviews/qtreewidget.h ../gui/itemviews/qtreewidgetitemiterator.h ../gui/widgets/qabstractbutton.h ../gui/widgets/qabstractscrollarea.h ../gui/widgets/qabstractslider.h ../gui/widgets/qabstractspinbox.h ../gui/widgets/qbuttongroup.h ../gui/widgets/qcalendarwidget.h ../gui/widgets/qcheckbox.h ../gui/widgets/qcombobox.h ../gui/widgets/qcommandlinkbutton.h ../gui/widgets/qdatetimeedit.h ../gui/widgets/qdial.h ../gui/widgets/qdialogbuttonbox.h ../gui/widgets/qdockwidget.h ../gui/widgets/qfocusframe.h ../gui/widgets/qfontcombobox.h ../gui/widgets/qframe.h ../gui/widgets/qgroupbox.h ../gui/widgets/qlabel.h ../gui/widgets/qlcdnumber.h ../gui/widgets/qlineedit.h ../gui/widgets/qmaccocoaviewcontainer_mac.h ../gui/widgets/qmacnativewidget_mac.h ../gui/widgets/qmainwindow.h ../gui/widgets/qmdiarea.h ../gui/widgets/qmdisubwindow.h ../gui/widgets/qmenu.h ../gui/widgets/qmenubar.h ../gui/widgets/qmenudata.h ../gui/widgets/qplaintextedit.h ../gui/widgets/qprintpreviewwidget.h ../gui/widgets/qprogressbar.h ../gui/widgets/qpushbutton.h ../gui/widgets/qradiobutton.h ../gui/widgets/qrubberband.h ../gui/widgets/qscrollarea.h ../gui/widgets/qscrollbar.h ../gui/widgets/qsizegrip.h ../gui/widgets/qslider.h ../gui/widgets/qspinbox.h ../gui/widgets/qsplashscreen.h ../gui/widgets/qsplitter.h ../gui/widgets/qstackedwidget.h ../gui/widgets/qstatusbar.h ../gui/widgets/qtabbar.h ../gui/widgets/qtabwidget.h ../gui/widgets/qtextbrowser.h ../gui/widgets/qtextedit.h ../gui/widgets/qtoolbar.h ../gui/widgets/qtoolbox.h ../gui/widgets/qtoolbutton.h ../gui/widgets/qvalidator.h ../gui/widgets/qworkspace.h ../gui/statemachine/qkeyeventtransition.h ../gui/statemachine/qmouseeventtransition.h ../gui/util/qcompleter.h ../gui/util/qdesktopservices.h ../gui/util/qsystemtrayicon.h ../gui/util/qundogroup.h ../gui/util/qundostack.h ../gui/util/qundoview.h ../gui/accessible/qaccessible.h ../gui/accessible/qaccessible2.h ../gui/accessible/qaccessiblebridge.h ../gui/accessible/qaccessibleobject.h ../gui/accessible/qaccessibleplugin.h ../gui/accessible/qaccessiblewidget.h ../gui/styles/qcdestyle.h ../gui/styles/qcleanlooksstyle.h ../gui/styles/qcommonstyle.h ../gui/styles/qgtkstyle.h ../gui/styles/qmacstyle_mac.h ../gui/styles/qmotifstyle.h ../gui/styles/qplastiquestyle.h ../gui/styles/qproxystyle.h ../gui/styles/qs60style.h ../gui/styles/qstyle.h ../gui/styles/qstylefactory.h ../gui/styles/qstyleoption.h ../gui/styles/qstyleplugin.h ../gui/styles/qwindowscestyle.h ../gui/styles/qwindowsmobilestyle.h ../gui/styles/qwindowsstyle.h ../gui/styles/qwindowsvistastyle.h ../gui/styles/qwindowsxpstyle.h ../gui/inputmethod/qinputcontext.h ../gui/inputmethod/qinputcontextfactory.h ../gui/inputmethod/qinputcontextplugin.h ../gui/painting/qbrush.h ../gui/painting/qcolor.h ../gui/painting/qcolormap.h ../gui/painting/qdrawutil.h ../gui/painting/qmatrix.h ../gui/painting/qpaintdevice.h ../gui/painting/qpaintengine.h ../gui/painting/qpainter.h ../gui/painting/qpainterpath.h ../gui/painting/qpen.h ../gui/painting/qpolygon.h ../gui/painting/qprintengine.h ../gui/painting/qprinter.h ../gui/painting/qprinterinfo.h ../gui/painting/qregion.h ../gui/painting/qrgb.h ../gui/painting/qstylepainter.h ../gui/painting/qtransform.h ../gui/painting/qwmatrix.h ../../include/QtGui/QtGui 
-SYNCQT.HEADER_CLASSES = ../../include/QtGui/QAbstractPageSetupDialog ../../include/QtGui/QAbstractPrintDialog ../../include/QtGui/QColorDialog ../../include/QtGui/QDialog ../../include/QtGui/QErrorMessage ../../include/QtGui/QFileDialog ../../include/QtGui/QFileSystemModel ../../include/QtGui/QFontDialog ../../include/QtGui/QInputDialog ../../include/QtGui/QMessageBox ../../include/QtGui/QPageSetupDialog ../../include/QtGui/QUnixPrintWidget ../../include/QtGui/QPrintDialog ../../include/QtGui/QPrintPreviewDialog ../../include/QtGui/QProgressDialog ../../include/QtGui/QWizard ../../include/QtGui/QWizardPage ../../include/QtGui/QCopChannel ../../include/QtGui/QDecorationAction ../../include/QtGui/QDecoration ../../include/QtGui/QDecorationDefault ../../include/QtGui/QDecorationFactory ../../include/QtGui/QDecorationFactoryInterface ../../include/QtGui/QDecorationPlugin ../../include/QtGui/QDecorationStyled ../../include/QtGui/QDecorationWindows ../../include/QtGui/QDirectPainter ../../include/QtGui/QWSKeyboardHandler ../../include/QtGui/QKbdDriverFactory ../../include/QtGui/QWSKeyboardHandlerFactoryInterface ../../include/QtGui/QKbdDriverPlugin ../../include/QtGui/QWSLinuxInputKeyboardHandler ../../include/QtGui/QWSQnxKeyboardHandler ../../include/QtGui/QWSTtyKeyboardHandler ../../include/QtGui/QWSUmKeyboardHandler ../../include/QtGui/QVFbKeyboardHandler ../../include/QtGui/QWSPointerCalibrationData ../../include/QtGui/QWSMouseHandler ../../include/QtGui/QWSCalibratedMouseHandler ../../include/QtGui/QMouseDriverFactory ../../include/QtGui/QWSMouseHandlerFactoryInterface ../../include/QtGui/QMouseDriverPlugin ../../include/QtGui/QWSLinuxInputMouseHandler ../../include/QtGui/QWSLinuxTPMouseHandler ../../include/QtGui/QWSPcMouseHandler ../../include/QtGui/QQnxMouseHandler ../../include/QtGui/QWSTslibMouseHandler ../../include/QtGui/QVFbMouseHandler ../../include/QtGui/QScreenCursor ../../include/QtGui/QPoolEntry ../../include/QtGui/QScreen ../../include/QtGui/QScreenDriverFactory ../../include/QtGui/QScreenDriverFactoryInterface ../../include/QtGui/QScreenDriverPlugin ../../include/QtGui/QLinuxFb_Shared ../../include/QtGui/QLinuxFbScreen ../../include/QtGui/QProxyScreenCursor ../../include/QtGui/QProxyScreen ../../include/QtGui/QQnxScreen ../../include/QtGui/QTransformedScreen ../../include/QtGui/QVFbScreen ../../include/QtGui/QWSSoundServer ../../include/QtGui/QWSSoundClient ../../include/QtGui/QWSSoundServerSocket ../../include/QtGui/QTransportAuth ../../include/QtGui/QAuthDevice ../../include/QtGui/QVFbHeader ../../include/QtGui/QVFbKeyData ../../include/QtGui/QWSInternalWindowInfo ../../include/QtGui/QWSScreenSaver ../../include/QtGui/QWSWindow ../../include/QtGui/QWSServer ../../include/QtGui/QWSInputMethod ../../include/QtGui/QWSCursorMap ../../include/QtGui/QWSClient ../../include/QtGui/QWSCursor ../../include/QtGui/QWSWindowInfo ../../include/QtGui/QWSDisplay ../../include/QtGui/QWSEmbedWidget ../../include/QtGui/QWSEvent ../../include/QtGui/QWSManager ../../include/QtGui/QWSPropertyManager ../../include/QtGui/QWSProtocolItem ../../include/QtGui/QWSSocket ../../include/QtGui/QWSServerSocket ../../include/QtGui/QGraphicsAnchor ../../include/QtGui/QGraphicsAnchorLayout ../../include/QtGui/QGraphicsGridLayout ../../include/QtGui/QGraphicsItem ../../include/QtGui/QGraphicsObject ../../include/QtGui/QAbstractGraphicsShapeItem ../../include/QtGui/QGraphicsPathItem ../../include/QtGui/QGraphicsRectItem ../../include/QtGui/QGraphicsEllipseItem ../../include/QtGui/QGraphicsPolygonItem ../../include/QtGui/QGraphicsLineItem ../../include/QtGui/QGraphicsPixmapItem ../../include/QtGui/QGraphicsTextItem ../../include/QtGui/QGraphicsSimpleTextItem ../../include/QtGui/QGraphicsItemGroup ../../include/QtGui/QGraphicsItemAnimation ../../include/QtGui/QGraphicsLayout ../../include/QtGui/QGraphicsLayoutItem ../../include/QtGui/QGraphicsLinearLayout ../../include/QtGui/QGraphicsProxyWidget ../../include/QtGui/QGraphicsScene ../../include/QtGui/QGraphicsSceneEvent ../../include/QtGui/QGraphicsSceneMouseEvent ../../include/QtGui/QGraphicsSceneWheelEvent ../../include/QtGui/QGraphicsSceneContextMenuEvent ../../include/QtGui/QGraphicsSceneHoverEvent ../../include/QtGui/QGraphicsSceneHelpEvent ../../include/QtGui/QGraphicsSceneDragDropEvent ../../include/QtGui/QGraphicsSceneResizeEvent ../../include/QtGui/QGraphicsSceneMoveEvent ../../include/QtGui/QGraphicsTransform ../../include/QtGui/QGraphicsScale ../../include/QtGui/QGraphicsRotation ../../include/QtGui/QGraphicsView ../../include/QtGui/QGraphicsWidget ../../include/QtGui/QAction ../../include/QtGui/QActionGroup ../../include/QtGui/QApplication ../../include/QtGui/QBoxLayout ../../include/QtGui/QHBoxLayout ../../include/QtGui/QVBoxLayout ../../include/QtGui/QClipboard ../../include/QtGui/QCursor ../../include/QtGui/QCursorShape ../../include/QtGui/QDesktopWidget ../../include/QtGui/QDrag ../../include/QtGui/QtEvents ../../include/QtGui/QInputEvent ../../include/QtGui/QMouseEvent ../../include/QtGui/QHoverEvent ../../include/QtGui/QWheelEvent ../../include/QtGui/QTabletEvent ../../include/QtGui/QKeyEvent ../../include/QtGui/QFocusEvent ../../include/QtGui/QPaintEvent ../../include/QtGui/QUpdateLaterEvent ../../include/QtGui/QMoveEvent ../../include/QtGui/QResizeEvent ../../include/QtGui/QCloseEvent ../../include/QtGui/QIconDragEvent ../../include/QtGui/QShowEvent ../../include/QtGui/QHideEvent ../../include/QtGui/QContextMenuEvent ../../include/QtGui/QInputMethodEvent ../../include/QtGui/QDropEvent ../../include/QtGui/QDragMoveEvent ../../include/QtGui/QDragEnterEvent ../../include/QtGui/QDragResponseEvent ../../include/QtGui/QDragLeaveEvent ../../include/QtGui/QHelpEvent ../../include/QtGui/QStatusTipEvent ../../include/QtGui/QWhatsThisClickedEvent ../../include/QtGui/QActionEvent ../../include/QtGui/QFileOpenEvent ../../include/QtGui/QToolBarChangeEvent ../../include/QtGui/QShortcutEvent ../../include/QtGui/QClipboardEvent ../../include/QtGui/QWindowStateChangeEvent ../../include/QtGui/QMenubarUpdatedEvent ../../include/QtGui/QTouchEvent ../../include/QtGui/QGestureEvent ../../include/QtGui/QFormLayout ../../include/QtGui/QGesture ../../include/QtGui/QPanGesture ../../include/QtGui/QPinchGesture ../../include/QtGui/QSwipeGesture ../../include/QtGui/QTapGesture ../../include/QtGui/QTapAndHoldGesture ../../include/QtGui/QGestureRecognizer ../../include/QtGui/QGridLayout ../../include/QtGui/QKeySequence ../../include/QtGui/QLayoutIterator ../../include/QtGui/QLayout ../../include/QtGui/QLayoutItem ../../include/QtGui/QSpacerItem ../../include/QtGui/QWidgetItem ../../include/QtGui/QWidgetItemV2 ../../include/QtGui/QMimeSource ../../include/QtGui/QWindowsMime ../../include/QtGui/QMacMime ../../include/QtGui/QMacPasteboardMime ../../include/QtGui/QPalette ../../include/QtGui/QColorGroup ../../include/QtGui/QSessionManager ../../include/QtGui/QShortcut ../../include/QtGui/QSizePolicy ../../include/QtGui/QSound ../../include/QtGui/QStackedLayout ../../include/QtGui/QToolTip ../../include/QtGui/QWhatsThis ../../include/QtGui/QWidgetData ../../include/QtGui/QWidget ../../include/QtGui/QWidgetAction ../../include/QtGui/QWidgetList ../../include/QtGui/QWidgetMapper ../../include/QtGui/QWidgetSet ../../include/QtGui/QX11EmbedWidget ../../include/QtGui/QX11EmbedContainer ../../include/QtGui/QX11Info ../../include/QtGui/QGraphicsEffect ../../include/QtGui/QGraphicsColorizeEffect ../../include/QtGui/QGraphicsBlurEffect ../../include/QtGui/QGraphicsDropShadowEffect ../../include/QtGui/QGraphicsOpacityEffect ../../include/QtGui/QS60MainApplicationBase ../../include/QtGui/QS60MainApplication ../../include/QtGui/QS60MainAppUiBase ../../include/QtGui/QS60StubAknAppUiBase ../../include/QtGui/QS60StubMEikStatusPaneObserver ../../include/QtGui/QS60StubMAknTouchPaneObserver ../../include/QtGui/QS60StubAknAppUi ../../include/QtGui/QS60MainAppUi ../../include/QtGui/QS60MainDocumentBase ../../include/QtGui/QS60MainDocument ../../include/QtGui/QGenericMatrix ../../include/QtGui/QMatrix2x2 ../../include/QtGui/QMatrix2x3 ../../include/QtGui/QMatrix2x4 ../../include/QtGui/QMatrix3x2 ../../include/QtGui/QMatrix3x3 ../../include/QtGui/QMatrix3x4 ../../include/QtGui/QMatrix4x2 ../../include/QtGui/QMatrix4x3 ../../include/QtGui/QMatrix4x4 ../../include/QtGui/QQuaternion ../../include/QtGui/QVector2D ../../include/QtGui/QVector3D ../../include/QtGui/QVector4D ../../include/QtGui/QBitmap ../../include/QtGui/QIcon ../../include/QtGui/QIconSet ../../include/QtGui/QIconEngine ../../include/QtGui/QIconEngineV2 ../../include/QtGui/QIconEngineFactoryInterface ../../include/QtGui/QIconEnginePlugin ../../include/QtGui/QIconEngineFactoryInterfaceV2 ../../include/QtGui/QIconEnginePluginV2 ../../include/QtGui/QImageTextKeyLang ../../include/QtGui/QImage ../../include/QtGui/QImageIOHandler ../../include/QtGui/QImageIOHandlerFactoryInterface ../../include/QtGui/QImageIOPlugin ../../include/QtGui/QImageReader ../../include/QtGui/QImageWriter ../../include/QtGui/QMovie ../../include/QtGui/QPicture ../../include/QtGui/QPictureIO ../../include/QtGui/QPictureFormatInterface ../../include/QtGui/QPictureFormatPlugin ../../include/QtGui/QPixmap ../../include/QtGui/QPixmapCache ../../include/QtGui/QSymbianEvent ../../include/QtGui/QFontEngineInfo ../../include/QtGui/QFontEngineFactoryInterface ../../include/QtGui/QFontEnginePlugin ../../include/QtGui/QAbstractFontEngine ../../include/QtGui/QAbstractTextDocumentLayout ../../include/QtGui/QTextObjectInterface ../../include/QtGui/QFont ../../include/QtGui/QFontDatabase ../../include/QtGui/QFontInfo ../../include/QtGui/QFontMetrics ../../include/QtGui/QFontMetricsF ../../include/QtGui/QStaticText ../../include/QtGui/QSyntaxHighlighter ../../include/QtGui/QTextCursor ../../include/QtGui/QAbstractUndoItem ../../include/QtGui/QTextDocument ../../include/QtGui/QTextDocumentFragment ../../include/QtGui/QTextDocumentWriter ../../include/QtGui/QTextLength ../../include/QtGui/QTextFormat ../../include/QtGui/QTextCharFormat ../../include/QtGui/QTextBlockFormat ../../include/QtGui/QTextListFormat ../../include/QtGui/QTextImageFormat ../../include/QtGui/QTextFrameFormat ../../include/QtGui/QTextTableFormat ../../include/QtGui/QTextTableCellFormat ../../include/QtGui/QTextInlineObject ../../include/QtGui/QTextLayout ../../include/QtGui/QTextLine ../../include/QtGui/QTextList ../../include/QtGui/QTextObject ../../include/QtGui/QTextBlockGroup ../../include/QtGui/QTextFrameLayoutData ../../include/QtGui/QTextFrame ../../include/QtGui/QTextBlockUserData ../../include/QtGui/QTextBlock ../../include/QtGui/QTextFragment ../../include/QtGui/QTextOption ../../include/QtGui/QTextTableCell ../../include/QtGui/QTextTable ../../include/QtGui/QAbstractItemDelegate ../../include/QtGui/QAbstractItemView ../../include/QtGui/QAbstractProxyModel ../../include/QtGui/QColumnView ../../include/QtGui/QDataWidgetMapper ../../include/QtGui/QDirModel ../../include/QtGui/QFileIconProvider ../../include/QtGui/QHeaderView ../../include/QtGui/QItemDelegate ../../include/QtGui/QItemEditorCreatorBase ../../include/QtGui/QItemEditorCreator ../../include/QtGui/QStandardItemEditorCreator ../../include/QtGui/QItemEditorFactory ../../include/QtGui/QItemSelectionRange ../../include/QtGui/QItemSelectionModel ../../include/QtGui/QItemSelection ../../include/QtGui/QListView ../../include/QtGui/QListWidgetItem ../../include/QtGui/QListWidget ../../include/QtGui/QProxyModel ../../include/QtGui/QSortFilterProxyModel ../../include/QtGui/QStandardItem ../../include/QtGui/QStandardItemModel ../../include/QtGui/QStringListModel ../../include/QtGui/QStyledItemDelegate ../../include/QtGui/QTableView ../../include/QtGui/QTableWidgetSelectionRange ../../include/QtGui/QTableWidgetItem ../../include/QtGui/QTableWidget ../../include/QtGui/QTreeView ../../include/QtGui/QTreeWidgetItem ../../include/QtGui/QTreeWidget ../../include/QtGui/QTreeWidgetItemIterator ../../include/QtGui/QAbstractButton ../../include/QtGui/QAbstractScrollArea ../../include/QtGui/QAbstractSlider ../../include/QtGui/QAbstractSpinBox ../../include/QtGui/QButtonGroup ../../include/QtGui/QCalendarWidget ../../include/QtGui/QCheckBox ../../include/QtGui/QComboBox ../../include/QtGui/QCommandLinkButton ../../include/QtGui/QDateTimeEdit ../../include/QtGui/QTimeEdit ../../include/QtGui/QDateEdit ../../include/QtGui/QDial ../../include/QtGui/QDialogButtonBox ../../include/QtGui/QDockWidget ../../include/QtGui/QFocusFrame ../../include/QtGui/QFontComboBox ../../include/QtGui/QFrame ../../include/QtGui/QGroupBox ../../include/QtGui/QLabel ../../include/QtGui/QLCDNumber ../../include/QtGui/QLineEdit ../../include/QtGui/QMacCocoaViewContainer ../../include/QtGui/QMacNativeWidget ../../include/QtGui/QMainWindow ../../include/QtGui/QMdiArea ../../include/QtGui/QMdiSubWindow ../../include/QtGui/QMenu ../../include/QtGui/QMenuBar ../../include/QtGui/QMenuItem ../../include/QtGui/QPlainTextEdit ../../include/QtGui/QPlainTextDocumentLayout ../../include/QtGui/QPrintPreviewWidget ../../include/QtGui/QProgressBar ../../include/QtGui/QPushButton ../../include/QtGui/QRadioButton ../../include/QtGui/QRubberBand ../../include/QtGui/QScrollArea ../../include/QtGui/QScrollBar ../../include/QtGui/QSizeGrip ../../include/QtGui/QSlider ../../include/QtGui/QSpinBox ../../include/QtGui/QDoubleSpinBox ../../include/QtGui/QSplashScreen ../../include/QtGui/QSplitter ../../include/QtGui/QSplitterHandle ../../include/QtGui/QStackedWidget ../../include/QtGui/QStatusBar ../../include/QtGui/QTabBar ../../include/QtGui/QTabWidget ../../include/QtGui/QTextBrowser ../../include/QtGui/QTextEdit ../../include/QtGui/QToolBar ../../include/QtGui/QToolBox ../../include/QtGui/QToolButton ../../include/QtGui/QValidator ../../include/QtGui/QIntValidator ../../include/QtGui/QDoubleValidator ../../include/QtGui/QRegExpValidator ../../include/QtGui/QWorkspace ../../include/QtGui/QKeyEventTransition ../../include/QtGui/QMouseEventTransition ../../include/QtGui/QCompleter ../../include/QtGui/QDesktopServices ../../include/QtGui/QSystemTrayIcon ../../include/QtGui/QUndoGroup ../../include/QtGui/QUndoCommand ../../include/QtGui/QUndoStack ../../include/QtGui/QUndoView ../../include/QtGui/QAccessible ../../include/QtGui/QAccessibleInterface ../../include/QtGui/QAccessibleInterfaceEx ../../include/QtGui/QAccessibleEvent ../../include/QtGui/QAccessible2Interface ../../include/QtGui/QAccessibleTextInterface ../../include/QtGui/QAccessibleEditableTextInterface ../../include/QtGui/QAccessibleSimpleEditableTextInterface ../../include/QtGui/QAccessibleValueInterface ../../include/QtGui/QAccessibleTableInterface ../../include/QtGui/QAccessibleActionInterface ../../include/QtGui/QAccessibleImageInterface ../../include/QtGui/QAccessibleBridge ../../include/QtGui/QAccessibleBridgeFactoryInterface ../../include/QtGui/QAccessibleBridgePlugin ../../include/QtGui/QAccessibleObject ../../include/QtGui/QAccessibleObjectEx ../../include/QtGui/QAccessibleApplication ../../include/QtGui/QAccessibleFactoryInterface ../../include/QtGui/QAccessiblePlugin ../../include/QtGui/QAccessibleWidget ../../include/QtGui/QAccessibleWidgetEx ../../include/QtGui/QCDEStyle ../../include/QtGui/QCleanlooksStyle ../../include/QtGui/QCommonStyle ../../include/QtGui/QGtkStyle ../../include/QtGui/QMacStyle ../../include/QtGui/QMotifStyle ../../include/QtGui/QPlastiqueStyle ../../include/QtGui/QProxyStyle ../../include/QtGui/QS60Style ../../include/QtGui/QStyle ../../include/QtGui/QStyleFactory ../../include/QtGui/QStyleOption ../../include/QtGui/QStyleOptionFocusRect ../../include/QtGui/QStyleOptionFrame ../../include/QtGui/QStyleOptionFrameV2 ../../include/QtGui/QStyleOptionFrameV3 ../../include/QtGui/QStyleOptionTabWidgetFrame ../../include/QtGui/QStyleOptionTabWidgetFrameV2 ../../include/QtGui/QStyleOptionTabBarBase ../../include/QtGui/QStyleOptionTabBarBaseV2 ../../include/QtGui/QStyleOptionHeader ../../include/QtGui/QStyleOptionButton ../../include/QtGui/QStyleOptionTab ../../include/QtGui/QStyleOptionTabV2 ../../include/QtGui/QStyleOptionTabV3 ../../include/QtGui/QStyleOptionToolBar ../../include/QtGui/QStyleOptionProgressBar ../../include/QtGui/QStyleOptionProgressBarV2 ../../include/QtGui/QStyleOptionMenuItem ../../include/QtGui/QStyleOptionQ3ListViewItem ../../include/QtGui/QStyleOptionQ3DockWindow ../../include/QtGui/QStyleOptionDockWidget ../../include/QtGui/QStyleOptionDockWidgetV2 ../../include/QtGui/QStyleOptionViewItem ../../include/QtGui/QStyleOptionViewItemV2 ../../include/QtGui/QStyleOptionViewItemV3 ../../include/QtGui/QStyleOptionViewItemV4 ../../include/QtGui/QStyleOptionToolBox ../../include/QtGui/QStyleOptionToolBoxV2 ../../include/QtGui/QStyleOptionRubberBand ../../include/QtGui/QStyleOptionComplex ../../include/QtGui/QStyleOptionSlider ../../include/QtGui/QStyleOptionSpinBox ../../include/QtGui/QStyleOptionQ3ListView ../../include/QtGui/QStyleOptionToolButton ../../include/QtGui/QStyleOptionComboBox ../../include/QtGui/QStyleOptionTitleBar ../../include/QtGui/QStyleOptionGroupBox ../../include/QtGui/QStyleOptionSizeGrip ../../include/QtGui/QStyleOptionGraphicsItem ../../include/QtGui/QStyleHintReturn ../../include/QtGui/QStyleHintReturnMask ../../include/QtGui/QStyleHintReturnVariant ../../include/QtGui/QStyleFactoryInterface ../../include/QtGui/QStylePlugin ../../include/QtGui/QWindowsCEStyle ../../include/QtGui/QWindowsMobileStyle ../../include/QtGui/QWindowsStyle ../../include/QtGui/QWindowsVistaStyle ../../include/QtGui/QWindowsXPStyle ../../include/QtGui/QInputContext ../../include/QtGui/QInputContextFactory ../../include/QtGui/QInputContextFactoryInterface ../../include/QtGui/QInputContextPlugin ../../include/QtGui/QBrush ../../include/QtGui/QBrushData ../../include/QtGui/QGradientStop ../../include/QtGui/QGradientStops ../../include/QtGui/QGradient ../../include/QtGui/QLinearGradient ../../include/QtGui/QRadialGradient ../../include/QtGui/QConicalGradient ../../include/QtGui/QColor ../../include/QtGui/QColormap ../../include/QtGui/QTileRules ../../include/QtGui/QMatrix ../../include/QtGui/QPaintDevice ../../include/QtGui/QTextItem ../../include/QtGui/QPaintEngine ../../include/QtGui/QPaintEngineState ../../include/QtGui/QPainter ../../include/QtGui/QPainterPath ../../include/QtGui/QPainterPathPrivate ../../include/QtGui/QPainterPathStroker ../../include/QtGui/QPen ../../include/QtGui/QPolygon ../../include/QtGui/QPolygonF ../../include/QtGui/QPrintEngine ../../include/QtGui/QPrinter ../../include/QtGui/QPrinterInfo ../../include/QtGui/QRegion ../../include/QtGui/QRgb ../../include/QtGui/QStylePainter ../../include/QtGui/QTransform ../../include/QtGui/QWMatrix 
-SYNCQT.PRIVATE_HEADER_FILES = ../gui/dialogs/qabstractpagesetupdialog_p.h ../gui/dialogs/qabstractprintdialog_p.h ../gui/dialogs/qcolordialog_p.h ../gui/dialogs/qdialog_p.h ../gui/dialogs/qfiledialog_p.h ../gui/dialogs/qfiledialog_win_p.h ../gui/dialogs/qfileinfogatherer_p.h ../gui/dialogs/qfilesystemmodel_p.h ../gui/dialogs/qfontdialog_p.h ../gui/dialogs/qfscompleter_p.h ../gui/dialogs/qpagesetupdialog_unix_p.h ../gui/dialogs/qsidebar_p.h ../gui/dialogs/qwizard_win_p.h ../gui/embedded/qkbd_defaultmap_qws_p.h ../gui/embedded/qkbd_qws_p.h ../gui/embedded/qlock_p.h ../gui/embedded/qscreenmulti_qws_p.h ../gui/embedded/qtransportauth_qws_p.h ../gui/embedded/qunixsocket_p.h ../gui/embedded/qunixsocketserver_p.h ../gui/embedded/qwindowsystem_p.h ../gui/embedded/qwscommand_qws_p.h ../gui/embedded/qwsdisplay_qws_p.h ../gui/embedded/qwslock_p.h ../gui/embedded/qwsmanager_p.h ../gui/embedded/qwssharedmemory_p.h ../gui/embedded/qwssignalhandler_p.h ../gui/graphicsview/qgraph_p.h ../gui/graphicsview/qgraphicsanchorlayout_p.h ../gui/graphicsview/qgraphicsitem_p.h ../gui/graphicsview/qgraphicslayout_p.h ../gui/graphicsview/qgraphicslayoutitem_p.h ../gui/graphicsview/qgraphicsproxywidget_p.h ../gui/graphicsview/qgraphicsscene_bsp_p.h ../gui/graphicsview/qgraphicsscene_p.h ../gui/graphicsview/qgraphicsscenebsptreeindex_p.h ../gui/graphicsview/qgraphicssceneindex_p.h ../gui/graphicsview/qgraphicsscenelinearindex_p.h ../gui/graphicsview/qgraphicstransform_p.h ../gui/graphicsview/qgraphicsview_p.h ../gui/graphicsview/qgraphicswidget_p.h ../gui/graphicsview/qgridlayoutengine_p.h ../gui/graphicsview/qsimplex_p.h ../gui/kernel/qaction_p.h ../gui/kernel/qapplication_p.h ../gui/kernel/qclipboard_p.h ../gui/kernel/qcocoaapplication_mac_p.h ../gui/kernel/qcocoaapplicationdelegate_mac_p.h ../gui/kernel/qcocoamenuloader_mac_p.h ../gui/kernel/qcocoapanel_mac_p.h ../gui/kernel/qcocoasharedwindowmethods_mac_p.h ../gui/kernel/qcocoaview_mac_p.h ../gui/kernel/qcocoawindow_mac_p.h ../gui/kernel/qcocoawindowcustomthemeframe_mac_p.h ../gui/kernel/qcocoawindowdelegate_mac_p.h ../gui/kernel/qcursor_p.h ../gui/kernel/qdesktopwidget_mac_p.h ../gui/kernel/qdnd_p.h ../gui/kernel/qevent_p.h ../gui/kernel/qeventdispatcher_glib_qws_p.h ../gui/kernel/qeventdispatcher_mac_p.h ../gui/kernel/qeventdispatcher_qws_p.h ../gui/kernel/qeventdispatcher_s60_p.h ../gui/kernel/qeventdispatcher_x11_p.h ../gui/kernel/qgesture_p.h ../gui/kernel/qgesturemanager_p.h ../gui/kernel/qguieventdispatcher_glib_p.h ../gui/kernel/qguiplatformplugin_p.h ../gui/kernel/qkde_p.h ../gui/kernel/qkeymapper_p.h ../gui/kernel/qkeysequence_p.h ../gui/kernel/qlayout_p.h ../gui/kernel/qlayoutengine_p.h ../gui/kernel/qmacgesturerecognizer_mac_p.h ../gui/kernel/qmultitouch_mac_p.h ../gui/kernel/qnsframeview_mac_p.h ../gui/kernel/qnsthemeframe_mac_p.h ../gui/kernel/qnstitledframe_mac_p.h ../gui/kernel/qshortcutmap_p.h ../gui/kernel/qsoftkeymanager_common_p.h ../gui/kernel/qsoftkeymanager_p.h ../gui/kernel/qsoftkeymanager_s60_p.h ../gui/kernel/qsound_p.h ../gui/kernel/qstandardgestures_p.h ../gui/kernel/qt_cocoa_helpers_mac_p.h ../gui/kernel/qt_gui_pch.h ../gui/kernel/qt_mac_p.h ../gui/kernel/qt_s60_p.h ../gui/kernel/qt_x11_p.h ../gui/kernel/qwidget_p.h ../gui/kernel/qwidgetaction_p.h ../gui/kernel/qwinnativepangesturerecognizer_win_p.h ../gui/effects/qgraphicseffect_p.h ../gui/s60framework/qs60mainapplication_p.h ../gui/image/qbmphandler_p.h ../gui/image/qgifhandler_p.h ../gui/image/qicon_p.h ../gui/image/qiconloader_p.h ../gui/image/qimage_p.h ../gui/image/qimagepixmapcleanuphooks_p.h ../gui/image/qjpeghandler_p.h ../gui/image/qmnghandler_p.h ../gui/image/qnativeimage_p.h ../gui/image/qpaintengine_pic_p.h ../gui/image/qpicture_p.h ../gui/image/qpixmap_mac_p.h ../gui/image/qpixmap_raster_p.h ../gui/image/qpixmap_s60_p.h ../gui/image/qpixmap_x11_p.h ../gui/image/qpixmapcache_p.h ../gui/image/qpixmapdata_p.h ../gui/image/qpixmapdatafactory_p.h ../gui/image/qpixmapfilter_p.h ../gui/image/qpnghandler_p.h ../gui/image/qppmhandler_p.h ../gui/image/qtiffhandler_p.h ../gui/image/qxbmhandler_p.h ../gui/image/qxpmhandler_p.h ../gui/text/qabstractfontengine_p.h ../gui/text/qabstracttextdocumentlayout_p.h ../gui/text/qcssparser_p.h ../gui/text/qfont_p.h ../gui/text/qfontengine_ft_p.h ../gui/text/qfontengine_p.h ../gui/text/qfontengine_qpf_p.h ../gui/text/qfontengine_s60_p.h ../gui/text/qfontengine_win_p.h ../gui/text/qfontengine_x11_p.h ../gui/text/qfontengineglyphcache_p.h ../gui/text/qfontsubset_p.h ../gui/text/qfragmentmap_p.h ../gui/text/qstatictext_p.h ../gui/text/qtextcontrol_p.h ../gui/text/qtextcontrol_p_p.h ../gui/text/qtextcursor_p.h ../gui/text/qtextdocument_p.h ../gui/text/qtextdocumentfragment_p.h ../gui/text/qtextdocumentlayout_p.h ../gui/text/qtextengine_p.h ../gui/text/qtextformat_p.h ../gui/text/qtexthtmlparser_p.h ../gui/text/qtextimagehandler_p.h ../gui/text/qtextobject_p.h ../gui/text/qtextodfwriter_p.h ../gui/text/qtexttable_p.h ../gui/text/qzipreader_p.h ../gui/text/qzipwriter_p.h ../gui/itemviews/qabstractitemview_p.h ../gui/itemviews/qabstractproxymodel_p.h ../gui/itemviews/qbsptree_p.h ../gui/itemviews/qcolumnview_p.h ../gui/itemviews/qcolumnviewgrip_p.h ../gui/itemviews/qheaderview_p.h ../gui/itemviews/qitemeditorfactory_p.h ../gui/itemviews/qitemselectionmodel_p.h ../gui/itemviews/qlistview_p.h ../gui/itemviews/qlistwidget_p.h ../gui/itemviews/qproxymodel_p.h ../gui/itemviews/qstandarditemmodel_p.h ../gui/itemviews/qtableview_p.h ../gui/itemviews/qtablewidget_p.h ../gui/itemviews/qtreeview_p.h ../gui/itemviews/qtreewidget_p.h ../gui/itemviews/qtreewidgetitemiterator_p.h ../gui/itemviews/qwidgetitemdata_p.h ../gui/widgets/qabstractbutton_p.h ../gui/widgets/qabstractscrollarea_p.h ../gui/widgets/qabstractslider_p.h ../gui/widgets/qabstractspinbox_p.h ../gui/widgets/qcalendartextnavigator_p.h ../gui/widgets/qcocoamenu_mac_p.h ../gui/widgets/qcocoatoolbardelegate_mac_p.h ../gui/widgets/qcombobox_p.h ../gui/widgets/qdatetimeedit_p.h ../gui/widgets/qdockarealayout_p.h ../gui/widgets/qdockwidget_p.h ../gui/widgets/qeffects_p.h ../gui/widgets/qframe_p.h ../gui/widgets/qlabel_p.h ../gui/widgets/qlinecontrol_p.h ../gui/widgets/qlineedit_p.h ../gui/widgets/qmainwindowlayout_p.h ../gui/widgets/qmdiarea_p.h ../gui/widgets/qmdisubwindow_p.h ../gui/widgets/qmenu_p.h ../gui/widgets/qmenu_wince_resource_p.h ../gui/widgets/qmenubar_p.h ../gui/widgets/qplaintextedit_p.h ../gui/widgets/qpushbutton_p.h ../gui/widgets/qscrollarea_p.h ../gui/widgets/qsplitter_p.h ../gui/widgets/qtabbar_p.h ../gui/widgets/qtextedit_p.h ../gui/widgets/qtoolbar_p.h ../gui/widgets/qtoolbararealayout_p.h ../gui/widgets/qtoolbarextension_p.h ../gui/widgets/qtoolbarlayout_p.h ../gui/widgets/qtoolbarseparator_p.h ../gui/widgets/qwidgetanimator_p.h ../gui/widgets/qwidgetresizehandler_p.h ../gui/statemachine/qbasickeyeventtransition_p.h ../gui/statemachine/qbasicmouseeventtransition_p.h ../gui/util/qcompleter_p.h ../gui/util/qsystemtrayicon_p.h ../gui/util/qundostack_p.h ../gui/accessible/qaccessible_mac_p.h ../gui/styles/qcleanlooksstyle_p.h ../gui/styles/qcommonstyle_p.h ../gui/styles/qcommonstylepixmaps_p.h ../gui/styles/qgtkpainter_p.h ../gui/styles/qgtkstyle_p.h ../gui/styles/qmacstyle_mac_p.h ../gui/styles/qmacstylepixmaps_mac_p.h ../gui/styles/qmotifstyle_p.h ../gui/styles/qproxystyle_p.h ../gui/styles/qs60style_p.h ../gui/styles/qstyle_p.h ../gui/styles/qstylehelper_p.h ../gui/styles/qstylesheetstyle_p.h ../gui/styles/qwindowscestyle_p.h ../gui/styles/qwindowsmobilestyle_p.h ../gui/styles/qwindowsstyle_p.h ../gui/styles/qwindowsvistastyle_p.h ../gui/styles/qwindowsxpstyle_p.h ../gui/egl/qegl_p.h ../gui/egl/qeglcontext_p.h ../gui/egl/qeglproperties_p.h ../gui/inputmethod/qcoefepinputcontext_p.h ../gui/inputmethod/qinputcontext_p.h ../gui/inputmethod/qmacinputcontext_p.h ../gui/inputmethod/qwininputcontext_p.h ../gui/inputmethod/qwsinputcontext_p.h ../gui/inputmethod/qximinputcontext_p.h ../gui/painting/qbackingstore_p.h ../gui/painting/qbezier_p.h ../gui/painting/qblendfunctions_p.h ../gui/painting/qcolor_p.h ../gui/painting/qcssutil_p.h ../gui/painting/qcups_p.h ../gui/painting/qdatabuffer_p.h ../gui/painting/qdrawhelper_arm_simd_p.h ../gui/painting/qdrawhelper_mmx_p.h ../gui/painting/qdrawhelper_neon_p.h ../gui/painting/qdrawhelper_p.h ../gui/painting/qdrawhelper_sse_p.h ../gui/painting/qdrawhelper_x86_p.h ../gui/painting/qdrawingprimitive_sse2_p.h ../gui/painting/qemulationpaintengine_p.h ../gui/painting/qfixed_p.h ../gui/painting/qgraphicssystem_mac_p.h ../gui/painting/qgraphicssystem_p.h ../gui/painting/qgraphicssystem_qws_p.h ../gui/painting/qgraphicssystem_raster_p.h ../gui/painting/qgraphicssystem_runtime_p.h ../gui/painting/qgraphicssystemfactory_p.h ../gui/painting/qgraphicssystemplugin_p.h ../gui/painting/qgrayraster_p.h ../gui/painting/qimagescale_p.h ../gui/painting/qmath_p.h ../gui/painting/qmemrotate_p.h ../gui/painting/qoutlinemapper_p.h ../gui/painting/qpaintbuffer_p.h ../gui/painting/qpaintengine_alpha_p.h ../gui/painting/qpaintengine_mac_p.h ../gui/painting/qpaintengine_p.h ../gui/painting/qpaintengine_preview_p.h ../gui/painting/qpaintengine_raster_p.h ../gui/painting/qpaintengine_s60_p.h ../gui/painting/qpaintengine_x11_p.h ../gui/painting/qpaintengineex_p.h ../gui/painting/qpainter_p.h ../gui/painting/qpainterpath_p.h ../gui/painting/qpathclipper_p.h ../gui/painting/qpdf_p.h ../gui/painting/qpen_p.h ../gui/painting/qpolygonclipper_p.h ../gui/painting/qprintengine_mac_p.h ../gui/painting/qprintengine_pdf_p.h ../gui/painting/qprintengine_ps_p.h ../gui/painting/qprintengine_qws_p.h ../gui/painting/qprintengine_win_p.h ../gui/painting/qprinter_p.h ../gui/painting/qprinterinfo_unix_p.h ../gui/painting/qrasterdefs_p.h ../gui/painting/qrasterizer_p.h ../gui/painting/qstroker_p.h ../gui/painting/qtessellator_p.h ../gui/painting/qtextureglyphcache_p.h ../gui/painting/qvectorpath_p.h ../gui/painting/qwindowsurface_mac_p.h ../gui/painting/qwindowsurface_p.h ../gui/painting/qwindowsurface_qws_p.h ../gui/painting/qwindowsurface_raster_p.h ../gui/painting/qwindowsurface_s60_p.h ../gui/painting/qwindowsurface_x11_p.h 
+SYNCQT.HEADER_FILES = ../gui/dialogs/qabstractpagesetupdialog.h ../gui/dialogs/qabstractprintdialog.h ../gui/dialogs/qcolordialog.h ../gui/dialogs/qdialog.h ../gui/dialogs/qerrormessage.h ../gui/dialogs/qfiledialog.h ../gui/dialogs/qfilesystemmodel.h ../gui/dialogs/qfontdialog.h ../gui/dialogs/qinputdialog.h ../gui/dialogs/qmessagebox.h ../gui/dialogs/qpagesetupdialog.h ../gui/dialogs/qprintdialog.h ../gui/dialogs/qprintpreviewdialog.h ../gui/dialogs/qprogressdialog.h ../gui/dialogs/qwizard.h ../gui/embedded/qcopchannel_qws.h ../gui/embedded/qdecoration_qws.h ../gui/embedded/qdecorationdefault_qws.h ../gui/embedded/qdecorationfactory_qws.h ../gui/embedded/qdecorationplugin_qws.h ../gui/embedded/qdecorationstyled_qws.h ../gui/embedded/qdecorationwindows_qws.h ../gui/embedded/qdirectpainter_qws.h ../gui/embedded/qkbd_qws.h ../gui/embedded/qkbddriverfactory_qws.h ../gui/embedded/qkbddriverplugin_qws.h ../gui/embedded/qkbdlinuxinput_qws.h ../gui/embedded/qkbdqnx_qws.h ../gui/embedded/qkbdtty_qws.h ../gui/embedded/qkbdum_qws.h ../gui/embedded/qkbdvfb_qws.h ../gui/embedded/qmouse_qws.h ../gui/embedded/qmousedriverfactory_qws.h ../gui/embedded/qmousedriverplugin_qws.h ../gui/embedded/qmouselinuxinput_qws.h ../gui/embedded/qmouselinuxtp_qws.h ../gui/embedded/qmousepc_qws.h ../gui/embedded/qmouseqnx_qws.h ../gui/embedded/qmousetslib_qws.h ../gui/embedded/qmousevfb_qws.h ../gui/embedded/qscreen_qws.h ../gui/embedded/qscreendriverfactory_qws.h ../gui/embedded/qscreendriverplugin_qws.h ../gui/embedded/qscreenlinuxfb_qws.h ../gui/embedded/qscreenproxy_qws.h ../gui/embedded/qscreenqnx_qws.h ../gui/embedded/qscreentransformed_qws.h ../gui/embedded/qscreenvfb_qws.h ../gui/embedded/qsoundqss_qws.h ../gui/embedded/qtransportauth_qws.h ../gui/embedded/qtransportauthdefs_qws.h ../gui/embedded/qvfbhdr.h ../gui/embedded/qwindowsystem_qws.h ../gui/embedded/qwscursor_qws.h ../gui/embedded/qwsdisplay_qws.h ../gui/embedded/qwsembedwidget.h ../gui/embedded/qwsevent_qws.h ../gui/embedded/qwsmanager_qws.h ../gui/embedded/qwsproperty_qws.h ../gui/embedded/qwsprotocolitem_qws.h ../gui/embedded/qwssocket_qws.h ../gui/embedded/qwsutils_qws.h ../gui/graphicsview/qgraphicsanchorlayout.h ../gui/graphicsview/qgraphicsgridlayout.h ../gui/graphicsview/qgraphicsitem.h ../gui/graphicsview/qgraphicsitemanimation.h ../gui/graphicsview/qgraphicslayout.h ../gui/graphicsview/qgraphicslayoutitem.h ../gui/graphicsview/qgraphicslinearlayout.h ../gui/graphicsview/qgraphicsproxywidget.h ../gui/graphicsview/qgraphicsscene.h ../gui/graphicsview/qgraphicssceneevent.h ../gui/graphicsview/qgraphicstransform.h ../gui/graphicsview/qgraphicsview.h ../gui/graphicsview/qgraphicswidget.h ../gui/kernel/qaction.h ../gui/kernel/qactiongroup.h ../gui/kernel/qapplication.h ../gui/kernel/qboxlayout.h ../gui/kernel/qclipboard.h ../gui/kernel/qcursor.h ../gui/kernel/qdesktopwidget.h ../gui/kernel/qdrag.h ../gui/kernel/qevent.h ../gui/kernel/qformlayout.h ../gui/kernel/qgesture.h ../gui/kernel/qgesturerecognizer.h ../gui/kernel/qgridlayout.h ../gui/kernel/qguifunctions_wince.h ../gui/kernel/qkeysequence.h ../gui/kernel/qlayout.h ../gui/kernel/qlayoutitem.h ../gui/kernel/qmacdefines_mac.h ../gui/kernel/qmime.h ../gui/kernel/qpalette.h ../gui/kernel/qsessionmanager.h ../gui/kernel/qshortcut.h ../gui/kernel/qsizepolicy.h ../gui/kernel/qsound.h ../gui/kernel/qstackedlayout.h ../gui/kernel/qtooltip.h ../gui/kernel/qwhatsthis.h ../gui/kernel/qwidget.h ../gui/kernel/qwidgetaction.h ../gui/kernel/qwindowdefs.h ../gui/kernel/qwindowdefs_win.h ../gui/kernel/qx11embed_x11.h ../gui/kernel/qx11info_x11.h ../gui/effects/qgraphicseffect.h ../gui/s60framework/qs60mainapplication.h ../gui/s60framework/qs60mainappui.h ../gui/s60framework/qs60maindocument.h ../gui/math3d/qgenericmatrix.h ../gui/math3d/qmatrix4x4.h ../gui/math3d/qquaternion.h ../gui/math3d/qvector2d.h ../gui/math3d/qvector3d.h ../gui/math3d/qvector4d.h ../gui/image/qbitmap.h ../gui/image/qicon.h ../gui/image/qiconengine.h ../gui/image/qiconengineplugin.h ../gui/image/qimage.h ../gui/image/qimageiohandler.h ../gui/image/qimagereader.h ../gui/image/qimagewriter.h ../gui/image/qmovie.h ../gui/image/qpicture.h ../gui/image/qpictureformatplugin.h ../gui/image/qpixmap.h ../gui/image/qpixmapcache.h ../gui/symbian/qsymbianevent.h ../gui/text/qabstractfontengine_qws.h ../gui/text/qabstracttextdocumentlayout.h ../gui/text/qfont.h ../gui/text/qfontdatabase.h ../gui/text/qfontinfo.h ../gui/text/qfontmetrics.h ../gui/text/qstatictext.h ../gui/text/qsyntaxhighlighter.h ../gui/text/qtextcursor.h ../gui/text/qtextdocument.h ../gui/text/qtextdocumentfragment.h ../gui/text/qtextdocumentwriter.h ../gui/text/qtextformat.h ../gui/text/qtextlayout.h ../gui/text/qtextlist.h ../gui/text/qtextobject.h ../gui/text/qtextoption.h ../gui/text/qtexttable.h ../gui/itemviews/qabstractitemdelegate.h ../gui/itemviews/qabstractitemview.h ../gui/itemviews/qabstractproxymodel.h ../gui/itemviews/qcolumnview.h ../gui/itemviews/qdatawidgetmapper.h ../gui/itemviews/qdirmodel.h ../gui/itemviews/qfileiconprovider.h ../gui/itemviews/qheaderview.h ../gui/itemviews/qitemdelegate.h ../gui/itemviews/qitemeditorfactory.h ../gui/itemviews/qitemselectionmodel.h ../gui/itemviews/qlistview.h ../gui/itemviews/qlistwidget.h ../gui/itemviews/qproxymodel.h ../gui/itemviews/qsortfilterproxymodel.h ../gui/itemviews/qstandarditemmodel.h ../gui/itemviews/qstringlistmodel.h ../gui/itemviews/qstyleditemdelegate.h ../gui/itemviews/qtableview.h ../gui/itemviews/qtablewidget.h ../gui/itemviews/qtreeview.h ../gui/itemviews/qtreewidget.h ../gui/itemviews/qtreewidgetitemiterator.h ../gui/widgets/qabstractbutton.h ../gui/widgets/qabstractscrollarea.h ../gui/widgets/qabstractslider.h ../gui/widgets/qabstractspinbox.h ../gui/widgets/qbuttongroup.h ../gui/widgets/qcalendarwidget.h ../gui/widgets/qcheckbox.h ../gui/widgets/qcombobox.h ../gui/widgets/qcommandlinkbutton.h ../gui/widgets/qdatetimeedit.h ../gui/widgets/qdial.h ../gui/widgets/qdialogbuttonbox.h ../gui/widgets/qdockwidget.h ../gui/widgets/qfocusframe.h ../gui/widgets/qfontcombobox.h ../gui/widgets/qframe.h ../gui/widgets/qgroupbox.h ../gui/widgets/qlabel.h ../gui/widgets/qlcdnumber.h ../gui/widgets/qlineedit.h ../gui/widgets/qmaccocoaviewcontainer_mac.h ../gui/widgets/qmacnativewidget_mac.h ../gui/widgets/qmainwindow.h ../gui/widgets/qmdiarea.h ../gui/widgets/qmdisubwindow.h ../gui/widgets/qmenu.h ../gui/widgets/qmenubar.h ../gui/widgets/qmenudata.h ../gui/widgets/qplaintextedit.h ../gui/widgets/qprintpreviewwidget.h ../gui/widgets/qprogressbar.h ../gui/widgets/qpushbutton.h ../gui/widgets/qradiobutton.h ../gui/widgets/qrubberband.h ../gui/widgets/qscrollarea.h ../gui/widgets/qscrollbar.h ../gui/widgets/qsizegrip.h ../gui/widgets/qslider.h ../gui/widgets/qspinbox.h ../gui/widgets/qsplashscreen.h ../gui/widgets/qsplitter.h ../gui/widgets/qstackedwidget.h ../gui/widgets/qstatusbar.h ../gui/widgets/qtabbar.h ../gui/widgets/qtabwidget.h ../gui/widgets/qtextbrowser.h ../gui/widgets/qtextedit.h ../gui/widgets/qtoolbar.h ../gui/widgets/qtoolbox.h ../gui/widgets/qtoolbutton.h ../gui/widgets/qvalidator.h ../gui/widgets/qworkspace.h ../gui/statemachine/qkeyeventtransition.h ../gui/statemachine/qmouseeventtransition.h ../gui/util/qcompleter.h ../gui/util/qdesktopservices.h ../gui/util/qsystemtrayicon.h ../gui/util/qundogroup.h ../gui/util/qundostack.h ../gui/util/qundoview.h ../gui/accessible/qaccessible.h ../gui/accessible/qaccessible2.h ../gui/accessible/qaccessiblebridge.h ../gui/accessible/qaccessibleobject.h ../gui/accessible/qaccessibleplugin.h ../gui/accessible/qaccessiblewidget.h ../gui/styles/qcdestyle.h ../gui/styles/qcleanlooksstyle.h ../gui/styles/qcommonstyle.h ../gui/styles/qgtkstyle.h ../gui/styles/qmacstyle_mac.h ../gui/styles/qmotifstyle.h ../gui/styles/qplastiquestyle.h ../gui/styles/qproxystyle.h ../gui/styles/qs60style.h ../gui/styles/qstyle.h ../gui/styles/qstylefactory.h ../gui/styles/qstyleoption.h ../gui/styles/qstyleplugin.h ../gui/styles/qwindowscestyle.h ../gui/styles/qwindowsmobilestyle.h ../gui/styles/qwindowsstyle.h ../gui/styles/qwindowsvistastyle.h ../gui/styles/qwindowsxpstyle.h ../gui/inputmethod/qinputcontext.h ../gui/inputmethod/qinputcontextfactory.h ../gui/inputmethod/qinputcontextplugin.h ../gui/painting/qbrush.h ../gui/painting/qcolor.h ../gui/painting/qcolormap.h ../gui/painting/qdrawutil.h ../gui/painting/qmatrix.h ../gui/painting/qpaintdevice.h ../gui/painting/qpaintengine.h ../gui/painting/qpainter.h ../gui/painting/qpainterpath.h ../gui/painting/qpen.h ../gui/painting/qpolygon.h ../gui/painting/qprintengine.h ../gui/painting/qprinter.h ../gui/painting/qprinterinfo.h ../gui/painting/qregion.h ../gui/painting/qrgb.h ../gui/painting/qstylepainter.h ../gui/painting/qtransform.h ../gui/painting/qwmatrix.h ../../include/QtGui/QtGui ../gui/kernel/qwindowdefs_haiku.h ../gui/kernel/qwidget_haiku.h ../gui/util/qsystemtrayicon_haiku.h
+SYNCQT.HEADER_CLASSES = ../../include/QtGui/QAbstractPageSetupDialog ../../include/QtGui/QAbstractPrintDialog ../../include/QtGui/QColorDialog ../../include/QtGui/QDialog ../../include/QtGui/QErrorMessage ../../include/QtGui/QFileDialog ../../include/QtGui/QFileSystemModel ../../include/QtGui/QFontDialog ../../include/QtGui/QInputDialog ../../include/QtGui/QMessageBox ../../include/QtGui/QPageSetupDialog ../../include/QtGui/QUnixPrintWidget ../../include/QtGui/QPrintDialog ../../include/QtGui/QPrintPreviewDialog ../../include/QtGui/QProgressDialog ../../include/QtGui/QWizard ../../include/QtGui/QWizardPage ../../include/QtGui/QCopChannel ../../include/QtGui/QDecorationAction ../../include/QtGui/QDecoration ../../include/QtGui/QDecorationDefault ../../include/QtGui/QDecorationFactory ../../include/QtGui/QDecorationFactoryInterface ../../include/QtGui/QDecorationPlugin ../../include/QtGui/QDecorationStyled ../../include/QtGui/QDecorationWindows ../../include/QtGui/QDirectPainter ../../include/QtGui/QWSKeyboardHandler ../../include/QtGui/QKbdDriverFactory ../../include/QtGui/QWSKeyboardHandlerFactoryInterface ../../include/QtGui/QKbdDriverPlugin ../../include/QtGui/QWSLinuxInputKeyboardHandler ../../include/QtGui/QWSQnxKeyboardHandler ../../include/QtGui/QWSTtyKeyboardHandler ../../include/QtGui/QWSUmKeyboardHandler ../../include/QtGui/QVFbKeyboardHandler ../../include/QtGui/QWSPointerCalibrationData ../../include/QtGui/QWSMouseHandler ../../include/QtGui/QWSCalibratedMouseHandler ../../include/QtGui/QMouseDriverFactory ../../include/QtGui/QWSMouseHandlerFactoryInterface ../../include/QtGui/QMouseDriverPlugin ../../include/QtGui/QWSLinuxInputMouseHandler ../../include/QtGui/QWSLinuxTPMouseHandler ../../include/QtGui/QWSPcMouseHandler ../../include/QtGui/QQnxMouseHandler ../../include/QtGui/QWSTslibMouseHandler ../../include/QtGui/QVFbMouseHandler ../../include/QtGui/QScreenCursor ../../include/QtGui/QPoolEntry ../../include/QtGui/QScreen ../../include/QtGui/QScreenDriverFactory ../../include/QtGui/QScreenDriverFactoryInterface ../../include/QtGui/QScreenDriverPlugin ../../include/QtGui/QLinuxFb_Shared ../../include/QtGui/QLinuxFbScreen ../../include/QtGui/QProxyScreenCursor ../../include/QtGui/QProxyScreen ../../include/QtGui/QQnxScreen ../../include/QtGui/QTransformedScreen ../../include/QtGui/QVFbScreen ../../include/QtGui/QWSSoundServer ../../include/QtGui/QWSSoundClient ../../include/QtGui/QWSSoundServerSocket ../../include/QtGui/QTransportAuth ../../include/QtGui/QAuthDevice ../../include/QtGui/QVFbHeader ../../include/QtGui/QVFbKeyData ../../include/QtGui/QWSInternalWindowInfo ../../include/QtGui/QWSScreenSaver ../../include/QtGui/QWSWindow ../../include/QtGui/QWSServer ../../include/QtGui/QWSInputMethod ../../include/QtGui/QWSCursorMap ../../include/QtGui/QWSClient ../../include/QtGui/QWSCursor ../../include/QtGui/QWSWindowInfo ../../include/QtGui/QWSDisplay ../../include/QtGui/QWSEmbedWidget ../../include/QtGui/QWSEvent ../../include/QtGui/QWSManager ../../include/QtGui/QWSPropertyManager ../../include/QtGui/QWSProtocolItem ../../include/QtGui/QWSSocket ../../include/QtGui/QWSServerSocket ../../include/QtGui/QGraphicsAnchor ../../include/QtGui/QGraphicsAnchorLayout ../../include/QtGui/QGraphicsGridLayout ../../include/QtGui/QGraphicsItem ../../include/QtGui/QGraphicsObject ../../include/QtGui/QAbstractGraphicsShapeItem ../../include/QtGui/QGraphicsPathItem ../../include/QtGui/QGraphicsRectItem ../../include/QtGui/QGraphicsEllipseItem ../../include/QtGui/QGraphicsPolygonItem ../../include/QtGui/QGraphicsLineItem ../../include/QtGui/QGraphicsPixmapItem ../../include/QtGui/QGraphicsTextItem ../../include/QtGui/QGraphicsSimpleTextItem ../../include/QtGui/QGraphicsItemGroup ../../include/QtGui/QGraphicsItemAnimation ../../include/QtGui/QGraphicsLayout ../../include/QtGui/QGraphicsLayoutItem ../../include/QtGui/QGraphicsLinearLayout ../../include/QtGui/QGraphicsProxyWidget ../../include/QtGui/QGraphicsScene ../../include/QtGui/QGraphicsSceneEvent ../../include/QtGui/QGraphicsSceneMouseEvent ../../include/QtGui/QGraphicsSceneWheelEvent ../../include/QtGui/QGraphicsSceneContextMenuEvent ../../include/QtGui/QGraphicsSceneHoverEvent ../../include/QtGui/QGraphicsSceneHelpEvent ../../include/QtGui/QGraphicsSceneDragDropEvent ../../include/QtGui/QGraphicsSceneResizeEvent ../../include/QtGui/QGraphicsSceneMoveEvent ../../include/QtGui/QGraphicsTransform ../../include/QtGui/QGraphicsScale ../../include/QtGui/QGraphicsRotation ../../include/QtGui/QGraphicsView ../../include/QtGui/QGraphicsWidget ../../include/QtGui/QAction ../../include/QtGui/QActionGroup ../../include/QtGui/QApplication ../../include/QtGui/QBoxLayout ../../include/QtGui/QHBoxLayout ../../include/QtGui/QVBoxLayout ../../include/QtGui/QClipboard ../../include/QtGui/QCursor ../../include/QtGui/QCursorShape ../../include/QtGui/QDesktopWidget ../../include/QtGui/QDrag ../../include/QtGui/QtEvents ../../include/QtGui/QInputEvent ../../include/QtGui/QMouseEvent ../../include/QtGui/QHoverEvent ../../include/QtGui/QWheelEvent ../../include/QtGui/QTabletEvent ../../include/QtGui/QKeyEvent ../../include/QtGui/QFocusEvent ../../include/QtGui/QPaintEvent ../../include/QtGui/QUpdateLaterEvent ../../include/QtGui/QMoveEvent ../../include/QtGui/QResizeEvent ../../include/QtGui/QCloseEvent ../../include/QtGui/QIconDragEvent ../../include/QtGui/QShowEvent ../../include/QtGui/QHideEvent ../../include/QtGui/QContextMenuEvent ../../include/QtGui/QInputMethodEvent ../../include/QtGui/QDropEvent ../../include/QtGui/QDragMoveEvent ../../include/QtGui/QDragEnterEvent ../../include/QtGui/QDragResponseEvent ../../include/QtGui/QDragLeaveEvent ../../include/QtGui/QHelpEvent ../../include/QtGui/QStatusTipEvent ../../include/QtGui/QWhatsThisClickedEvent ../../include/QtGui/QActionEvent ../../include/QtGui/QFileOpenEvent ../../include/QtGui/QToolBarChangeEvent ../../include/QtGui/QShortcutEvent ../../include/QtGui/QClipboardEvent ../../include/QtGui/QWindowStateChangeEvent ../../include/QtGui/QMenubarUpdatedEvent ../../include/QtGui/QTouchEvent ../../include/QtGui/QGestureEvent ../../include/QtGui/QFormLayout ../../include/QtGui/QGesture ../../include/QtGui/QPanGesture ../../include/QtGui/QPinchGesture ../../include/QtGui/QSwipeGesture ../../include/QtGui/QTapGesture ../../include/QtGui/QTapAndHoldGesture ../../include/QtGui/QGestureRecognizer ../../include/QtGui/QGridLayout ../../include/QtGui/QKeySequence ../../include/QtGui/QLayoutIterator ../../include/QtGui/QLayout ../../include/QtGui/QLayoutItem ../../include/QtGui/QSpacerItem ../../include/QtGui/QWidgetItem ../../include/QtGui/QWidgetItemV2 ../../include/QtGui/QMimeSource ../../include/QtGui/QWindowsMime ../../include/QtGui/QMacMime ../../include/QtGui/QMacPasteboardMime ../../include/QtGui/QPalette ../../include/QtGui/QColorGroup ../../include/QtGui/QSessionManager ../../include/QtGui/QShortcut ../../include/QtGui/QSizePolicy ../../include/QtGui/QSound ../../include/QtGui/QStackedLayout ../../include/QtGui/QToolTip ../../include/QtGui/QWhatsThis ../../include/QtGui/QWidgetData ../../include/QtGui/QWidget ../../include/QtGui/QWidgetAction ../../include/QtGui/QWidgetList ../../include/QtGui/QWidgetMapper ../../include/QtGui/QWidgetSet ../../include/QtGui/QX11EmbedWidget ../../include/QtGui/QX11EmbedContainer ../../include/QtGui/QX11Info ../../include/QtGui/QGraphicsEffect ../../include/QtGui/QGraphicsColorizeEffect ../../include/QtGui/QGraphicsBlurEffect ../../include/QtGui/QGraphicsDropShadowEffect ../../include/QtGui/QGraphicsOpacityEffect ../../include/QtGui/QS60MainApplicationBase ../../include/QtGui/QS60MainApplication ../../include/QtGui/QS60MainAppUiBase ../../include/QtGui/QS60StubAknAppUiBase ../../include/QtGui/QS60StubMEikStatusPaneObserver ../../include/QtGui/QS60StubMAknTouchPaneObserver ../../include/QtGui/QS60StubAknAppUi ../../include/QtGui/QS60MainAppUi ../../include/QtGui/QS60MainDocumentBase ../../include/QtGui/QS60MainDocument ../../include/QtGui/QGenericMatrix ../../include/QtGui/QMatrix2x2 ../../include/QtGui/QMatrix2x3 ../../include/QtGui/QMatrix2x4 ../../include/QtGui/QMatrix3x2 ../../include/QtGui/QMatrix3x3 ../../include/QtGui/QMatrix3x4 ../../include/QtGui/QMatrix4x2 ../../include/QtGui/QMatrix4x3 ../../include/QtGui/QMatrix4x4 ../../include/QtGui/QQuaternion ../../include/QtGui/QVector2D ../../include/QtGui/QVector3D ../../include/QtGui/QVector4D ../../include/QtGui/QBitmap ../../include/QtGui/QIcon ../../include/QtGui/QIconSet ../../include/QtGui/QIconEngine ../../include/QtGui/QIconEngineV2 ../../include/QtGui/QIconEngineFactoryInterface ../../include/QtGui/QIconEnginePlugin ../../include/QtGui/QIconEngineFactoryInterfaceV2 ../../include/QtGui/QIconEnginePluginV2 ../../include/QtGui/QImageTextKeyLang ../../include/QtGui/QImage ../../include/QtGui/QImageIOHandler ../../include/QtGui/QImageIOHandlerFactoryInterface ../../include/QtGui/QImageIOPlugin ../../include/QtGui/QImageReader ../../include/QtGui/QImageWriter ../../include/QtGui/QMovie ../../include/QtGui/QPicture ../../include/QtGui/QPictureIO ../../include/QtGui/QPictureFormatInterface ../../include/QtGui/QPictureFormatPlugin ../../include/QtGui/QPixmap ../../include/QtGui/QPixmapCache ../../include/QtGui/QSymbianEvent ../../include/QtGui/QFontEngineInfo ../../include/QtGui/QFontEngineFactoryInterface ../../include/QtGui/QFontEnginePlugin ../../include/QtGui/QAbstractFontEngine ../../include/QtGui/QAbstractTextDocumentLayout ../../include/QtGui/QTextObjectInterface ../../include/QtGui/QFont ../../include/QtGui/QFontDatabase ../../include/QtGui/QFontInfo ../../include/QtGui/QFontMetrics ../../include/QtGui/QFontMetricsF ../../include/QtGui/QStaticText ../../include/QtGui/QSyntaxHighlighter ../../include/QtGui/QTextCursor ../../include/QtGui/QAbstractUndoItem ../../include/QtGui/QTextDocument ../../include/QtGui/QTextDocumentFragment ../../include/QtGui/QTextDocumentWriter ../../include/QtGui/QTextLength ../../include/QtGui/QTextFormat ../../include/QtGui/QTextCharFormat ../../include/QtGui/QTextBlockFormat ../../include/QtGui/QTextListFormat ../../include/QtGui/QTextImageFormat ../../include/QtGui/QTextFrameFormat ../../include/QtGui/QTextTableFormat ../../include/QtGui/QTextTableCellFormat ../../include/QtGui/QTextInlineObject ../../include/QtGui/QTextLayout ../../include/QtGui/QTextLine ../../include/QtGui/QTextList ../../include/QtGui/QTextObject ../../include/QtGui/QTextBlockGroup ../../include/QtGui/QTextFrameLayoutData ../../include/QtGui/QTextFrame ../../include/QtGui/QTextBlockUserData ../../include/QtGui/QTextBlock ../../include/QtGui/QTextFragment ../../include/QtGui/QTextOption ../../include/QtGui/QTextTableCell ../../include/QtGui/QTextTable ../../include/QtGui/QAbstractItemDelegate ../../include/QtGui/QAbstractItemView ../../include/QtGui/QAbstractProxyModel ../../include/QtGui/QColumnView ../../include/QtGui/QDataWidgetMapper ../../include/QtGui/QDirModel ../../include/QtGui/QFileIconProvider ../../include/QtGui/QHeaderView ../../include/QtGui/QItemDelegate ../../include/QtGui/QItemEditorCreatorBase ../../include/QtGui/QItemEditorCreator ../../include/QtGui/QStandardItemEditorCreator ../../include/QtGui/QItemEditorFactory ../../include/QtGui/QItemSelectionRange ../../include/QtGui/QItemSelectionModel ../../include/QtGui/QItemSelection ../../include/QtGui/QListView ../../include/QtGui/QListWidgetItem ../../include/QtGui/QListWidget ../../include/QtGui/QProxyModel ../../include/QtGui/QSortFilterProxyModel ../../include/QtGui/QStandardItem ../../include/QtGui/QStandardItemModel ../../include/QtGui/QStringListModel ../../include/QtGui/QStyledItemDelegate ../../include/QtGui/QTableView ../../include/QtGui/QTableWidgetSelectionRange ../../include/QtGui/QTableWidgetItem ../../include/QtGui/QTableWidget ../../include/QtGui/QTreeView ../../include/QtGui/QTreeWidgetItem ../../include/QtGui/QTreeWidget ../../include/QtGui/QTreeWidgetItemIterator ../../include/QtGui/QAbstractButton ../../include/QtGui/QAbstractScrollArea ../../include/QtGui/QAbstractSlider ../../include/QtGui/QAbstractSpinBox ../../include/QtGui/QButtonGroup ../../include/QtGui/QCalendarWidget ../../include/QtGui/QCheckBox ../../include/QtGui/QComboBox ../../include/QtGui/QCommandLinkButton ../../include/QtGui/QDateTimeEdit ../../include/QtGui/QTimeEdit ../../include/QtGui/QDateEdit ../../include/QtGui/QDial ../../include/QtGui/QDialogButtonBox ../../include/QtGui/QDockWidget ../../include/QtGui/QFocusFrame ../../include/QtGui/QFontComboBox ../../include/QtGui/QFrame ../../include/QtGui/QGroupBox ../../include/QtGui/QLabel ../../include/QtGui/QLCDNumber ../../include/QtGui/QLineEdit ../../include/QtGui/QMacCocoaViewContainer ../../include/QtGui/QMacNativeWidget ../../include/QtGui/QMainWindow ../../include/QtGui/QMdiArea ../../include/QtGui/QMdiSubWindow ../../include/QtGui/QMenu ../../include/QtGui/QMenuBar ../../include/QtGui/QMenuItem ../../include/QtGui/QPlainTextEdit ../../include/QtGui/QPlainTextDocumentLayout ../../include/QtGui/QPrintPreviewWidget ../../include/QtGui/QProgressBar ../../include/QtGui/QPushButton ../../include/QtGui/QRadioButton ../../include/QtGui/QRubberBand ../../include/QtGui/QScrollArea ../../include/QtGui/QScrollBar ../../include/QtGui/QSizeGrip ../../include/QtGui/QSlider ../../include/QtGui/QSpinBox ../../include/QtGui/QDoubleSpinBox ../../include/QtGui/QSplashScreen ../../include/QtGui/QSplitter ../../include/QtGui/QSplitterHandle ../../include/QtGui/QStackedWidget ../../include/QtGui/QStatusBar ../../include/QtGui/QTabBar ../../include/QtGui/QTabWidget ../../include/QtGui/QTextBrowser ../../include/QtGui/QTextEdit ../../include/QtGui/QToolBar ../../include/QtGui/QToolBox ../../include/QtGui/QToolButton ../../include/QtGui/QValidator ../../include/QtGui/QIntValidator ../../include/QtGui/QDoubleValidator ../../include/QtGui/QRegExpValidator ../../include/QtGui/QWorkspace ../../include/QtGui/QKeyEventTransition ../../include/QtGui/QMouseEventTransition ../../include/QtGui/QCompleter ../../include/QtGui/QDesktopServices ../../include/QtGui/QSystemTrayIcon ../../include/QtGui/QUndoGroup ../../include/QtGui/QUndoCommand ../../include/QtGui/QUndoStack ../../include/QtGui/QUndoView ../../include/QtGui/QAccessible ../../include/QtGui/QAccessibleInterface ../../include/QtGui/QAccessibleInterfaceEx ../../include/QtGui/QAccessibleEvent ../../include/QtGui/QAccessible2Interface ../../include/QtGui/QAccessibleTextInterface ../../include/QtGui/QAccessibleEditableTextInterface ../../include/QtGui/QAccessibleSimpleEditableTextInterface ../../include/QtGui/QAccessibleValueInterface ../../include/QtGui/QAccessibleTableInterface ../../include/QtGui/QAccessibleActionInterface ../../include/QtGui/QAccessibleImageInterface ../../include/QtGui/QAccessibleBridge ../../include/QtGui/QAccessibleBridgeFactoryInterface ../../include/QtGui/QAccessibleBridgePlugin ../../include/QtGui/QAccessibleObject ../../include/QtGui/QAccessibleObjectEx ../../include/QtGui/QAccessibleApplication ../../include/QtGui/QAccessibleFactoryInterface ../../include/QtGui/QAccessiblePlugin ../../include/QtGui/QAccessibleWidget ../../include/QtGui/QAccessibleWidgetEx ../../include/QtGui/QCDEStyle ../../include/QtGui/QCleanlooksStyle ../../include/QtGui/QCommonStyle ../../include/QtGui/QGtkStyle ../../include/QtGui/QMacStyle ../../include/QtGui/QMotifStyle ../../include/QtGui/QPlastiqueStyle ../../include/QtGui/QProxyStyle ../../include/QtGui/QS60Style ../../include/QtGui/QStyle ../../include/QtGui/QStyleFactory ../../include/QtGui/QStyleOption ../../include/QtGui/QStyleOptionFocusRect ../../include/QtGui/QStyleOptionFrame ../../include/QtGui/QStyleOptionFrameV2 ../../include/QtGui/QStyleOptionFrameV3 ../../include/QtGui/QStyleOptionTabWidgetFrame ../../include/QtGui/QStyleOptionTabWidgetFrameV2 ../../include/QtGui/QStyleOptionTabBarBase ../../include/QtGui/QStyleOptionTabBarBaseV2 ../../include/QtGui/QStyleOptionHeader ../../include/QtGui/QStyleOptionButton ../../include/QtGui/QStyleOptionTab ../../include/QtGui/QStyleOptionTabV2 ../../include/QtGui/QStyleOptionTabV3 ../../include/QtGui/QStyleOptionToolBar ../../include/QtGui/QStyleOptionProgressBar ../../include/QtGui/QStyleOptionProgressBarV2 ../../include/QtGui/QStyleOptionMenuItem ../../include/QtGui/QStyleOptionQ3ListViewItem ../../include/QtGui/QStyleOptionQ3DockWindow ../../include/QtGui/QStyleOptionDockWidget ../../include/QtGui/QStyleOptionDockWidgetV2 ../../include/QtGui/QStyleOptionViewItem ../../include/QtGui/QStyleOptionViewItemV2 ../../include/QtGui/QStyleOptionViewItemV3 ../../include/QtGui/QStyleOptionViewItemV4 ../../include/QtGui/QStyleOptionToolBox ../../include/QtGui/QStyleOptionToolBoxV2 ../../include/QtGui/QStyleOptionRubberBand ../../include/QtGui/QStyleOptionComplex ../../include/QtGui/QStyleOptionSlider ../../include/QtGui/QStyleOptionSpinBox ../../include/QtGui/QStyleOptionQ3ListView ../../include/QtGui/QStyleOptionToolButton ../../include/QtGui/QStyleOptionComboBox ../../include/QtGui/QStyleOptionTitleBar ../../include/QtGui/QStyleOptionGroupBox ../../include/QtGui/QStyleOptionSizeGrip ../../include/QtGui/QStyleOptionGraphicsItem ../../include/QtGui/QStyleHintReturn ../../include/QtGui/QStyleHintReturnMask ../../include/QtGui/QStyleHintReturnVariant ../../include/QtGui/QStyleFactoryInterface ../../include/QtGui/QStylePlugin ../../include/QtGui/QWindowsCEStyle ../../include/QtGui/QWindowsMobileStyle ../../include/QtGui/QWindowsStyle ../../include/QtGui/QWindowsVistaStyle ../../include/QtGui/QWindowsXPStyle ../../include/QtGui/QInputContext ../../include/QtGui/QInputContextFactory ../../include/QtGui/QInputContextFactoryInterface ../../include/QtGui/QInputContextPlugin ../../include/QtGui/QBrush ../../include/QtGui/QBrushData ../../include/QtGui/QGradientStop ../../include/QtGui/QGradientStops ../../include/QtGui/QGradient ../../include/QtGui/QLinearGradient ../../include/QtGui/QRadialGradient ../../include/QtGui/QConicalGradient ../../include/QtGui/QColor ../../include/QtGui/QColormap ../../include/QtGui/QTileRules ../../include/QtGui/QMatrix ../../include/QtGui/QPaintDevice ../../include/QtGui/QTextItem ../../include/QtGui/QPaintEngine ../../include/QtGui/QPaintEngineState ../../include/QtGui/QPainter ../../include/QtGui/QPainterPath ../../include/QtGui/QPainterPathPrivate ../../include/QtGui/QPainterPathStroker ../../include/QtGui/QPen ../../include/QtGui/QPolygon ../../include/QtGui/QPolygonF ../../include/QtGui/QPrintEngine ../../include/QtGui/QPrinter ../../include/QtGui/QPrinterInfo ../../include/QtGui/QRegion ../../include/QtGui/QRgb ../../include/QtGui/QStylePainter ../../include/QtGui/QTransform ../../include/QtGui/QWMatrix ../../include/QtGui/QHaikuStyle ../../include/QtGui/QtHaikuView ../../include/QtGui/QtHaikuWindow
+SYNCQT.PRIVATE_HEADER_FILES = ../gui/dialogs/qabstractpagesetupdialog_p.h ../gui/dialogs/qabstractprintdialog_p.h ../gui/dialogs/qcolordialog_p.h ../gui/dialogs/qdialog_p.h ../gui/dialogs/qfiledialog_p.h ../gui/dialogs/qfiledialog_win_p.h ../gui/dialogs/qfileinfogatherer_p.h ../gui/dialogs/qfilesystemmodel_p.h ../gui/dialogs/qfontdialog_p.h ../gui/dialogs/qfscompleter_p.h ../gui/dialogs/qpagesetupdialog_unix_p.h ../gui/dialogs/qsidebar_p.h ../gui/dialogs/qwizard_win_p.h ../gui/embedded/qkbd_defaultmap_qws_p.h ../gui/embedded/qkbd_qws_p.h ../gui/embedded/qlock_p.h ../gui/embedded/qscreenmulti_qws_p.h ../gui/embedded/qtransportauth_qws_p.h ../gui/embedded/qunixsocket_p.h ../gui/embedded/qunixsocketserver_p.h ../gui/embedded/qwindowsystem_p.h ../gui/embedded/qwscommand_qws_p.h ../gui/embedded/qwsdisplay_qws_p.h ../gui/embedded/qwslock_p.h ../gui/embedded/qwsmanager_p.h ../gui/embedded/qwssharedmemory_p.h ../gui/embedded/qwssignalhandler_p.h ../gui/graphicsview/qgraph_p.h ../gui/graphicsview/qgraphicsanchorlayout_p.h ../gui/graphicsview/qgraphicsitem_p.h ../gui/graphicsview/qgraphicslayout_p.h ../gui/graphicsview/qgraphicslayoutitem_p.h ../gui/graphicsview/qgraphicsproxywidget_p.h ../gui/graphicsview/qgraphicsscene_bsp_p.h ../gui/graphicsview/qgraphicsscene_p.h ../gui/graphicsview/qgraphicsscenebsptreeindex_p.h ../gui/graphicsview/qgraphicssceneindex_p.h ../gui/graphicsview/qgraphicsscenelinearindex_p.h ../gui/graphicsview/qgraphicstransform_p.h ../gui/graphicsview/qgraphicsview_p.h ../gui/graphicsview/qgraphicswidget_p.h ../gui/graphicsview/qgridlayoutengine_p.h ../gui/graphicsview/qsimplex_p.h ../gui/kernel/qaction_p.h ../gui/kernel/qapplication_p.h ../gui/kernel/qclipboard_p.h ../gui/kernel/qcocoaapplication_mac_p.h ../gui/kernel/qcocoaapplicationdelegate_mac_p.h ../gui/kernel/qcocoamenuloader_mac_p.h ../gui/kernel/qcocoapanel_mac_p.h ../gui/kernel/qcocoasharedwindowmethods_mac_p.h ../gui/kernel/qcocoaview_mac_p.h ../gui/kernel/qcocoawindow_mac_p.h ../gui/kernel/qcocoawindowcustomthemeframe_mac_p.h ../gui/kernel/qcocoawindowdelegate_mac_p.h ../gui/kernel/qcursor_p.h ../gui/kernel/qdesktopwidget_mac_p.h ../gui/kernel/qdnd_p.h ../gui/kernel/qevent_p.h ../gui/kernel/qeventdispatcher_glib_qws_p.h ../gui/kernel/qeventdispatcher_mac_p.h ../gui/kernel/qeventdispatcher_qws_p.h ../gui/kernel/qeventdispatcher_s60_p.h ../gui/kernel/qeventdispatcher_x11_p.h ../gui/kernel/qgesture_p.h ../gui/kernel/qgesturemanager_p.h ../gui/kernel/qguieventdispatcher_glib_p.h ../gui/kernel/qguiplatformplugin_p.h ../gui/kernel/qkde_p.h ../gui/kernel/qkeymapper_p.h ../gui/kernel/qkeysequence_p.h ../gui/kernel/qlayout_p.h ../gui/kernel/qlayoutengine_p.h ../gui/kernel/qmacgesturerecognizer_mac_p.h ../gui/kernel/qmultitouch_mac_p.h ../gui/kernel/qnsframeview_mac_p.h ../gui/kernel/qnsthemeframe_mac_p.h ../gui/kernel/qnstitledframe_mac_p.h ../gui/kernel/qshortcutmap_p.h ../gui/kernel/qsoftkeymanager_common_p.h ../gui/kernel/qsoftkeymanager_p.h ../gui/kernel/qsoftkeymanager_s60_p.h ../gui/kernel/qsound_p.h ../gui/kernel/qstandardgestures_p.h ../gui/kernel/qt_cocoa_helpers_mac_p.h ../gui/kernel/qt_gui_pch.h ../gui/kernel/qt_mac_p.h ../gui/kernel/qt_s60_p.h ../gui/kernel/qt_x11_p.h ../gui/kernel/qwidget_p.h ../gui/kernel/qwidgetaction_p.h ../gui/kernel/qwinnativepangesturerecognizer_win_p.h ../gui/effects/qgraphicseffect_p.h ../gui/s60framework/qs60mainapplication_p.h ../gui/image/qbmphandler_p.h ../gui/image/qgifhandler_p.h ../gui/image/qicon_p.h ../gui/image/qiconloader_p.h ../gui/image/qimage_p.h ../gui/image/qimagepixmapcleanuphooks_p.h ../gui/image/qjpeghandler_p.h ../gui/image/qmnghandler_p.h ../gui/image/qnativeimage_p.h ../gui/image/qpaintengine_pic_p.h ../gui/image/qpicture_p.h ../gui/image/qpixmap_mac_p.h ../gui/image/qpixmap_raster_p.h ../gui/image/qpixmap_s60_p.h ../gui/image/qpixmap_x11_p.h ../gui/image/qpixmapcache_p.h ../gui/image/qpixmapdata_p.h ../gui/image/qpixmapdatafactory_p.h ../gui/image/qpixmapfilter_p.h ../gui/image/qpnghandler_p.h ../gui/image/qppmhandler_p.h ../gui/image/qtiffhandler_p.h ../gui/image/qxbmhandler_p.h ../gui/image/qxpmhandler_p.h ../gui/text/qabstractfontengine_p.h ../gui/text/qabstracttextdocumentlayout_p.h ../gui/text/qcssparser_p.h ../gui/text/qfont_p.h ../gui/text/qfontengine_ft_p.h ../gui/text/qfontengine_p.h ../gui/text/qfontengine_qpf_p.h ../gui/text/qfontengine_s60_p.h ../gui/text/qfontengine_win_p.h ../gui/text/qfontengine_x11_p.h ../gui/text/qfontengineglyphcache_p.h ../gui/text/qfontsubset_p.h ../gui/text/qfragmentmap_p.h ../gui/text/qstatictext_p.h ../gui/text/qtextcontrol_p.h ../gui/text/qtextcontrol_p_p.h ../gui/text/qtextcursor_p.h ../gui/text/qtextdocument_p.h ../gui/text/qtextdocumentfragment_p.h ../gui/text/qtextdocumentlayout_p.h ../gui/text/qtextengine_p.h ../gui/text/qtextformat_p.h ../gui/text/qtexthtmlparser_p.h ../gui/text/qtextimagehandler_p.h ../gui/text/qtextobject_p.h ../gui/text/qtextodfwriter_p.h ../gui/text/qtexttable_p.h ../gui/text/qzipreader_p.h ../gui/text/qzipwriter_p.h ../gui/itemviews/qabstractitemview_p.h ../gui/itemviews/qabstractproxymodel_p.h ../gui/itemviews/qbsptree_p.h ../gui/itemviews/qcolumnview_p.h ../gui/itemviews/qcolumnviewgrip_p.h ../gui/itemviews/qheaderview_p.h ../gui/itemviews/qitemeditorfactory_p.h ../gui/itemviews/qitemselectionmodel_p.h ../gui/itemviews/qlistview_p.h ../gui/itemviews/qlistwidget_p.h ../gui/itemviews/qproxymodel_p.h ../gui/itemviews/qstandarditemmodel_p.h ../gui/itemviews/qtableview_p.h ../gui/itemviews/qtablewidget_p.h ../gui/itemviews/qtreeview_p.h ../gui/itemviews/qtreewidget_p.h ../gui/itemviews/qtreewidgetitemiterator_p.h ../gui/itemviews/qwidgetitemdata_p.h ../gui/widgets/qabstractbutton_p.h ../gui/widgets/qabstractscrollarea_p.h ../gui/widgets/qabstractslider_p.h ../gui/widgets/qabstractspinbox_p.h ../gui/widgets/qcalendartextnavigator_p.h ../gui/widgets/qcocoamenu_mac_p.h ../gui/widgets/qcocoatoolbardelegate_mac_p.h ../gui/widgets/qcombobox_p.h ../gui/widgets/qdatetimeedit_p.h ../gui/widgets/qdockarealayout_p.h ../gui/widgets/qdockwidget_p.h ../gui/widgets/qeffects_p.h ../gui/widgets/qframe_p.h ../gui/widgets/qlabel_p.h ../gui/widgets/qlinecontrol_p.h ../gui/widgets/qlineedit_p.h ../gui/widgets/qmainwindowlayout_p.h ../gui/widgets/qmdiarea_p.h ../gui/widgets/qmdisubwindow_p.h ../gui/widgets/qmenu_p.h ../gui/widgets/qmenu_wince_resource_p.h ../gui/widgets/qmenubar_p.h ../gui/widgets/qplaintextedit_p.h ../gui/widgets/qpushbutton_p.h ../gui/widgets/qscrollarea_p.h ../gui/widgets/qsplitter_p.h ../gui/widgets/qtabbar_p.h ../gui/widgets/qtextedit_p.h ../gui/widgets/qtoolbar_p.h ../gui/widgets/qtoolbararealayout_p.h ../gui/widgets/qtoolbarextension_p.h ../gui/widgets/qtoolbarlayout_p.h ../gui/widgets/qtoolbarseparator_p.h ../gui/widgets/qwidgetanimator_p.h ../gui/widgets/qwidgetresizehandler_p.h ../gui/statemachine/qbasickeyeventtransition_p.h ../gui/statemachine/qbasicmouseeventtransition_p.h ../gui/util/qcompleter_p.h ../gui/util/qsystemtrayicon_p.h ../gui/util/qundostack_p.h ../gui/accessible/qaccessible_mac_p.h ../gui/styles/qcleanlooksstyle_p.h ../gui/styles/qcommonstyle_p.h ../gui/styles/qcommonstylepixmaps_p.h ../gui/styles/qgtkpainter_p.h ../gui/styles/qgtkstyle_p.h ../gui/styles/qmacstyle_mac_p.h ../gui/styles/qmacstylepixmaps_mac_p.h ../gui/styles/qmotifstyle_p.h ../gui/styles/qproxystyle_p.h ../gui/styles/qs60style_p.h ../gui/styles/qstyle_p.h ../gui/styles/qstylehelper_p.h ../gui/styles/qstylesheetstyle_p.h ../gui/styles/qwindowscestyle_p.h ../gui/styles/qwindowsmobilestyle_p.h ../gui/styles/qwindowsstyle_p.h ../gui/styles/qwindowsvistastyle_p.h ../gui/styles/qwindowsxpstyle_p.h ../gui/egl/qegl_p.h ../gui/egl/qeglcontext_p.h ../gui/egl/qeglproperties_p.h ../gui/inputmethod/qcoefepinputcontext_p.h ../gui/inputmethod/qinputcontext_p.h ../gui/inputmethod/qmacinputcontext_p.h ../gui/inputmethod/qwininputcontext_p.h ../gui/inputmethod/qwsinputcontext_p.h ../gui/inputmethod/qximinputcontext_p.h ../gui/painting/qbackingstore_p.h ../gui/painting/qbezier_p.h ../gui/painting/qblendfunctions_p.h ../gui/painting/qcolor_p.h ../gui/painting/qcssutil_p.h ../gui/painting/qcups_p.h ../gui/painting/qdatabuffer_p.h ../gui/painting/qdrawhelper_arm_simd_p.h ../gui/painting/qdrawhelper_mmx_p.h ../gui/painting/qdrawhelper_neon_p.h ../gui/painting/qdrawhelper_p.h ../gui/painting/qdrawhelper_sse_p.h ../gui/painting/qdrawhelper_x86_p.h ../gui/painting/qdrawingprimitive_sse2_p.h ../gui/painting/qemulationpaintengine_p.h ../gui/painting/qfixed_p.h ../gui/painting/qgraphicssystem_mac_p.h ../gui/painting/qgraphicssystem_p.h ../gui/painting/qgraphicssystem_qws_p.h ../gui/painting/qgraphicssystem_raster_p.h ../gui/painting/qgraphicssystem_runtime_p.h ../gui/painting/qgraphicssystemfactory_p.h ../gui/painting/qgraphicssystemplugin_p.h ../gui/painting/qgrayraster_p.h ../gui/painting/qimagescale_p.h ../gui/painting/qmath_p.h ../gui/painting/qmemrotate_p.h ../gui/painting/qoutlinemapper_p.h ../gui/painting/qpaintbuffer_p.h ../gui/painting/qpaintengine_alpha_p.h ../gui/painting/qpaintengine_mac_p.h ../gui/painting/qpaintengine_p.h ../gui/painting/qpaintengine_preview_p.h ../gui/painting/qpaintengine_raster_p.h ../gui/painting/qpaintengine_s60_p.h ../gui/painting/qpaintengine_x11_p.h ../gui/painting/qpaintengineex_p.h ../gui/painting/qpainter_p.h ../gui/painting/qpainterpath_p.h ../gui/painting/qpathclipper_p.h ../gui/painting/qpdf_p.h ../gui/painting/qpen_p.h ../gui/painting/qpolygonclipper_p.h ../gui/painting/qprintengine_mac_p.h ../gui/painting/qprintengine_pdf_p.h ../gui/painting/qprintengine_ps_p.h ../gui/painting/qprintengine_qws_p.h ../gui/painting/qprintengine_win_p.h ../gui/painting/qprinter_p.h ../gui/painting/qprinterinfo_unix_p.h ../gui/painting/qrasterdefs_p.h ../gui/painting/qrasterizer_p.h ../gui/painting/qstroker_p.h ../gui/painting/qtessellator_p.h ../gui/painting/qtextureglyphcache_p.h ../gui/painting/qvectorpath_p.h ../gui/painting/qwindowsurface_mac_p.h ../gui/painting/qwindowsurface_p.h ../gui/painting/qwindowsurface_qws_p.h ../gui/painting/qwindowsurface_raster_p.h ../gui/painting/qwindowsurface_s60_p.h ../gui/painting/qwindowsurface_x11_p.h ../gui/image/qpixmap_haiku_p.h ../gui/styles/qhaikustyle_p.h ../gui/kernel/qeventdispatcher_haiku_p.h
diff -rupN qt-everywhere-opensource-src-4.7.3/include/QtGui/private/qeventdispatcher_haiku_p.h qt-everywhere-opensource-src-4.7.3_haiku/include/QtGui/private/qeventdispatcher_haiku_p.h
--- qt-everywhere-opensource-src-4.7.3/include/QtGui/private/qeventdispatcher_haiku_p.h	1970-01-01 00:00:00.000000000 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/include/QtGui/private/qeventdispatcher_haiku_p.h	2011-06-14 03:50:02.157024256 +0000
@@ -0,0 +1 @@
+#include "../../../src/gui/kernel/qeventdispatcher_haiku_p.h"
diff -rupN qt-everywhere-opensource-src-4.7.3/include/QtGui/private/qhaikustyle_p.h qt-everywhere-opensource-src-4.7.3_haiku/include/QtGui/private/qhaikustyle_p.h
--- qt-everywhere-opensource-src-4.7.3/include/QtGui/private/qhaikustyle_p.h	1970-01-01 00:00:00.000000000 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/include/QtGui/private/qhaikustyle_p.h	2011-06-14 03:49:44.729284608 +0000
@@ -0,0 +1 @@
+#include "../../../src/gui/styles/qhaikustyle_p.h"
diff -rupN qt-everywhere-opensource-src-4.7.3/include/QtGui/private/qpixmap_haiku_p.h qt-everywhere-opensource-src-4.7.3_haiku/include/QtGui/private/qpixmap_haiku_p.h
--- qt-everywhere-opensource-src-4.7.3/include/QtGui/private/qpixmap_haiku_p.h	1970-01-01 00:00:00.000000000 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/include/QtGui/private/qpixmap_haiku_p.h	2011-06-13 22:06:43.089653248 +0000
@@ -0,0 +1 @@
+#include "../../../src/gui/image/qpixmap_haiku_p.h"
diff -rupN qt-everywhere-opensource-src-4.7.3/include/QtGui/qhaikustyle.h qt-everywhere-opensource-src-4.7.3_haiku/include/QtGui/qhaikustyle.h
--- qt-everywhere-opensource-src-4.7.3/include/QtGui/qhaikustyle.h	1970-01-01 00:00:00.000000000 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/include/QtGui/qhaikustyle.h	2010-04-15 16:14:35.000000000 +0000
@@ -0,0 +1 @@
+#include "../../src/gui/styles/qhaikustyle.h"
diff -rupN qt-everywhere-opensource-src-4.7.3/include/QtGui/qsystemtrayicon_haiku.h qt-everywhere-opensource-src-4.7.3_haiku/include/QtGui/qsystemtrayicon_haiku.h
--- qt-everywhere-opensource-src-4.7.3/include/QtGui/qsystemtrayicon_haiku.h	1970-01-01 00:00:00.000000000 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/include/QtGui/qsystemtrayicon_haiku.h	2010-07-02 03:02:00.000000000 +0000
@@ -0,0 +1 @@
+#include "../../src/gui/util/qsystemtrayicon_haiku.h"
diff -rupN qt-everywhere-opensource-src-4.7.3/include/QtGui/qwidget_haiku.h qt-everywhere-opensource-src-4.7.3_haiku/include/QtGui/qwidget_haiku.h
--- qt-everywhere-opensource-src-4.7.3/include/QtGui/qwidget_haiku.h	1970-01-01 00:00:00.000000000 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/include/QtGui/qwidget_haiku.h	2010-11-09 02:20:07.000000000 +0000
@@ -0,0 +1 @@
+#include "../../src/gui/kernel/qwidget_haiku.h"
diff -rupN qt-everywhere-opensource-src-4.7.3/include/QtGui/qwindowdefs_haiku.h qt-everywhere-opensource-src-4.7.3_haiku/include/QtGui/qwindowdefs_haiku.h
--- qt-everywhere-opensource-src-4.7.3/include/QtGui/qwindowdefs_haiku.h	1970-01-01 00:00:00.000000000 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/include/QtGui/qwindowdefs_haiku.h	2011-06-13 22:06:43.090963968 +0000
@@ -0,0 +1 @@
+#include "../../src/gui/kernel/qwindowdefs_haiku.h"
diff -rupN qt-everywhere-opensource-src-4.7.3/makehaikupkg.sh qt-everywhere-opensource-src-4.7.3_haiku/makehaikupkg.sh
--- qt-everywhere-opensource-src-4.7.3/makehaikupkg.sh	1970-01-01 00:00:00.000000000 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/makehaikupkg.sh	2011-06-13 22:42:41.748945408 +0000
@@ -0,0 +1,1853 @@
+#!/bin/sh
+
+QTROOT=../qtbuild
+QTROOT=`readlink -f $QTROOT`
+
+######################################################################
+echo "Install Qt into sandbox :$QTROOT"
+######################################################################
+echo " Prepare"
+mkdir -p $QTROOT
+rm -rf $QTROOT/boot
+echo " Install Qt"
+INSTALL_ROOT=$QTROOT make install
+echo " Install documentation"
+INSTALL_ROOT=$QTROOT make install_qchdocs
+
+######################################################################
+echo "Remove debug info"
+######################################################################
+echo " Delete *.debug files"
+find "$QTROOT/boot/common/" -name "*.debug" -delete
+echo " Strip debug info from *.so files"
+find "$QTROOT/boot/common/" -name "*.so*" -exec strip -s {} \;
+echo " Strip debug info from binary files"
+find "$QTROOT/boot/common/bin/" -name "*" -exec strip -s {} \;
+
+######################################################################
+echo "Make qsystray utility"
+######################################################################
+echo " Make"
+cd ./src/3rdparty/haiku-tools/qsystray
+make
+echo " Install"
+cp -f ./qsystray $QTROOT/boot/common/bin
+cp -f ./qsystray_gcc2 $QTROOT/boot/common/bin
+mimeset -f $QTROOT/boot/common/bin/qsystray
+mimeset -f $QTROOT/boot/common/bin/qsystray_gcc2
+
+######################################################################
+echo "Remove useless files"
+######################################################################
+echo " HTML docs"
+rm -rf $QTROOT/boot/common/documentation/doc/Qt/html
+echo " Images"
+rm -rf $QTROOT/boot/common/documentation/doc/Qt/src
+
+######################################################################
+echo "Check for hybrid build"
+######################################################################
+if [ -f /boot/system/lib/libsupc++.so ] ; then
+	echo "gcc4 build - install libs into /common/lib folder"
+else
+	echo "gcc2 build - install libs into /common/lib/gcc4 folder"
+	echo "Move pkgconfig files from lib/gcc4 to parent folder"
+	mkdir $QTROOT/boot/common/lib/pkgconfig
+	mv $QTROOT/boot/common/lib/gcc4/pkgconfig $QTROOT/boot/common/lib
+fi
+
+######################################################################
+echo "Add Resources for binaries"
+######################################################################
+
+######################################################################
+echo " Qt Assistant"
+######################################################################
+echo 'resource app_signature "application/x-vnd.assistant";
+resource app_flags B_SINGLE_LAUNCH;
+resource app_version {
+	major  = 4,
+	middle = 7,
+	minor  = 0,
+	variety = 0,
+	internal = 0,
+	short_info = "Qt Assistant",
+	long_info  = "Qt Assistant"
+};
+resource vector_icon {
+	$"6E6369660A030062250380C34205FF04003303663333020106023DDD49000000"
+	$"0000003DDD4949EEA449EEA400B00000FF993300020106043DA9380000000000"
+	$"003DA93849EEA449EEA400FFFFFF2FFF93936CFF0000FFCF000004FF7F04FF66"
+	$"04614C1E060AEFE707B93AB30DB93AB30DB8EB20B852B302B89DB2FCB852B302"
+	$"B852B302B639B327B650B325B464B34D20B6E320B4CE20B6E3CF6BB50DD154C9"
+	$"ABCDDDC9ABCDDDCB16CD9ECC35CA23CC35CBF2CC35CA23B6290606EF0BCC35CA"
+	$"23CC35CA23CC35CBF2C9ABCDDDCB16CD9EC9ABCDDDB50DD154B50DB6C2B50DB6"
+	$"C2B50DB457B93AB30DB6FBB2AEB93AB30DCC35B62906149AF9FFFF99C5DBB9A3"
+	$"C785B9D1BCBDC965BCDFBEB4C785BE9EC785C551C785C551C785C5E6C7B7C671"
+	$"C796C646C7D4C699C840C6ACC803C6ACC846C6ACC853C6ACC84CC6ACC8B1C6A6"
+	$"C987C656C918C689C987C656C987C805C987C805C8C9C859C758C89AC80FC88B"
+	$"C73DC89CC70BC89DC723C89DC665C89DC58FC80CC5E6C86DC52AC79BC4F8C5ED"
+	$"C4F8C6E5C4F8C5EDBE80C412BE75BC7EC52ABC930A04C965BEB4C785BE9EC785"
+	$"BEA8C886BEB40205C7E9C69BC826C68CC802C6A7C840C6AC55C6ACC846C6ACC8"
+	$"53C6ACC84CC6ACC8B1C6A6C987C656C918C689C987C656C8A9C656C8A9C656C8"
+	$"65C675060D9FF1FE03C58FC80CC5E6C86DC52AC79BC4F8C5EDC4F8C6E5C4F8C5"
+	$"EDBE80C412BE75BC7EC333C333BCEFC333BCEFC353BD68C37FBE79C36CBDEBC3"
+	$"7FBE79C419BE80C419C5EDC419C5EDC419C6E5C4B1C80CC44CC79BC507C86DC6"
+	$"2CC89DC586C89DC62CC89DC70BC89DC70BC89DC665C89D0A04C5DBB9A3C4FCB9"
+	$"A3C450BC83C52ABC93000BC02DC624C02DC624C084C544C0AFC0FEC0AFC38DC0"
+	$"AFBEB2C02EBC40C085BD1EBFD8BB60BEA9BAD9BF57BAE8BE9CBAD8BE82BAD7BE"
+	$"8FBAD7BDE1BAD7BD0FBBF1BD66BB35BCB2BCBEBC83C0ECBC83BE68BC83C35ABD"
+	$"0DC617BCB1C514BD65C70EBE92C789BDE7C789BE9AC789BEA9C788BEA1C788BF"
+	$"55C77DC02DC624BFD6C706C02DC6240211C2C7C6AFC35DC54DC22EC817C008C9"
+	$"6FC146C902C028CA13C099CABCC0595BC0CBCAE9C17FCB00C118CB00C19DCB00"
+	$"C1DFCAFAC1BDCAFEC1DFCAFAC1DFCCE0C1DFCCE0C1DFCCE0C103CCFDC103CCFD"
+	$"C0C2CD05C049CD09C084CD09BF88CD09BE76CC7CBEECCCDBBDDBCBFFBD1EC9A9"
+	$"BD68CB0EBBCCC961BA0EC721BAC4C88AB955C5B2B8F6C0DDB8F6C39AB8F6BDE8"
+	$"BA75BA58B977BBBABB4BB92EBDEEB89BBC76B89BBE2BB89BBEA9B8A6BE69B89F"
+	$"C064B8D9C275BB14C1A4B9AAC342BC75C3A7C10BC3A7BE71C3A7C36D0203C17F"
+	$"CB00C162CB00C19DCB00C1DFCAFAC1BDCAFEC1DFCAFAC12CCAFAC12CCAFAC145"
+	$"CAFE020DBF44BC40BEFCBB85BF9BBD1EBFC5C0FEBFC5BEB2BFC5C38DBF43C624"
+	$"BF9AC544BEFDC6D9BE20C774BE9CC749BE44C782BE92C789BE6AC789BE9AC789"
+	$"BEA9C788BEA1C788BF55C77DC02DC624BFD6C706C084C544C0AFC0FEC0AFC38D"
+	$"C0AFBEB2C02EBC40C085BD1EBFD8BB60BEA9BAD9BF57BAE8BE9CBAD8BE82BAD7"
+	$"BE8FBAD7BE5ABAD7BE10BAE9BE34BADDBE10BAE9BE10BAE9BE10BAE9BE95BB12"
+	$"0222BEEDCCC5BEEECCC6BEE9CCC4BEE1CCC0BEE5CCC2BEE1CCBFBEE0CCBFBEE0"
+	$"CCBFBEDCCCBDBED4CCB9BED8CCBBBED4CCB9BED2CCB8BED3CCB8BECFCCB6BEC8"
+	$"CCB3BECBCCB4BEC7CCB2BEC5CCB1BEC6CCB1BEC2CCAFBEBCCCACBEBFCCADBEBA"
+	$"CCABBEB8CCA9BEB9CCAABEB5CCA8BEB0CCA4BEB2CCA6BEAECCA3BEAACCA1BEAC"
+	$"CCA2BEA8CCA0BEA4CC9DBEA6CC9EBEA2CC9BBE9ECC99BEA0CC9ABE9CCC97BE98"
+	$"CC95BE9ACC96BE96CC93BE91CC90BE93CC92BE90CC8FBE8DCC8D3DCC8EBE8ACC"
+	$"8BBE84CC87BE87CC89BE83CC86BE81CC85BE82CC85BE7ECC82BE76CC7CBE7ACC"
+	$"7FBDDBCBFFBD1EC9A9BD68CB0EBBCCC961BA0EC721BAC4C88AB955C5B2B8F6C0"
+	$"DDB8F6C39AB8F6BDE8BA75BA58B977BBBABB4BB92EBDEEB89BBC76B89BBDF0B8"
+	$"9BBD03B89BBD03B89BBB8CB89BB98BBA58BA61B92EB88DBBBAB80CC0DDB80CBD"
+	$"E8B80CC39AB924C721B86AC5B2B9DAC88ABC34C9A9BAE2C961BC7ECB0EBD8CCC"
+	$"7CBCF0CBFFBE02CCDBBF5FCD09BE9ECD09BF63CD09BF6ACD09BF67CD09BF6ACD"
+	$"09C037CD09C037CD09BFB9CD07BEEECCC6BF4BCCF1BEEECCC60204B3A5BFF7B3"
+	$"A5B92CB3A5C6C2BFF7CC48B92CCC48C6C2CC48CC48BFF7CC48C6C2CC48B92CBF"
+	$"F7B3A5C6C2B3A5B92CB3A50204BB6DBFF7BB6DC277BB6DBD76BFF7BB6DBD76BB"
+	$"6DC277BB6DC481BFF7C481BD76C481C277BFF7C481C277C481BD76C481020420"
+	$"BF8820B89F20C671BF88CC11B89FCC11C671CC11CC11BF88CC11C671CC11B89F"
+	$"BF8820C67120B89F200204BB36BF88BB36C1EABB36BD26BF88BB36BD26BB36C1"
+	$"EABB36C3DBBF88C3DBBD26C3DBC1EABF88C3DBC1EAC3DBBD26C3DB0204B337BF"
+	$"88B337B8BDB337C653BF88CBDAB8BDCBDAC653CBDACBDABF88CBDAC653CBDAB8"
+	$"BDBF88B337C653B337B8BDB3370204BAFEBF88BAFEC209BAFEBD08BF88BAFEBD"
+	$"08BAFEC209BAFEC412BF88C412BD08C412C209BF88C412C209C412BD08C41202"
+	$"04BF88B3DDC5FAB3DDB916B3DDB3DDBF88B3DDB916B3DDC5FABF88CB34B916CB"
+	$"34C5FACB34CB34BF88CB34C5FACB34B9160204BF88C4B8C264C4B8BCACC4B8BA"
+	$"58BF88BA58C264BA58BCACBF88BA58BCACBA58C264BA58C4B8BF88C4B8BCACC4"
+	$"B8C2640206BF88B63DB9D4B63DC53CB63DCA4FC04AC9EBBAAFCA53C00ACA56BF"
+	$"88CA56BFC9CA56B993BF88B4BAC57DB4BAB993B4BAB4BABF88B4BAB993B4BABF"
+	$"C9B4C2C04AB4BDC00AB525BAAF0206BF88C718BC32C718C2DEC718C595C10BC5"
+	$"95C462C595C0CAC589C04AC591C089C529C345BF88C595C29DC595BC74C595B9"
+	$"88C04AB9E7C345B980C089B97BC10BB97BC0CAB97BC4620206BF88CB34BD68CB"
+	$"34C1A8CB34C55EC9A3C3A6CAA1C55EC9A3C220C405C220C405C15CC477BF88C4"
+	$"B8C07AC4B8BE97C4B8BCF1C405BDB4C477BCF1C405B9B3C9A3B9B3C9A3BB6ACA"
+	$"A10206BF88B3DDC1A8B3DDBD68B3DDB9B3B56DBB6AB46FB9B3B56DBCF1BB0BBC"
+	$"F1BB0BBDB4BA9ABF88BA58BE97BA58C07ABA58C220BB0BC15CBA9AC220BB0BC5"
+	$"5EB56DC55EB56DC3A6B46F0206C4B8BF88C4B8BE97C4B8C07AC405C220C477C1"
+	$"5CC405C220C9A3C55EC9A3C55ECAA1C3A6CB34BF88CB34C1A8CB34BD68C9A3B9"
+	$"B3CAA1BB6AC9A3B9B3C405BCF1C405BCF1C477BDB40206BA58BF88BA58C07ABA"
+	$"58BE97BB0BBCF1BA9ABDB4BB0BBCF1B56DB9B3B56DB9B3B46FBB6AB3DDBF88B3"
+	$"DDBD68B3DDC1A8B56DC55EB46FC3A6B56DC55EBB0BC220BB0BC220BA9AC15C02"
+	$"06BF88B90DC264B90DBCACB90DBA58BE3CBA58BB60BA58BE75BA63BEE2BA5CBE"
+	$"ACBAB5BC54BF88BA58BCE4BA58C22CBA58C4ADBEE2C45BBC54C4B4BEACC4B8BE"
+	$"3CC4B8BE75C4B8BB600206BF88C9E8C5C2C9E8B94EC9E8B3E2BEE2B438C507B3"
+	$"DFBF19B3DDBF88B3DDBF50B3DDC5FABF88CB34B916CB34C5FACB34CB34BF88CB"
+	$"34C5FACB34BF50CB2FBEE2CB32BF19CAD9C5070206BF88CB34B93ECB34C5D2CB"
+	$"34CB31BFFECAF2C639CB30BFE9CB2F40CB30BFD4CAD9C5E4BF88CAC5C5C2CAC5"
+	$"B94ECAC5B3E240B438C5E4B3E0BFD4B3E0BFFEB3E1BFE9B41EC6390206BA58BF"
+	$"1ABA58BC3DBA58BF2ABA5ABF49BA59BF39BA7BBC8ABF88BA58BCC1BA58C24FBA"
+	$"58C4B6BF49C495BC8AC4B7BF39C4B8BF1AC4B8BF2AC4B8BC3DBF88B9EAC264B9"
+	$"EABCACB9EA150A000100023F6E570000000000003F0079920DF9AFA7960A0101"
+	$"01023F6E570000000000003F0079920DF9AFA7960A020102023F6E5700000000"
+	$"00003F0079920DF9AFA7960A000103023F6E570000000000003F0079920DF9AF"
+	$"A7960A000104023F6E570000000000003F0079920DF9AFA7960A00020506023F"
+	$"6E570000000000003F0079920DF9AFA7960A02020708023F6E57000000000000"
+	$"3F0079920DF9AFA7960A000109023F6E570000000000003F0079920DF9AFA796"
+	$"0A00020A0B023D6A390000000000003D3C934A3EB74A17E90A03020C0D023DD6"
+	$"F90000000000003DF73F4A20004A10000A04020E0F023DD6F90000000000003D"
+	$"F73F4A20004A10000A05021011023DD6F90000000000003DF73F4A20004A1000"
+	$"0A06021213023DD6F90000000000003DF73F4A20004A10000A070114023DD6F9"
+	$"0000000000003DF73F4A20004A10000A080115023DD6F90000000000003DF73F"
+	$"4A20004A10000A020116023DD6F90000000000003DF73F4A20004A10000A0201"
+	$"17023DD6F90000000000003DF73F4A20004A10000A020118023DD6F900000000"
+	$"00003DF73F4A20004A10000A020119023DD6F90000000000003DF73F4A20004A"
+	$"10000A09021A1B023DD6F90000000000003DF73F4A20004A10000A09021C1D02"
+	$"3DD6F90000000000003DF73F4A20004A1000"	
+};' >/tmp/assistent.rdef
+rc /tmp/assistent.rdef
+xres -o "$QTROOT/boot/common/bin/assistant" /tmp/assistent.rsrc
+mimeset -f "$QTROOT/boot/common/bin/assistant"
+
+
+######################################################################
+echo " Qt Designer"
+######################################################################
+echo 'resource app_signature "application/x-vnd.designer";
+
+resource app_flags B_SINGLE_LAUNCH;
+
+resource app_version {
+	major  = 4,
+	middle = 7,
+	minor  = 0,
+	variety = 0,
+	internal = 0,
+	short_info = "Qt Designer",
+	long_info  = "Qt Designer"
+};
+
+resource vector_icon {
+	$"6E63696613030062250380C34205FF04003303663333020106023DDD49000000"
+	$"0000003DDD4949EEA449EEA400B00000FF993300020106043DA9380000000000"
+	$"003DA93849EEA449EEA400FFFFFF2FFF93936CFF0000FFCF000004FF7F04FF66"
+	$"04614C050002001602BC612BBC6F8A3C6F8ABC612B4B0EBF4768A700E4FFFE02"
+	$"0016023C68F73C78F1BC78F13C68F74652864B378800E4FFFE04002302000603"
+	$"38BB01B81D04381D0438BB014A2F8B4A6CC900EFF0CE7FFFFFFFFFEFF0CE03E0"
+	$"C35D03C8AF5303F7E46E02000603343E6CB2D79432D794343E6C486F84489C71"
+	$"000000007F616061FF0000002B060AEFE707B93AB30DB93AB30DB8EB20B852B3"
+	$"02B89DB2FCB852B302B852B302B639B327B650B325B464B34D20B6E320B4CE20"
+	$"B6E3CF6BB50DD154C9ABCDDDC9ABCDDDCB16CD9ECC35CA23CC35CBF2CC35CA23"
+	$"B6290606EF0BCC35CA23CC35CA23CC35CBF2C9ABCDDDCB16CD9EC9ABCDDDB50D"
+	$"D154B50DB6C2B50DB6C2B50DB457B93AB30DB6FBB2AEB93AB30DCC35B6290614"
+	$"9AF9FFFF99C5DBB9A3C785B9D1BCBDC965BCDFBEB4C785BE9EC785C551C785C5"
+	$"51C785C5E6C7B7C671C796C646C7D4C699C840C6ACC803C6ACC846C6ACC853C6"
+	$"ACC84CC6ACC8B1C6A6C987C656C918C689C987C656C987C805C987C805C8C9C8"
+	$"59C758C89AC80FC88BC73DC89CC70BC89DC723C89DC665C89DC58FC80CC5E6C8"
+	$"6DC52AC79BC4F8C5EDC4F8C6E5C4F8C5EDBE80C412BE75BC7EC52ABC930A04C9"
+	$"65BEB4C785BE9EC785BEA8C886BEB40205C7E9C69BC826C68CC802C6A7C840C6"
+	$"AC55C6ACC846C6ACC853C6ACC84CC6ACC8B1C6A6C987C656C918C689C987C656"
+	$"C8A9C656C8A9C656C865C675060D9FF1FE03C58FC80CC5E6C86DC52AC79BC4F8"
+	$"C5EDC4F8C6E5C4F8C5EDBE80C412BE75BC7EC333C333BCEFC333BCEFC353BD68"
+	$"C37FBE79C36CBDEBC37FBE79C419BE80C419C5EDC419C5EDC419C6E5C4B1C80C"
+	$"C44CC79BC507C86DC62CC89DC586C89DC62CC89DC70BC89DC70BC89DC665C89D"
+	$"0A04C5DBB9A3C4FCB9A3C450BC83C52ABC93000BC02DC624C02DC624C084C544"
+	$"C0AFC0FEC0AFC38DC0AFBEB2C02EBC40C085BD1EBFD8BB60BEA9BAD9BF57BAE8"
+	$"BE9CBAD8BE82BAD7BE8FBAD7BDE1BAD7BD0FBBF1BD66BB35BCB2BCBEBC83C0EC"
+	$"BC83BE68BC83C35ABD0DC617BCB1C514BD65C70EBE92C789BDE7C789BE9AC789"
+	$"BEA9C788BEA1C788BF55C77DC02DC624BFD6C706C02DC6240211C2C7C6AFC35D"
+	$"C54DC22EC817C008C96FC146C902C028CA13C099CABCC0595BC0CBCAE9C17FCB"
+	$"00C118CB00C19DCB00C1DFCAFAC1BDCAFEC1DFCAFAC1DFCCE0C1DFCCE0C1DFCC"
+	$"E0C103CCFDC103CCFDC0C2CD05C049CD09C084CD09BF88CD09BE76CC7CBEECCC"
+	$"DBBDDBCBFFBD1EC9A9BD68CB0EBBCCC961BA0EC721BAC4C88AB955C5B2B8F6C0"
+	$"DDB8F6C39AB8F6BDE8BA75BA58B977BBBABB4BB92EBDEEB89BBC76B89BBE2BB8"
+	$"9BBEA9B8A6BE69B89FC064B8D9C275BB14C1A4B9AAC342BC75C3A7C10BC3A7BE"
+	$"71C3A7C36D0203C17FCB00C162CB00C19DCB00C1DFCAFAC1BDCAFEC1DFCAFAC1"
+	$"2CCAFAC12CCAFAC145CAFE020DBF44BC40BEFCBB85BF9BBD1EBFC5C0FEBFC5BE"
+	$"B2BFC5C38DBF43C624BF9AC544BEFDC6D9BE20C774BE9CC749BE44C782BE92C7"
+	$"89BE6AC789BE9AC789BEA9C788BEA1C788BF55C77DC02DC624BFD6C706C084C5"
+	$"44C0AFC0FEC0AFC38DC0AFBEB2C02EBC40C085BD1EBFD8BB60BEA9BAD9BF57BA"
+	$"E8BE9CBAD8BE82BAD7BE8FBAD7BE5ABAD7BE10BAE9BE34BADDBE10BAE9BE10BA"
+	$"E9BE10BAE9BE95BB120222BEEDCCC5BEEECCC6BEE9CCC4BEE1CCC0BEE5CCC2BE"
+	$"E1CCBFBEE0CCBFBEE0CCBFBEDCCCBDBED4CCB9BED8CCBBBED4CCB9BED2CCB8BE"
+	$"D3CCB8BECFCCB6BEC8CCB3BECBCCB4BEC7CCB2BEC5CCB1BEC6CCB1BEC2CCAFBE"
+	$"BCCCACBEBFCCADBEBACCABBEB8CCA9BEB9CCAABEB5CCA8BEB0CCA4BEB2CCA6BE"
+	$"AECCA3BEAACCA1BEACCCA2BEA8CCA0BEA4CC9DBEA6CC9EBEA2CC9BBE9ECC99BE"
+	$"A0CC9ABE9CCC97BE98CC95BE9ACC96BE96CC93BE91CC90BE93CC92BE90CC8FBE"
+	$"8DCC8D3DCC8EBE8ACC8BBE84CC87BE87CC89BE83CC86BE81CC85BE82CC85BE7E"
+	$"CC82BE76CC7CBE7ACC7FBDDBCBFFBD1EC9A9BD68CB0EBBCCC961BA0EC721BAC4"
+	$"C88AB955C5B2B8F6C0DDB8F6C39AB8F6BDE8BA75BA58B977BBBABB4BB92EBDEE"
+	$"B89BBC76B89BBDF0B89BBD03B89BBD03B89BBB8CB89BB98BBA58BA61B92EB88D"
+	$"BBBAB80CC0DDB80CBDE8B80CC39AB924C721B86AC5B2B9DAC88ABC34C9A9BAE2"
+	$"C961BC7ECB0EBD8CCC7CBCF0CBFFBE02CCDBBF5FCD09BE9ECD09BF63CD09BF6A"
+	$"CD09BF67CD09BF6ACD09C037CD09C037CD09BFB9CD07BEEECCC6BF4BCCF1BEEE"
+	$"CCC60204B3A5BFF7B3A5B92CB3A5C6C2BFF7CC48B92CCC48C6C2CC48CC48BFF7"
+	$"CC48C6C2CC48B92CBFF7B3A5C6C2B3A5B92CB3A50204BB6DBFF7BB6DC277BB6D"
+	$"BD76BFF7BB6DBD76BB6DC277BB6DC481BFF7C481BD76C481C277BFF7C481C277"
+	$"C481BD76C481020420BF8820B89F20C671BF88CC11B89FCC11C671CC11CC11BF"
+	$"88CC11C671CC11B89FBF8820C67120B89F200204BB36BF88BB36C1EABB36BD26"
+	$"BF88BB36BD26BB36C1EABB36C3DBBF88C3DBBD26C3DBC1EABF88C3DBC1EAC3DB"
+	$"BD26C3DB0204B337BF88B337B8BDB337C653BF88CBDAB8BDCBDAC653CBDACBDA"
+	$"BF88CBDAC653CBDAB8BDBF88B337C653B337B8BDB3370204BAFEBF88BAFEC209"
+	$"BAFEBD08BF88BAFEBD08BAFEC209BAFEC412BF88C412BD08C412C209BF88C412"
+	$"C209C412BD08C4120204BF88B3DDC5FAB3DDB916B3DDB3DDBF88B3DDB916B3DD"
+	$"C5FABF88CB34B916CB34C5FACB34CB34BF88CB34C5FACB34B9160204BF88C4B8"
+	$"C264C4B8BCACC4B8BA58BF88BA58C264BA58BCACBF88BA58BCACBA58C264BA58"
+	$"C4B8BF88C4B8BCACC4B8C2640206BF88B63DB9D4B63DC53CB63DCA4FC04AC9EB"
+	$"BAAFCA53C00ACA56BF88CA56BFC9CA56B993BF88B4BAC57DB4BAB993B4BAB4BA"
+	$"BF88B4BAB993B4BABFC9B4C2C04AB4BDC00AB525BAAF0206BF88C718BC32C718"
+	$"C2DEC718C595C10BC595C462C595C0CAC589C04AC591C089C529C345BF88C595"
+	$"C29DC595BC74C595B988C04AB9E7C345B980C089B97BC10BB97BC0CAB97BC462"
+	$"0206BF88CB34BD68CB34C1A8CB34C55EC9A3C3A6CAA1C55EC9A3C220C405C220"
+	$"C405C15CC477BF88C4B8C07AC4B8BE97C4B8BCF1C405BDB4C477BCF1C405B9B3"
+	$"C9A3B9B3C9A3BB6ACAA10206BF88B3DDC1A8B3DDBD68B3DDB9B3B56DBB6AB46F"
+	$"B9B3B56DBCF1BB0BBCF1BB0BBDB4BA9ABF88BA58BE97BA58C07ABA58C220BB0B"
+	$"C15CBA9AC220BB0BC55EB56DC55EB56DC3A6B46F0206C4B8BF88C4B8BE97C4B8"
+	$"C07AC405C220C477C15CC405C220C9A3C55EC9A3C55ECAA1C3A6CB34BF88CB34"
+	$"C1A8CB34BD68C9A3B9B3CAA1BB6AC9A3B9B3C405BCF1C405BCF1C477BDB40206"
+	$"BA58BF88BA58C07ABA58BE97BB0BBCF1BA9ABDB4BB0BBCF1B56DB9B3B56DB9B3"
+	$"B46FBB6AB3DDBF88B3DDBD68B3DDC1A8B56DC55EB46FC3A6B56DC55EBB0BC220"
+	$"BB0BC220BA9AC15C0206BF88B90DC264B90DBCACB90DBA58BE3CBA58BB60BA58"
+	$"BE75BA63BEE2BA5CBEACBAB5BC54BF88BA58BCE4BA58C22CBA58C4ADBEE2C45B"
+	$"BC54C4B4BEACC4B8BE3CC4B8BE75C4B8BB600206BF88C9E8C5C2C9E8B94EC9E8"
+	$"B3E2BEE2B438C507B3DFBF19B3DDBF88B3DDBF50B3DDC5FABF88CB34B916CB34"
+	$"C5FACB34CB34BF88CB34C5FACB34BF50CB2FBEE2CB32BF19CAD9C5070206BF88"
+	$"CB34B93ECB34C5D2CB34CB31BFFECAF2C639CB30BFE9CB2F40CB30BFD4CAD9C5"
+	$"E4BF88CAC5C5C2CAC5B94ECAC5B3E240B438C5E4B3E0BFD4B3E0BFFEB3E1BFE9"
+	$"B41EC6390206BA58BF1ABA58BC3DBA58BF2ABA5ABF49BA59BF39BA7BBC8ABF88"
+	$"BA58BCC1BA58C24FBA58C4B6BF49C495BC8AC4B7BF39C4B8BF1AC4B8BF2AC4B8"
+	$"BC3DBF88B9EAC264B9EABCACB9EA020AB691B41FB691B41FB5C1B41FB524B58C"
+	$"B524B4BBB524B58CB524C93CB524C93CB524C9F3B677CA8FB5A6CA8FB677CA8F"
+	$"C851CA8FC851CA8FC908CA8FC9A4C93CC9A4C9F3C9A4C93CC9A4B89CC9A4B89C"
+	$"C9A4B7FFC922B72EC970B77CC922B72EC6C9B4D6C6C9B4D6C661B46DC50DB41F"
+	$"C5AAB41FC50DB41F020AB691B41FB691B41FB5C1B41FB524B58CB524B4BBB524"
+	$"B58CB524C93CB524C93CB524C9F3B677CA8FB5A6CA8FB677CA8FC851CA8FC851"
+	$"CA8FC908CA8FC9A4C93CC9A4C9F3C9A4C93CC9A4B89CC9A4B89CC9A4B7FFC922"
+	$"B72EC970B77CC922B72EC6C9B4D6C6C9B4D6C661B46DC50DB41FC5AAB41FC50D"
+	$"B41F020AC4F3B50AC55CB50AC4F3B50AB691B50AB691B50AB629B50AB60FB58C"
+	$"B60FB53EB60FB58CB60FC93CB60FC93CB60FC98AB691C9A4B629C9A4B691C9A4"
+	$"C86BC9A4C86BC9A4C89FC9A4C8D3C93CC8D3C970C8D3C93CC8D3B89CC8D3B89C"
+	$"C8D3B833C885B7CBC8B9B7E5C885B7CBC62DB572C62DB572C5DEB5240206B6E0"
+	$"B5DBB6E0B5DBB6E02BB6E0C8D3B6E0C74CB867C8D3C7E8C8D3C661C8D3C7E8C7"
+	$"4CC7E8B867C7E8B91EC780B819C55CB5DBC5AAB643C4BFB5DBB6FAB5DBB882B5"
+	$"DBB6FAB5DB0A04B904C3BAC5AAC3BAC5AAC661B904C6610A04B904B904C5AAB9"
+	$"04C5AABBABB904BBAB0A04B904BE6CC5AABE6CC5AAC113B904C1130A07B987B9"
+	$"BBBF3DBCCAC55CC50DC542C661C3D4C7CEC24CC79ABBDF400A07B987B9BBBF3D"
+	$"BCCAC55CC50DC542C661C3D4C7CEC24CC79ABBDF400A04BDCFC042C3BAC7B4C2"
+	$"4CC79ABBDF400A05BF71BEBAC542C647C3D4C7B4BDCFC042BF57BEBA0A04BF23"
+	$"BCCAC542C50DC527C661BF57BED406032FBC13BB0EBC13BB0EBC13BBF9BAA6BC"
+	$"7CBB91BC7CBAA6BC7CB987B9BB0E0A000100023F6E570000000000003F007992"
+	$"0DF9AFA7960A010101023F6E570000000000003F0079920DF9AFA7960A020102"
+	$"023F6E570000000000003F0079920DF9AFA7960A000103023F6E570000000000"
+	$"003F0079920DF9AFA7960A000104023F6E570000000000003F0079920DF9AFA7"
+	$"960A00020506023F6E570000000000003F0079920DF9AFA7960A02020708023F"
+	$"6E570000000000003F0079920DF9AFA7960A000109023E0AB60000000000003D"
+	$"2781493ACE49C5AC0A0A01251233B4D6BFA5C03F7D5C32C38F4788D04C593E01"
+	$"178422040A0E01260233B4D6BFA5C03F7D5C32C38F4788D04C593E0A0F012702"
+	$"33B4D6BFA5C03F7D5C32C38F4788D04C593E0A1001280233B4D6BFA5C03F7D5C"
+	$"32C38F4788D04C593E0A1101290233B4D6BFA5C03F7D5C32C38F4788D04C593E"
+	$"0A12012A0233B4D6BFA5C03F7D5C32C38F4788D04C593E"
+};' >/tmp/designer.rdef
+rc /tmp/designer.rdef
+xres -o "$QTROOT/boot/common/bin/designer" /tmp/designer.rsrc
+mimeset -f "$QTROOT/boot/common/bin/designer"
+
+######################################################################
+echo " Qt Linguist"
+######################################################################
+echo 'resource app_signature "application/x-vnd.linguist";
+
+resource app_flags B_SINGLE_LAUNCH;
+
+resource app_version {
+	major  = 4,
+	middle = 7,
+	minor  = 0,
+	variety = 0,
+	internal = 0,
+	short_info = "Qt Linguist",
+	long_info  = "Qt Linguist"
+};
+
+resource vector_icon {
+	$"6E63696618030062250380C34205FF04003303663333020106023DDD49000000"
+	$"0000003DDD4949EEA449EEA400B00000FF993300020106043DA9380000000000"
+	$"003DA93849EEA449EEA400FFFFFF2FFF93936CFF0000FFCF000004FF7F04FF66"
+	$"04614C02000602000000BDC8803DC8800000004BD3074987D3000035EDFF0000"
+	$"8D020106063EFBB90000000000003EFBB949F0D94BC42D00FFFFFF53DEFFFFBF"
+	$"94CAFFDD499BFFF3147AFFFF006DFF020106023EAC420000000000003EAC424A"
+	$"2B784BC42D00FFFFFFFF00339902000602000000BCA3653CA3650000004A62E4"
+	$"49D43C00FFFFFFFFB3CAFF020006080000003B1FAABB1FAA0000004841E7484E"
+	$"3D00FFFFFF26FBFDFF4DEEF7FF75DAEDFF9EBDDFFFC697CCFFEF6AB6FFFF57AD"
+	$"FF020006053B84A70000000000003B84A749DF004B668300428AFF442969F88E"
+	$"124DF2CF053BEEFF0035ED020006053B84A70000000000003B84A749DF004B6A"
+	$"5900428AFF442969F88E124DF2CF053BEEFF0035ED020016063AF08600000000"
+	$"00003AF08649DEE04B3FE800E604E74CF980FFC3FAFFF0050003B1B1C5020006"
+	$"0238270AB103BF3103BF38270A48A9A849875A00FFFFFFFFCECEDB020016022F"
+	$"032F3626A4B626A42F032F4872BB48FFBD00FFFF0002000602B82720B103DDB1"
+	$"03DD3827204A7CE349876200FFFFFFFFCECEDB02001602AF0317362693362693"
+	$"2F03174A985648FFC600FFFF0036060AEFE707B93AB30DB93AB30DB8EB20B852"
+	$"B302B89DB2FCB852B302B852B302B639B327B650B325B464B34D20B6E320B4CE"
+	$"20B6E3CF6BB50DD154C9ABCDDDC9ABCDDDCB16CD9ECC35CA23CC35CBF2CC35CA"
+	$"23B6290606EF0BCC35CA23CC35CA23CC35CBF2C9ABCDDDCB16CD9EC9ABCDDDB5"
+	$"0DD154B50DB6C2B50DB6C2B50DB457B93AB30DB6FBB2AEB93AB30DCC35B62906"
+	$"149AF9FFFF99C5DBB9A3C785B9D1BCBDC965BCDFBEB4C785BE9EC785C551C785"
+	$"C551C785C5E6C7B7C671C796C646C7D4C699C840C6ACC803C6ACC846C6ACC853"
+	$"C6ACC84CC6ACC8B1C6A6C987C656C918C689C987C656C987C805C987C805C8C9"
+	$"C859C758C89AC80FC88BC73DC89CC70BC89DC723C89DC665C89DC58FC80CC5E6"
+	$"C86DC52AC79BC4F8C5EDC4F8C6E5C4F8C5EDBE80C412BE75BC7EC52ABC930A04"
+	$"C965BEB4C785BE9EC785BEA8C886BEB40205C7E9C69BC826C68CC802C6A7C840"
+	$"C6AC55C6ACC846C6ACC853C6ACC84CC6ACC8B1C6A6C987C656C918C689C987C6"
+	$"56C8A9C656C8A9C656C865C675060D9FF1FE03C58FC80CC5E6C86DC52AC79BC4"
+	$"F8C5EDC4F8C6E5C4F8C5EDBE80C412BE75BC7EC333C333BCEFC333BCEFC353BD"
+	$"68C37FBE79C36CBDEBC37FBE79C419BE80C419C5EDC419C5EDC419C6E5C4B1C8"
+	$"0CC44CC79BC507C86DC62CC89DC586C89DC62CC89DC70BC89DC70BC89DC665C8"
+	$"9D0A04C5DBB9A3C4FCB9A3C450BC83C52ABC93000BC02DC624C02DC624C084C5"
+	$"44C0AFC0FEC0AFC38DC0AFBEB2C02EBC40C085BD1EBFD8BB60BEA9BAD9BF57BA"
+	$"E8BE9CBAD8BE82BAD7BE8FBAD7BDE1BAD7BD0FBBF1BD66BB35BCB2BCBEBC83C0"
+	$"ECBC83BE68BC83C35ABD0DC617BCB1C514BD65C70EBE92C789BDE7C789BE9AC7"
+	$"89BEA9C788BEA1C788BF55C77DC02DC624BFD6C706C02DC6240211C2C7C6AFC3"
+	$"5DC54DC22EC817C008C96FC146C902C028CA13C099CABCC0595BC0CBCAE9C17F"
+	$"CB00C118CB00C19DCB00C1DFCAFAC1BDCAFEC1DFCAFAC1DFCCE0C1DFCCE0C1DF"
+	$"CCE0C103CCFDC103CCFDC0C2CD05C049CD09C084CD09BF88CD09BE76CC7CBEEC"
+	$"CCDBBDDBCBFFBD1EC9A9BD68CB0EBBCCC961BA0EC721BAC4C88AB955C5B2B8F6"
+	$"C0DDB8F6C39AB8F6BDE8BA75BA58B977BBBABB4BB92EBDEEB89BBC76B89BBE2B"
+	$"B89BBEA9B8A6BE69B89FC064B8D9C275BB14C1A4B9AAC342BC75C3A7C10BC3A7"
+	$"BE71C3A7C36D0203C17FCB00C162CB00C19DCB00C1DFCAFAC1BDCAFEC1DFCAFA"
+	$"C12CCAFAC12CCAFAC145CAFE020DBF44BC40BEFCBB85BF9BBD1EBFC5C0FEBFC5"
+	$"BEB2BFC5C38DBF43C624BF9AC544BEFDC6D9BE20C774BE9CC749BE44C782BE92"
+	$"C789BE6AC789BE9AC789BEA9C788BEA1C788BF55C77DC02DC624BFD6C706C084"
+	$"C544C0AFC0FEC0AFC38DC0AFBEB2C02EBC40C085BD1EBFD8BB60BEA9BAD9BF57"
+	$"BAE8BE9CBAD8BE82BAD7BE8FBAD7BE5ABAD7BE10BAE9BE34BADDBE10BAE9BE10"
+	$"BAE9BE10BAE9BE95BB120222BEEDCCC5BEEECCC6BEE9CCC4BEE1CCC0BEE5CCC2"
+	$"BEE1CCBFBEE0CCBFBEE0CCBFBEDCCCBDBED4CCB9BED8CCBBBED4CCB9BED2CCB8"
+	$"BED3CCB8BECFCCB6BEC8CCB3BECBCCB4BEC7CCB2BEC5CCB1BEC6CCB1BEC2CCAF"
+	$"BEBCCCACBEBFCCADBEBACCABBEB8CCA9BEB9CCAABEB5CCA8BEB0CCA4BEB2CCA6"
+	$"BEAECCA3BEAACCA1BEACCCA2BEA8CCA0BEA4CC9DBEA6CC9EBEA2CC9BBE9ECC99"
+	$"BEA0CC9ABE9CCC97BE98CC95BE9ACC96BE96CC93BE91CC90BE93CC92BE90CC8F"
+	$"BE8DCC8D3DCC8EBE8ACC8BBE84CC87BE87CC89BE83CC86BE81CC85BE82CC85BE"
+	$"7ECC82BE76CC7CBE7ACC7FBDDBCBFFBD1EC9A9BD68CB0EBBCCC961BA0EC721BA"
+	$"C4C88AB955C5B2B8F6C0DDB8F6C39AB8F6BDE8BA75BA58B977BBBABB4BB92EBD"
+	$"EEB89BBC76B89BBDF0B89BBD03B89BBD03B89BBB8CB89BB98BBA58BA61B92EB8"
+	$"8DBBBAB80CC0DDB80CBDE8B80CC39AB924C721B86AC5B2B9DAC88ABC34C9A9BA"
+	$"E2C961BC7ECB0EBD8CCC7CBCF0CBFFBE02CCDBBF5FCD09BE9ECD09BF63CD09BF"
+	$"6ACD09BF67CD09BF6ACD09C037CD09C037CD09BFB9CD07BEEECCC6BF4BCCF1BE"
+	$"EECCC60204B3A5BFF7B3A5B92CB3A5C6C2BFF7CC48B92CCC48C6C2CC48CC48BF"
+	$"F7CC48C6C2CC48B92CBFF7B3A5C6C2B3A5B92CB3A50204BB6DBFF7BB6DC277BB"
+	$"6DBD76BFF7BB6DBD76BB6DC277BB6DC481BFF7C481BD76C481C277BFF7C481C2"
+	$"77C481BD76C481020420BF8820B89F20C671BF88CC11B89FCC11C671CC11CC11"
+	$"BF88CC11C671CC11B89FBF8820C67120B89F200204BB36BF88BB36C1EABB36BD"
+	$"26BF88BB36BD26BB36C1EABB36C3DBBF88C3DBBD26C3DBC1EABF88C3DBC1EAC3"
+	$"DBBD26C3DB0204B337BF88B337B8BDB337C653BF88CBDAB8BDCBDAC653CBDACB"
+	$"DABF88CBDAC653CBDAB8BDBF88B337C653B337B8BDB3370204BAFEBF88BAFEC2"
+	$"09BAFEBD08BF88BAFEBD08BAFEC209BAFEC412BF88C412BD08C412C209BF88C4"
+	$"12C209C412BD08C4120204BF88B3DDC5FAB3DDB916B3DDB3DDBF88B3DDB916B3"
+	$"DDC5FABF88CB34B916CB34C5FACB34CB34BF88CB34C5FACB34B9160204BF88C4"
+	$"B8C264C4B8BCACC4B8BA58BF88BA58C264BA58BCACBF88BA58BCACBA58C264BA"
+	$"58C4B8BF88C4B8BCACC4B8C2640206BF88B63DB9D4B63DC53CB63DCA4FC04AC9"
+	$"EBBAAFCA53C00ACA56BF88CA56BFC9CA56B993BF88B4BAC57DB4BAB993B4BAB4"
+	$"BABF88B4BAB993B4BABFC9B4C2C04AB4BDC00AB525BAAF0206BF88C718BC32C7"
+	$"18C2DEC718C595C10BC595C462C595C0CAC589C04AC591C089C529C345BF88C5"
+	$"95C29DC595BC74C595B988C04AB9E7C345B980C089B97BC10BB97BC0CAB97BC4"
+	$"620206BF88CB34BD68CB34C1A8CB34C55EC9A3C3A6CAA1C55EC9A3C220C405C2"
+	$"20C405C15CC477BF88C4B8C07AC4B8BE97C4B8BCF1C405BDB4C477BCF1C405B9"
+	$"B3C9A3B9B3C9A3BB6ACAA10206BF88B3DDC1A8B3DDBD68B3DDB9B3B56DBB6AB4"
+	$"6FB9B3B56DBCF1BB0BBCF1BB0BBDB4BA9ABF88BA58BE97BA58C07ABA58C220BB"
+	$"0BC15CBA9AC220BB0BC55EB56DC55EB56DC3A6B46F0206C4B8BF88C4B8BE97C4"
+	$"B8C07AC405C220C477C15CC405C220C9A3C55EC9A3C55ECAA1C3A6CB34BF88CB"
+	$"34C1A8CB34BD68C9A3B9B3CAA1BB6AC9A3B9B3C405BCF1C405BCF1C477BDB402"
+	$"06BA58BF88BA58C07ABA58BE97BB0BBCF1BA9ABDB4BB0BBCF1B56DB9B3B56DB9"
+	$"B3B46FBB6AB3DDBF88B3DDBD68B3DDC1A8B56DC55EB46FC3A6B56DC55EBB0BC2"
+	$"20BB0BC220BA9AC15C0206BF88B90DC264B90DBCACB90DBA58BE3CBA58BB60BA"
+	$"58BE75BA63BEE2BA5CBEACBAB5BC54BF88BA58BCE4BA58C22CBA58C4ADBEE2C4"
+	$"5BBC54C4B4BEACC4B8BE3CC4B8BE75C4B8BB600206BF88C9E8C5C2C9E8B94EC9"
+	$"E8B3E2BEE2B438C507B3DFBF19B3DDBF88B3DDBF50B3DDC5FABF88CB34B916CB"
+	$"34C5FACB34CB34BF88CB34C5FACB34BF50CB2FBEE2CB32BF19CAD9C5070206BF"
+	$"88CB34B93ECB34C5D2CB34CB31BFFECAF2C639CB30BFE9CB2F40CB30BFD4CAD9"
+	$"C5E4BF88CAC5C5C2CAC5B94ECAC5B3E240B438C5E4B3E0BFD4B3E0BFFEB3E1BF"
+	$"E9B41EC6390206BA58BF1ABA58BC3DBA58BF2ABA5ABF49BA59BF39BA7BBC8ABF"
+	$"88BA58BCC1BA58C24FBA58C4B6BF49C495BC8AC4B7BF39C4B8BF1AC4B8BF2AC4"
+	$"B8BC3DBF88B9EAC264B9EABCACB9EA0209B3C1BF37B3C1BA88B3C1C1D2B846C5"
+	$"E1B56EC447B79FC6B5B68DC7ABB6FEC74DB68DC7ABB544C8BCB544C8BCB544C8"
+	$"BCB6EFC8A4B6EFC8A4B93156BC86C768BB12C819BD8CC79BBFA8C7B6BE99C7B6"
+	$"C639C7B6CB90BF37CB90C3E6CB90BA88BFA8B6B9C639B6B9B918B6B80209B3A8"
+	$"BEEEB3A8BA3FB3A8C1892DC598B556C3FDB787C66CB674C761B6E5C703B674C7"
+	$"61B52BC872B52BC872B52BC872B6D6C85BB6D6C85BB919C83BBC6DC71EBAF9C7"
+	$"D0BD7353BF90C76CBE81C76C50C76CCB77BEEECB77C39DCB77BA3EBF90B66F50"
+	$"B66FB8FFB66F0209B36ABEBDB36ABA0DB36A44B7EFC567B517C3CCB748C63BB6"
+	$"36C730B6A7C6D2B636C730B4EDC842B4EDC842B4EDC842B698C82AB698C82AB8"
+	$"DBC80ABC2FC6EEBABBC79FBD35C721BF52C73BBE42C73BC5E2C73BCB39BEBDCB"
+	$"39C36CCB39BA0EBF52B63EC5E2B63EB8C1B63E0207BF52B6CBC594B6CBB90FB6"
+	$"CBB3F7BEBDB3F7BA5BB3F7C169B8C4C537B5DDC3C7B7FEC64DB690C79DB733C7"
+	$"16B935C777BC1DC65BBAF6C6EFBD21C691BF52C6AEBE35C6AEC595C6AECAACBE"
+	$"BDCAACC31ECAACBA5B0204BB64C65BBB90C664BA5CC6E0B6A2C78EB8D7C75BB6"
+	$"9CC793B690C79D29C798B90FC779BBE9C674BAC3C6FEBBBDC66C0206BF52B6CB"
+	$"C594B6CBBF33B6CBBEF6B6CCBF14B6CCC50EB6EEC9F4BEBDC9F4BA71C9F4C308"
+	$"BEF7C6ADC50EC68ABF15C6AEBF52C6AEBF33C6AEC594C6AECAACBEBDCAACC31E"
+	$"CAACBA5B0204BCAFC65BBDA0C68DBCA2C662BC86C66FBC94C668BD6BC698BF52"
+	$"C6AEBE5BC6AEBF6DC6AEBFA3C6ADBF88C6AEBE9DC6A90208B690C79DB733C716"
+	$"B6C7C79AB731C7912AC796B7D1C70BB957C537B896C646B670C3C7B48ABEBDB4"
+	$"8AC169B48ABA6CBF9BB6CCB97AB6E7BF83B6CBBF52B6CBBF6AB6CBB90FB6CBB3"
+	$"F7BEBDB3F7BA5BB3F7C169B8C4C537B5DDC3C7B7FEC64D0205B6F4BAE5B869B8"
+	$"B3BA4FBCC5C20BBC36BE22BD3BC2DABBFCC477BB73C3ACBBB6C56CBB22C764BA"
+	$"8FC667BACFC5D3B88ABF4DB73FC2BDB73FBBB2B73F0207C459C0ACC48EC0A1C4"
+	$"59C0ACBA53C0ACBA53C0ACBA1EC0A1B9C1C0CAB9E9C0ABB99CC0E8B986C142B9"
+	$"86C113B986C396BF56C57BBC22C57B47C57BC526C142C526C396C526C113C4EB"
+	$"C0CAC511C0E8C4C4C0AB0207C459C0C5C48EC0B9C459C0C5BA53C0C5BA53C0C5"
+	$"BA1EC0B9B9C1C0E3B9E9C0C4B99CC100B986C15AB986C12CB986C3AFBF56C594"
+	$"BC22C59447C594C526C15AC526C3AFC526C12CC4EBC0E3C511C100C4C4C0C402"
+	$"05BA53C105BA53C105BA29C105BA07C141BA07C120BA07C358BF56C50ABC69C5"
+	$"0AC244C50AC4A6C141C4A6C358C4A6C120C45AC105C484C105C45AC1050204BB"
+	$"43B95BBA1BB95BBC6CB95BBD55BC63BD55BAB0BD55BE15BB43BF6BBC6CBF6BBA"
+	$"1BBF6BB931BC63B931BE15B931BAB00204BB4431BA4131BC4731BD12BC6BBD12"
+	$"BAF0BD12BDE5BB44BF0FBC47BF0FBA41BF0FB976BC6BB976BDE5B976BAF00204"
+	$"BB56BA02BA5FBA02BC4DBA02BD0FBC88BD0FBB1EBD0FBDF1BB56BF0DBC4DBF0D"
+	$"BA5FBF0DB99DBC88B99DBDF1B99DBB1E0205BA50BC7FBA30BD15BA8CBB5DBC1A"
+	$"BA9ABB54BA8EBBD7BA62BB38BA4CBB89BA45BA62BA5FB9E6BCA6B9CABB6CB9F3"
+	$"BD38BA6ABE19BA24BDB9BA3DBDA60204BBC2BC51BB41BC51BC43BC51BCA9BD37"
+	$"BCA9BCB6BCA9BDB9BBC2BE1EBC43BE1EBB41BE1EBADBBD37BADBBDB9BADBBCB6"
+	$"0204BBB6BC65BB52BC65BC1BBC65BC6BBD1ABC6BBCB5BC6BBD7FBBB6BDCEBC1B"
+	$"BDCEBB52BDCEBB02BD1ABB02BD7FBB02BCB50204C315B95BC1ECB95BC43EB95B"
+	$"C527BC63C527BAB0C527BE15C315BF6BC43EBF6BC1ECBF6BC103BC63C103BE15"
+	$"C103BAB00204C31431C21131C41731C4E2BC6BC4E2BAF0C4E2BDE5C314BF0FC4"
+	$"17BF0FC211BF0FC146BC6BC146BDE5C146BAF00204C302BA02C20BBA02C3F9BA"
+	$"02C4BBBC88C4BBBB1EC4BBBDF1C302BF0DC3F9BF0DC20BBF0DC149BC88C149BD"
+	$"F1C149BB1E0205C408BC7FC428BD15C3CCBB5DC23EBA9AC305BA8EC281BA62C3"
+	$"1FBA4CC2CFBA45C3F6BA5FC472BCA6C48EBB6CC465BD38C3EEBE19C434BDB9C4"
+	$"1BBDA60204C296BC50C215BC50C317BC50C37DBD37C37DBCB6C37DBDB9C296BE"
+	$"1FC317BE1FC215BE1FC1AFBD37C1AFBDB9C1AFBCB60204C2A1BC65C23CBC65C3"
+	$"06BC6549BD1A49BCB549BD7FC2A1BDCEC306BDCEC23CBDCEC1EDBD1AC1EDBD7F"
+	$"C1EDBCB50F0A000100023F6E570000000000003F0079920DF9AFA7960A010101"
+	$"023F6E570000000000003F0079920DF9AFA7960A020102023F6E570000000000"
+	$"003F0079920DF9AFA7960A000103023F6E570000000000003F0079920DF9AFA7"
+	$"960A000104023F6E570000000000003F0079920DF9AFA7960A00020506023F6E"
+	$"570000000000003F0079920DF9AFA7960A02020708023F6E570000000000003F"
+	$"0079920DF9AFA7960A000109023F6E570000000000003F0079920DF9AFA7960A"
+	$"03011E000A03011F000A0A0120023EBA690000000000003E684D48AAA149C7C1"
+	$"0A0B0121023EBA690000000000003E684D48AAA149C7C10A0C022223023EBA69"
+	$"0000000000003E684D48AAA149C7C10A0D022425023EBA690000000000003E68"
+	$"4D48AAA149C7C10A0E0126023EBA690000000000003E684D48AAA149C7C1"
+};' >/tmp/linguist.rdef
+rc /tmp/linguist.rdef
+xres -o "$QTROOT/boot/common/bin/linguist" /tmp/linguist.rsrc
+mimeset -f "$QTROOT/boot/common/bin/linguist"
+
+######################################################################
+echo " Qt Help Conversion Wizard"
+######################################################################
+
+echo 'resource app_signature "application/x-vnd.qhelpconverter";
+
+resource app_flags B_SINGLE_LAUNCH;
+
+resource app_version {
+	major  = 4,
+	middle = 7,
+	minor  = 0,
+	variety = 0,
+	internal = 0,
+	short_info = "Qt Help Conversion Wizard",
+	long_info  = "Qt Help Conversion Wizard"
+};
+
+resource vector_icon {
+$"6E6369660A030062250380C34205FF04003303663333020106023DDD49000000"
+	$"0000003DDD4949EEA449EEA400B00000FF993300020106043DA9380000000000"
+	$"003DA93849EEA449EEA400FFFFFF2FFF93936CFF0000FFCF000004FF7F04FF66"
+	$"04614C1E060AEFE707B93AB30DB93AB30DB8EB20B852B302B89DB2FCB852B302"
+	$"B852B302B639B327B650B325B464B34D20B6E320B4CE20B6E3CF6BB50DD154C9"
+	$"ABCDDDC9ABCDDDCB16CD9ECC35CA23CC35CBF2CC35CA23B6290606EF0BCC35CA"
+	$"23CC35CA23CC35CBF2C9ABCDDDCB16CD9EC9ABCDDDB50DD154B50DB6C2B50DB6"
+	$"C2B50DB457B93AB30DB6FBB2AEB93AB30DCC35B62906149AF9FFFF99C5DBB9A3"
+	$"C785B9D1BCBDC965BCDFBEB4C785BE9EC785C551C785C551C785C5E6C7B7C671"
+	$"C796C646C7D4C699C840C6ACC803C6ACC846C6ACC853C6ACC84CC6ACC8B1C6A6"
+	$"C987C656C918C689C987C656C987C805C987C805C8C9C859C758C89AC80FC88B"
+	$"C73DC89CC70BC89DC723C89DC665C89DC58FC80CC5E6C86DC52AC79BC4F8C5ED"
+	$"C4F8C6E5C4F8C5EDBE80C412BE75BC7EC52ABC930A04C965BEB4C785BE9EC785"
+	$"BEA8C886BEB40205C7E9C69BC826C68CC802C6A7C840C6AC55C6ACC846C6ACC8"
+	$"53C6ACC84CC6ACC8B1C6A6C987C656C918C689C987C656C8A9C656C8A9C656C8"
+	$"65C675060D9FF1FE03C58FC80CC5E6C86DC52AC79BC4F8C5EDC4F8C6E5C4F8C5"
+	$"EDBE80C412BE75BC7EC333C333BCEFC333BCEFC353BD68C37FBE79C36CBDEBC3"
+	$"7FBE79C419BE80C419C5EDC419C5EDC419C6E5C4B1C80CC44CC79BC507C86DC6"
+	$"2CC89DC586C89DC62CC89DC70BC89DC70BC89DC665C89D0A04C5DBB9A3C4FCB9"
+	$"A3C450BC83C52ABC93000BC02DC624C02DC624C084C544C0AFC0FEC0AFC38DC0"
+	$"AFBEB2C02EBC40C085BD1EBFD8BB60BEA9BAD9BF57BAE8BE9CBAD8BE82BAD7BE"
+	$"8FBAD7BDE1BAD7BD0FBBF1BD66BB35BCB2BCBEBC83C0ECBC83BE68BC83C35ABD"
+	$"0DC617BCB1C514BD65C70EBE92C789BDE7C789BE9AC789BEA9C788BEA1C788BF"
+	$"55C77DC02DC624BFD6C706C02DC6240211C2C7C6AFC35DC54DC22EC817C008C9"
+	$"6FC146C902C028CA13C099CABCC0595BC0CBCAE9C17FCB00C118CB00C19DCB00"
+	$"C1DFCAFAC1BDCAFEC1DFCAFAC1DFCCE0C1DFCCE0C1DFCCE0C103CCFDC103CCFD"
+	$"C0C2CD05C049CD09C084CD09BF88CD09BE76CC7CBEECCCDBBDDBCBFFBD1EC9A9"
+	$"BD68CB0EBBCCC961BA0EC721BAC4C88AB955C5B2B8F6C0DDB8F6C39AB8F6BDE8"
+	$"BA75BA58B977BBBABB4BB92EBDEEB89BBC76B89BBE2BB89BBEA9B8A6BE69B89F"
+	$"C064B8D9C275BB14C1A4B9AAC342BC75C3A7C10BC3A7BE71C3A7C36D0203C17F"
+	$"CB00C162CB00C19DCB00C1DFCAFAC1BDCAFEC1DFCAFAC12CCAFAC12CCAFAC145"
+	$"CAFE020DBF44BC40BEFCBB85BF9BBD1EBFC5C0FEBFC5BEB2BFC5C38DBF43C624"
+	$"BF9AC544BEFDC6D9BE20C774BE9CC749BE44C782BE92C789BE6AC789BE9AC789"
+	$"BEA9C788BEA1C788BF55C77DC02DC624BFD6C706C084C544C0AFC0FEC0AFC38D"
+	$"C0AFBEB2C02EBC40C085BD1EBFD8BB60BEA9BAD9BF57BAE8BE9CBAD8BE82BAD7"
+	$"BE8FBAD7BE5ABAD7BE10BAE9BE34BADDBE10BAE9BE10BAE9BE10BAE9BE95BB12"
+	$"0222BEEDCCC5BEEECCC6BEE9CCC4BEE1CCC0BEE5CCC2BEE1CCBFBEE0CCBFBEE0"
+	$"CCBFBEDCCCBDBED4CCB9BED8CCBBBED4CCB9BED2CCB8BED3CCB8BECFCCB6BEC8"
+	$"CCB3BECBCCB4BEC7CCB2BEC5CCB1BEC6CCB1BEC2CCAFBEBCCCACBEBFCCADBEBA"
+	$"CCABBEB8CCA9BEB9CCAABEB5CCA8BEB0CCA4BEB2CCA6BEAECCA3BEAACCA1BEAC"
+	$"CCA2BEA8CCA0BEA4CC9DBEA6CC9EBEA2CC9BBE9ECC99BEA0CC9ABE9CCC97BE98"
+	$"CC95BE9ACC96BE96CC93BE91CC90BE93CC92BE90CC8FBE8DCC8D3DCC8EBE8ACC"
+	$"8BBE84CC87BE87CC89BE83CC86BE81CC85BE82CC85BE7ECC82BE76CC7CBE7ACC"
+	$"7FBDDBCBFFBD1EC9A9BD68CB0EBBCCC961BA0EC721BAC4C88AB955C5B2B8F6C0"
+	$"DDB8F6C39AB8F6BDE8BA75BA58B977BBBABB4BB92EBDEEB89BBC76B89BBDF0B8"
+	$"9BBD03B89BBD03B89BBB8CB89BB98BBA58BA61B92EB88DBBBAB80CC0DDB80CBD"
+	$"E8B80CC39AB924C721B86AC5B2B9DAC88ABC34C9A9BAE2C961BC7ECB0EBD8CCC"
+	$"7CBCF0CBFFBE02CCDBBF5FCD09BE9ECD09BF63CD09BF6ACD09BF67CD09BF6ACD"
+	$"09C037CD09C037CD09BFB9CD07BEEECCC6BF4BCCF1BEEECCC60204B3A5BFF7B3"
+	$"A5B92CB3A5C6C2BFF7CC48B92CCC48C6C2CC48CC48BFF7CC48C6C2CC48B92CBF"
+	$"F7B3A5C6C2B3A5B92CB3A50204BB6DBFF7BB6DC277BB6DBD76BFF7BB6DBD76BB"
+	$"6DC277BB6DC481BFF7C481BD76C481C277BFF7C481C277C481BD76C481020420"
+	$"BF8820B89F20C671BF88CC11B89FCC11C671CC11CC11BF88CC11C671CC11B89F"
+	$"BF8820C67120B89F200204BB36BF88BB36C1EABB36BD26BF88BB36BD26BB36C1"
+	$"EABB36C3DBBF88C3DBBD26C3DBC1EABF88C3DBC1EAC3DBBD26C3DB0204B337BF"
+	$"88B337B8BDB337C653BF88CBDAB8BDCBDAC653CBDACBDABF88CBDAC653CBDAB8"
+	$"BDBF88B337C653B337B8BDB3370204BAFEBF88BAFEC209BAFEBD08BF88BAFEBD"
+	$"08BAFEC209BAFEC412BF88C412BD08C412C209BF88C412C209C412BD08C41202"
+	$"04BF88B3DDC5FAB3DDB916B3DDB3DDBF88B3DDB916B3DDC5FABF88CB34B916CB"
+	$"34C5FACB34CB34BF88CB34C5FACB34B9160204BF88C4B8C264C4B8BCACC4B8BA"
+	$"58BF88BA58C264BA58BCACBF88BA58BCACBA58C264BA58C4B8BF88C4B8BCACC4"
+	$"B8C2640206BF88B63DB9D4B63DC53CB63DCA4FC04AC9EBBAAFCA53C00ACA56BF"
+	$"88CA56BFC9CA56B993BF88B4BAC57DB4BAB993B4BAB4BABF88B4BAB993B4BABF"
+	$"C9B4C2C04AB4BDC00AB525BAAF0206BF88C718BC32C718C2DEC718C595C10BC5"
+	$"95C462C595C0CAC589C04AC591C089C529C345BF88C595C29DC595BC74C595B9"
+	$"88C04AB9E7C345B980C089B97BC10BB97BC0CAB97BC4620206BF88CB34BD68CB"
+	$"34C1A8CB34C55EC9A3C3A6CAA1C55EC9A3C220C405C220C405C15CC477BF88C4"
+	$"B8C07AC4B8BE97C4B8BCF1C405BDB4C477BCF1C405B9B3C9A3B9B3C9A3BB6ACA"
+	$"A10206BF88B3DDC1A8B3DDBD68B3DDB9B3B56DBB6AB46FB9B3B56DBCF1BB0BBC"
+	$"F1BB0BBDB4BA9ABF88BA58BE97BA58C07ABA58C220BB0BC15CBA9AC220BB0BC5"
+	$"5EB56DC55EB56DC3A6B46F0206C4B8BF88C4B8BE97C4B8C07AC405C220C477C1"
+	$"5CC405C220C9A3C55EC9A3C55ECAA1C3A6CB34BF88CB34C1A8CB34BD68C9A3B9"
+	$"B3CAA1BB6AC9A3B9B3C405BCF1C405BCF1C477BDB40206BA58BF88BA58C07ABA"
+	$"58BE97BB0BBCF1BA9ABDB4BB0BBCF1B56DB9B3B56DB9B3B46FBB6AB3DDBF88B3"
+	$"DDBD68B3DDC1A8B56DC55EB46FC3A6B56DC55EBB0BC220BB0BC220BA9AC15C02"
+	$"06BF88B90DC264B90DBCACB90DBA58BE3CBA58BB60BA58BE75BA63BEE2BA5CBE"
+	$"ACBAB5BC54BF88BA58BCE4BA58C22CBA58C4ADBEE2C45BBC54C4B4BEACC4B8BE"
+	$"3CC4B8BE75C4B8BB600206BF88C9E8C5C2C9E8B94EC9E8B3E2BEE2B438C507B3"
+	$"DFBF19B3DDBF88B3DDBF50B3DDC5FABF88CB34B916CB34C5FACB34CB34BF88CB"
+	$"34C5FACB34BF50CB2FBEE2CB32BF19CAD9C5070206BF88CB34B93ECB34C5D2CB"
+	$"34CB31BFFECAF2C639CB30BFE9CB2F40CB30BFD4CAD9C5E4BF88CAC5C5C2CAC5"
+	$"B94ECAC5B3E240B438C5E4B3E0BFD4B3E0BFFEB3E1BFE9B41EC6390206BA58BF"
+	$"1ABA58BC3DBA58BF2ABA5ABF49BA59BF39BA7BBC8ABF88BA58BCC1BA58C24FBA"
+	$"58C4B6BF49C495BC8AC4B7BF39C4B8BF1AC4B8BF2AC4B8BC3DBF88B9EAC264B9"
+	$"EABCACB9EA150A000100023F6E570000000000003F0079920DF9AFA7960A0101"
+	$"01023F6E570000000000003F0079920DF9AFA7960A020102023F6E5700000000"
+	$"00003F0079920DF9AFA7960A000103023F6E570000000000003F0079920DF9AF"
+	$"A7960A000104023F6E570000000000003F0079920DF9AFA7960A00020506023F"
+	$"6E570000000000003F0079920DF9AFA7960A02020708023F6E57000000000000"
+	$"3F0079920DF9AFA7960A000109023F6E570000000000003F0079920DF9AFA796"
+	$"0A00020A0B023D6A390000000000003D3C934A3EB74A17E90A03020C0D023DD6"
+	$"F90000000000003DF73F4A20004A10000A04020E0F023DD6F90000000000003D"
+	$"F73F4A20004A10000A05021011023DD6F90000000000003DF73F4A20004A1000"
+	$"0A06021213023DD6F90000000000003DF73F4A20004A10000A070114023DD6F9"
+	$"0000000000003DF73F4A20004A10000A080115023DD6F90000000000003DF73F"
+	$"4A20004A10000A020116023DD6F90000000000003DF73F4A20004A10000A0201"
+	$"17023DD6F90000000000003DF73F4A20004A10000A020118023DD6F900000000"
+	$"00003DF73F4A20004A10000A020119023DD6F90000000000003DF73F4A20004A"
+	$"10000A09021A1B023DD6F90000000000003DF73F4A20004A10000A09021C1D02"
+	$"3DD6F90000000000003DF73F4A20004A1000"	
+};' >/tmp/qhelpconverter.rdef
+rc /tmp/qhelpconverter.rdef
+xres -o "$QTROOT/boot/common/bin/qhelpconverter" /tmp/qhelpconverter.rsrc
+mimeset -f "$QTROOT/boot/common/bin/qhelpconverter"
+
+######################################################################
+echo " Qt QML Viewer"
+######################################################################
+
+echo 'resource app_signature "application/x-vnd.qmlviewer";
+
+resource app_flags B_MULTIPLE_LAUNCH;
+
+resource app_version {
+	major  = 4,
+	middle = 7,
+	minor  = 0,
+	variety = 0,
+	internal = 0,
+	short_info = "Qt QML Viewer",
+	long_info  = "Qt QML Viewer"
+};
+
+resource file_types message {
+	"types" = "text/x-qml",
+	"types" = "application/x-qml"
+};
+
+resource vector_icon {
+	$"6E63696603030062250380C34205FF0C060AEFE707B93AB30DB93AB30DB8EB20"
+	$"B852B302B89DB2FCB852B302B852B302B639B327B650B325B464B34D20B6E320"
+	$"B4CE20B6E3CF6BB50DD154C9ABCDDDC9ABCDDDCB16CD9ECC35CA23CC35CBF2CC"
+	$"35CA23B6290606EF0BCC35CA23CC35CA23CC35CBF2C9ABCDDDCB16CD9EC9ABCD"
+	$"DDB50DD154B50DB6C2B50DB6C2B50DB457B93AB30DB6FBB2AEB93AB30DCC35B6"
+	$"2906149AF9FFFF99C5DBB9A3C785B9D1BCBDC965BCDFBEB4C785BE9EC785C551"
+	$"C785C551C785C5E6C7B7C671C796C646C7D4C699C840C6ACC803C6ACC846C6AC"
+	$"C853C6ACC84CC6ACC8B1C6A6C987C656C918C689C987C656C987C805C987C805"
+	$"C8C9C859C758C89AC80FC88BC73DC89CC70BC89DC723C89DC665C89DC58FC80C"
+	$"C5E6C86DC52AC79BC4F8C5EDC4F8C6E5C4F8C5EDBE80C412BE75BC7EC52ABC93"
+	$"0A04C965BEB4C785BE9EC785BEA8C886BEB40205C7E9C69BC826C68CC802C6A7"
+	$"C840C6AC55C6ACC846C6ACC853C6ACC84CC6ACC8B1C6A6C987C656C918C689C9"
+	$"87C656C8A9C656C8A9C656C865C675060D9FF1FE03C58FC80CC5E6C86DC52AC7"
+	$"9BC4F8C5EDC4F8C6E5C4F8C5EDBE80C412BE75BC7EC333C333BCEFC333BCEFC3"
+	$"53BD68C37FBE79C36CBDEBC37FBE79C419BE80C419C5EDC419C5EDC419C6E5C4"
+	$"B1C80CC44CC79BC507C86DC62CC89DC586C89DC62CC89DC70BC89DC70BC89DC6"
+	$"65C89D0A04C5DBB9A3C4FCB9A3C450BC83C52ABC93000BC02DC624C02DC624C0"
+	$"84C544C0AFC0FEC0AFC38DC0AFBEB2C02EBC40C085BD1EBFD8BB60BEA9BAD9BF"
+	$"57BAE8BE9CBAD8BE82BAD7BE8FBAD7BDE1BAD7BD0FBBF1BD66BB35BCB2BCBEBC"
+	$"83C0ECBC83BE68BC83C35ABD0DC617BCB1C514BD65C70EBE92C789BDE7C789BE"
+	$"9AC789BEA9C788BEA1C788BF55C77DC02DC624BFD6C706C02DC6240211C2C7C6"
+	$"AFC35DC54DC22EC817C008C96FC146C902C028CA13C099CABCC0595BC0CBCAE9"
+	$"C17FCB00C118CB00C19DCB00C1DFCAFAC1BDCAFEC1DFCAFAC1DFCCE0C1DFCCE0"
+	$"C1DFCCE0C103CCFDC103CCFDC0C2CD05C049CD09C084CD09BF88CD09BE76CC7C"
+	$"BEECCCDBBDDBCBFFBD1EC9A9BD68CB0EBBCCC961BA0EC721BAC4C88AB955C5B2"
+	$"B8F6C0DDB8F6C39AB8F6BDE8BA75BA58B977BBBABB4BB92EBDEEB89BBC76B89B"
+	$"BE2BB89BBEA9B8A6BE69B89FC064B8D9C275BB14C1A4B9AAC342BC75C3A7C10B"
+	$"C3A7BE71C3A7C36D0203C17FCB00C162CB00C19DCB00C1DFCAFAC1BDCAFEC1DF"
+	$"CAFAC12CCAFAC12CCAFAC145CAFE020DBF44BC40BEFCBB85BF9BBD1EBFC5C0FE"
+	$"BFC5BEB2BFC5C38DBF43C624BF9AC544BEFDC6D9BE20C774BE9CC749BE44C782"
+	$"BE92C789BE6AC789BE9AC789BEA9C788BEA1C788BF55C77DC02DC624BFD6C706"
+	$"C084C544C0AFC0FEC0AFC38DC0AFBEB2C02EBC40C085BD1EBFD8BB60BEA9BAD9"
+	$"BF57BAE8BE9CBAD8BE82BAD7BE8FBAD7BE5ABAD7BE10BAE9BE34BADDBE10BAE9"
+	$"BE10BAE9BE10BAE9BE95BB120222BEEDCCC5BEEECCC6BEE9CCC4BEE1CCC0BEE5"
+	$"CCC2BEE1CCBFBEE0CCBFBEE0CCBFBEDCCCBDBED4CCB9BED8CCBBBED4CCB9BED2"
+	$"CCB8BED3CCB8BECFCCB6BEC8CCB3BECBCCB4BEC7CCB2BEC5CCB1BEC6CCB1BEC2"
+	$"CCAFBEBCCCACBEBFCCADBEBACCABBEB8CCA9BEB9CCAABEB5CCA8BEB0CCA4BEB2"
+	$"CCA6BEAECCA3BEAACCA1BEACCCA2BEA8CCA0BEA4CC9DBEA6CC9EBEA2CC9BBE9E"
+	$"CC99BEA0CC9ABE9CCC97BE98CC95BE9ACC96BE96CC93BE91CC90BE93CC92BE90"
+	$"CC8FBE8DCC8D3DCC8EBE8ACC8BBE84CC87BE87CC89BE83CC86BE81CC85BE82CC"
+	$"85BE7ECC82BE76CC7CBE7ACC7FBDDBCBFFBD1EC9A9BD68CB0EBBCCC961BA0EC7"
+	$"21BAC4C88AB955C5B2B8F6C0DDB8F6C39AB8F6BDE8BA75BA58B977BBBABB4BB9"
+	$"2EBDEEB89BBC76B89BBDF0B89BBD03B89BBD03B89BBB8CB89BB98BBA58BA61B9"
+	$"2EB88DBBBAB80CC0DDB80CBDE8B80CC39AB924C721B86AC5B2B9DAC88ABC34C9"
+	$"A9BAE2C961BC7ECB0EBD8CCC7CBCF0CBFFBE02CCDBBF5FCD09BE9ECD09BF63CD"
+	$"09BF6ACD09BF67CD09BF6ACD09C037CD09C037CD09BFB9CD07BEEECCC6BF4BCC"
+	$"F1BEEECCC6090A000100023F8EB50000000000003F43B74400003FFD4E0A0101"
+	$"01023F8EB50000000000003F43B74400003FFD4E0A020102023F8EB500000000"
+	$"00003F43B74400003FFD4E0A000103023F8EB50000000000003F43B74400003F"
+	$"FD4E0A000104023F8EB50000000000003F43B74400003FFD4E0A00020506023F"
+	$"8EB50000000000003F43B74400003FFD4E0A02020708023F8EB5000000000000"
+	$"3F43B74400003FFD4E0A000109023F8EB50000000000003F43B74400003FFD4E"
+	$"0A00020A0B023F8EB50000000000003F43B74400003FFD4E"
+};' >/tmp/qmlviewer.rdef
+rc /tmp/qmlviewer.rdef
+xres -o "$QTROOT/boot/common/bin/qmlviewer" /tmp/qmlviewer.rsrc
+mimeset -f "$QTROOT/boot/common/bin/qmlviewer"
+
+######################################################################
+echo " Qt Config"
+######################################################################
+
+echo 'resource app_signature "application/x-vnd.qtconfig";
+
+resource app_flags B_SINGLE_LAUNCH;
+
+resource app_version {
+	major  = 4,
+	middle = 7,
+	minor  = 0,
+	variety = 0,
+	internal = 0,
+	short_info = "Qt Config",
+	long_info  = "Qt Configuration"
+};
+
+resource vector_icon {
+	$"6E6369660503076324037FC24105FF03FFC96903FFB23D120206B5BEB707B536"
+	$"2CB633B636B808B600B73BB634B74CB695B69AB859B683B751B68BBD18B68CC6"
+	$"98B6B0C1D8B611C63CB55AC544B53DC604B549C162B552B99BB55CBD7EB55AB8"
+	$"BE0206B84DBEAAB86CC012B83FBCDFB9F1B97DB827BA84B9F1B97DB9D031B9D0"
+	$"31B95DBAB7B8D7BCBFB8E7BBAFB8B7BE98BA29C21EB8CBC0B5BA29C21EBA5DC2"
+	$"5FBA5DC25FB8B3C2070204BF62BB21BF62BB21BF16BA7FC007B981BF98B9EAC0"
+	$"07B981BFF9B9DABFF9B9DABFE3BA57BF9BBB4ABFCDBAD5BF9BBB4A0203BC34BA"
+	$"5FBCD4BCAFBD21BB14BD2DBD61BD2CBC51BD27BEC2BC4EC16FBD5AC059BCB5BF"
+	$"180207BE8FBB35BE8FBB35BEACBB56BF01BBBBBEE5BB99BF45BC41BF88BD65BF"
+	$"91BCCBBF88BEE8BFCEC1ECBF8EC06DBFCEC1ECBFD8C237BFD8C237BE6DC0B2BE"
+	$"D5BCAABF6ABE7BBEC4BC49BE9EBB89BEB2BBE9BE9EBB890204C71DBD22C736BD"
+	$"A4C767BCD4C7EDBC2DC7ACBC81C7EABD15C816BEE3C7FCBDFCC7ECBED4C76FBE"
+	$"A8C799BEB6C754BE250204CC18BCAFCC3DBCCBCC35BCA2CC88BC7BCC6CBC88CC"
+	$"99BC97CCCDBCEDCCBBBCD0CCCDBCEDCCA9BD1CCCA9BD1CCC84BD010203BA8AC2"
+	$"60BAB9C313BB18C2A3BB94C3BDBB55C337BB94C3BDBBBAC414BBBAC414BAFBC3"
+	$"CD0204C139C355C166C38EC189C2FAC22CC246C1DAC29FC229C277C21FC30AC2"
+	$"22C2D9C20DC370C1EAC43BC1FDC3D645C4010203C630C65CC650C678C6A2C63C"
+	$"C790C627C719C631C7BEC694C6B1C6CDC70BC6E1C691C6B1000CB808B600B808"
+	$"B600BBE6B67FC399B7CCBFBCB740C3BFBA8DC3E2C011C34DBD5BC335C100C21F"
+	$"C30AC297C1FDC222C2D9C22CC246C229C277C1DAC29FC139C355C189C2FAC128"
+	$"C33FC0F3C2FDC104C313BFDDC3BEBE23C5C1BEE0C4A7BB94C5CAB689C6DBB90F"
+	$"C674B689C6DBB68CC698B68CC698B6B0C1D8B69AB859B68BBD18B683B751B808"
+	$"B600B74CB695B808B600021CB9D031BAB9B96FB9D031B9F1B97DB9F1B97DB827"
+	$"BA84B84DBEAAB83FBCDFB86CC012BA5DC25FB8B3C207BA5DC25FBA29C21EBA29"
+	$"C21EBA41C22EBA8AC260BA72C24FBAB9C313BBBAC414BAFBC3CDBBBAC414BB94"
+	$"C3BDBB94C3BDBC18C464BDC4C45DBCFDC485BE0FC38FBCC8C29ABD34C323BEDA"
+	$"C169BED5BCAABEF2BEC6BF6ABE7BBFD8C237BE6DC0B2BFD8C237BFCEC1ECBFCE"
+	$"C1ECC091C1E5C210C19FC152C1CDC1BAC13FC10EC07DC156C0E9C0EFBF38C0FE"
+	$"BCACC108BDF2C15738C209BC57C1B0BC73C209BC27C205BB96C207BBC6C1AEBB"
+	$"85C0FFBB63C156BB74C0FDBADEC0F7B9D3C0FBBA58C0B7B9D4BFF9B9DAC038B9"
+	$"D8BFF9B9DAC007B981C007B981BF98B9EABF62BB21BF16BA7FBF62BB21BF9BBB"
+	$"4ABF9BBB4ABF75BB66BF01BBBBBF28BB9FBEE5BB99BE8FBB35BEACBB56BE8FBB"
+	$"35BE9EBB89BE9EBB89BE4ABA9ABCB1B957BDB1B9A5BBB7B8ED0205BACDBE05BA"
+	$"DCBF5CBAD4BC9EBC25BA18BAAABAD6BC25BA18BC34BA5FBC34BA5FBCD4BCAFBC"
+	$"4EC16FBCB5BF18BC4EC16FBC45C1B1BC45C1B1BAC2C11C000BB9D031B9D031BA"
+	$"B9B96FBCB1B957BBB7B8EDBDB1B9A5BE9EBB89BE4ABA9ABEB2BBE9BED5BCAABE"
+	$"C4BC49BEF2BEC6BCC8C29ABEDAC169BD34C323BDC4C45DBE0FC38FBCFDC485BB"
+	$"94C3BDBC18C464BB55C337BA8AC260BB18C2A3BA72C24FBA29C21EBA41C22EB8"
+	$"CBC0B5B8D7BCBFB8B7BE98B8E7BBAFB9D031B95DBAB7B9D0310206BACDBE05BA"
+	$"D4BC9EBADCBF5CBC45C1B1BAC2C11CBC45C1B1BC4EC16FBC4EC16FBD5AC059BD"
+	$"2DBD61BD27BEC2BD2CBC51BC34BA5FBD21BB14BC34BA5FBC25BA18BC25BA18BA"
+	$"AABAD6020CBFF9B9DABFE3BA57C038B9D8C0F7B9D3C0B7B9D4C0FBBA58C0FFBB"
+	$"63C0FDBADEC156BB74C205BB96C1AEBB85C207BBC6C209BC57C209BC27C1B0BC"
+	$"73C0FEBCACC15738C108BDF2C10EC07DC0EFBF38C156C0E9C210C19FC1BAC13F"
+	$"C152C1CDBFCEC1ECC091C1E5BF8EC06DBF88BD65BF88BEE8BF91BCCBBF01BBBB"
+	$"BF45BC41BF28BB9FBF9BBB4ABF75BB66BFCDBAD50212C7EDBC2DC7EABD15C9C2"
+	$"BB14CDE2BA16CBBCBA3ECD99BAD4CD0EBC54CD4FBB93CCEDBC5ECC88BC7BCCA9"
+	$"BC71CC6CBC88CC18BCAFCC35BCA2CC3DBCCBCCA9BD1CCC84BD01CCA9BD1CCCF1"
+	$"BD33CCF1BD33CC7DBE87CBA3C136CC5BBFFDCB2AC222C93FC2D3CA15C25BC9B5"
+	$"C2EACAA2C31BCA2CC302CA24C47DC790C627C935C613C719C631C630C65CC6A2"
+	$"C63CC650C678C6B1C6CDC691C6B1C6B1C6CDC704C711C704C711C53AC85DC0CD"
+	$"C835C2ED56C330C72BC6C1C347C567C589C795C1E5C76FBEA8C7ACC037C799BE"
+	$"B6C816BEE3C7ECBED4C7FCBDFC020EC3E2C011C335C100C4E3BF09C71DBD22C5"
+	$"C2BDB8C736BDA4C76FBEA8C754BE25C7ACC037C6C1C347C795C1E5C567C589C0"
+	$"CDC835C330C72BBFD7C808BE02C755BEEAC7B0BBDFC875B712C8DFB96DC89CB6"
+	$"FAC8A4B6B2C7F5B6CAC82FB8C4C812BCD6C728BAE0C7D8BD88C6FEBE23C5C1BD"
+	$"C1C644BEE0C4A7C0F3C2FDBFDDC3BEC104C313C139C355C128C33FC166C38EC1"
+	$"EAC43B45C401C1FDC3D6C21FC30AC20DC370C297C1FD100A000100201B210A00"
+	$"0101201B210A000102201B210A000103201B210A000104201B210A000105201B"
+	$"210A000106201B210A000107201B210A000108201B210A000109201B210A0102"
+	$"0A0B201B210A01010C201B210A02020D0E201B210A02010F201B210A03011020"
+	$"1B210A040111201B21"
+};' >/tmp/qtconfig.rdef
+rc /tmp/qtconfig.rdef
+xres -o "$QTROOT/boot/common/bin/qtconfig" /tmp/qtconfig.rsrc
+mimeset -f "$QTROOT/boot/common/bin/qtconfig"
+
+
+######################################################################
+echo "Make menu items"
+######################################################################
+mkdir -p  "$QTROOT/boot/home/config/be/Preferences"
+mkdir -p  "$QTROOT/boot/home/config/be/Qt/Development"
+ln -s -f "/boot/common/data/licenses/LGPL v2.1" "$QTROOT/boot/home/config/be/Qt/LGPL v2.1"
+ln -s -f "/boot/common/bin/qtconfig" "$QTROOT/boot/home/config/be/Preferences/Qt Config"
+ln -s -f "/boot/common/bin/assistant" "$QTROOT/boot/home/config/be/Qt/Development/Qt Assistant"
+ln -s -f "/boot/common/bin/designer" "$QTROOT/boot/home/config/be/Qt/Development/Qt Designer"
+ln -s -f "/boot/common/bin/qhelpconverter" "$QTROOT/boot/home/config/be/Qt/Development/Qt Help Conversion Wizard"
+ln -s -f "/boot/common/bin/linguist" "$QTROOT/boot/home/config/be/Qt/Development/Qt Linguist"
+ln -s -f "/boot/common/bin/qmlviewer" "$QTROOT/boot/home/config/be/Qt/Development/Qt QML Viewer"
+
+
+######################################################################
+# create GNU Free Documentation License file
+######################################################################
+mkdir -p  "$QTROOT/boot/common/data/licenses"
+echo "
+                GNU Free Documentation License
+                 Version 1.3, 3 November 2008
+
+
+ Copyright (C) 2000, 2001, 2002, 2007, 2008 Free Software Foundation, Inc.
+     <http://fsf.org/>
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+0. PREAMBLE
+
+The purpose of this License is to make a manual, textbook, or other
+functional and useful document \"free\" in the sense of freedom: to
+assure everyone the effective freedom to copy and redistribute it,
+with or without modifying it, either commercially or noncommercially.
+Secondarily, this License preserves for the author and publisher a way
+to get credit for their work, while not being considered responsible
+for modifications made by others.
+
+This License is a kind of \"copyleft\", which means that derivative
+works of the document must themselves be free in the same sense.  It
+complements the GNU General Public License, which is a copyleft
+license designed for free software.
+
+We have designed this License in order to use it for manuals for free
+software, because free software needs free documentation: a free
+program should come with manuals providing the same freedoms that the
+software does.  But this License is not limited to software manuals;
+it can be used for any textual work, regardless of subject matter or
+whether it is published as a printed book.  We recommend this License
+principally for works whose purpose is instruction or reference.
+
+
+1. APPLICABILITY AND DEFINITIONS
+
+This License applies to any manual or other work, in any medium, that
+contains a notice placed by the copyright holder saying it can be
+distributed under the terms of this License.  Such a notice grants a
+world-wide, royalty-free license, unlimited in duration, to use that
+work under the conditions stated herein.  The \"Document\", below,
+refers to any such manual or work.  Any member of the public is a
+licensee, and is addressed as \"you\".  You accept the license if you
+copy, modify or distribute the work in a way requiring permission
+under copyright law.
+
+A \"Modified Version\" of the Document means any work containing the
+Document or a portion of it, either copied verbatim, or with
+modifications and/or translated into another language.
+
+A \"Secondary Section\" is a named appendix or a front-matter section of
+the Document that deals exclusively with the relationship of the
+publishers or authors of the Document to the Document's overall
+subject (or to related matters) and contains nothing that could fall
+directly within that overall subject.  (Thus, if the Document is in
+part a textbook of mathematics, a Secondary Section may not explain
+any mathematics.)  The relationship could be a matter of historical
+connection with the subject or with related matters, or of legal,
+commercial, philosophical, ethical or political position regarding
+them.
+
+The \"Invariant Sections\" are certain Secondary Sections whose titles
+are designated, as being those of Invariant Sections, in the notice
+that says that the Document is released under this License.  If a
+section does not fit the above definition of Secondary then it is not
+allowed to be designated as Invariant.  The Document may contain zero
+Invariant Sections.  If the Document does not identify any Invariant
+Sections then there are none.
+
+The \"Cover Texts\" are certain short passages of text that are listed,
+as Front-Cover Texts or Back-Cover Texts, in the notice that says that
+the Document is released under this License.  A Front-Cover Text may
+be at most 5 words, and a Back-Cover Text may be at most 25 words.
+
+A \"Transparent\" copy of the Document means a machine-readable copy,
+represented in a format whose specification is available to the
+general public, that is suitable for revising the document
+straightforwardly with generic text editors or (for images composed of
+pixels) generic paint programs or (for drawings) some widely available
+drawing editor, and that is suitable for input to text formatters or
+for automatic translation to a variety of formats suitable for input
+to text formatters.  A copy made in an otherwise Transparent file
+format whose markup, or absence of markup, has been arranged to thwart
+or discourage subsequent modification by readers is not Transparent.
+An image format is not Transparent if used for any substantial amount
+of text.  A copy that is not \"Transparent\" is called \"Opaque\".
+
+Examples of suitable formats for Transparent copies include plain
+ASCII without markup, Texinfo input format, LaTeX input format, SGML
+or XML using a publicly available DTD, and standard-conforming simple
+HTML, PostScript or PDF designed for human modification.  Examples of
+transparent image formats include PNG, XCF and JPG.  Opaque formats
+include proprietary formats that can be read and edited only by
+proprietary word processors, SGML or XML for which the DTD and/or
+processing tools are not generally available, and the
+machine-generated HTML, PostScript or PDF produced by some word
+processors for output purposes only.
+
+The \"Title Page\" means, for a printed book, the title page itself,
+plus such following pages as are needed to hold, legibly, the material
+this License requires to appear in the title page.  For works in
+formats which do not have any title page as such, \"Title Page\" means
+the text near the most prominent appearance of the work's title,
+preceding the beginning of the body of the text.
+
+The \"publisher\" means any person or entity that distributes copies of
+the Document to the public.
+
+A section \"Entitled XYZ\" means a named subunit of the Document whose
+title either is precisely XYZ or contains XYZ in parentheses following
+text that translates XYZ in another language.  (Here XYZ stands for a
+specific section name mentioned below, such as \"Acknowledgements\",
+\"Dedications\", \"Endorsements\", or \"History\".)  To \"Preserve the Title\"
+of such a section when you modify the Document means that it remains a
+section \"Entitled XYZ\" according to this definition.
+
+The Document may include Warranty Disclaimers next to the notice which
+states that this License applies to the Document.  These Warranty
+Disclaimers are considered to be included by reference in this
+License, but only as regards disclaiming warranties: any other
+implication that these Warranty Disclaimers may have is void and has
+no effect on the meaning of this License.
+
+2. VERBATIM COPYING
+
+You may copy and distribute the Document in any medium, either
+commercially or noncommercially, provided that this License, the
+copyright notices, and the license notice saying this License applies
+to the Document are reproduced in all copies, and that you add no
+other conditions whatsoever to those of this License.  You may not use
+technical measures to obstruct or control the reading or further
+copying of the copies you make or distribute.  However, you may accept
+compensation in exchange for copies.  If you distribute a large enough
+number of copies you must also follow the conditions in section 3.
+
+You may also lend copies, under the same conditions stated above, and
+you may publicly display copies.
+
+
+3. COPYING IN QUANTITY
+
+If you publish printed copies (or copies in media that commonly have
+printed covers) of the Document, numbering more than 100, and the
+Document's license notice requires Cover Texts, you must enclose the
+copies in covers that carry, clearly and legibly, all these Cover
+Texts: Front-Cover Texts on the front cover, and Back-Cover Texts on
+the back cover.  Both covers must also clearly and legibly identify
+you as the publisher of these copies.  The front cover must present
+the full title with all words of the title equally prominent and
+visible.  You may add other material on the covers in addition.
+Copying with changes limited to the covers, as long as they preserve
+the title of the Document and satisfy these conditions, can be treated
+as verbatim copying in other respects.
+
+If the required texts for either cover are too voluminous to fit
+legibly, you should put the first ones listed (as many as fit
+reasonably) on the actual cover, and continue the rest onto adjacent
+pages.
+
+If you publish or distribute Opaque copies of the Document numbering
+more than 100, you must either include a machine-readable Transparent
+copy along with each Opaque copy, or state in or with each Opaque copy
+a computer-network location from which the general network-using
+public has access to download using public-standard network protocols
+a complete Transparent copy of the Document, free of added material.
+If you use the latter option, you must take reasonably prudent steps,
+when you begin distribution of Opaque copies in quantity, to ensure
+that this Transparent copy will remain thus accessible at the stated
+location until at least one year after the last time you distribute an
+Opaque copy (directly or through your agents or retailers) of that
+edition to the public.
+
+It is requested, but not required, that you contact the authors of the
+Document well before redistributing any large number of copies, to
+give them a chance to provide you with an updated version of the
+Document.
+
+
+4. MODIFICATIONS
+
+You may copy and distribute a Modified Version of the Document under
+the conditions of sections 2 and 3 above, provided that you release
+the Modified Version under precisely this License, with the Modified
+Version filling the role of the Document, thus licensing distribution
+and modification of the Modified Version to whoever possesses a copy
+of it.  In addition, you must do these things in the Modified Version:
+
+A. Use in the Title Page (and on the covers, if any) a title distinct
+   from that of the Document, and from those of previous versions
+   (which should, if there were any, be listed in the History section
+   of the Document).  You may use the same title as a previous version
+   if the original publisher of that version gives permission.
+B. List on the Title Page, as authors, one or more persons or entities
+   responsible for authorship of the modifications in the Modified
+   Version, together with at least five of the principal authors of the
+   Document (all of its principal authors, if it has fewer than five),
+   unless they release you from this requirement.
+C. State on the Title page the name of the publisher of the
+   Modified Version, as the publisher.
+D. Preserve all the copyright notices of the Document.
+E. Add an appropriate copyright notice for your modifications
+   adjacent to the other copyright notices.
+F. Include, immediately after the copyright notices, a license notice
+   giving the public permission to use the Modified Version under the
+   terms of this License, in the form shown in the Addendum below.
+G. Preserve in that license notice the full lists of Invariant Sections
+   and required Cover Texts given in the Document's license notice.
+H. Include an unaltered copy of this License.
+I. Preserve the section Entitled \"History\", Preserve its Title, and add
+   to it an item stating at least the title, year, new authors, and
+   publisher of the Modified Version as given on the Title Page.  If
+   there is no section Entitled \"History\" in the Document, create one
+   stating the title, year, authors, and publisher of the Document as
+   given on its Title Page, then add an item describing the Modified
+   Version as stated in the previous sentence.
+J. Preserve the network location, if any, given in the Document for
+   public access to a Transparent copy of the Document, and likewise
+   the network locations given in the Document for previous versions
+   it was based on.  These may be placed in the \"History\" section.
+   You may omit a network location for a work that was published at
+   least four years before the Document itself, or if the original
+   publisher of the version it refers to gives permission.
+K. For any section Entitled \"Acknowledgements\" or \"Dedications\",
+   Preserve the Title of the section, and preserve in the section all
+   the substance and tone of each of the contributor acknowledgements
+   and/or dedications given therein.
+L. Preserve all the Invariant Sections of the Document,
+   unaltered in their text and in their titles.  Section numbers
+   or the equivalent are not considered part of the section titles.
+M. Delete any section Entitled \"Endorsements\".  Such a section
+   may not be included in the Modified Version.
+N. Do not retitle any existing section to be Entitled \"Endorsements\"
+   or to conflict in title with any Invariant Section.
+O. Preserve any Warranty Disclaimers.
+
+If the Modified Version includes new front-matter sections or
+appendices that qualify as Secondary Sections and contain no material
+copied from the Document, you may at your option designate some or all
+of these sections as invariant.  To do this, add their titles to the
+list of Invariant Sections in the Modified Version's license notice.
+These titles must be distinct from any other section titles.
+
+You may add a section Entitled \"Endorsements\", provided it contains
+nothing but endorsements of your Modified Version by various
+parties--for example, statements of peer review or that the text has
+been approved by an organization as the authoritative definition of a
+standard.
+
+You may add a passage of up to five words as a Front-Cover Text, and a
+passage of up to 25 words as a Back-Cover Text, to the end of the list
+of Cover Texts in the Modified Version.  Only one passage of
+Front-Cover Text and one of Back-Cover Text may be added by (or
+through arrangements made by) any one entity.  If the Document already
+includes a cover text for the same cover, previously added by you or
+by arrangement made by the same entity you are acting on behalf of,
+you may not add another; but you may replace the old one, on explicit
+permission from the previous publisher that added the old one.
+
+The author(s) and publisher(s) of the Document do not by this License
+give permission to use their names for publicity for or to assert or
+imply endorsement of any Modified Version.
+
+
+5. COMBINING DOCUMENTS
+
+You may combine the Document with other documents released under this
+License, under the terms defined in section 4 above for modified
+versions, provided that you include in the combination all of the
+Invariant Sections of all of the original documents, unmodified, and
+list them all as Invariant Sections of your combined work in its
+license notice, and that you preserve all their Warranty Disclaimers.
+
+The combined work need only contain one copy of this License, and
+multiple identical Invariant Sections may be replaced with a single
+copy.  If there are multiple Invariant Sections with the same name but
+different contents, make the title of each such section unique by
+adding at the end of it, in parentheses, the name of the original
+author or publisher of that section if known, or else a unique number.
+Make the same adjustment to the section titles in the list of
+Invariant Sections in the license notice of the combined work.
+
+In the combination, you must combine any sections Entitled \"History\"
+in the various original documents, forming one section Entitled
+\"History\"; likewise combine any sections Entitled \"Acknowledgements\",
+and any sections Entitled \"Dedications\".  You must delete all sections
+Entitled \"Endorsements\".
+
+
+6. COLLECTIONS OF DOCUMENTS
+
+You may make a collection consisting of the Document and other
+documents released under this License, and replace the individual
+copies of this License in the various documents with a single copy
+that is included in the collection, provided that you follow the rules
+of this License for verbatim copying of each of the documents in all
+other respects.
+
+You may extract a single document from such a collection, and
+distribute it individually under this License, provided you insert a
+copy of this License into the extracted document, and follow this
+License in all other respects regarding verbatim copying of that
+document.
+
+
+7. AGGREGATION WITH INDEPENDENT WORKS
+
+A compilation of the Document or its derivatives with other separate
+and independent documents or works, in or on a volume of a storage or
+distribution medium, is called an \"aggregate\" if the copyright
+resulting from the compilation is not used to limit the legal rights
+of the compilation's users beyond what the individual works permit.
+When the Document is included in an aggregate, this License does not
+apply to the other works in the aggregate which are not themselves
+derivative works of the Document.
+
+If the Cover Text requirement of section 3 is applicable to these
+copies of the Document, then if the Document is less than one half of
+the entire aggregate, the Document's Cover Texts may be placed on
+covers that bracket the Document within the aggregate, or the
+electronic equivalent of covers if the Document is in electronic form.
+Otherwise they must appear on printed covers that bracket the whole
+aggregate.
+
+
+8. TRANSLATION
+
+Translation is considered a kind of modification, so you may
+distribute translations of the Document under the terms of section 4.
+Replacing Invariant Sections with translations requires special
+permission from their copyright holders, but you may include
+translations of some or all Invariant Sections in addition to the
+original versions of these Invariant Sections.  You may include a
+translation of this License, and all the license notices in the
+Document, and any Warranty Disclaimers, provided that you also include
+the original English version of this License and the original versions
+of those notices and disclaimers.  In case of a disagreement between
+the translation and the original version of this License or a notice
+or disclaimer, the original version will prevail.
+
+If a section in the Document is Entitled \"Acknowledgements\",
+\"Dedications\", or \"History\", the requirement (section 4) to Preserve
+its Title (section 1) will typically require changing the actual
+title.
+
+
+9. TERMINATION
+
+You may not copy, modify, sublicense, or distribute the Document
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense, or distribute it is void, and
+will automatically terminate your rights under this License.
+
+However, if you cease all violation of this License, then your license
+from a particular copyright holder is reinstated (a) provisionally,
+unless and until the copyright holder explicitly and finally
+terminates your license, and (b) permanently, if the copyright holder
+fails to notify you of the violation by some reasonable means prior to
+60 days after the cessation.
+
+Moreover, your license from a particular copyright holder is
+reinstated permanently if the copyright holder notifies you of the
+violation by some reasonable means, this is the first time you have
+received notice of violation of this License (for any work) from that
+copyright holder, and you cure the violation prior to 30 days after
+your receipt of the notice.
+
+Termination of your rights under this section does not terminate the
+licenses of parties who have received copies or rights from you under
+this License.  If your rights have been terminated and not permanently
+reinstated, receipt of a copy of some or all of the same material does
+not give you any rights to use it.
+
+
+10. FUTURE REVISIONS OF THIS LICENSE
+
+The Free Software Foundation may publish new, revised versions of the
+GNU Free Documentation License from time to time.  Such new versions
+will be similar in spirit to the present version, but may differ in
+detail to address new problems or concerns.  See
+http://www.gnu.org/copyleft/.
+
+Each version of the License is given a distinguishing version number.
+If the Document specifies that a particular numbered version of this
+License \"or any later version\" applies to it, you have the option of
+following the terms and conditions either of that specified version or
+of any later version that has been published (not as a draft) by the
+Free Software Foundation.  If the Document does not specify a version
+number of this License, you may choose any version ever published (not
+as a draft) by the Free Software Foundation.  If the Document
+specifies that a proxy can decide which future versions of this
+License can be used, that proxy's public statement of acceptance of a
+version permanently authorizes you to choose that version for the
+Document.
+
+11. RELICENSING
+
+\"Massive Multiauthor Collaboration Site\" (or \"MMC Site\") means any
+World Wide Web server that publishes copyrightable works and also
+provides prominent facilities for anybody to edit those works.  A
+public wiki that anybody can edit is an example of such a server.  A
+\"Massive Multiauthor Collaboration\" (or \"MMC\") contained in the site
+means any set of copyrightable works thus published on the MMC site.
+
+\"CC-BY-SA\" means the Creative Commons Attribution-Share Alike 3.0 
+license published by Creative Commons Corporation, a not-for-profit 
+corporation with a principal place of business in San Francisco, 
+California, as well as future copyleft versions of that license 
+published by that same organization.
+
+\"Incorporate\" means to publish or republish a Document, in whole or in 
+part, as part of another Document.
+
+An MMC is \"eligible for relicensing\" if it is licensed under this 
+License, and if all works that were first published under this License 
+somewhere other than this MMC, and subsequently incorporated in whole or 
+in part into the MMC, (1) had no cover texts or invariant sections, and 
+(2) were thus incorporated prior to November 1, 2008.
+
+The operator of an MMC Site may republish an MMC contained in the site
+under CC-BY-SA on the same site at any time before August 1, 2009,
+provided the MMC is eligible for relicensing.
+
+
+ADDENDUM: How to use this License for your documents
+
+To use this License in a document you have written, include a copy of
+the License in the document and put the following copyright and
+license notices just after the title page:
+
+    Copyright (c)  YEAR  YOUR NAME.
+    Permission is granted to copy, distribute and/or modify this document
+    under the terms of the GNU Free Documentation License, Version 1.3
+    or any later version published by the Free Software Foundation;
+    with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
+    A copy of the license is included in the section entitled \"GNU
+    Free Documentation License\".
+
+If you have Invariant Sections, Front-Cover Texts and Back-Cover Texts,
+replace the \"with...Texts.\" line with this:
+
+    with the Invariant Sections being LIST THEIR TITLES, with the
+    Front-Cover Texts being LIST, and with the Back-Cover Texts being LIST.
+
+If you have Invariant Sections without Cover Texts, or some other
+combination of the three, merge those two alternatives to suit the
+situation.
+
+If your document contains nontrivial examples of program code, we
+recommend releasing these examples in parallel under your choice of
+free software license, such as the GNU General Public License,
+to permit their use in free software.
+" >"$QTROOT/boot/common/data/licenses/FDL v1.3"
+mimeset -f "$QTROOT/boot/common/data/licenses/FDL v1.3"
+
+######################################################################
+# create GNU Free Documentation License file
+######################################################################
+mkdir -p  "$QTROOT/boot/common/data/licenses"
+echo "
+		  GNU LESSER GENERAL PUBLIC LICENSE
+		       Version 2.1, February 1999
+
+ Copyright (C) 1991, 1999 Free Software Foundation, Inc.
+ 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+[This is the first released version of the Lesser GPL.  It also counts
+ as the successor of the GNU Library Public License, version 2, hence
+ the version number 2.1.]
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+Licenses are intended to guarantee your freedom to share and change
+free software--to make sure the software is free for all its users.
+
+  This license, the Lesser General Public License, applies to some
+specially designated software packages--typically libraries--of the
+Free Software Foundation and other authors who decide to use it.  You
+can use it too, but we suggest you first think carefully about whether
+this license or the ordinary General Public License is the better
+strategy to use in any particular case, based on the explanations below.
+
+  When we speak of free software, we are referring to freedom of use,
+not price.  Our General Public Licenses are designed to make sure that
+you have the freedom to distribute copies of free software (and charge
+for this service if you wish); that you receive source code or can get
+it if you want it; that you can change the software and use pieces of
+it in new free programs; and that you are informed that you can do
+these things.
+
+  To protect your rights, we need to make restrictions that forbid
+distributors to deny you these rights or to ask you to surrender these
+rights.  These restrictions translate to certain responsibilities for
+you if you distribute copies of the library or if you modify it.
+
+  For example, if you distribute copies of the library, whether gratis
+or for a fee, you must give the recipients all the rights that we gave
+you.  You must make sure that they, too, receive or can get the source
+code.  If you link other code with the library, you must provide
+complete object files to the recipients, so that they can relink them
+with the library after making changes to the library and recompiling
+it.  And you must show them these terms so they know their rights.
+
+  We protect your rights with a two-step method: (1) we copyright the
+library, and (2) we offer you this license, which gives you legal
+permission to copy, distribute and/or modify the library.
+
+  To protect each distributor, we want to make it very clear that
+there is no warranty for the free library.  Also, if the library is
+modified by someone else and passed on, the recipients should know
+that what they have is not the original version, so that the original
+author's reputation will not be affected by problems that might be
+introduced by others.
+
+  Finally, software patents pose a constant threat to the existence of
+any free program.  We wish to make sure that a company cannot
+effectively restrict the users of a free program by obtaining a
+restrictive license from a patent holder.  Therefore, we insist that
+any patent license obtained for a version of the library must be
+consistent with the full freedom of use specified in this license.
+
+  Most GNU software, including some libraries, is covered by the
+ordinary GNU General Public License.  This license, the GNU Lesser
+General Public License, applies to certain designated libraries, and
+is quite different from the ordinary General Public License.  We use
+this license for certain libraries in order to permit linking those
+libraries into non-free programs.
+
+  When a program is linked with a library, whether statically or using
+a shared library, the combination of the two is legally speaking a
+combined work, a derivative of the original library.  The ordinary
+General Public License therefore permits such linking only if the
+entire combination fits its criteria of freedom.  The Lesser General
+Public License permits more lax criteria for linking other code with
+the library.
+
+  We call this license the \"Lesser\" General Public License because it
+does Less to protect the user's freedom than the ordinary General
+Public License.  It also provides other free software developers Less
+of an advantage over competing non-free programs.  These disadvantages
+are the reason we use the ordinary General Public License for many
+libraries.  However, the Lesser license provides advantages in certain
+special circumstances.
+
+  For example, on rare occasions, there may be a special need to
+encourage the widest possible use of a certain library, so that it becomes
+a de-facto standard.  To achieve this, non-free programs must be
+allowed to use the library.  A more frequent case is that a free
+library does the same job as widely used non-free libraries.  In this
+case, there is little to gain by limiting the free library to free
+software only, so we use the Lesser General Public License.
+
+  In other cases, permission to use a particular library in non-free
+programs enables a greater number of people to use a large body of
+free software.  For example, permission to use the GNU C Library in
+non-free programs enables many more people to use the whole GNU
+operating system, as well as its variant, the GNU/Linux operating
+system.
+
+  Although the Lesser General Public License is Less protective of the
+users' freedom, it does ensure that the user of a program that is
+linked with the Library has the freedom and the wherewithal to run
+that program using a modified version of the Library.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.  Pay close attention to the difference between a
+\"work based on the library\" and a \"work that uses the library\".  The
+former contains code derived from the library, whereas the latter must
+be combined with the library in order to run.
+
+		  GNU LESSER GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License Agreement applies to any software library or other
+program which contains a notice placed by the copyright holder or
+other authorized party saying it may be distributed under the terms of
+this Lesser General Public License (also called \"this License\").
+Each licensee is addressed as \"you\".
+
+  A \"library\" means a collection of software functions and/or data
+prepared so as to be conveniently linked with application programs
+(which use some of those functions and data) to form executables.
+
+  The \"Library\", below, refers to any such software library or work
+which has been distributed under these terms.  A \"work based on the
+Library\" means either the Library or any derivative work under
+copyright law: that is to say, a work containing the Library or a
+portion of it, either verbatim or with modifications and/or translated
+straightforwardly into another language.  (Hereinafter, translation is
+included without limitation in the term \"modification\".)
+
+  \"Source code\" for a work means the preferred form of the work for
+making modifications to it.  For a library, complete source code means
+all the source code for all modules it contains, plus any associated
+interface definition files, plus the scripts used to control compilation
+and installation of the library.
+
+  Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running a program using the Library is not restricted, and output from
+such a program is covered only if its contents constitute a work based
+on the Library (independent of the use of the Library in a tool for
+writing it).  Whether that is true depends on what the Library does
+and what the program that uses the Library does.
+  
+  1. You may copy and distribute verbatim copies of the Library's
+complete source code as you receive it, in any medium, provided that
+you conspicuously and appropriately publish on each copy an
+appropriate copyright notice and disclaimer of warranty; keep intact
+all the notices that refer to this License and to the absence of any
+warranty; and distribute a copy of this License along with the
+Library.
+
+  You may charge a fee for the physical act of transferring a copy,
+and you may at your option offer warranty protection in exchange for a
+fee.
+
+  2. You may modify your copy or copies of the Library or any portion
+of it, thus forming a work based on the Library, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) The modified work must itself be a software library.
+
+    b) You must cause the files modified to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    c) You must cause the whole of the work to be licensed at no
+    charge to all third parties under the terms of this License.
+
+    d) If a facility in the modified Library refers to a function or a
+    table of data to be supplied by an application program that uses
+    the facility, other than as an argument passed when the facility
+    is invoked, then you must make a good faith effort to ensure that,
+    in the event an application does not supply such function or
+    table, the facility still operates, and performs whatever part of
+    its purpose remains meaningful.
+
+    (For example, a function in a library to compute square roots has
+    a purpose that is entirely well-defined independent of the
+    application.  Therefore, Subsection 2d requires that any
+    application-supplied function or table used by this function must
+    be optional: if the application does not supply it, the square
+    root function must still compute square roots.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Library,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Library, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote
+it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Library.
+
+In addition, mere aggregation of another work not based on the Library
+with the Library (or with a work based on the Library) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may opt to apply the terms of the ordinary GNU General Public
+License instead of this License to a given copy of the Library.  To do
+this, you must alter all the notices that refer to this License, so
+that they refer to the ordinary GNU General Public License, version 2,
+instead of to this License.  (If a newer version than version 2 of the
+ordinary GNU General Public License has appeared, then you can specify
+that version instead if you wish.)  Do not make any other change in
+these notices.
+
+  Once this change is made in a given copy, it is irreversible for
+that copy, so the ordinary GNU General Public License applies to all
+subsequent copies and derivative works made from that copy.
+
+  This option is useful when you wish to copy part of the code of
+the Library into a program that is not a library.
+
+  4. You may copy and distribute the Library (or a portion or
+derivative of it, under Section 2) in object code or executable form
+under the terms of Sections 1 and 2 above provided that you accompany
+it with the complete corresponding machine-readable source code, which
+must be distributed under the terms of Sections 1 and 2 above on a
+medium customarily used for software interchange.
+
+  If distribution of object code is made by offering access to copy
+from a designated place, then offering equivalent access to copy the
+source code from the same place satisfies the requirement to
+distribute the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  5. A program that contains no derivative of any portion of the
+Library, but is designed to work with the Library by being compiled or
+linked with it, is called a \"work that uses the Library\".  Such a
+work, in isolation, is not a derivative work of the Library, and
+therefore falls outside the scope of this License.
+
+  However, linking a \"work that uses the Library\" with the Library
+creates an executable that is a derivative of the Library (because it
+contains portions of the Library), rather than a \"work that uses the
+library\".  The executable is therefore covered by this License.
+Section 6 states terms for distribution of such executables.
+
+  When a \"work that uses the Library\" uses material from a header file
+that is part of the Library, the object code for the work may be a
+derivative work of the Library even though the source code is not.
+Whether this is true is especially significant if the work can be
+linked without the Library, or if the work is itself a library.  The
+threshold for this to be true is not precisely defined by law.
+
+  If such an object file uses only numerical parameters, data
+structure layouts and accessors, and small macros and small inline
+functions (ten lines or less in length), then the use of the object
+file is unrestricted, regardless of whether it is legally a derivative
+work.  (Executables containing this object code plus portions of the
+Library will still fall under Section 6.)
+
+  Otherwise, if the work is a derivative of the Library, you may
+distribute the object code for the work under the terms of Section 6.
+Any executables containing that work also fall under Section 6,
+whether or not they are linked directly with the Library itself.
+
+  6. As an exception to the Sections above, you may also combine or
+link a \"work that uses the Library\" with the Library to produce a
+work containing portions of the Library, and distribute that work
+under terms of your choice, provided that the terms permit
+modification of the work for the customer's own use and reverse
+engineering for debugging such modifications.
+
+  You must give prominent notice with each copy of the work that the
+Library is used in it and that the Library and its use are covered by
+this License.  You must supply a copy of this License.  If the work
+during execution displays copyright notices, you must include the
+copyright notice for the Library among them, as well as a reference
+directing the user to the copy of this License.  Also, you must do one
+of these things:
+
+    a) Accompany the work with the complete corresponding
+    machine-readable source code for the Library including whatever
+    changes were used in the work (which must be distributed under
+    Sections 1 and 2 above); and, if the work is an executable linked
+    with the Library, with the complete machine-readable \"work that
+    uses the Library\", as object code and/or source code, so that the
+    user can modify the Library and then relink to produce a modified
+    executable containing the modified Library.  (It is understood
+    that the user who changes the contents of definitions files in the
+    Library will not necessarily be able to recompile the application
+    to use the modified definitions.)
+
+    b) Use a suitable shared library mechanism for linking with the
+    Library.  A suitable mechanism is one that (1) uses at run time a
+    copy of the library already present on the user's computer system,
+    rather than copying library functions into the executable, and (2)
+    will operate properly with a modified version of the library, if
+    the user installs one, as long as the modified version is
+    interface-compatible with the version that the work was made with.
+
+    c) Accompany the work with a written offer, valid for at
+    least three years, to give the same user the materials
+    specified in Subsection 6a, above, for a charge no more
+    than the cost of performing this distribution.
+
+    d) If distribution of the work is made by offering access to copy
+    from a designated place, offer equivalent access to copy the above
+    specified materials from the same place.
+
+    e) Verify that the user has already received a copy of these
+    materials or that you have already sent this user a copy.
+
+  For an executable, the required form of the \"work that uses the
+Library\" must include any data and utility programs needed for
+reproducing the executable from it.  However, as a special exception,
+the materials to be distributed need not include anything that is
+normally distributed (in either source or binary form) with the major
+components (compiler, kernel, and so on) of the operating system on
+which the executable runs, unless that component itself accompanies
+the executable.
+
+  It may happen that this requirement contradicts the license
+restrictions of other proprietary libraries that do not normally
+accompany the operating system.  Such a contradiction means you cannot
+use both them and the Library together in an executable that you
+distribute.
+
+  7. You may place library facilities that are a work based on the
+Library side-by-side in a single library together with other library
+facilities not covered by this License, and distribute such a combined
+library, provided that the separate distribution of the work based on
+the Library and of the other library facilities is otherwise
+permitted, and provided that you do these two things:
+
+    a) Accompany the combined library with a copy of the same work
+    based on the Library, uncombined with any other library
+    facilities.  This must be distributed under the terms of the
+    Sections above.
+
+    b) Give prominent notice with the combined library of the fact
+    that part of it is a work based on the Library, and explaining
+    where to find the accompanying uncombined form of the same work.
+
+  8. You may not copy, modify, sublicense, link with, or distribute
+the Library except as expressly provided under this License.  Any
+attempt otherwise to copy, modify, sublicense, link with, or
+distribute the Library is void, and will automatically terminate your
+rights under this License.  However, parties who have received copies,
+or rights, from you under this License will not have their licenses
+terminated so long as such parties remain in full compliance.
+
+  9. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Library or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Library (or any work based on the
+Library), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Library or works based on it.
+
+  10. Each time you redistribute the Library (or any work based on the
+Library), the recipient automatically receives a license from the
+original licensor to copy, distribute, link with or modify the Library
+subject to these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties with
+this License.
+
+  11. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Library at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Library by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Library.
+
+If any portion of this section is held invalid or unenforceable under any
+particular circumstance, the balance of the section is intended to apply,
+and the section as a whole is intended to apply in other circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  12. If the distribution and/or use of the Library is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Library under this License may add
+an explicit geographical distribution limitation excluding those countries,
+so that distribution is permitted only in or among countries not thus
+excluded.  In such case, this License incorporates the limitation as if
+written in the body of this License.
+
+  13. The Free Software Foundation may publish revised and/or new
+versions of the Lesser General Public License from time to time.
+Such new versions will be similar in spirit to the present version,
+but may differ in detail to address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Library
+specifies a version number of this License which applies to it and
+\"any later version\", you have the option of following the terms and
+conditions either of that version or of any later version published by
+the Free Software Foundation.  If the Library does not specify a
+license version number, you may choose any version ever published by
+the Free Software Foundation.
+
+  14. If you wish to incorporate parts of the Library into other free
+programs whose distribution conditions are incompatible with these,
+write to the author to ask for permission.  For software which is
+copyrighted by the Free Software Foundation, write to the Free
+Software Foundation; we sometimes make exceptions for this.  Our
+decision will be guided by the two goals of preserving the free status
+of all derivatives of our free software and of promoting the sharing
+and reuse of software generally.
+
+			    NO WARRANTY
+
+  15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO
+WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.
+EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR
+OTHER PARTIES PROVIDE THE LIBRARY \"AS IS\" WITHOUT WARRANTY OF ANY
+KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
+LIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME
+THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
+
+  16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
+WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY
+AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU
+FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
+CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
+LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
+RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
+FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
+SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+           How to Apply These Terms to Your New Libraries
+
+  If you develop a new library, and you want it to be of the greatest
+possible use to the public, we recommend making it free software that
+everyone can redistribute and change.  You can do so by permitting
+redistribution under these terms (or, alternatively, under the terms of the
+ordinary General Public License).
+
+  To apply these terms, attach the following notices to the library.  It is
+safest to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least the
+\"copyright\" line and a pointer to where the full notice is found.
+
+    <one line to give the library's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+
+Also add information on how to contact you by electronic and paper mail.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a \"copyright disclaimer\" for the library, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the
+  library 'Frob' (a library for tweaking knobs) written by James Random Hacker.
+
+  <signature of Ty Coon>, 1 April 1990
+  Ty Coon, President of Vice
+
+That's all there is to it!
+" >"$QTROOT/boot/common/data/licenses/LGPL v2.1"
+mimeset -f "$QTROOT/boot/common/data/licenses/LGPL v2.1"
+
+######################################################################
+echo  "Make full pack"
+######################################################################
+cd $QTROOT/boot
+zip -ry9 ../qt_4.7.3_haiku_r1a3_$(date +%d%b%Y)_dev.zip * >/dev/null
+cd ..
+
+######################################################################
+echo "Remove files for minimal pack"
+######################################################################
+echo " documantation"
+rm -rf $QTROOT/boot/common/documentation/doc/Qt
+echo " mkspecs"
+rm -rf $QTROOT/boot/common/data/Qt/mkspecs
+echo " include"
+rm -rf $QTROOT/boot/common/include
+echo " assistant"
+rm -f $QTROOT/boot/common/bin/assistant
+echo " designer"
+rm -f $QTROOT/boot/common/bin/designer
+echo " linguist"
+rm -f $QTROOT/boot/common/bin/linguist
+echo " qhelpconverter"
+rm -f $QTROOT/boot/common/bin/qhelpconverter
+echo " qhelpgenerator"
+rm -f $QTROOT/boot/common/bin/qhelpgenerator
+echo " qt3to4"
+rm -f $QTROOT/boot/common/bin/qt3to4
+echo " pixeltool"
+rm -f $QTROOT/boot/common/bin/pixeltool
+echo " moc"
+rm -f $QTROOT/boot/common/bin/moc
+echo " qmake"
+rm -f $QTROOT/boot/common/bin/qmake
+echo " rcc"
+rm -f $QTROOT/boot/common/bin/rcc
+echo " qdoc3"
+rm -f $QTROOT/boot/common/bin/qdoc3
+echo " rcc"
+rm -f $QTROOT/boot/common/bin/rcc
+echo " uic"
+rm -f $QTROOT/boot/common/bin/uic
+echo " uic3"
+rm -f $QTROOT/boot/common/bin/uic3
+echo " libQtUiTools.a"
+rm -f $QTROOT/boot/common/lib/gcc4/libQtUiTools.a
+echo " *.la"
+rm -f $QTROOT/boot/common/lib/gcc4/*.la
+echo " *.prl"
+rm -f $QTROOT/boot/common/lib/gcc4/*.prl
+
+echo " symlinks from menu"
+rm -f "$QTROOT/boot/home/config/be/Qt/Development/Qt Assistant"
+rm -f "$QTROOT/boot/home/config/be/Qt/Development/Qt Help Conversion Wizard"
+rm -f "$QTROOT/boot/home/config/be/Qt/Development/Qt Designer"
+rm -f "$QTROOT/boot/home/config/be/Qt/Development/Qt Linguist"
+
+######################################################################
+echo  "Make min pack"
+######################################################################
+cd $QTROOT/boot
+zip -ry9 ../qt_4.7.3_haiku_r1a3_$(date +%d%b%Y)_min.zip * >/dev/null
+cd ..
+
+######################################################################
+echo  "Clean sandbox"
+######################################################################
+rm -rf $QTROOT/boot
+
+######################################################################
+echo  "Done"
+######################################################################
+
diff -rupN qt-everywhere-opensource-src-4.7.3/mkspecs/haiku-g++/qmake.conf qt-everywhere-opensource-src-4.7.3_haiku/mkspecs/haiku-g++/qmake.conf
--- qt-everywhere-opensource-src-4.7.3/mkspecs/haiku-g++/qmake.conf	1970-01-01 00:00:00.000000000 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/mkspecs/haiku-g++/qmake.conf	2011-06-13 22:06:43.097255424 +0000
@@ -0,0 +1,37 @@
+#
+# qmake configuration for Haiku-g++
+#
+
+MAKEFILE_GENERATOR	= UNIX
+TARGET_PLATFORM	= haiku
+TEMPLATE		= app
+CONFIG			+= qt warn_on release link_prl
+QT			+= core gui
+
+QMAKE_LIBS		= -lroot
+QMAKE_INCDIR          =
+QMAKE_LIBDIR          =
+QMAKE_INCDIR_QT       = $$[QT_INSTALL_HEADERS]
+QMAKE_LIBDIR_QT       = $$[QT_INSTALL_LIBS]
+QMAKE_LIBS_NETWORK	= -lnetwork
+
+QMAKE_MOC		= $$[QT_INSTALL_BINS]/moc
+QMAKE_UIC		= $$[QT_INSTALL_BINS]/uic
+
+QMAKE_AR		= ar cqs
+QMAKE_OBJCOPY           = objcopy
+QMAKE_RANLIB		=
+
+QMAKE_TAR		= tar -cf
+QMAKE_GZIP		= gzip -9f
+
+QMAKE_COPY		= cp -f
+QMAKE_MOVE		= mv -f
+QMAKE_DEL_FILE		= rm -f
+QMAKE_DEL_DIR		= rmdir
+QMAKE_CHK_DIR_EXISTS	= test -d
+QMAKE_MKDIR		= mkdir -p
+
+include(../common/g++.conf)
+include(../common/unix.conf)
+load(qt_config)
diff -rupN qt-everywhere-opensource-src-4.7.3/mkspecs/haiku-g++/qplatformdefs.h qt-everywhere-opensource-src-4.7.3_haiku/mkspecs/haiku-g++/qplatformdefs.h
--- qt-everywhere-opensource-src-4.7.3/mkspecs/haiku-g++/qplatformdefs.h	1970-01-01 00:00:00.000000000 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/mkspecs/haiku-g++/qplatformdefs.h	2011-06-13 22:06:43.106168320 +0000
@@ -0,0 +1,43 @@
+#ifndef QPLATFORMDEFS_H
+#define QPLATFORMDEFS_H
+
+// Get Qt defines/settings
+
+#include "qglobal.h"
+
+// Set any POSIX/XOPEN defines at the top of this file to turn on specific APIs
+
+#include <unistd.h>
+
+
+// We are hot - unistd.h should have turned on the specific APIs we requested
+
+#include <pthread.h>
+#include <dirent.h>
+#include <fcntl.h>
+#include <grp.h>
+#include <pwd.h>
+#include <signal.h>
+#include <dlfcn.h>
+
+#include <sys/types.h>
+#include <sys/ioctl.h>
+#include <sys/ipc.h>
+#include <sys/time.h>
+//#include <sys/shm.h>
+#include <sys/socket.h>
+#include <sys/stat.h>
+#include <sys/wait.h>
+#include <netinet/in.h>
+#ifndef QT_NO_IPV6IFNAME
+#include <net/if.h>
+#endif
+
+#include "../common/posix/qplatformdefs.h"
+
+#define QT_SOCKLEN_T		socklen_t
+
+#define QT_SNPRINTF		::snprintf
+#define QT_VSNPRINTF		::vsnprintf
+
+#endif // QPLATFORMDEFS_H
diff -rupN qt-everywhere-opensource-src-4.7.3/qmake/generators/makefile.cpp qt-everywhere-opensource-src-4.7.3_haiku/qmake/generators/makefile.cpp
--- qt-everywhere-opensource-src-4.7.3/qmake/generators/makefile.cpp	2011-03-30 05:15:42.028835840 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/qmake/generators/makefile.cpp	2011-06-13 22:06:43.110624768 +0000
@@ -2202,6 +2202,8 @@ QString MakefileGenerator::buildArgs(con
             ret += " -unix";
         else if (Option::target_mode == Option::TARG_WIN_MODE)
             ret += " -win32";
+        else if(Option::target_mode == Option::TARG_HAIKU_MODE)
+            ret += " -haiku";            
     }
 
     //configs
diff -rupN qt-everywhere-opensource-src-4.7.3/qmake/generators/metamakefile.cpp qt-everywhere-opensource-src-4.7.3_haiku/qmake/generators/metamakefile.cpp
--- qt-everywhere-opensource-src-4.7.3/qmake/generators/metamakefile.cpp	2011-03-30 05:15:42.022806528 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/qmake/generators/metamakefile.cpp	2011-06-13 22:06:43.112721920 +0000
@@ -525,6 +525,9 @@ MetaMakefileGenerator::modesForGenerator
 #ifdef Q_OS_MAC
         *host_mode = Option::HOST_MACX_MODE;
         *target_mode = Option::TARG_MACX_MODE;
+#elif defined(Q_OS_HAIKU)
+        *host_mode = Option::HOST_HAIKU_MODE;
+        *target_mode = Option::TARG_HAIKU_MODE;        
 #else
         *host_mode = Option::HOST_UNIX_MODE;
         *target_mode = Option::TARG_UNIX_MODE;
diff -rupN qt-everywhere-opensource-src-4.7.3/qmake/generators/unix/unixmake.cpp qt-everywhere-opensource-src-4.7.3_haiku/qmake/generators/unix/unixmake.cpp
--- qt-everywhere-opensource-src-4.7.3/qmake/generators/unix/unixmake.cpp	2011-03-30 05:15:42.025427968 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/qmake/generators/unix/unixmake.cpp	2011-06-13 22:06:43.115343360 +0000
@@ -811,6 +811,7 @@ UnixMakefileGenerator::defaultInstall(co
         if(!links.isEmpty()) {
             for(int i = 0; i < links.size(); ++i) {
                 if(Option::target_mode == Option::TARG_UNIX_MODE ||
+                   Option::target_mode == Option::TARG_HAIKU_MODE ||
                    Option::target_mode == Option::TARG_MACX_MODE) {
                     QString link = Option::fixPathToTargetOS(destdir + links[i], false);
                     int lslash = link.lastIndexOf(Option::dir_sep);
diff -rupN qt-everywhere-opensource-src-4.7.3/qmake/option.cpp qt-everywhere-opensource-src-4.7.3_haiku/qmake/option.cpp
--- qt-everywhere-opensource-src-4.7.3/qmake/option.cpp	2011-03-30 05:15:42.029360128 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/qmake/option.cpp	2011-06-13 22:06:43.117702656 +0000
@@ -260,6 +260,11 @@ Option::parseCommandLine(int argc, char 
                 Option::host_mode = HOST_WIN_MODE;
                 Option::target_mode = TARG_WIN_MODE;
                 Option::target_mode_overridden = true;
+            } else if(opt == "haiku") {
+                fprintf(stderr, "-haiku is deprecated.\n");
+                Option::host_mode = HOST_HAIKU_MODE;
+                Option::target_mode = TARG_HAIKU_MODE;
+                Option::target_mode_overridden = true;                
             } else if(opt == "d") {
                 Option::debug_level++;
             } else if(opt == "version" || opt == "v" || opt == "-version") {
@@ -535,6 +540,9 @@ Option::init(int argc, char **argv)
 #if defined(Q_OS_MAC)
         Option::host_mode = Option::HOST_MACX_MODE;
         Option::target_mode = Option::TARG_MACX_MODE;
+#elif defined(Q_OS_HAIKU)
+        Option::host_mode = Option::HOST_HAIKU_MODE;
+        Option::target_mode = Option::TARG_HAIKU_MODE;        
 #elif defined(Q_OS_UNIX)
         Option::host_mode = Option::HOST_UNIX_MODE;
         Option::target_mode = Option::TARG_UNIX_MODE;
diff -rupN qt-everywhere-opensource-src-4.7.3/qmake/option.h qt-everywhere-opensource-src-4.7.3_haiku/qmake/option.h
--- qt-everywhere-opensource-src-4.7.3/qmake/option.h	2011-03-30 05:15:42.030146560 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/qmake/option.h	2011-06-13 22:06:43.119799808 +0000
@@ -153,10 +153,10 @@ struct Option
     enum QMAKE_RECURSIVE { QMAKE_RECURSIVE_DEFAULT, QMAKE_RECURSIVE_YES, QMAKE_RECURSIVE_NO };
     static QMAKE_RECURSIVE recursive;
     static QStringList before_user_vars, after_user_vars, user_configs, after_user_configs;
-    enum HOST_MODE { HOST_UNKNOWN_MODE, HOST_UNIX_MODE, HOST_WIN_MODE, HOST_MACX_MODE };
+    enum HOST_MODE { HOST_UNKNOWN_MODE, HOST_UNIX_MODE, HOST_WIN_MODE, HOST_MACX_MODE, HOST_HAIKU_MODE };
     static HOST_MODE host_mode;
     enum TARG_MODE { TARG_UNKNOWN_MODE, TARG_UNIX_MODE, TARG_WIN_MODE, TARG_MACX_MODE,
-                     TARG_SYMBIAN_MODE };
+                     TARG_SYMBIAN_MODE, TARG_HAIKU_MODE };
     static TARG_MODE target_mode;
     static bool target_mode_overridden;
     static QString user_template, user_template_prefix;
diff -rupN qt-everywhere-opensource-src-4.7.3/qmake/project.cpp qt-everywhere-opensource-src-4.7.3_haiku/qmake/project.cpp
--- qt-everywhere-opensource-src-4.7.3/qmake/project.cpp	2011-03-30 05:15:42.030408704 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/qmake/project.cpp	2011-06-13 22:06:43.123994112 +0000
@@ -541,6 +541,10 @@ QStringList qmake_feature_paths(QMakePro
         case Option::TARG_UNIX_MODE:
             concat << base_concat + QDir::separator() + "unix";
             break;
+        case Option::TARG_HAIKU_MODE:
+            concat << base_concat + QDir::separator() + "haiku";
+            concat << base_concat + QDir::separator() + "unix";
+            break;            
         case Option::TARG_WIN_MODE:
             concat << base_concat + QDir::separator() + "win32";
             break;
@@ -1505,6 +1509,8 @@ void QMakeProject::validateModes()
                     const QString &os = tgt.first();
                     if (os == "unix")
                         Option::target_mode = Option::TARG_UNIX_MODE;
+                    else if (os == "haiku")
+                        Option::target_mode = Option::TARG_HAIKU_MODE;                        
                     else if (os == "macx")
                         Option::target_mode = Option::TARG_MACX_MODE;
                     else if (os == "symbian")
@@ -1538,6 +1544,7 @@ QMakeProject::isActiveConfig(const QStri
         validateModes();
         return Option::target_mode == Option::TARG_UNIX_MODE
                || Option::target_mode == Option::TARG_MACX_MODE
+               || Option::target_mode == Option::TARG_HAIKU_MODE
                || Option::target_mode == Option::TARG_SYMBIAN_MODE;
     } else if (x == "macx" || x == "mac") {
         validateModes();
@@ -1548,6 +1555,9 @@ QMakeProject::isActiveConfig(const QStri
     } else if (x == "win32") {
         validateModes();
         return Option::target_mode == Option::TARG_WIN_MODE;
+    } else if (x == "haiku") {
+        validateModes();
+        return Option::target_mode == Option::TARG_HAIKU_MODE;        
     }
 
     //mkspecs
diff -rupN qt-everywhere-opensource-src-4.7.3/src/3rdparty/clucene/src/CLucene/config/compiler.h qt-everywhere-opensource-src-4.7.3_haiku/src/3rdparty/clucene/src/CLucene/config/compiler.h
--- qt-everywhere-opensource-src-4.7.3/src/3rdparty/clucene/src/CLucene/config/compiler.h	2011-03-30 05:18:56.033030144 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/3rdparty/clucene/src/CLucene/config/compiler.h	2011-06-13 22:06:43.126091264 +0000
@@ -65,7 +65,7 @@
 ////////////////////////////////////////////////////////////////////
 
 /* Operating system recognition (basic) */
-#if defined (__unix) || defined (__linux__) || defined (__QNX__) || defined (_AIX) || defined (__NetBSD__) || defined (__OpenBSD__) || defined (__Lynx__) || defined(hpux) || defined(__hpux)
+#if defined (__unix) || defined (__linux__) || defined (__QNX__) || defined (_AIX) || defined (__NetBSD__) || defined (__OpenBSD__) || defined (__Lynx__) || defined(hpux) || defined(__hpux) || defined (__HAIKU__)
 #undef  _UNIX
 #define _UNIX 1
 #include "CLucene/config/PlatformUnix.h"
diff -rupN qt-everywhere-opensource-src-4.7.3/src/3rdparty/haiku-tools/qsystray/Makefile qt-everywhere-opensource-src-4.7.3_haiku/src/3rdparty/haiku-tools/qsystray/Makefile
--- qt-everywhere-opensource-src-4.7.3/src/3rdparty/haiku-tools/qsystray/Makefile	1970-01-01 00:00:00.000000000 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/3rdparty/haiku-tools/qsystray/Makefile	2011-06-13 22:06:43.127926272 +0000
@@ -0,0 +1,25 @@
+all: clean qsystray qsystray_gcc2
+
+qsystray: 
+		setgcc gcc4
+		sleep 1
+		make -f Makefile.gcc4
+
+qsystray_gcc2: 
+		setgcc gcc2
+		sleep 1
+		make -f Makefile.gcc2
+		setgcc gcc4
+		sleep 1
+		
+clean:
+		make -f Makefile.gcc4 clean
+		make -f Makefile.gcc2 clean
+
+install:
+		make -f Makefile.gcc4 install
+		make -f Makefile.gcc2 install
+
+		make -f Makefile.gcc4 clean
+		make -f Makefile.gcc2 clean
+
diff -rupN qt-everywhere-opensource-src-4.7.3/src/3rdparty/haiku-tools/qsystray/Makefile.gcc2 qt-everywhere-opensource-src-4.7.3_haiku/src/3rdparty/haiku-tools/qsystray/Makefile.gcc2
--- qt-everywhere-opensource-src-4.7.3/src/3rdparty/haiku-tools/qsystray/Makefile.gcc2	1970-01-01 00:00:00.000000000 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/3rdparty/haiku-tools/qsystray/Makefile.gcc2	2011-06-13 22:06:43.142082048 +0000
@@ -0,0 +1,24 @@
+CC=g++
+SIGNATURE="application/x-vnd.QtSystrayManager_gcc2"
+
+all: qsystray
+
+qsystray: qsystray_gcc2.o
+		$(CC) -g qsystray_gcc2.o -ltracker -lroot -lbe -oqsystray_gcc2
+		rc qsystray_gcc2.rdef
+		xres -o ./qsystray_gcc2 qsystray_gcc2.rsrc
+		mimeset -f ./qsystray_gcc2
+
+qsystray_gcc2.o:
+		$(CC) -g -oqsystray_gcc2.o -DGCC2BUILD=1 -DAPP_SIGNATURE="\"$(SIGNATURE)\"" -c qsystray.cpp
+
+clean:
+		rm -f ./qsystray_gcc2.o
+		rm -f ./qsystray_gcc2.rsrc
+		rm -f ./qsystray_gcc2
+		
+install:
+		cp -f ./qsystray_gcc2 /boot/common/bin/qsystray_gcc2
+		rm -f ./qsystray_gcc2.o
+		rm -f ./qsystray_gcc2.rsrc
+		rm -f ./qsystray_gcc2
diff -rupN qt-everywhere-opensource-src-4.7.3/src/3rdparty/haiku-tools/qsystray/Makefile.gcc4 qt-everywhere-opensource-src-4.7.3_haiku/src/3rdparty/haiku-tools/qsystray/Makefile.gcc4
--- qt-everywhere-opensource-src-4.7.3/src/3rdparty/haiku-tools/qsystray/Makefile.gcc4	1970-01-01 00:00:00.000000000 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/3rdparty/haiku-tools/qsystray/Makefile.gcc4	2011-06-13 22:06:43.143392768 +0000
@@ -0,0 +1,24 @@
+CC=g++
+SIGNATURE="application/x-vnd.QtSystrayManager_gcc4"
+
+all: qsystray
+
+qsystray: qsystray_gcc4.o
+		$(CC) -g qsystray_gcc4.o -ltracker -lroot -lbe -oqsystray
+		rc qsystray_gcc4.rdef
+		xres -o ./qsystray qsystray_gcc4.rsrc
+		mimeset -f ./qsystray
+
+qsystray_gcc4.o:
+		$(CC) -g -oqsystray_gcc4.o -DGCC4BUILD=1 -DAPP_SIGNATURE="\"$(SIGNATURE)\"" -c qsystray.cpp
+
+clean:
+		rm -f ./qsystray_gcc4.o
+		rm -f ./qsystray_gcc4.rsrc
+		rm -f ./qsystray
+
+install:
+		cp -f ./qsystray /boot/common/bin/qsystray
+		rm -f ./qsystray_gcc4.o
+		rm -f ./qsystray_gcc4.rsrc
+		rm -f ./qsystray
diff -rupN qt-everywhere-opensource-src-4.7.3/src/3rdparty/haiku-tools/qsystray/qsystray.cpp qt-everywhere-opensource-src-4.7.3_haiku/src/3rdparty/haiku-tools/qsystray/qsystray.cpp
--- qt-everywhere-opensource-src-4.7.3/src/3rdparty/haiku-tools/qsystray/qsystray.cpp	1970-01-01 00:00:00.000000000 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/3rdparty/haiku-tools/qsystray/qsystray.cpp	2011-06-13 22:06:43.145489920 +0000
@@ -0,0 +1,303 @@
+#include <OS.h>
+
+#include <Application.h>
+#include <Window.h>
+#include <Deskbar.h>
+#include <View.h>
+#include <Roster.h>
+#include <Point.h>
+#include <Resources.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+
+#include "qsystray.h"
+
+#ifndef APP_SIGNATURE
+#define APP_SIGNATURE	"application/x-vnd.QtSystrayManager"
+#endif
+
+#define REPL_NAME		"QtTrayItem"
+#define DBAR_SIGNATURE 	"application/x-vnd.Be-TSKB"
+
+
+DeskbarView::DeskbarView(team_id tid) : BView(BRect(0,0,15,15), REPL_NAME,B_FOLLOW_NONE,B_WILL_DRAW)
+{
+	id = -1;
+	team = tid;
+	ticks = 0;
+	icon = NULL;
+	traysysobject = NULL;
+	lastButtons = 0;
+}
+
+DeskbarView::DeskbarView(BMessage *message) : BView(message)
+{
+	const void* data;
+	ssize_t numBytes;
+	message->FindData("color",B_ANY_TYPE,&data,&numBytes);	
+	color = *((rgb_color*)data);
+	message->FindData("team",B_ANY_TYPE,&data,&numBytes);
+	team = *((team_id*)data);
+	id = -1;
+	ticks = 0;
+	icon = NULL;
+	traysysobject = NULL;	
+	lastButtons = 0;
+}
+
+DeskbarView *DeskbarView::Instantiate(BMessage *data) {
+	if (!validate_instantiation(data, REPL_NAME)) return NULL;
+	return new DeskbarView(data);
+}
+
+status_t DeskbarView::Archive(BMessage *data, bool deep) const {
+	BView::Archive(data, deep);
+	data->AddString("add_on", APP_SIGNATURE);
+	data->AddString("class", REPL_NAME);
+	
+	data->AddData("color",B_ANY_TYPE,&color,sizeof(rgb_color));
+	data->AddData("team",B_ANY_TYPE,&team,sizeof(team_id));
+	return B_OK;
+}		
+
+void DeskbarView::AttachedToWindow()
+{
+	ticks = 0;	
+	BMessage* tickMsg = new BMessage('LIVE');
+	BMessageRunner *runner = new BMessageRunner( this, tickMsg, 1000000 );
+	color = Parent()->ViewColor();	
+	BView::AttachedToWindow();
+}
+
+void DeskbarView::Draw(BRect r)
+{
+	SetDrawingMode(B_OP_COPY);
+	SetHighColor(Parent()->ViewColor());
+	FillRect(Bounds());
+	if(ticks>3 && !icon) {
+		SetHighColor(32,32,32,100);			
+		SetDrawingMode(B_OP_ALPHA);
+		DrawChar('?',BPoint(4,12));
+	}
+	if(icon) {
+		float dx = (Bounds().Width() - icon->Bounds().Width())/2;
+		float dy = (Bounds().Height() - icon->Bounds().Height())/2;
+		SetDrawingMode(B_OP_ALPHA);		
+		DrawBitmap(icon,BPoint(dx,dy));
+	}
+}
+
+void DeskbarView::MouseMoved(BPoint point, uint32 transit,const BMessage *message)
+{
+}
+
+void DeskbarView::MouseUp(BPoint point)
+{
+   uint32 buttons = lastButtons;
+   
+   BMessage *mes = new BMessage('TRAY');
+   mes->AddInt32("event",TRAY_MOUSEUP);
+   mes->AddPoint("point",ConvertToScreen(point));
+   mes->AddInt32("buttons",buttons);
+   mes->AddInt32("clicks",1);
+   mes->AddData("qtrayobject",B_ANY_TYPE,&traysysobject,sizeof(void*));
+   ReplyMessenger.SendMessage(mes);
+   
+}
+
+void DeskbarView::MouseDown(BPoint point)
+{
+   uint32 buttons = Window()->CurrentMessage()->FindInt32("buttons");
+   int32 clicks = Window()->CurrentMessage()->FindInt32("clicks");
+   lastButtons = buttons;
+   
+   BMessage *mes = new BMessage('TRAY');
+   mes->AddInt32("event",TRAY_MOUSEDOWN);
+   mes->AddPoint("point",ConvertToScreen(point));
+   mes->AddInt32("buttons",buttons);
+   mes->AddInt32("clicks",clicks);
+   mes->AddData("qtrayobject",B_ANY_TYPE,&traysysobject,sizeof(void*));
+   ReplyMessenger.SendMessage(mes);
+   
+}
+
+void DeskbarView::MessageReceived(BMessage *message) {
+//	message->PrintToStream();
+	switch (message->what)
+	{
+		case 'LIVE':
+			{
+				ticks++;				
+				Invalidate();
+				team_info teamInfo;
+				status_t error = get_team_info(team, &teamInfo);
+				if (error != B_OK && id>0) {
+					BDeskbar deskbar;
+					deskbar.RemoveItem(id);
+				} else {
+					BMessage *mes=new BMessage(*message);
+					mes->AddRect("rect",ConvertToScreen(Bounds()));
+					ReplyMessenger.SendMessage(mes);
+				}
+				break;
+			}
+		case B_SET_PROPERTY:
+			{
+				switch( message->FindInt32("what2") ) {
+					case 'TTIP':
+						{							
+							const char *tip=NULL;
+							status_t res = message->FindString("tooltip",&tip);
+							
+							if(!tip || res!=B_OK)
+								tip = applicationName.String();
+							if(strlen(tip)==0)
+								tip = applicationName.String();													
+							if(strlen(tip)!=0)		
+								SetToolTip(tip);
+								
+							break;
+						}					
+					case 'BITS':
+						{
+							BBitmap *oldicon=icon;
+							icon=NULL;
+							delete oldicon;
+							BMessage bits;
+							message->FindMessage("icon", &bits);
+							icon = new BBitmap(&bits);
+							bits.MakeEmpty();
+							Invalidate();
+							break;
+						}
+					case '_ID_':
+						{
+							message->FindInt32("ReplicantID",&id);
+							break;
+						}
+					case 'MSGR':
+						{
+							ssize_t numBytes;
+							const char *name=NULL;
+							message->FindMessenger("messenger", &ReplyMessenger);
+							message->FindData("qtrayobject",B_ANY_TYPE,&traysysobject,&numBytes);
+							if(message->FindString("application_name",&name)==B_OK)
+								applicationName.SetTo(name);
+							break;
+						}
+				}
+			}
+			break;		
+		default:
+			BView::MessageReceived(message);
+			break;
+	}
+}
+
+DeskbarView::~DeskbarView()
+{
+ 
+}
+
+BMessenger GetMessenger(void)
+{
+	BMessenger aResult;
+	status_t aErr = B_OK;
+	BMessenger aDeskbar(DBAR_SIGNATURE, -1, &aErr);
+	if (aErr != B_OK)return aResult;
+
+	BMessage aMessage(B_GET_PROPERTY);
+	
+	aMessage.AddSpecifier("Messenger");
+	aMessage.AddSpecifier("Shelf");
+	aMessage.AddSpecifier("View", "Status");
+	aMessage.AddSpecifier("Window", "Deskbar");
+	
+	BMessage aReply;
+
+	if (aDeskbar.SendMessage(&aMessage, &aReply, 1000000, 1000000) == B_OK)
+		aReply.FindMessenger("result", &aResult);
+	return aResult;
+}
+
+
+status_t SendMessageToReplicant(int32 index, BMessage *msg)
+{
+	BMessage aReply;
+	status_t aErr = B_OK;
+	
+	msg->AddInt32( "what2", msg->what );
+	msg->what = B_SET_PROPERTY;
+
+	BMessage	uid_specifier(B_ID_SPECIFIER);
+	
+	msg->AddSpecifier("View");
+	uid_specifier.AddInt32("id", index);
+	uid_specifier.AddString("property", "Replicant");
+	msg->AddSpecifier(&uid_specifier);
+		
+	aErr = GetMessenger().SendMessage( msg, (BHandler*)NULL, 1000000 );
+	return aErr;
+}
+
+int32 LoadIcon(team_id tid)
+{
+	BDeskbar deskbar;
+	int32 id=-1;
+
+	deskbar.AddItem(new DeskbarView(tid),&id);
+	
+	if(id>0) {
+		BMessage msg('_ID_');
+		msg.AddInt32("ReplicantID",id);
+		SendMessageToReplicant(id,&msg);
+	}
+	
+	return id;	
+}
+
+int32 LoadIcon(void)
+{
+	thread_info threadInfo;
+	status_t error = get_thread_info(find_thread(NULL), &threadInfo);
+	if (error != B_OK) {
+		return 0;
+	}
+	team_id sTeam = threadInfo.team;
+	
+	return LoadIcon(sTeam);
+}
+
+void RemoveIcon(int32 id)
+{
+	BDeskbar deskbar;
+	deskbar.RemoveItem(id);
+}
+
+int main(int argc, char *argv[])
+{
+	BApplication(APP_SIGNATURE);
+	
+	if(argc<2) {
+#ifdef GCC4BUILD
+		printf("QtSystrayManager for Haiku v0.1\n\tqsystray [team_id]\n\n");
+#else		
+		printf("QtSystrayManager for Haiku v0.1 (gcc2 loader)\n\tqsystray_gcc2 [team_id]\n\n");
+#endif
+		exit(0);
+	}
+
+	int32 team_id = atoi(argv[1]);
+	int32 id = LoadIcon(team_id);
+#ifdef GCC4BUILD
+	if(id<=0) {
+		char cmd[128];
+		sprintf(cmd,"qsystray_gcc2 %d",team_id);
+		return system(cmd);
+	}		
+#endif	
+	printf("%d\n",id);
+	
+	return id;
+}
diff -rupN qt-everywhere-opensource-src-4.7.3/src/3rdparty/haiku-tools/qsystray/qsystray.h qt-everywhere-opensource-src-4.7.3_haiku/src/3rdparty/haiku-tools/qsystray/qsystray.h
--- qt-everywhere-opensource-src-4.7.3/src/3rdparty/haiku-tools/qsystray/qsystray.h	1970-01-01 00:00:00.000000000 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/3rdparty/haiku-tools/qsystray/qsystray.h	2011-06-13 22:06:43.147324928 +0000
@@ -0,0 +1,45 @@
+#ifndef DESKBARVIEW_H
+#define DESKBARVIEW_H
+
+#include <OS.h>
+#include <app/MessageRunner.h>
+#include <View.h>
+#include <PopUpMenu.h>
+#include <MenuItem.h>
+#include <Message.h>
+#include <Bitmap.h>
+#include <String.h>
+
+#define TRAY_MOUSEDOWN 	1
+#define TRAY_MOUSEUP	2
+
+class DeskbarView : public BView {
+	public:
+		DeskbarView(team_id tid);
+		~DeskbarView();
+		void MouseDown(BPoint point);
+		void MouseUp(BPoint point);
+		void MouseMoved(BPoint point, uint32 transit,const BMessage *message);
+		void Draw(BRect r);
+		void MessageReceived(BMessage *message);
+		void AttachedToWindow();
+		DeskbarView(BMessage *message);
+		static DeskbarView *Instantiate(BMessage *data);	
+		virtual	status_t Archive(BMessage *data, bool deep = true) const;
+
+	private:
+		BPopUpMenu		*RightClickPopUp;
+		BBitmap			*fBitmap;
+		int32			lastButtons;		
+		entry_ref		appref;
+		rgb_color		color;
+		team_id			team;
+		int32			id;
+		unsigned int	ticks;
+		BBitmap			*icon;
+		BMessenger 		ReplyMessenger;		
+		const void 		*traysysobject;
+		BString			applicationName;
+};
+
+#endif
diff -rupN qt-everywhere-opensource-src-4.7.3/src/3rdparty/haiku-tools/qsystray/qsystray_gcc2.rdef qt-everywhere-opensource-src-4.7.3_haiku/src/3rdparty/haiku-tools/qsystray/qsystray_gcc2.rdef
--- qt-everywhere-opensource-src-4.7.3/src/3rdparty/haiku-tools/qsystray/qsystray_gcc2.rdef	1970-01-01 00:00:00.000000000 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/3rdparty/haiku-tools/qsystray/qsystray_gcc2.rdef	2011-06-13 22:06:43.148897792 +0000
@@ -0,0 +1,13 @@
+resource app_signature "application/x-vnd.QtSystrayManager_gcc2";
+
+resource app_flags B_MULTIPLE_LAUNCH | B_BACKGROUND_APP;
+
+resource app_version {
+	major  = 0,
+	middle = 1,
+	minor  = 0,
+	variety = 0,
+	internal = 0,
+	short_info = "QtSystrayManager",
+	long_info  = "QtSystrayManager (gcc2 loader)"
+};
diff -rupN qt-everywhere-opensource-src-4.7.3/src/3rdparty/haiku-tools/qsystray/qsystray_gcc4.rdef qt-everywhere-opensource-src-4.7.3_haiku/src/3rdparty/haiku-tools/qsystray/qsystray_gcc4.rdef
--- qt-everywhere-opensource-src-4.7.3/src/3rdparty/haiku-tools/qsystray/qsystray_gcc4.rdef	1970-01-01 00:00:00.000000000 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/3rdparty/haiku-tools/qsystray/qsystray_gcc4.rdef	2011-06-13 22:06:43.150208512 +0000
@@ -0,0 +1,13 @@
+resource app_signature "application/x-vnd.QtSystrayManager_gcc4";
+
+resource app_flags B_MULTIPLE_LAUNCH | B_BACKGROUND_APP;
+
+resource app_version {
+	major  = 0,
+	middle = 1,
+	minor  = 0,
+	variety = 0,
+	internal = 0,
+	short_info = "QtSystrayManager",
+	long_info  = "QtSystrayManager"
+};
diff -rupN qt-everywhere-opensource-src-4.7.3/src/3rdparty/webkit/JavaScriptCore/wtf/MathExtras.h qt-everywhere-opensource-src-4.7.3_haiku/src/3rdparty/webkit/JavaScriptCore/wtf/MathExtras.h
--- qt-everywhere-opensource-src-4.7.3/src/3rdparty/webkit/JavaScriptCore/wtf/MathExtras.h	2011-03-30 05:18:55.028573696 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/3rdparty/webkit/JavaScriptCore/wtf/MathExtras.h	2011-06-13 22:06:43.152043520 +0000
@@ -190,7 +190,7 @@ inline float deg2turn(float d) { return 
 inline float rad2grad(float r) { return r * 200.0f / piFloat; }
 inline float grad2rad(float g) { return g * piFloat / 200.0f; }
 
-#if !COMPILER(MSVC) && !COMPILER(RVCT) && !OS(ANDROID) && !COMPILER(WINSCW)
+#if !COMPILER(MSVC) && !COMPILER(RVCT) && !OS(ANDROID) && !COMPILER(WINSCW) && !OS(HAIKU)
 using std::isfinite;
 using std::isinf;
 using std::isnan;
diff -rupN qt-everywhere-opensource-src-4.7.3/src/3rdparty/webkit/WebCore/WebCore.pri qt-everywhere-opensource-src-4.7.3_haiku/src/3rdparty/webkit/WebCore/WebCore.pri
--- qt-everywhere-opensource-src-4.7.3/src/3rdparty/webkit/WebCore/WebCore.pri	2011-03-30 05:18:48.014155776 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/3rdparty/webkit/WebCore/WebCore.pri	2011-06-13 22:06:43.154927104 +0000
@@ -86,7 +86,7 @@ greaterThan(QT_MINOR_VERSION, 5) {
 
 # Nescape plugins support (NPAPI)
 !contains(DEFINES, ENABLE_NETSCAPE_PLUGIN_API=.) {
-    unix|win32-*:!embedded:!wince*: {
+    unix|win32-*:!embedded:!wince*:!haiku: {
         DEFINES += ENABLE_NETSCAPE_PLUGIN_API=1
     } else {
         DEFINES += ENABLE_NETSCAPE_PLUGIN_API=0
diff -rupN qt-everywhere-opensource-src-4.7.3/src/3rdparty/webkit/WebCore/websockets/WebSocketHandshake.cpp qt-everywhere-opensource-src-4.7.3_haiku/src/3rdparty/webkit/WebCore/websockets/WebSocketHandshake.cpp
--- qt-everywhere-opensource-src-4.7.3/src/3rdparty/webkit/WebCore/websockets/WebSocketHandshake.cpp	2011-03-30 05:18:51.049545216 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/3rdparty/webkit/WebCore/websockets/WebSocketHandshake.cpp	2011-06-13 22:06:43.157548544 +0000
@@ -54,6 +54,29 @@ const char webSocketServerHandshakeHeade
 const char webSocketUpgradeHeader[] = "Upgrade: WebSocket\r\n";
 const char webSocketConnectionHeader[] = "Connection: Upgrade\r\n";
 
+#if !defined(strnstr) && defined(__HAIKU__)
+static char *
+strnstr(const char *s, const char *find, size_t slen)
+{
+	char c, sc;
+	size_t len;
+
+	if ((c = *find++) != '\0') {
+		len = strlen(find);
+		do {
+			do {
+				if (slen-- < 1 || (sc = *s++) == '\0')
+					return (NULL);
+			} while (sc != c);
+			if (len > slen)
+				return (NULL);
+		} while (strncmp(s, find, len) != 0);
+		s--;
+	}
+	return ((char *)s);
+}
+#endif
+
 static String extractResponseCode(const char* header, int len)
 {
     const char* space1 = 0;
diff -rupN qt-everywhere-opensource-src-4.7.3/src/3rdparty/webkit/include/QtWebKit/libdummy.prl qt-everywhere-opensource-src-4.7.3_haiku/src/3rdparty/webkit/include/QtWebKit/libdummy.prl
--- qt-everywhere-opensource-src-4.7.3/src/3rdparty/webkit/include/QtWebKit/libdummy.prl	1970-01-01 00:00:00.000000000 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/3rdparty/webkit/include/QtWebKit/libdummy.prl	2011-06-13 22:06:43.159383552 +0000
@@ -0,0 +1,5 @@
+QMAKE_PRL_BUILD_DIR = /HaikuStorage/NewQt/qt-everywhere-opensource-src-4.7.3/./src/3rdparty/webkit/WebKit/qt/Api
+QMAKE_PRO_INPUT = DerivedSources.pro
+QMAKE_PRL_TARGET = libdummy.so.1.0.0
+QMAKE_PRL_CONFIG = lex yacc warn_on uic resources qt warn_on release link_prl def_files_disabled exceptions no_mocdepend release stl qt_no_framework release shared dll stl mmx 3dnow sse sse2 sse3 ssse3 sse4_1 sse4_2 avx dylib create_prl link_prl depend_includepath fix_output_dirs QTDIR_build shared dll moc thread
+QMAKE_PRL_VERSION = 1.0.0
diff -rupN qt-everywhere-opensource-src-4.7.3/src/corelib/animation/qvariantanimation.cpp qt-everywhere-opensource-src-4.7.3_haiku/src/corelib/animation/qvariantanimation.cpp
--- qt-everywhere-opensource-src-4.7.3/src/corelib/animation/qvariantanimation.cpp	2011-03-30 05:19:08.061079552 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/corelib/animation/qvariantanimation.cpp	2011-06-13 22:06:43.186384384 +0000
@@ -434,9 +434,15 @@ void QVariantAnimation::registerInterpol
 #ifndef QT_NO_THREAD
     QMutexLocker locker(QMutexPool::globalInstanceGet(interpolators));
 #endif
+#if defined(Q_OS_HAIKU) //temporary dirty hack
+if(interpolators) {
+#endif	
     if (int(interpolationType) >= interpolators->count())
         interpolators->resize(int(interpolationType) + 1);
     interpolators->replace(interpolationType, func);
+#if defined(Q_OS_HAIKU)
+}
+#endif	
 }
 
 
diff -rupN qt-everywhere-opensource-src-4.7.3/src/corelib/concurrent/qtconcurrentiteratekernel.cpp qt-everywhere-opensource-src-4.7.3_haiku/src/corelib/concurrent/qtconcurrentiteratekernel.cpp
--- qt-everywhere-opensource-src-4.7.3/src/corelib/concurrent/qtconcurrentiteratekernel.cpp	2011-03-30 05:19:08.058458112 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/corelib/concurrent/qtconcurrentiteratekernel.cpp	2011-06-13 22:06:43.188219392 +0000
@@ -54,6 +54,9 @@
 #elif defined(Q_OS_WIN)
 #include <qt_windows.h>
 #endif
+#if defined(Q_OS_HAIKU)
+#include <os/kernel/OS.h>
+#endif
 
 #include "private/qfunctions_p.h"
 
@@ -67,7 +70,14 @@ enum {
     MedianSize = 7
 };
 
-#if defined(Q_OS_MAC)
+#if defined(Q_OS_HAIKU)
+
+static qint64 getticks()
+{
+    return system_time();
+}
+
+#elif defined(Q_OS_MAC)
 
 static qint64 getticks()
 {
diff -rupN qt-everywhere-opensource-src-4.7.3/src/corelib/corelib.pro qt-everywhere-opensource-src-4.7.3_haiku/src/corelib/corelib.pro
--- qt-everywhere-opensource-src-4.7.3/src/corelib/corelib.pro	2011-03-30 05:19:08.013369344 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/corelib/corelib.pro	2011-06-13 22:06:43.190578688 +0000
@@ -23,6 +23,7 @@ mac|darwin:LIBS_PRIVATE += -framework Ap
 
 mac:lib_bundle:DEFINES += QT_NO_DEBUG_PLUGIN_CHECK
 win32:DEFINES-=QT_NO_CAST_TO_ASCII
+haiku:DEFINES += QT_NO_SHAREDMEMORY
 
 QMAKE_LIBS += $$QMAKE_LIBS_CORE
 
@@ -40,3 +41,7 @@ symbian: {
                   "$${LITERAL_HASH}endif"
     MMP_RULES += pagingBlock
 }
+
+haiku: {
+	LIBS_PRIVATE += -lbe
+}
diff -rupN qt-everywhere-opensource-src-4.7.3/src/corelib/global/qconfig.cpp qt-everywhere-opensource-src-4.7.3_haiku/src/corelib/global/qconfig.cpp
--- qt-everywhere-opensource-src-4.7.3/src/corelib/global/qconfig.cpp	1970-01-01 00:00:00.000000000 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/corelib/global/qconfig.cpp	2011-06-13 22:06:43.192937984 +0000
@@ -0,0 +1,34 @@
+/* License Info */
+static const char qt_configure_licensee_str          [256 + 12] = "qt_lcnsuser=Open Source\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";
+static const char qt_configure_licensed_products_str [256 + 12] = "qt_lcnsprod=OpenSource\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";
+
+/* Installation date */
+static const char qt_configure_installation          [12+11]    = "qt_instdate=2011-06-13";
+/* Installation Info */
+static const char qt_configure_prefix_path_str       [256 + 12] = "qt_prfxpath=/boot/common\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";
+static const char qt_configure_documentation_path_str[256 + 12] = "qt_docspath=/boot/common/documentation/doc/Qt\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";
+static const char qt_configure_headers_path_str      [256 + 12] = "qt_hdrspath=/boot/common/include\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";
+static const char qt_configure_libraries_path_str    [256 + 12] = "qt_libspath=/boot/common/lib\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";
+static const char qt_configure_binaries_path_str     [256 + 12] = "qt_binspath=/boot/common/bin\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";
+static const char qt_configure_plugins_path_str      [256 + 12] = "qt_plugpath=/boot/common/add-ons/Qt/plugins\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";
+static const char qt_configure_imports_path_str      [256 + 12] = "qt_impspath=/boot/common/add-ons/Qt/imports\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";
+static const char qt_configure_data_path_str         [256 + 12] = "qt_datapath=/boot/common/data/Qt\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";
+static const char qt_configure_translations_path_str [256 + 12] = "qt_trnspath=/boot/common/data/Qt/translations\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";
+static const char qt_configure_settings_path_str     [256 + 12] = "qt_stngpath=/boot/common/settings/Qt\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";
+static const char qt_configure_examples_path_str     [256 + 12] = "qt_xmplpath=/boot/apps/Qt/Examples\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";
+static const char qt_configure_demos_path_str        [256 + 12] = "qt_demopath=/boot/apps/Qt/Demos\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";
+/* strlen( "qt_lcnsxxxx" ) == 12 */
+#define QT_CONFIGURE_LICENSEE qt_configure_licensee_str + 12;
+#define QT_CONFIGURE_LICENSED_PRODUCTS qt_configure_licensed_products_str + 12;
+#define QT_CONFIGURE_PREFIX_PATH qt_configure_prefix_path_str + 12;
+#define QT_CONFIGURE_DOCUMENTATION_PATH qt_configure_documentation_path_str + 12;
+#define QT_CONFIGURE_HEADERS_PATH qt_configure_headers_path_str + 12;
+#define QT_CONFIGURE_LIBRARIES_PATH qt_configure_libraries_path_str + 12;
+#define QT_CONFIGURE_BINARIES_PATH qt_configure_binaries_path_str + 12;
+#define QT_CONFIGURE_PLUGINS_PATH qt_configure_plugins_path_str + 12;
+#define QT_CONFIGURE_IMPORTS_PATH qt_configure_imports_path_str + 12;
+#define QT_CONFIGURE_DATA_PATH qt_configure_data_path_str + 12;
+#define QT_CONFIGURE_TRANSLATIONS_PATH qt_configure_translations_path_str + 12;
+#define QT_CONFIGURE_SETTINGS_PATH qt_configure_settings_path_str + 12;
+#define QT_CONFIGURE_EXAMPLES_PATH qt_configure_examples_path_str + 12;
+#define QT_CONFIGURE_DEMOS_PATH qt_configure_demos_path_str + 12;
diff -rupN qt-everywhere-opensource-src-4.7.3/src/corelib/global/qconfig.h qt-everywhere-opensource-src-4.7.3_haiku/src/corelib/global/qconfig.h
--- qt-everywhere-opensource-src-4.7.3/src/corelib/global/qconfig.h	1970-01-01 00:00:00.000000000 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/corelib/global/qconfig.h	2011-06-13 22:06:43.194510848 +0000
@@ -0,0 +1,225 @@
+/* Everything */
+
+/* Qt Edition */
+#ifndef QT_EDITION
+#  define QT_EDITION QT_EDITION_OPENSOURCE
+#endif
+
+/* Machine byte-order */
+#define Q_BIG_ENDIAN 4321
+#define Q_LITTLE_ENDIAN 1234
+#define QT_BUILD_KEY "i386 haiku g++-4 full-config"
+#define QT_BUILD_KEY_COMPAT "BePC Haiku g++-4 full-config"
+
+#ifdef QT_BOOTSTRAPPED
+#define Q_BYTE_ORDER Q_LITTLE_ENDIAN
+#else
+#define Q_BYTE_ORDER Q_LITTLE_ENDIAN
+#endif
+/* Machine Architecture */
+#ifndef QT_BOOTSTRAPPED
+# define QT_ARCH_I386
+#else
+# define QT_ARCH_I386
+#endif
+/* Compile time features */
+#define QT_POINTER_SIZE 4
+
+#ifndef QT_BOOTSTRAPPED
+
+#if defined(QT_NO_ALSA) && defined(QT_ALSA)
+# undef QT_NO_ALSA
+#elif !defined(QT_NO_ALSA) && !defined(QT_ALSA)
+# define QT_NO_ALSA
+#endif
+
+#if defined(QT_NO_CLOCK_MONOTONIC) && defined(QT_CLOCK_MONOTONIC)
+# undef QT_NO_CLOCK_MONOTONIC
+#elif !defined(QT_NO_CLOCK_MONOTONIC) && !defined(QT_CLOCK_MONOTONIC)
+# define QT_NO_CLOCK_MONOTONIC
+#endif
+
+#if defined(QT_NO_CUPS) && defined(QT_CUPS)
+# undef QT_NO_CUPS
+#elif !defined(QT_NO_CUPS) && !defined(QT_CUPS)
+# define QT_NO_CUPS
+#endif
+
+#if defined(QT_NO_DBUS) && defined(QT_DBUS)
+# undef QT_NO_DBUS
+#elif !defined(QT_NO_DBUS) && !defined(QT_DBUS)
+# define QT_NO_DBUS
+#endif
+
+#if defined(QT_NO_EGL) && defined(QT_EGL)
+# undef QT_NO_EGL
+#elif !defined(QT_NO_EGL) && !defined(QT_EGL)
+# define QT_NO_EGL
+#endif
+
+#if defined(QT_NO_GETIFADDRS) && defined(QT_GETIFADDRS)
+# undef QT_NO_GETIFADDRS
+#elif !defined(QT_NO_GETIFADDRS) && !defined(QT_GETIFADDRS)
+# define QT_NO_GETIFADDRS
+#endif
+
+#if defined(QT_NO_GLIB) && defined(QT_GLIB)
+# undef QT_NO_GLIB
+#elif !defined(QT_NO_GLIB) && !defined(QT_GLIB)
+# define QT_NO_GLIB
+#endif
+
+#if defined(QT_NO_GSTREAMER) && defined(QT_GSTREAMER)
+# undef QT_NO_GSTREAMER
+#elif !defined(QT_NO_GSTREAMER) && !defined(QT_GSTREAMER)
+# define QT_NO_GSTREAMER
+#endif
+
+#if defined(QT_NO_GUI) && defined(QT_GUI)
+# undef QT_NO_GUI
+#elif !defined(QT_NO_GUI) && !defined(QT_GUI)
+# define QT_NO_GUI
+#endif
+
+#if defined(QT_NO_ICD) && defined(QT_ICD)
+# undef QT_NO_ICD
+#elif !defined(QT_NO_ICD) && !defined(QT_ICD)
+# define QT_NO_ICD
+#endif
+
+#if defined(QT_NO_ICONV) && defined(QT_ICONV)
+# undef QT_NO_ICONV
+#elif !defined(QT_NO_ICONV) && !defined(QT_ICONV)
+# define QT_NO_ICONV
+#endif
+
+#if defined(QT_NO_IMAGEFORMAT_JPEG) && defined(QT_IMAGEFORMAT_JPEG)
+# undef QT_NO_IMAGEFORMAT_JPEG
+#elif !defined(QT_NO_IMAGEFORMAT_JPEG) && !defined(QT_IMAGEFORMAT_JPEG)
+# define QT_NO_IMAGEFORMAT_JPEG
+#endif
+
+#if defined(QT_NO_IMAGEFORMAT_MNG) && defined(QT_IMAGEFORMAT_MNG)
+# undef QT_NO_IMAGEFORMAT_MNG
+#elif !defined(QT_NO_IMAGEFORMAT_MNG) && !defined(QT_IMAGEFORMAT_MNG)
+# define QT_NO_IMAGEFORMAT_MNG
+#endif
+
+#if defined(QT_NO_IMAGEFORMAT_TIFF) && defined(QT_IMAGEFORMAT_TIFF)
+# undef QT_NO_IMAGEFORMAT_TIFF
+#elif !defined(QT_NO_IMAGEFORMAT_TIFF) && !defined(QT_IMAGEFORMAT_TIFF)
+# define QT_NO_IMAGEFORMAT_TIFF
+#endif
+
+#if defined(QT_NO_INOTIFY) && defined(QT_INOTIFY)
+# undef QT_NO_INOTIFY
+#elif !defined(QT_NO_INOTIFY) && !defined(QT_INOTIFY)
+# define QT_NO_INOTIFY
+#endif
+
+#if defined(QT_NO_MREMAP) && defined(QT_MREMAP)
+# undef QT_NO_MREMAP
+#elif !defined(QT_NO_MREMAP) && !defined(QT_MREMAP)
+# define QT_NO_MREMAP
+#endif
+
+#if defined(QT_NO_NAS) && defined(QT_NAS)
+# undef QT_NO_NAS
+#elif !defined(QT_NO_NAS) && !defined(QT_NAS)
+# define QT_NO_NAS
+#endif
+
+#if defined(QT_NO_NIS) && defined(QT_NIS)
+# undef QT_NO_NIS
+#elif !defined(QT_NO_NIS) && !defined(QT_NIS)
+# define QT_NO_NIS
+#endif
+
+#if defined(QT_NO_OPENGL) && defined(QT_OPENGL)
+# undef QT_NO_OPENGL
+#elif !defined(QT_NO_OPENGL) && !defined(QT_OPENGL)
+# define QT_NO_OPENGL
+#endif
+
+#if defined(QT_NO_OPENVG) && defined(QT_OPENVG)
+# undef QT_NO_OPENVG
+#elif !defined(QT_NO_OPENVG) && !defined(QT_OPENVG)
+# define QT_NO_OPENVG
+#endif
+
+#if defined(QT_NO_PULSEAUDIO) && defined(QT_PULSEAUDIO)
+# undef QT_NO_PULSEAUDIO
+#elif !defined(QT_NO_PULSEAUDIO) && !defined(QT_PULSEAUDIO)
+# define QT_NO_PULSEAUDIO
+#endif
+
+#if defined(QT_NO_S60) && defined(QT_S60)
+# undef QT_NO_S60
+#elif !defined(QT_NO_S60) && !defined(QT_S60)
+# define QT_NO_S60
+#endif
+
+#if defined(QT_NO_STYLE_GTK) && defined(QT_STYLE_GTK)
+# undef QT_NO_STYLE_GTK
+#elif !defined(QT_NO_STYLE_GTK) && !defined(QT_STYLE_GTK)
+# define QT_NO_STYLE_GTK
+#endif
+
+#if defined(QT_NO_STYLE_S60) && defined(QT_STYLE_S60)
+# undef QT_NO_STYLE_S60
+#elif !defined(QT_NO_STYLE_S60) && !defined(QT_STYLE_S60)
+# define QT_NO_STYLE_S60
+#endif
+
+#if defined(QT_NO_SXE) && defined(QT_SXE)
+# undef QT_NO_SXE
+#elif !defined(QT_NO_SXE) && !defined(QT_SXE)
+# define QT_NO_SXE
+#endif
+
+#if defined(QT_NO_ZLIB) && defined(QT_ZLIB)
+# undef QT_NO_ZLIB
+#elif !defined(QT_NO_ZLIB) && !defined(QT_ZLIB)
+# define QT_NO_ZLIB
+#endif
+
+#if defined(QT_RUNTIME_XCURSOR) && defined(QT_NO_RUNTIME_XCURSOR)
+# undef QT_RUNTIME_XCURSOR
+#elif !defined(QT_RUNTIME_XCURSOR) && !defined(QT_NO_RUNTIME_XCURSOR)
+# define QT_RUNTIME_XCURSOR
+#endif
+
+#if defined(QT_RUNTIME_XFIXES) && defined(QT_NO_RUNTIME_XFIXES)
+# undef QT_RUNTIME_XFIXES
+#elif !defined(QT_RUNTIME_XFIXES) && !defined(QT_NO_RUNTIME_XFIXES)
+# define QT_RUNTIME_XFIXES
+#endif
+
+#if defined(QT_RUNTIME_XINERAMA) && defined(QT_NO_RUNTIME_XINERAMA)
+# undef QT_RUNTIME_XINERAMA
+#elif !defined(QT_RUNTIME_XINERAMA) && !defined(QT_NO_RUNTIME_XINERAMA)
+# define QT_RUNTIME_XINERAMA
+#endif
+
+#if defined(QT_RUNTIME_XINPUT) && defined(QT_NO_RUNTIME_XINPUT)
+# undef QT_RUNTIME_XINPUT
+#elif !defined(QT_RUNTIME_XINPUT) && !defined(QT_NO_RUNTIME_XINPUT)
+# define QT_RUNTIME_XINPUT
+#endif
+
+#if defined(QT_RUNTIME_XRANDR) && defined(QT_NO_RUNTIME_XRANDR)
+# undef QT_RUNTIME_XRANDR
+#elif !defined(QT_RUNTIME_XRANDR) && !defined(QT_NO_RUNTIME_XRANDR)
+# define QT_RUNTIME_XRANDR
+#endif
+
+#if defined(QT_USE_MATH_H_FLOATS) && defined(QT_NO_USE_MATH_H_FLOATS)
+# undef QT_USE_MATH_H_FLOATS
+#elif !defined(QT_USE_MATH_H_FLOATS) && !defined(QT_NO_USE_MATH_H_FLOATS)
+# define QT_USE_MATH_H_FLOATS
+#endif
+
+#endif // QT_BOOTSTRAPPED
+
+#define QT_VISIBILITY_AVAILABLE
+
diff -rupN qt-everywhere-opensource-src-4.7.3/src/corelib/global/qconfig.h.qmake qt-everywhere-opensource-src-4.7.3_haiku/src/corelib/global/qconfig.h.qmake
--- qt-everywhere-opensource-src-4.7.3/src/corelib/global/qconfig.h.qmake	1970-01-01 00:00:00.000000000 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/corelib/global/qconfig.h.qmake	2011-06-13 22:06:43.196345856 +0000
@@ -0,0 +1 @@
+/* All features enabled while building qmake */
diff -rupN qt-everywhere-opensource-src-4.7.3/src/corelib/global/qglobal.h qt-everywhere-opensource-src-4.7.3_haiku/src/corelib/global/qglobal.h
--- qt-everywhere-opensource-src-4.7.3/src/corelib/global/qglobal.h	2011-03-30 05:19:08.006553600 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/corelib/global/qglobal.h	2011-06-13 22:06:43.213385216 +0000
@@ -173,6 +173,7 @@ namespace QT_NAMESPACE {}
      LYNX     - LynxOS
      BSD4     - Any BSD 4.4 system
      UNIX     - Any UNIX BSD/SYSV system
+     HAIKU    - Haiku
 */
 
 #if defined(__APPLE__) && (defined(__GNUC__) || defined(__xlC__) || defined(__xlc__))
@@ -256,6 +257,8 @@ namespace QT_NAMESPACE {}
 #  define Q_OS_INTEGRITY
 #elif defined(VXWORKS) /* there is no "real" VxWorks define - this has to be set in the mkspec! */
 #  define Q_OS_VXWORKS
+#elif defined(__HAIKU__)
+#  define Q_OS_HAIKU
 #elif defined(__MAKEDEPEND__)
 #else
 #  error "Qt has not been ported to this OS - talk to qt-bugs@trolltech.com"
@@ -781,6 +784,7 @@ namespace QT_NAMESPACE {}
      S60      - Symbian S60
      PM       - unsupported
      WIN16    - unsupported
+     HAIKU	  - Haiku, Application Server
 */
 
 #if defined(Q_OS_MSDOS)
@@ -788,6 +792,8 @@ namespace QT_NAMESPACE {}
 #  error "Qt requires Win32 and does not work with Windows 3.x"
 #elif defined(_WIN32_X11_)
 #  define Q_WS_X11
+#elif defined(Q_OS_HAIKU)
+#  define Q_WS_HAIKU
 #elif defined(Q_OS_WIN32)
 #  define Q_WS_WIN32
 #  if defined(Q_OS_WIN64)
@@ -820,6 +826,10 @@ namespace QT_NAMESPACE {}
 #  endif
 #endif
 
+#if defined(Q_OS_HAIKU) && defined (Q_WS_X11)
+#undef Q_WS_X11
+#endif
+
 #if defined(Q_WS_WIN16) || defined(Q_WS_WIN32) || defined(Q_WS_WINCE)
 #  define Q_WS_WIN
 #endif
diff -rupN qt-everywhere-opensource-src-4.7.3/src/corelib/global/qnamespace.h qt-everywhere-opensource-src-4.7.3_haiku/src/corelib/global/qnamespace.h
--- qt-everywhere-opensource-src-4.7.3/src/corelib/global/qnamespace.h	2011-03-30 05:19:08.006291456 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/corelib/global/qnamespace.h	2011-06-13 22:06:43.216006656 +0000
@@ -1670,6 +1670,8 @@ public:
     typedef void * HANDLE;
 #elif defined(Q_OS_SYMBIAN)
     typedef unsigned long int HANDLE; // equivalent to TUint32
+#elif defined(Q_OS_HAIKU)
+    typedef unsigned long HANDLE;    
 #endif
     typedef WindowFlags WFlags;
 
diff -rupN qt-everywhere-opensource-src-4.7.3/src/corelib/io/qfsfileengine_unix.cpp qt-everywhere-opensource-src-4.7.3_haiku/src/corelib/io/qfsfileengine_unix.cpp
--- qt-everywhere-opensource-src-4.7.3/src/corelib/io/qfsfileengine_unix.cpp	2011-03-30 05:19:08.055312384 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/corelib/io/qfsfileengine_unix.cpp	2011-06-13 22:06:43.218628096 +0000
@@ -625,6 +625,9 @@ QString QFSFileEngine::homePath()
     QString home = rootPath();
 #else
     QString home = QFile::decodeName(qgetenv("HOME"));
+#ifdef Q_OS_HAIKU
+	home += QLatin1String("/config/settings/Qt");
+#endif        
     if (home.isNull())
         home = rootPath();
 #endif
diff -rupN qt-everywhere-opensource-src-4.7.3/src/corelib/io/qprocess_unix.cpp qt-everywhere-opensource-src-4.7.3_haiku/src/corelib/io/qprocess_unix.cpp
--- qt-everywhere-opensource-src-4.7.3/src/corelib/io/qprocess_unix.cpp	2011-03-30 05:19:08.050331648 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/corelib/io/qprocess_unix.cpp	2011-06-13 22:06:43.221249536 +0000
@@ -792,8 +792,12 @@ qint64 QProcessPrivate::bytesAvailableFr
 {
     int nbytes = 0;
     qint64 available = 0;
+#ifdef Q_OS_HAIKU
+	available = 1024;
+#else    
     if (::ioctl(stdoutChannel.pipe[0], FIONREAD, (char *) &nbytes) >= 0)
         available = (qint64) nbytes;
+#endif        
 #if defined (QPROCESS_DEBUG)
     qDebug("QProcessPrivate::bytesAvailableFromStdout() == %lld", available);
 #endif
@@ -804,8 +808,12 @@ qint64 QProcessPrivate::bytesAvailableFr
 {
     int nbytes = 0;
     qint64 available = 0;
+#ifdef Q_OS_HAIKU
+	available = 1024;
+#else    
     if (::ioctl(stderrChannel.pipe[0], FIONREAD, (char *) &nbytes) >= 0)
         available = (qint64) nbytes;
+#endif        
 #if defined (QPROCESS_DEBUG)
     qDebug("QProcessPrivate::bytesAvailableFromStderr() == %lld", available);
 #endif
diff -rupN qt-everywhere-opensource-src-4.7.3/src/corelib/kernel/qsystemsemaphore_unix.cpp qt-everywhere-opensource-src-4.7.3_haiku/src/corelib/kernel/qsystemsemaphore_unix.cpp
--- qt-everywhere-opensource-src-4.7.3/src/corelib/kernel/qsystemsemaphore_unix.cpp	2011-03-30 05:19:08.063438848 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/corelib/kernel/qsystemsemaphore_unix.cpp	2011-06-13 22:06:43.223346688 +0000
@@ -52,7 +52,9 @@
 #include <sys/ipc.h>
 #include <fcntl.h>
 #include <errno.h>
+#if !defined(Q_OS_HAIKU)
 #include <sys/shm.h>
+#endif
 
 #include <sys/sem.h>
 
diff -rupN qt-everywhere-opensource-src-4.7.3/src/corelib/thread/qthread_p.h qt-everywhere-opensource-src-4.7.3_haiku/src/corelib/thread/qthread_p.h
--- qt-everywhere-opensource-src-4.7.3/src/corelib/thread/qthread_p.h	2011-03-30 05:19:08.008650752 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/corelib/thread/qthread_p.h	2011-06-13 22:06:43.225443840 +0000
@@ -140,7 +140,7 @@ public:
     QWaitCondition thread_done;
 
     static void *start(void *arg);
-#if defined(Q_OS_SYMBIAN)
+#if defined(Q_OS_SYMBIAN) || defined(Q_OS_HAIKU)
     static void finish(void *arg, bool lockAnyway=true, bool closeNativeHandle=true);
 #else
     static void finish(void *);
@@ -156,7 +156,7 @@ public:
     static void finish(void *, bool lockAnyway=true);
 #endif // Q_OS_WIN32
 
-#if defined(Q_OS_WIN32) || defined(Q_OS_WINCE) || defined (Q_OS_SYMBIAN)
+#if defined(Q_OS_WIN32) || defined(Q_OS_WINCE) || defined (Q_OS_SYMBIAN) || defined (Q_OS_HAIKU)
     bool terminationEnabled, terminatePending;
 # endif
     QThreadData *data;
diff -rupN qt-everywhere-opensource-src-4.7.3/src/corelib/thread/qthread_unix.cpp qt-everywhere-opensource-src-4.7.3_haiku/src/corelib/thread/qthread_unix.cpp
--- qt-everywhere-opensource-src-4.7.3/src/corelib/thread/qthread_unix.cpp	2011-03-30 05:19:08.009699328 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/corelib/thread/qthread_unix.cpp	2011-06-13 22:06:43.228327424 +0000
@@ -274,7 +274,7 @@ void QThreadPrivate::createEventDispatch
 void *QThreadPrivate::start(void *arg)
 {
     // Symbian Open C supports neither thread cancellation nor cleanup_push.
-#ifndef Q_OS_SYMBIAN
+#if !defined(Q_OS_SYMBIAN) && !defined(Q_OS_HAIKU)
     pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL);
     pthread_cleanup_push(QThreadPrivate::finish, arg);
 #endif
@@ -319,7 +319,7 @@ void *QThreadPrivate::start(void *arg)
 #endif
     thr->run();
 
-#ifdef Q_OS_SYMBIAN
+#if defined(Q_OS_SYMBIAN) || defined(Q_OS_HAIKU)
     QThreadPrivate::finish(arg);
 #else
     pthread_cleanup_pop(1);
@@ -328,7 +328,7 @@ void *QThreadPrivate::start(void *arg)
     return 0;
 }
 
-#ifdef Q_OS_SYMBIAN
+#if defined(Q_OS_SYMBIAN) || defined(Q_OS_HAIKU)
 void QThreadPrivate::finish(void *arg, bool lockAnyway, bool closeNativeHandle)
 #else
 void QThreadPrivate::finish(void *arg)
@@ -336,7 +336,7 @@ void QThreadPrivate::finish(void *arg)
 {
     QThread *thr = reinterpret_cast<QThread *>(arg);
     QThreadPrivate *d = thr->d_func();
-#ifdef Q_OS_SYMBIAN
+#if defined(Q_OS_SYMBIAN) || defined(Q_OS_HAIKU)
     if (lockAnyway)
 #endif
         d->mutex.lock();
@@ -365,7 +365,7 @@ void QThreadPrivate::finish(void *arg)
         d->data->symbian_thread_handle.Close();
 #endif
     d->thread_done.wakeAll();
-#ifdef Q_OS_SYMBIAN
+#if defined(Q_OS_SYMBIAN) || defined(Q_OS_HAIKU)
     if (lockAnyway)
 #endif
         d->mutex.unlock();
@@ -634,7 +634,7 @@ void QThread::start(Priority priority)
     if (code == EPERM) {
         // caller does not have permission to set the scheduling
         // parameters/policy
-#ifndef Q_OS_SYMBIAN
+#if !defined(Q_OS_SYMBIAN) && !defined(Q_OS_HAIKU)
         pthread_attr_setinheritsched(&attr, PTHREAD_INHERIT_SCHED);
 #endif
         code =
@@ -663,7 +663,7 @@ void QThread::terminate()
     if (!d->thread_id)
         return;
 
-#ifndef Q_OS_SYMBIAN
+#if !defined(Q_OS_SYMBIAN) && !defined(Q_OS_HAIKU)
     int code = pthread_cancel(d->thread_id);
     if (code) {
         qWarning("QThread::start: Thread termination error: %s",
@@ -686,11 +686,14 @@ void QThread::terminate()
     // 2. closeNativeSymbianHandle = false. We don't want to close the thread handle,
     //    because we need it here to terminate the thread.
     QThreadPrivate::finish(this, false, false);
+#ifdef Q_OS_SYMBIAN
     d->data->symbian_thread_handle.Terminate(KErrNone);
     d->data->symbian_thread_handle.Close();
 #endif
-
-
+#ifdef Q_OS_HAIKU
+	pthread_kill(d->thread_id,0);
+#endif
+#endif
 }
 
 bool QThread::wait(unsigned long time)
diff -rupN qt-everywhere-opensource-src-4.7.3/src/corelib/tools/qlocale.cpp qt-everywhere-opensource-src-4.7.3_haiku/src/corelib/tools/qlocale.cpp
--- qt-everywhere-opensource-src-4.7.3/src/corelib/tools/qlocale.cpp	2011-03-30 05:19:08.013893632 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/corelib/tools/qlocale.cpp	2011-06-13 22:06:43.234356736 +0000
@@ -63,6 +63,9 @@ QT_END_NAMESPACE
 #   include "qt_windows.h"
 #   include <time.h>
 #endif
+#if defined(Q_OS_HAIKU)
+#include <LocaleKit.h>
+#endif
 #if !defined(QWS) && defined(Q_OS_MAC)
 #   include "private/qcore_mac_p.h"
 #   include <CoreFoundation/CoreFoundation.h>
@@ -1249,6 +1252,78 @@ QVariant QSystemLocale::query(QueryType 
     return QVariant();
 }
 
+#elif defined(Q_OS_HAIKU) && !defined(QT_BUILD_QMAKE)
+
+QLocale QSystemLocale::fallbackLocale() const
+{
+	BLanguage lang;
+	BLocale::Default()->GetLanguage(&lang);	
+    return QLocale(QLatin1String(lang.ID()));
+}
+
+QVariant QSystemLocale::query(QueryType type, QVariant in = QVariant()) const
+{
+	BLanguage lang;
+	BLocale::Default()->GetLanguage(&lang);	
+
+	switch(type) {		
+	case DecimalPoint: {
+		BString test, unitest;
+		BLocale::Default()->FormatNumber(&test,1.1);
+		BLocale::Default()->FormatNumber(&unitest,(int32)1);
+		QString result = QString().fromLocal8Bit(test.String());
+		result.remove(QString().fromLocal8Bit(unitest.String()));
+		if(!result.isEmpty() && result.size()<=2) {
+			return result;
+		}
+        return QVariant();
+    }
+    case GroupSeparator: {
+    	BString test, unitest;
+		BLocale::Default()->FormatNumber(&test,(int32)11111);
+		BLocale::Default()->FormatNumber(&unitest,(int32)1);
+		QString result = QString().fromLocal8Bit(test.String());
+		result.remove(QString().fromLocal8Bit(unitest.String()));
+		if(!result.isEmpty() && result.size()<=3) {
+			return result;
+		}
+        return QVariant();
+    }	
+    case LanguageId:
+    case CountryId: {
+        QString preferredLanguage = QString().fromLocal8Bit(lang.Code());
+        QString preferredCountry(3, QChar());
+        preferredCountry = QString().fromLocal8Bit(lang.CountryCode());
+        QLocale::Language languageCode = (preferredLanguage.isEmpty() ? QLocale::C : codeToLanguage(preferredLanguage.data()));
+        QLocale::Country countryCode = (preferredCountry.isEmpty() ? QLocale::AnyCountry : codeToCountry(preferredCountry.data()));
+        const QLocalePrivate *d = findLocale(languageCode, countryCode);
+        if (type == LanguageId) {
+            return (QLocale::Language)d->languageId();
+        }
+        return (QLocale::Country)d->countryId();
+    }
+    case MeasurementSystem: {
+		BFormattingConventions conventions;
+		BLocale::Default()->GetFormattingConventions(&conventions);
+		if(conventions.MeasurementKind()==B_METRIC) {
+	        return QLocale::MetricSystem;
+	    } else {
+        	return QLocale::ImperialSystem;
+    	}    	
+    }
+    case NegativeSign:
+    case PositiveSign:
+    case ZeroDigit:
+        break;
+    case AMText:
+    case PMText:
+        break;        
+    default:
+        break;	
+	}
+    return QVariant();
+}
+
 #elif defined(Q_OS_UNIX) && !defined(Q_OS_SYMBIAN)
 
 static uint unixGetSystemMeasurementSystem()
diff -rupN qt-everywhere-opensource-src-4.7.3/src/corelib/tools/tools.pri qt-everywhere-opensource-src-4.7.3_haiku/src/corelib/tools/tools.pri
--- qt-everywhere-opensource-src-4.7.3/src/corelib/tools/tools.pri	2011-03-30 05:19:08.024117248 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/corelib/tools/tools.pri	2011-06-13 22:06:43.235929600 +0000
@@ -110,5 +110,5 @@ INCLUDEPATH += ../3rdparty/md5 \
                ../3rdparty/md4
 
 # Note: libm should be present by default becaue this is C++
-!macx-icc:!vxworks:!symbian:unix:LIBS_PRIVATE += -lm
+!macx-icc:!vxworks:!symbian:!haiku:unix:LIBS_PRIVATE += -lm
 
diff -rupN qt-everywhere-opensource-src-4.7.3/src/gui/dialogs/dialogs.pri qt-everywhere-opensource-src-4.7.3_haiku/src/gui/dialogs/dialogs.pri
--- qt-everywhere-opensource-src-4.7.3/src/gui/dialogs/dialogs.pri	2011-03-30 05:19:03.013369344 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/gui/dialogs/dialogs.pri	2011-06-13 22:06:43.238026752 +0000
@@ -61,6 +61,11 @@ win32 {
     !win32-borland:!wince*: LIBS += -lshell32 	# the filedialog needs this library
 }
 
+haiku {
+    SOURCES +=         dialogs/qfiledialog_haiku.cpp    
+    LIBS += -ltracker 	# the filedialog needs this library
+}
+
 !mac:!embedded:!symbian:unix {
         HEADERS += dialogs/qpagesetupdialog_unix_p.h
 	SOURCES += dialogs/qprintdialog_unix.cpp \
diff -rupN qt-everywhere-opensource-src-4.7.3/src/gui/dialogs/qfiledialog.cpp qt-everywhere-opensource-src-4.7.3_haiku/src/gui/dialogs/qfiledialog.cpp
--- qt-everywhere-opensource-src-4.7.3/src/gui/dialogs/qfiledialog.cpp	2011-03-30 05:19:03.020185088 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/gui/dialogs/qfiledialog.cpp	2011-06-13 22:06:43.243269632 +0000
@@ -292,7 +292,7 @@ Q_GUI_EXPORT _qt_filedialog_save_filenam
   This signal is emitted when the user selects a \a filter.
 */
 
-#if defined(Q_WS_WIN) || defined(Q_WS_MAC)
+#if defined(Q_WS_WIN) || defined(Q_WS_MAC) || defined(Q_WS_HAIKU)
 bool Q_GUI_EXPORT qt_use_native_dialogs = true; // for the benefit of testing tools, until we have a proper API
 #endif
 
@@ -1617,6 +1617,25 @@ extern QString qt_win_get_existing_direc
 #endif
 
 /*
+    For Haiku file dialogs
+*/
+#if defined(Q_WS_HAIKU)
+extern QString qt_haiku_get_open_file_name(const QFileDialogArgs &args,
+                                         QString *initialDirectory,
+                                         QString *selectedFilter);
+
+extern QString qt_haiku_get_save_file_name(const QFileDialogArgs &args,
+                                         QString *initialDirectory,
+                                         QString *selectedFilter);
+
+extern QStringList qt_haiku_get_open_file_names(const QFileDialogArgs &args,
+                                              QString *initialDirectory,
+                                              QString *selectedFilter);
+
+extern QString qt_haiku_get_existing_directory(const QFileDialogArgs &args);
+#endif
+
+/*
     For Symbian file dialogs
 */
 #if defined(Q_WS_S60)
@@ -1713,6 +1732,12 @@ QString QFileDialog::getOpenFileName(QWi
     }
 #endif
 
+#if defined(Q_WS_HAIKU)
+    if (qt_use_native_dialogs && !(args.options & DontUseNativeDialog)) {
+        return qt_haiku_get_open_file_name(args, &(args.directory), selectedFilter);
+    }
+#endif
+
     // create a qt dialog
     QFileDialog dialog(args);
     if (selectedFilter)
@@ -1806,6 +1831,12 @@ QStringList QFileDialog::getOpenFileName
     }
 #endif
 
+#if defined(Q_WS_HAIKU)
+    if (qt_use_native_dialogs && !(args.options & DontUseNativeDialog)) {
+        return qt_haiku_get_open_file_names(args, &(args.directory), selectedFilter);
+    }
+#endif
+
     // create a qt dialog
     QFileDialog dialog(args);
     if (selectedFilter)
@@ -1900,6 +1931,12 @@ QString QFileDialog::getSaveFileName(QWi
     }
 #endif
 
+#if defined(Q_WS_HAIKU)
+    if (qt_use_native_dialogs && !(args.options & DontUseNativeDialog)) {
+        return qt_haiku_get_save_file_name(args, &(args.directory), selectedFilter);
+    }
+#endif
+
     // create a qt dialog
     QFileDialog dialog(args);
     dialog.setAcceptMode(AcceptSave);
@@ -1984,6 +2021,11 @@ QString QFileDialog::getExistingDirector
     }
 #endif
 
+#if defined(Q_WS_HAIKU)
+    if (qt_use_native_dialogs && !(args.options & DontUseNativeDialog) && (options & ShowDirsOnly))
+    	return qt_haiku_get_existing_directory(args);
+#endif
+
     // create a qt dialog
     QFileDialog dialog(args);
     if (dialog.exec() == QDialog::Accepted) {
diff -rupN qt-everywhere-opensource-src-4.7.3/src/gui/dialogs/qfiledialog_haiku.cpp qt-everywhere-opensource-src-4.7.3_haiku/src/gui/dialogs/qfiledialog_haiku.cpp
--- qt-everywhere-opensource-src-4.7.3/src/gui/dialogs/qfiledialog_haiku.cpp	1970-01-01 00:00:00.000000000 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/gui/dialogs/qfiledialog_haiku.cpp	2011-06-13 22:06:43.245628928 +0000
@@ -0,0 +1,465 @@
+/****************************************************************************
+**
+** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: Qt Software Information (qt-info@nokia.com)
+**
+** This file is part of the QtGui module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial Usage
+** Licensees holding valid Qt Commercial licenses may use this file in
+** accordance with the Qt Commercial License Agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Nokia.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain
+** additional rights. These rights are described in the Nokia Qt LGPL
+** Exception version 1.0, included in the file LGPL_EXCEPTION.txt in this
+** package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+** If you are unsure which license is appropriate for your use, please
+** contact the sales department at qt-sales@nokia.com.
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qfiledialog.h"
+
+#ifndef QT_NO_FILEDIALOG
+
+#include <private/qfiledialog_p.h>
+#include <qapplication.h>
+#include <private/qapplication_p.h>
+#include <qdesktopservices.h>
+#include <qglobal.h>
+#include <qregexp.h>
+#include <qbuffer.h>
+#include <qdir.h>
+#include <qstringlist.h>
+#include <qlibrary.h>
+#include "qeventloop.h"
+
+#ifndef QT_NO_THREAD
+#  include <private/qmutexpool_p.h>
+#endif
+
+#include <FilePanel.h>
+#include <Directory.h>
+#include <Entry.h>
+#include <Node.h>
+#include <Path.h>
+#include <TextControl.h>
+
+QT_BEGIN_NAMESPACE
+
+extern const char* qt_file_dialog_filter_reg_exp; // defined in qfiledialog.cpp
+extern QStringList qt_make_filter_list(const QString &filter);
+
+const int maxNameLen = 1023;
+const int maxMultiLen = 65535;
+
+class PanelLooper : public BLooper {
+public:
+							PanelLooper();
+	virtual					~PanelLooper();
+	virtual	void			MessageReceived(BMessage* message);
+
+	int						Wait(BFilePanel *panel);
+	
+	QString					GetFilename();
+	QStringList				GetFilenames();
+		
+private:
+	int 					state;
+	QString					filename;
+	QStringList				filenames;
+	entry_ref				fRef;	
+};
+
+
+PanelLooper::PanelLooper() : BLooper("PanelLooper"), state(B_CANCEL) { }
+PanelLooper::~PanelLooper() { }
+
+int
+PanelLooper::Wait(BFilePanel *panel)
+{
+    QEventLoop::ProcessEventsFlags flags;
+    flags |= QEventLoop::WaitForMoreEvents;
+    while(panel->IsShowing()) {
+    	QCoreApplication::processEvents(flags);
+    	snooze(250);
+    }	
+    return state;
+}
+
+QString
+PanelLooper::GetFilename()
+{
+	return filename;
+}
+
+QStringList
+PanelLooper::GetFilenames()
+{
+	return filenames;
+}
+
+void
+PanelLooper::MessageReceived(BMessage* message)
+{
+	switch (message->what) {
+		case B_SAVE_REQUESTED:
+			{
+				entry_ref ref;
+				const char *name;
+				message->FindRef("directory", &ref);
+				BDirectory  dir(&ref);
+				BPath path(&dir, NULL, false);
+				message->FindString("name", &name);
+				path.Append(name);
+				filename = QString::fromUtf8(path.Path());
+				filenames.append(filename);
+								
+				state = B_OK;
+			}
+			break;
+		case B_REFS_RECEIVED:
+			{
+				uint32 type;
+       			int32 count;				
+       			
+				message->GetInfo("refs", &type, &count);
+       			if ( type != B_REF_TYPE || count <= 0)
+           			return;				
+
+				for ( long i = --count; i >= 0; i-- ) {
+           			if ( message->FindRef("refs", i, &fRef) == B_OK ) {
+						BPath path(&fRef);
+				    	filename = QString::fromUtf8(path.Path());
+				    	filenames.append(filename);   				
+           			}
+				}
+								    	
+		    	state = B_OK;
+			}
+			break;
+		case B_CANCEL:
+			{
+				if(state!=B_OK) {
+					state = B_CANCEL;
+					filename.clear();
+					filenames.clear();
+				}
+			}
+			break;
+		default:
+			break;
+	}
+}
+
+
+// Returns the wildcard part of a filter.
+static QString qt_haiku_extract_filter(const QString &rawFilter)
+{
+    QString result = rawFilter;
+    QRegExp r(QString::fromLatin1(qt_file_dialog_filter_reg_exp));
+    int index = r.indexIn(result);
+    if (index >= 0)
+        result = r.cap(2);
+    QStringList list = result.split(QLatin1Char(' '));
+    for(QStringList::iterator it = list.begin(); it < list.end(); ++it) {
+        if (*it == QLatin1String("*")) {
+            *it = QLatin1String("*.*");
+            break;
+        }
+    }
+    return list.join(QLatin1String(";"));
+}
+
+static QStringList qt_haiku_make_filters_list(const QString &filter)
+{
+    QString f(filter);
+
+    if (f.isEmpty())
+        f = QFileDialog::tr("All Files (*.*)");
+
+    return qt_make_filter_list(f);
+}
+
+// Makes a NUL-oriented Haiku filter from a Qt filter.
+static QString qt_haiku_filter(const QString &filter)
+{
+    QStringList filterLst = qt_haiku_make_filters_list(filter);
+    QStringList::Iterator it = filterLst.begin();
+    QString haikufilters;
+    for (; it != filterLst.end(); ++it) {
+        QString subfilter = *it;
+        if (!subfilter.isEmpty()) {
+            haikufilters += subfilter;
+            haikufilters += QChar();
+            haikufilters += qt_haiku_extract_filter(subfilter);
+            haikufilters += QChar();
+        }
+    }
+    haikufilters += QChar();
+    return haikufilters;
+}
+
+static QString qt_haiku_selected_filter(const QString &filter, int idx)
+{
+    return qt_haiku_make_filters_list(filter).at((int)idx - 1);
+}
+
+
+QString qt_haiku_get_open_file_name(const QFileDialogArgs &args,
+                                  QString *initialDirectory,
+                                  QString *selectedFilter)
+{	
+    QString result;
+
+	QString title = args.caption;
+    QString isel = args.selection;
+
+    if (initialDirectory && initialDirectory->left(5) == QLatin1String("file:"))
+        initialDirectory->remove(0, 5);
+    QFileInfo fi(*initialDirectory);
+
+    if (initialDirectory && !fi.isDir()) {
+        *initialDirectory = fi.absolutePath();
+        if (isel.isEmpty())
+            isel = fi.fileName();
+    }
+
+    if (!fi.exists() || *initialDirectory==QDir::homePath())
+        *initialDirectory = QDesktopServices::storageLocation(QDesktopServices::HomeLocation);
+
+/*    int selFilIdx = 0;
+
+    int idx = 0;
+    if (selectedFilter) {
+        QStringList filterLst = qt_haiku_make_filters_list(args.filter);
+        idx = filterLst.indexOf(*selectedFilter);
+    }*/
+
+	PanelLooper *looper = new PanelLooper();
+	looper->Run();	
+
+    BFilePanel *openpanel = new BFilePanel(B_OPEN_PANEL,NULL,NULL,0,false,NULL,NULL,true,true);
+    openpanel->SetTarget(BMessenger(looper));    
+	if(!title.isEmpty()) {
+		openpanel->Window()->SetTitle((title.toUtf8()).data());
+	}      
+    QByteArray dirpath = initialDirectory->toUtf8();
+    openpanel->SetPanelDirectory(dirpath.data());    
+    openpanel->Show();
+    
+	looper->Wait(openpanel);
+	result = looper->GetFilename();
+	
+	delete openpanel;
+
+	looper->Lock();
+	looper->Quit();	
+
+    if (result.isEmpty())
+        return result;
+
+    fi = result;
+    *initialDirectory = fi.path();
+	    
+	return  fi.absoluteFilePath();;
+}
+
+QString qt_haiku_get_save_file_name(const QFileDialogArgs &args,
+                                  QString *initialDirectory,
+				  QString *selectedFilter)
+{
+    QString result;
+
+	QString title = args.caption;
+    QString isel = args.selection;
+    
+    if (initialDirectory && initialDirectory->left(5) == QLatin1String("file:"))
+        initialDirectory->remove(0, 5);
+    QFileInfo fi(*initialDirectory);
+
+    if (initialDirectory && !fi.isDir()) {
+        *initialDirectory = fi.absolutePath();
+        if (isel.isEmpty())
+            isel = fi.fileName();
+    }
+	
+    if (!fi.exists() || *initialDirectory==QDir::homePath())
+        *initialDirectory = QDesktopServices::storageLocation(QDesktopServices::HomeLocation);
+/*
+    int selFilIdx = 0;
+
+    int idx = 0;
+    if (selectedFilter) {
+        QStringList filterLst = qt_haiku_make_filters_list(args.filter);
+        idx = filterLst.indexOf(*selectedFilter);
+    }
+
+    QString defaultSaveExt;
+    if (selectedFilter && !selectedFilter->isEmpty()) {
+        defaultSaveExt = qt_haiku_extract_filter(*selectedFilter);
+        // make sure we only have the extension
+        int firstDot = defaultSaveExt.indexOf(QLatin1Char('.'));
+        if (firstDot != -1) {
+            defaultSaveExt.remove(0, firstDot + 1);
+        } else {
+            defaultSaveExt.clear();
+        }
+    }*/
+    
+	PanelLooper *looper = new PanelLooper();
+	looper->Run();	    
+
+    BFilePanel *savepanel = new BFilePanel(B_SAVE_PANEL,NULL,NULL,0,false,NULL,NULL,true,true);
+    savepanel->SetTarget(BMessenger(looper));    
+	if(!title.isEmpty()) {
+		savepanel->Window()->SetTitle((title.toUtf8()).data());
+	}     
+    QByteArray dirpath = initialDirectory->toUtf8();
+    savepanel->SetPanelDirectory(dirpath.data());    
+	savepanel->SetSaveText((isel.toUtf8()).data());
+    savepanel->Show();
+    
+	looper->Wait(savepanel);
+	result = looper->GetFilename();	
+	
+	delete savepanel;
+	
+	looper->Lock();
+	looper->Quit();	
+	
+    if (result.isEmpty())
+        return result;
+
+    fi = result;
+    *initialDirectory = fi.path();
+/*    if (selectedFilter)
+        *selectedFilter = qt_haiku_selected_filter(args.filter, selFilIdx);*/
+    return fi.absoluteFilePath();
+}
+
+QStringList qt_haiku_get_open_file_names(const QFileDialogArgs &args,
+                                       QString *initialDirectory,
+                                       QString *selectedFilter)
+{
+	QStringList result;
+	
+	QString title = args.caption;
+    QString isel = args.selection;
+
+    if (initialDirectory && initialDirectory->left(5) == QLatin1String("file:"))
+        initialDirectory->remove(0, 5);
+    QFileInfo fi(*initialDirectory);
+
+    if (initialDirectory && !fi.isDir()) {
+        *initialDirectory = fi.absolutePath();
+        if (isel.isEmpty())
+            isel = fi.fileName();
+    }
+
+    if (!fi.exists() || *initialDirectory==QDir::homePath())
+        *initialDirectory = QDesktopServices::storageLocation(QDesktopServices::HomeLocation);
+
+    int selFilIdx = 0;
+
+/*    int idx = 0;
+    if (selectedFilter) {
+        QStringList filterLst = qt_haiku_make_filters_list(args.filter);
+        idx = filterLst.indexOf(*selectedFilter);
+    }*/
+    
+	PanelLooper *looper = new PanelLooper();
+	looper->Run();    
+
+    BFilePanel *openpanel = new BFilePanel(B_OPEN_PANEL,NULL,NULL,0,true,NULL,NULL,true,true);
+    openpanel->SetTarget(BMessenger(looper));
+	if(!title.isEmpty()) {
+		openpanel->Window()->SetTitle((title.toUtf8()).data());
+	}    
+    QByteArray dirpath = initialDirectory->toUtf8();
+    openpanel->SetPanelDirectory(dirpath.data());
+    openpanel->Show();
+    
+	looper->Wait(openpanel);
+	result = looper->GetFilenames();
+
+	delete openpanel;
+
+	looper->Lock();
+	looper->Quit();		    
+
+    if (!result.isEmpty()) {
+        *initialDirectory = fi.path();    // only save the path if there is a result
+    }
+    return result;
+}
+
+class DirectoryFilter : public BRefFilter {
+public:
+	DirectoryFilter() {};
+	virtual bool Filter(const entry_ref* ref,
+		BNode* node, struct stat_beos* st, const char* filetype)
+	{
+		return node->IsDirectory();
+	}
+};
+
+
+QString qt_haiku_get_existing_directory(const QFileDialogArgs &args)
+{
+    QString initDir = QDir::toNativeSeparators(args.directory);
+    QString result;
+    
+    QString title = args.caption;
+    
+	PanelLooper *looper = new PanelLooper();
+	looper->Run();	
+	    
+	BFilePanel *dirpanel = new BFilePanel(B_OPEN_PANEL, NULL, NULL,	B_DIRECTORY_NODE, true, NULL, NULL, true, true);	
+ 	dirpanel->SetTarget(BMessenger(looper));  	
+	dirpanel->SetButtonLabel(B_DEFAULT_BUTTON, "Select");
+	if(!title.isEmpty()) {
+		dirpanel->Window()->SetTitle((title.toUtf8()).data());
+	}
+
+	BRefFilter *filter;
+	filter = new DirectoryFilter;
+	dirpanel->SetRefFilter(filter);   
+	dirpanel->Show();
+	
+	looper->Wait(dirpanel);
+	result = looper->GetFilename();
+	    
+    delete dirpanel;
+    
+	looper->Lock();
+	looper->Quit();  
+    
+    return result;
+}
+
+
+QT_END_NAMESPACE
+
+#endif
diff -rupN qt-everywhere-opensource-src-4.7.3/src/gui/gui.pro qt-everywhere-opensource-src-4.7.3_haiku/src/gui/gui.pro
--- qt-everywhere-opensource-src-4.7.3/src/gui/gui.pro	2011-03-30 05:19:06.004980736 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/gui/gui.pro	2011-06-13 22:06:43.247726080 +0000
@@ -5,7 +5,7 @@ DEFINES   += QT_BUILD_GUI_LIB QT_NO_USIN
 win32-msvc*|win32-icc:QMAKE_LFLAGS += /BASE:0x65000000
 irix-cc*:QMAKE_CXXFLAGS += -no_prelink -ptused
 
-!win32:!embedded:!mac:!symbian:CONFIG      += x11
+!win32:!embedded:!mac:!symbian:!haiku:CONFIG      += x11
 
 unix:QMAKE_PKGCONFIG_REQUIRES = QtCore
 
@@ -22,6 +22,7 @@ symbian {
     include(kernel/symbian.pri)
     include(s60framework/s60framework.pri)
 }
+haiku:include(kernel/haiku.pri)
 
 #modules
 include(animation/animation.pri)
diff -rupN qt-everywhere-opensource-src-4.7.3/src/gui/image/image.pri qt-everywhere-opensource-src-4.7.3_haiku/src/gui/image/image.pri
--- qt-everywhere-opensource-src-4.7.3/src/gui/image/image.pri	2011-03-30 05:19:04.013893632 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/gui/image/image.pri	2011-06-13 22:06:43.249561088 +0000
@@ -71,6 +71,10 @@ else:symbian {
     HEADERS += image/qpixmap_s60_p.h
     SOURCES += image/qpixmap_s60.cpp
 }
+else:haiku {
+    HEADERS += image/qpixmap_haiku_p.h
+    SOURCES += image/qpixmap_haiku.cpp
+}
 
 # Built-in image format support
 HEADERS += \
diff -rupN qt-everywhere-opensource-src-4.7.3/src/gui/image/qnativeimage.cpp qt-everywhere-opensource-src-4.7.3_haiku/src/gui/image/qnativeimage.cpp
--- qt-everywhere-opensource-src-4.7.3/src/gui/image/qnativeimage.cpp	2011-03-30 05:19:04.007602176 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/gui/image/qnativeimage.cpp	2011-06-13 22:06:43.252182528 +0000
@@ -268,6 +268,28 @@ QImage::Format QNativeImage::systemForma
     return QImage::Format_RGB32;
 }
 
+#elif defined(Q_WS_HAIKU)
+
+QNativeImage::QNativeImage(int width, int height, QImage::Format  
+format,  bool /* isTextBuffer */, QWidget *)
+    : image(width, height, format)
+{
+	bitmap = new BBitmap(BRect(0,0,width-1,height-1), B_RGBA32, false,  true); // we use continuous for now
+	uchar *bits = (uchar*)bitmap->Bits();
+	image = QImage(bits, width, height, format);
+}
+
+
+QNativeImage::~QNativeImage()
+{
+	delete bitmap;
+	bitmap = 0;
+}
+
+QImage::Format QNativeImage::systemFormat()
+{
+    return QImage::Format_RGB32;
+}
 
 #else // other platforms...
 
diff -rupN qt-everywhere-opensource-src-4.7.3/src/gui/image/qnativeimage_p.h qt-everywhere-opensource-src-4.7.3_haiku/src/gui/image/qnativeimage_p.h
--- qt-everywhere-opensource-src-4.7.3/src/gui/image/qnativeimage_p.h	2011-03-30 05:19:04.011010048 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/gui/image/qnativeimage_p.h	2011-06-13 22:06:43.254017536 +0000
@@ -64,6 +64,9 @@
 #elif defined(Q_WS_MAC)
 #include <private/qt_mac_p.h>
 
+#elif defined(Q_WS_HAIKU)
+#include <Bitmap.h>
+
 #endif
 
 QT_BEGIN_NAMESPACE
@@ -95,6 +98,10 @@ public:
 
 #elif defined(Q_WS_MAC)
     CGContextRef cg;
+
+#elif defined(Q_WS_HAIKU)
+	BBitmap* bitmap;
+	    
 #endif
 
 private:
diff -rupN qt-everywhere-opensource-src-4.7.3/src/gui/image/qpixmap.cpp qt-everywhere-opensource-src-4.7.3_haiku/src/gui/image/qpixmap.cpp
--- qt-everywhere-opensource-src-4.7.3/src/gui/image/qpixmap.cpp	2011-03-30 05:19:04.009961472 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/gui/image/qpixmap.cpp	2011-06-13 22:06:43.257425408 +0000
@@ -71,6 +71,10 @@
 # include "private/qpixmap_mac_p.h"
 #endif
 
+#ifdef Q_WS_HAIKU
+# include "private/qpixmap_haiku_p.h"
+#endif
+
 #if defined(Q_WS_X11)
 # include "qx11info_x11.h"
 # include <private/qt_x11_p.h>
@@ -1960,6 +1964,8 @@ int QPixmap::defaultDepth()
     return 32; // XXX
 #elif defined(Q_WS_MAC)
     return 32;
+#elif defined(Q_WS_HAIKU)
+    return 32;    
 #elif defined(Q_OS_SYMBIAN)
     return S60->screenDepth;
 #endif
diff -rupN qt-everywhere-opensource-src-4.7.3/src/gui/image/qpixmap.h qt-everywhere-opensource-src-4.7.3_haiku/src/gui/image/qpixmap.h
--- qt-everywhere-opensource-src-4.7.3/src/gui/image/qpixmap.h	2011-03-30 05:19:04.009437184 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/gui/image/qpixmap.h	2011-06-13 22:06:43.259784704 +0000
@@ -57,6 +57,10 @@ class CFbsBitmap;
 class RSgImage;
 #endif
 
+#if defined(Q_OS_HAIKU)
+class BBitmap;
+#endif
+
 QT_BEGIN_NAMESPACE
 
 QT_MODULE(Gui)
@@ -164,6 +168,11 @@ public:
     static QPixmap fromMacCGImageRef(CGImageRef image);
 #endif
 
+#if defined(Q_OS_HAIKU)
+	BBitmap *toHaikuBitmap() const;
+	static QPixmap fromHaikuBitmap(BBitmap *);
+#endif
+
 #if defined(Q_OS_SYMBIAN)
     CFbsBitmap *toSymbianCFbsBitmap() const;
     static QPixmap fromSymbianCFbsBitmap(CFbsBitmap *bitmap);
diff -rupN qt-everywhere-opensource-src-4.7.3/src/gui/image/qpixmap_haiku.cpp qt-everywhere-opensource-src-4.7.3_haiku/src/gui/image/qpixmap_haiku.cpp
--- qt-everywhere-opensource-src-4.7.3/src/gui/image/qpixmap_haiku.cpp	1970-01-01 00:00:00.000000000 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/gui/image/qpixmap_haiku.cpp	2011-06-13 22:06:43.261619712 +0000
@@ -0,0 +1,126 @@
+#include "qpixmap.h"
+
+#include "qpixmap_raster_p.h"
+
+#include "qbitmap.h"
+#include "qimage.h"
+#include "qwidget.h"
+#include "qpainter.h"
+#include "qdatastream.h"
+#include "qbuffer.h"
+#include "qapplication.h"
+#include "qevent.h"
+#include "qfile.h"
+#include "qfileinfo.h"
+#include "qdatetime.h"
+#include "qpixmapcache.h"
+#include "qimagereader.h"
+#include "qimagewriter.h"
+#include "qdebug.h"
+
+#include <stdio.h>
+
+#include <View.h>
+#include <Window.h>
+#include <Screen.h>
+#include <Bitmap.h>
+
+BBitmap *
+QPixmap::toHaikuBitmap() const
+{
+	BBitmap *bitmap = NULL;
+	
+    if (isNull())
+        return 0;
+    
+    if (data->classId() == QPixmapData::RasterClass) {
+        QRasterPixmapData* d = static_cast<QRasterPixmapData*>(data.data());
+        int w = d->image.width();
+        int h = d->image.height();
+
+        const QImage image = d->image.convertToFormat(QImage::Format_ARGB32);
+        int bytes_per_line = w * 4;        
+        
+        bitmap = new BBitmap(BRect(0,0,w-1,h-1), B_RGBA32);
+        uchar *pixels = (uchar *)bitmap->Bits();
+
+        for (int y=0; y<h; ++y)
+            memcpy(pixels + y * bytes_per_line, image.scanLine(y), bytes_per_line);
+	
+	} else {
+    
+        QPixmapData *data = new QRasterPixmapData(depth() == 1 ?
+                                                  QPixmapData::BitmapType : QPixmapData::PixmapType);
+        data->fromImage(toImage(), Qt::AutoColor);
+        return QPixmap(data).toHaikuBitmap();
+    }        	
+	return bitmap;
+}
+
+QPixmap
+QPixmap::fromHaikuBitmap(BBitmap *bmp)
+{
+	if(!bmp) 
+		return QPixmap();
+		
+	int w = bmp->Bounds().IntegerWidth() + 1;
+	int h = bmp->Bounds().IntegerHeight() + 1;
+	
+	QImage image(w,h,QImage::Format_ARGB32);
+
+	int bytes_per_line = w * 4;                        	
+    uchar *pixels = (uchar *)bmp->Bits();
+
+    for (int y=0; y<h; ++y)
+       memcpy( image.scanLine(y), pixels + y * bytes_per_line, bytes_per_line);
+    
+	return QPixmap::fromImage(image);
+}
+
+QPixmap 
+QPixmap::grabWindow(WId winId, int x, int y, int w, int h )
+{
+    if (w == 0 || h == 0 || winId!=0)
+        return QPixmap();
+        	
+	BScreen screen(NULL);
+	BBitmap *bitmap=NULL;
+	screen.GetBitmap(&bitmap);
+
+	int screen_w = screen.Frame().Width()+1;
+	int screen_h = screen.Frame().Height()+1;	
+
+    if (w < 0)
+        w = screen_w - x;
+    if (h < 0)
+        h = screen_h - y;
+
+	QImage::Format format = QImage::Format_RGB32;
+	switch(bitmap->ColorSpace()) {
+		case B_GRAY1:
+			format = QImage::Format_Mono;
+			break;
+		case B_GRAY8:
+		case B_CMAP8:
+			format = QImage::Format_Indexed8;
+			break;
+		case B_RGB15:
+		case B_RGBA15:
+		case B_RGB16:
+			format = QImage::Format_RGB16;
+			break;
+		case B_RGB32:
+		default:
+			format = QImage::Format_RGB32;
+			break;
+	}
+
+	QRect grabRect(x,y,w,h);
+	QImage image((uchar*)bitmap->Bits(), screen_w, screen_h, bitmap->BytesPerRow(), format);
+    image = image.copy(grabRect);
+    
+	delete bitmap;
+	
+	return QPixmap::fromImage(image);
+}
+
diff -rupN qt-everywhere-opensource-src-4.7.3/src/gui/image/qpixmap_haiku_p.h qt-everywhere-opensource-src-4.7.3_haiku/src/gui/image/qpixmap_haiku_p.h
--- qt-everywhere-opensource-src-4.7.3/src/gui/image/qpixmap_haiku_p.h	1970-01-01 00:00:00.000000000 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/gui/image/qpixmap_haiku_p.h	2011-06-13 22:06:43.272367616 +0000
@@ -0,0 +1,6 @@
+#include "qpixmap.h"
+#include "qpixmapdata_p.h"
+
+#include <stdio.h>
+#include <Bitmap.h>
+
diff -rupN qt-everywhere-opensource-src-4.7.3/src/gui/image/qpixmapdatafactory.cpp qt-everywhere-opensource-src-4.7.3_haiku/src/gui/image/qpixmapdatafactory.cpp
--- qt-everywhere-opensource-src-4.7.3/src/gui/image/qpixmapdatafactory.cpp	2011-03-30 05:19:04.015990784 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/gui/image/qpixmapdatafactory.cpp	2011-06-13 22:06:43.274464768 +0000
@@ -56,6 +56,9 @@
 #ifdef Q_OS_SYMBIAN
 # include <private/qpixmap_s60_p.h>
 #endif
+#ifdef Q_WS_HAIKU
+# include <private/qpixmap_raster_p.h>
+#endif
 
 #include "private/qapplication_p.h"
 #include "private/qgraphicssystem_p.h"
@@ -83,7 +86,9 @@ QPixmapData* QSimplePixmapDataFactory::c
 #elif defined(Q_WS_MAC)
     return new QMacPixmapData(type);
 #elif defined(Q_OS_SYMBIAN)
-    return new QS60PixmapData(type);    
+    return new QS60PixmapData(type);
+#elif defined(Q_WS_HAIKU)
+    return new QRasterPixmapData(type);    
 #else
 #error QSimplePixmapDataFactory::create() not implemented
 #endif
diff -rupN qt-everywhere-opensource-src-4.7.3/src/gui/itemviews/qfileiconprovider.cpp qt-everywhere-opensource-src-4.7.3_haiku/src/gui/itemviews/qfileiconprovider.cpp
--- qt-everywhere-opensource-src-4.7.3/src/gui/itemviews/qfileiconprovider.cpp	2011-03-30 05:19:05.040894464 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/gui/itemviews/qfileiconprovider.cpp	2011-06-13 22:06:43.277348352 +0000
@@ -53,6 +53,11 @@
 #  include <objbase.h>
 #elif defined(Q_WS_MAC)
 #  include <private/qt_cocoa_helpers_mac_p.h>
+#elif defined(Q_WS_HAIKU)
+#  include <AppKit.h>
+#  include <StorageKit.h>
+#  include <InterfaceKit.h>
+#  include <NodeInfo.h>
 #endif
 
 #include <private/qfunctions_p.h>
@@ -98,6 +103,8 @@ public:
     QIcon getWinIcon(const QFileInfo &fi) const;
 #elif defined(Q_WS_MAC)
     QIcon getMacIcon(const QFileInfo &fi) const;
+#elif defined(Q_WS_HAIKU)
+    QIcon getHaikuIcon(const QFileInfo &fi) const;    
 #endif
     QFileIconProvider *q_ptr;
     const QString homePath;
@@ -389,6 +396,33 @@ QIcon QFileIconProviderPrivate::getMacIc
 
     return retIcon;
 }
+#elif defined(Q_WS_HAIKU)
+QIcon QFileIconProviderPrivate::getHaikuIcon(const QFileInfo &fi) const
+{
+    QIcon retIcon;
+    
+	BNode node(fi.canonicalFilePath().toUtf8().constData());
+	if (node.InitCheck() == B_OK) {
+		BNodeInfo nodeinfo(&node);
+		
+		BBitmap *hIcon = new BBitmap(BRect(0, 0, 15, 15), B_RGBA32);
+		nodeinfo.GetTrackerIcon(hIcon, B_MINI_ICON);
+		if(hIcon) {
+			QPixmap p = QPixmap::fromHaikuBitmap(hIcon);
+			retIcon.addPixmap(p);
+			delete hIcon;
+		}
+
+		BBitmap *hIconBig = new BBitmap(BRect(0, 0, 31, 31), B_RGBA32);
+		nodeinfo.GetTrackerIcon(hIcon, B_LARGE_ICON);
+		if(hIconBig) {
+			QPixmap p = QPixmap::fromHaikuBitmap(hIconBig);
+			retIcon.addPixmap(p);
+			delete hIconBig;
+		}		
+	}	
+    return retIcon;
+}
 #endif
 
 
@@ -420,6 +454,10 @@ QIcon QFileIconProvider::icon(const QFil
     QIcon icon = d->getWinIcon(info);
     if (!icon.isNull())
         return icon;
+#elif defined Q_WS_HAIKU
+    QIcon icon = d->getHaikuIcon(info);
+    if (!icon.isNull())
+        return icon;        
 #endif
     if (info.isRoot())
 #if defined (Q_WS_WIN) && !defined(Q_WS_WINCE)
diff -rupN qt-everywhere-opensource-src-4.7.3/src/gui/kernel/haiku.pri qt-everywhere-opensource-src-4.7.3_haiku/src/gui/kernel/haiku.pri
--- qt-everywhere-opensource-src-4.7.3/src/gui/kernel/haiku.pri	1970-01-01 00:00:00.000000000 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/gui/kernel/haiku.pri	2011-06-13 22:06:43.279445504 +0000
@@ -0,0 +1,2 @@
+DEFINES += QT_NO_FONTCONFIG
+LIBS_PRIVATE += -lbe
diff -rupN qt-everywhere-opensource-src-4.7.3/src/gui/kernel/kernel.pri qt-everywhere-opensource-src-4.7.3_haiku/src/gui/kernel/kernel.pri
--- qt-everywhere-opensource-src-4.7.3/src/gui/kernel/kernel.pri	2011-03-30 05:19:04.051118080 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/gui/kernel/kernel.pri	2011-06-13 22:06:43.281018368 +0000
@@ -262,3 +262,18 @@ wince*: {
                 ../corelib/kernel/qfunctions_wince.cpp \
                 kernel/qguifunctions_wince.cpp
 }
+
+haiku {
+	HEADERS += kernel/qwidget_haiku.h
+    
+	SOURCES += \
+		kernel/qapplication_haiku.cpp \
+		kernel/qwidget_haiku.cpp \
+		kernel/qdnd_haiku.cpp \
+		kernel/qdesktopwidget_haiku.cpp \
+		kernel/qclipboard_haiku.cpp \
+		kernel/qcursor_haiku.cpp \
+		kernel/qkeymapper_haiku.cpp \
+		kernel/qsound_haiku.cpp \
+		kernel/qeventdispatcher_haiku.cpp
+}
diff -rupN qt-everywhere-opensource-src-4.7.3/src/gui/kernel/qapplication.cpp qt-everywhere-opensource-src-4.7.3_haiku/src/gui/kernel/qapplication.cpp
--- qt-everywhere-opensource-src-4.7.3/src/gui/kernel/qapplication.cpp	2011-03-30 05:19:04.057671680 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/gui/kernel/qapplication.cpp	2011-06-13 22:06:43.288096256 +0000
@@ -4760,7 +4760,7 @@ bool QApplicationPrivate::notify_helper(
   Stubbed session management support
  *****************************************************************************/
 #ifndef QT_NO_SESSIONMANAGER
-#if defined(Q_WS_WIN) || defined(Q_WS_MAC) || defined(Q_WS_QWS)
+#if defined(Q_WS_WIN) || defined(Q_WS_MAC) || defined(Q_WS_QWS) || defined(Q_WS_HAIKU)
 
 #if defined(Q_OS_WINCE)
 HRESULT qt_CoCreateGuid(GUID* guid)
diff -rupN qt-everywhere-opensource-src-4.7.3/src/gui/kernel/qapplication_haiku.cpp qt-everywhere-opensource-src-4.7.3_haiku/src/gui/kernel/qapplication_haiku.cpp
--- qt-everywhere-opensource-src-4.7.3/src/gui/kernel/qapplication_haiku.cpp	1970-01-01 00:00:00.000000000 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/gui/kernel/qapplication_haiku.cpp	2011-06-13 22:06:43.291241984 +0000
@@ -0,0 +1,655 @@
+#include "qapplication_p.h"
+#include "qsessionmanager.h"
+#include "qapplication.h"
+#include "qevent.h"
+#include "qeventdispatcher_haiku_p.h"
+#include "qwidget.h"
+#include "qwidget_p.h"
+#include "private/qsystemtrayicon_p.h"
+#include <QtGui>
+#include <Application.h>
+#include <Path.h>
+#include <Entry.h>
+#include <String.h>
+#include <OS.h>
+#include <QDebug>
+#include <stdio.h>
+
+/*****************************************************************************
+  Internal variables and functions
+ *****************************************************************************/
+static WId curWin;
+
+// ignore the next release event if return from a modal widget
+Q_GUI_EXPORT bool qt_win_ignoreNextMouseReleaseEvent = false;
+
+#if defined(QT_DEBUG)
+static bool        appNoGrab        = false;        // mouse/keyboard grabbing
+#endif
+
+static bool        app_do_modal           = false;        // modal mode
+extern QWidgetList *qt_modal_stack;
+//extern QDesktopWidget *qt_desktopWidget;
+//static QPointer<QWidget> popupButtonFocus;
+
+QPointer<QWidget> qt_last_mouse_receiver = 0;
+QWidget* qt_button_down = 0;
+QTextCodec * qt_input_mapper = 0;
+
+char *qAppSignature = NULL;
+
+bool qt_nograb()                                // application no-grab option
+{
+#if defined(QT_DEBUG)
+    return appNoGrab;
+#else
+    return false;
+#endif
+}
+
+class HQApplication : public BApplication
+{
+public:
+	HQApplication(const char*, QApplicationPrivate *priv);
+	~HQApplication();
+
+	virtual void MessageReceived(BMessage *message);
+	void	ArgvReceived(int32 argc, char **argv);
+	void	RefsReceived(BMessage *pmsg);
+	virtual	bool QuitRequested();
+	bool	RefHandled;
+	entry_ref Ref;
+private:
+	BMessenger  fTrackerMessenger;
+	QApplicationPrivate *priv_ptr;
+};
+
+namespace {
+static HQApplication* happ = 0;
+}
+
+HQApplication::HQApplication(const char* signature, QApplicationPrivate *priv)
+		: BApplication(signature)
+{
+	RefHandled = false;
+	
+	qDebug("Reimp: HQApplication::HQApplication\n");
+
+	if(qAppSignature)
+		free(qAppSignature);
+	qAppSignature = strdup(signature);
+	
+	priv_ptr = priv;	
+}
+
+HQApplication::~HQApplication()
+{
+	qDebug("Reimp: HQApplication::~HQApplication\n");
+}
+
+void HQApplication::MessageReceived(BMessage* msg)
+{
+	BApplication::MessageReceived(msg);
+}
+
+void 
+HQApplication::RefsReceived(BMessage *pmsg)
+{
+	if (pmsg->HasMessenger("TrackerViewToken")) {
+		pmsg->FindMessenger("TrackerViewToken", &fTrackerMessenger);
+	}
+
+	uint32 type;
+	int32 count;
+	status_t ret = pmsg->GetInfo("refs", &type, &count);
+	if (ret != B_OK || type != B_REF_TYPE)
+		return;
+
+	entry_ref ref;
+	for (int32 i = 0; i < count; i++) {
+   		if (pmsg->FindRef("refs", i, &ref) == B_OK) {
+   			BPath p(&ref);
+   			Ref = ref;
+   			RefHandled = true;
+   		}
+   	}
+}
+
+void
+HQApplication::ArgvReceived(int32 argc, char **argv)
+{
+}
+
+bool 
+HQApplication::QuitRequested() {
+    QEvent quitEvent(QEvent::Quit);
+    QApplication::sendEvent(qApp, &quitEvent);	    
+	return true;
+}
+
+
+int32 AppThread(void *data)
+{
+	HQApplication *app = (HQApplication*)data;
+	app->LockLooper();
+	app->Run();	
+}
+
+
+void qt_init(QApplicationPrivate *priv, int)
+{
+	int i;
+	qDebug("qt_init()");
+
+	thread_id my_thread;	
+
+	happ = new HQApplication("application/x-vnd."+QFileInfo(QApplication::applicationFilePath()).fileName().toLatin1(), priv );	
+	be_app = happ;
+    		
+	QApplicationPrivate::haiku_apply_settings();	
+	
+	my_thread = spawn_thread(AppThread,"app_thread",1,(void*)happ);
+	resume_thread(my_thread);
+		
+	happ->UnlockLooper();
+
+	if(priv->argc==1) {
+		for(i=0;i<100;i++) {
+			if(happ->RefHandled) {
+				BPath p(&happ->Ref);
+				priv->argc = 2;
+				priv->argv[1]=strdup(p.Path());
+				priv->argv[2]=0;
+				break;
+			}
+			snooze(1000);
+		}	
+		
+		QString appDir = QCoreApplication::applicationDirPath();
+		chdir(appDir.toUtf8());		
+	}
+}
+
+void qt_cleanup()
+{
+	qDebug("qt_cleanup()");
+}
+
+void QApplicationPrivate::_q_alertTimeOut()
+{
+	qDebug("Unimplemented: void  QApplicationPrivate::_q_alertTimeOut()\n");
+}
+
+QString QApplicationPrivate::appName() const
+{
+	return QCoreApplicationPrivate::appName();
+}
+
+void QApplicationPrivate::createEventDispatcher()
+{
+	Q_Q(QApplication);
+	qDebug("Reimplemented: void  QApplicationPrivate::createEventDispatcher\n");
+	if (q->type() != QApplication::Tty)
+		eventDispatcher = new QEventDispatcherHaiku(q);
+	else
+		eventDispatcher = new QEventDispatcherUNIX(q);
+}
+
+/*****************************************************************************
+  Popup widget mechanism
+
+  openPopup()
+        Adds a widget to the list of popup widgets
+        Arguments:
+            QWidget *widget        The popup widget to be added
+
+  closePopup()
+        Removes a widget from the list of popup widgets
+        Arguments:
+            QWidget *widget        The popup widget to be removed
+ *****************************************************************************/
+
+
+void QApplicationPrivate::openPopup(QWidget *popup)
+{
+    if (!QApplicationPrivate::popupWidgets)
+        QApplicationPrivate::popupWidgets = new QWidgetList;
+    QApplicationPrivate::popupWidgets->append(popup);
+    if (!popup->isEnabled())
+        return;
+
+    if (QApplicationPrivate::popupWidgets->count() == 1 && !qt_nograb()) {
+        Q_ASSERT(popup->testAttribute(Qt::WA_WState_Created));
+//        setAutoCapture(popup->internalWinId());        // grab mouse/keyboard
+    }
+    // Popups are not focus-handled by the window system (the first
+    // popup grabbed the keyboard), so we have to do that manually: A
+    // new popup gets the focus
+    if (popup->focusWidget()) {
+        popup->focusWidget()->setFocus(Qt::PopupFocusReason);
+    } else if (QApplicationPrivate::popupWidgets->count() == 1) { // this was the first popup
+        if (QWidget *fw = q_func()->focusWidget()) {
+            QFocusEvent e(QEvent::FocusOut, Qt::PopupFocusReason);
+            q_func()->sendEvent(fw, &e);
+        }
+    }
+}
+
+void QApplicationPrivate::closePopup(QWidget *popup)
+{
+    if (!QApplicationPrivate::popupWidgets)
+        return;
+    QApplicationPrivate::popupWidgets->removeAll(popup);
+//    POINT curPos;
+//    GetCursorPos(&curPos);
+
+    if (QApplicationPrivate::popupWidgets->isEmpty()) { // this was the last popup
+        delete QApplicationPrivate::popupWidgets;
+        QApplicationPrivate::popupWidgets = 0;
+//        replayPopupMouseEvent = (!popup->geometry().contains(QPoint(curPos.x, curPos.y))
+//                                && !popup->testAttribute(Qt::WA_NoMouseReplay));
+        if (!popup->isEnabled())
+            return;
+//        if (!qt_nograb())                        // grabbing not disabled
+//            releaseAutoCapture();
+        QWidget *fw = QApplicationPrivate::active_window ? QApplicationPrivate::active_window->focusWidget()
+            : q_func()->focusWidget();
+        if (fw) {
+            if (fw != q_func()->focusWidget()) {
+                fw->setFocus(Qt::PopupFocusReason);
+            } else {
+                QFocusEvent e(QEvent::FocusIn, Qt::PopupFocusReason);
+                q_func()->sendEvent(fw, &e);
+            }
+        }
+    } else {
+        // Popups are not focus-handled by the window system (the
+        // first popup grabbed the keyboard), so we have to do that
+        // manually: A popup was closed, so the previous popup gets
+        // the focus.
+        QWidget* aw = QApplicationPrivate::popupWidgets->last();
+        if (QApplicationPrivate::popupWidgets->count() == 1) {
+            Q_ASSERT(aw->testAttribute(Qt::WA_WState_Created));
+//            setAutoCapture(aw->internalWinId());
+        }
+        if (QWidget *fw = aw->focusWidget())
+            fw->setFocus(Qt::PopupFocusReason);
+    }
+}
+
+void QApplicationPrivate::initializeWidgetPaletteHash()
+{
+	qDebug("Unimplemented:  QApplicationPrivate::initializeWidgetPaletteHash\n");
+}
+
+/*! \internal
+    apply the settings to the application
+*/
+bool QApplicationPrivate::haiku_apply_settings()
+{
+    QSettings settings(QSettings::UserScope, QLatin1String("Trolltech"));
+
+    settings.beginGroup(QLatin1String("Qt"));
+
+    /*
+      Qt settings. This is now they are written into the datastream.
+
+      Palette / *                - QPalette
+      font                       - QFont
+      libraryPath                - QStringList
+      style                      - QString
+      doubleClickInterval        - int
+      keyboardInputInterval  - int
+      cursorFlashTime            - int
+      wheelScrollLines           - int
+      colorSpec                  - QString
+      defaultCodec               - QString
+      globalStrut/width          - int
+      globalStrut/height         - int
+      GUIEffects                 - QStringList
+      Font Substitutions/ *      - QStringList
+      Font Substitutions/...     - QStringList
+    */
+
+    QStringList strlist;
+    int i;
+    QPalette pal(Qt::black);
+    int groupCount = 0;
+    strlist = settings.value(QLatin1String("Palette/active")).toStringList();
+    if (!strlist.isEmpty()) {
+        ++groupCount;
+        for (i = 0; i < qMin(strlist.count(), int(QPalette::NColorRoles)); i++)
+            pal.setColor(QPalette::Active, (QPalette::ColorRole) i,
+                         QColor(strlist[i]));
+    }
+    strlist = settings.value(QLatin1String("Palette/inactive")).toStringList();
+    if (!strlist.isEmpty()) {
+        ++groupCount;
+        for (i = 0; i < qMin(strlist.count(), int(QPalette::NColorRoles)); i++)
+            pal.setColor(QPalette::Inactive, (QPalette::ColorRole) i,
+                         QColor(strlist[i]));
+    }
+    strlist = settings.value(QLatin1String("Palette/disabled")).toStringList();
+    if (!strlist.isEmpty()) {
+        ++groupCount;
+        for (i = 0; i < qMin(strlist.count(), int(QPalette::NColorRoles)); i++)
+            pal.setColor(QPalette::Disabled, (QPalette::ColorRole) i,
+                         QColor(strlist[i]));
+    }
+ 
+/*    if (!appFont) {
+        QFont font(QApplication::font());
+        QString fontDescription;
+        if (fontDescription.isEmpty())
+            fontDescription = settings.value(QLatin1String("font")).toString();
+        if (!fontDescription .isEmpty()) {
+            font.fromString(fontDescription );
+            QApplicationPrivate::setSystemFont(font);
+        }
+    }*/
+
+    // read new QStyle
+    QString stylename = settings.value(QLatin1String("style")).toString();
+    if (stylename.isEmpty() && QApplicationPrivate::styleOverride.isNull()) {
+        QStringList availableStyles = QStyleFactory::keys();
+    }
+
+    static QString currentStyleName = stylename;
+    if (QCoreApplication::startingUp()) {
+        if (!stylename.isEmpty() && QApplicationPrivate::styleOverride.isNull())
+            QApplicationPrivate::styleOverride = stylename;
+    } else {
+        if (currentStyleName != stylename) {
+            currentStyleName = stylename;
+            QApplication::setStyle(stylename);
+        }
+    }
+
+    int num =
+        settings.value(QLatin1String("doubleClickInterval"),
+                       QApplication::doubleClickInterval()).toInt();
+    QApplication::setDoubleClickInterval(num);
+
+    num =
+        settings.value(QLatin1String("cursorFlashTime"),
+                       QApplication::cursorFlashTime()).toInt();
+    QApplication::setCursorFlashTime(num);
+
+    num =
+        settings.value(QLatin1String("wheelScrollLines"),
+                       QApplication::wheelScrollLines()).toInt();
+    QApplication::setWheelScrollLines(num);
+
+    QString colorspec = settings.value(QLatin1String("colorSpec"),
+                                       QVariant(QLatin1String("default"))).toString();
+    if (colorspec == QLatin1String("normal"))
+        QApplication::setColorSpec(QApplication::NormalColor);
+    else if (colorspec == QLatin1String("custom"))
+        QApplication::setColorSpec(QApplication::CustomColor);
+    else if (colorspec == QLatin1String("many"))
+        QApplication::setColorSpec(QApplication::ManyColor);
+    else if (colorspec != QLatin1String("default"))
+        colorspec = QLatin1String("default");
+
+/*    QString defaultcodec = settings.value(QLatin1String("defaultCodec"),
+                                          QVariant(QLatin1String("none"))).toString();
+    if (defaultcodec != QLatin1String("none")) {
+        QTextCodec *codec = QTextCodec::codecForName(defaultcodec.toLatin1());
+        if (codec)
+            QTextCodec::setCodecForTr(codec);
+    }*/
+    QTextCodec *codec = QTextCodec::codecForName("UTF-8");
+    if (codec) {
+     	QTextCodec::setCodecForLocale(codec);
+    }           	
+    qt_input_mapper = QTextCodec::codecForName("UTF-8");
+    
+
+    int w = settings.value(QLatin1String("globalStrut/width")).toInt();
+    int h = settings.value(QLatin1String("globalStrut/height")).toInt();
+    QSize strut(w, h);
+    if (strut.isValid())
+        QApplication::setGlobalStrut(strut);
+
+    QStringList effects = settings.value(QLatin1String("GUIEffects")).toStringList();
+    QApplication::setEffectEnabled(Qt::UI_General,
+                                   effects.contains(QLatin1String("general")));
+    QApplication::setEffectEnabled(Qt::UI_AnimateMenu,
+                                   effects.contains(QLatin1String("animatemenu")));
+    QApplication::setEffectEnabled(Qt::UI_FadeMenu,
+                                   effects.contains(QLatin1String("fademenu")));
+    QApplication::setEffectEnabled(Qt::UI_AnimateCombo,
+                                   effects.contains(QLatin1String("animatecombo")));
+    QApplication::setEffectEnabled(Qt::UI_AnimateTooltip,
+                                   effects.contains(QLatin1String("animatetooltip")));
+    QApplication::setEffectEnabled(Qt::UI_FadeTooltip,
+                                   effects.contains(QLatin1String("fadetooltip")));
+    QApplication::setEffectEnabled(Qt::UI_AnimateToolBox,
+                                   effects.contains(QLatin1String("animatetoolbox")));
+
+  	settings.beginGroup(QLatin1String("Font Substitutions"));
+    QStringList fontsubs = settings.childKeys();
+    if (!fontsubs.isEmpty()) {
+         QStringList::Iterator it = fontsubs.begin();
+         for (; it != fontsubs.end(); ++it) {
+             QString fam = *it;
+             QStringList subs = settings.value(fam).toStringList();
+             QFont::insertSubstitutions(fam, subs);
+         }
+    }
+    settings.endGroup();
+    
+    settings.endGroup(); // Qt
+
+    return true;
+}
+
+
+void QApplicationPrivate::haiku_initialize_style()
+{
+    if (QApplicationPrivate::app_style)
+        return;
+
+    QApplicationPrivate::app_style = QStyleFactory::create(QLatin1String("haiku"));        
+}
+
+/*****************************************************************************
+  Modal widgets; We have implemented our own modal widget mechanism
+  to get total control.
+  A modal widget without a parent becomes application-modal.
+  A modal widget with a parent becomes modal to its parent and grandparents..
+
+  QApplicationPrivate::enterModal()
+        Enters modal state
+        Arguments:
+            QWidget *widget        A modal widget
+
+  QApplicationPrivate::leaveModal()
+        Leaves modal state for a widget
+        Arguments:
+            QWidget *widget        A modal widget
+ *****************************************************************************/
+
+bool QApplicationPrivate::modalState()
+{
+	//qDebug()<<"Unimplemented: QApplicationPrivate::modalState():"<<app_do_modal;
+	return app_do_modal;
+}
+
+void QApplicationPrivate::enterModal_sys(QWidget *widget)
+{
+//	qDebug()<<"Unimplemented: QApplicationPrivate::enterModal_sys(). Widget:"<<widget;
+
+    if (!qt_modal_stack)
+        qt_modal_stack = new QWidgetList;
+
+//    releaseAutoCapture();
+//    ClipCursor(0);
+    QWidget *leave = qt_last_mouse_receiver;
+    if (!leave)
+        leave = QWidget::find(curWin);
+    QApplicationPrivate::dispatchEnterLeave(0, leave);
+    qt_modal_stack->insert(0, widget);
+    app_do_modal = true;
+    curWin = 0;
+    qt_last_mouse_receiver = 0;
+    qt_win_ignoreNextMouseReleaseEvent = false;
+}
+
+void QApplicationPrivate::leaveModal_sys(QWidget *widget)
+{
+	//qDebug()<<"Unimplemented: QApplicationPrivate::leaveModal_sys(). Widget:"<<widget;
+
+    if (qt_modal_stack && qt_modal_stack->removeAll(widget)) {
+        if (qt_modal_stack->isEmpty()) {
+            delete qt_modal_stack;
+            qt_modal_stack = 0;
+            QPoint p(QCursor::pos());
+            app_do_modal = false; // necessary, we may get recursively into qt_try_modal below
+            QWidget* w = QApplication::widgetAt(p.x(), p.y());
+            QWidget *leave = qt_last_mouse_receiver;
+            if (!leave)
+                leave = QWidget::find((WId)curWin);
+            if (QWidget *grabber = QWidget::mouseGrabber()) {
+                w = grabber;
+                if (leave == w)
+                    leave = 0;
+            }
+            QApplicationPrivate::dispatchEnterLeave(w, leave); // send synthetic enter event
+            curWin = w ? w->effectiveWinId() : 0;
+            qt_last_mouse_receiver = w;
+        }
+        qt_win_ignoreNextMouseReleaseEvent = true;
+    }
+    app_do_modal = qt_modal_stack != 0;
+}
+
+
+/*****************************************************************************
+  Platform specific QApplication members
+ *****************************************************************************/
+
+#ifdef QT3_SUPPORT
+void QApplication::setMainWidget(QWidget *mainWidget)
+{
+#ifndef QT_NO_DEBUG
+    if (mainWidget && mainWidget->parentWidget() && mainWidget->isWindow())
+        qWarning("QApplication::setMainWidget: New main widget (%s/%s) "
+                  "has a parent",
+                  mainWidget->metaObject()->className(), mainWidget->objectName().toLocal8Bit().constData());
+#endif
+    if (mainWidget)
+        mainWidget->d_func()->createWinId();
+    QApplicationPrivate::main_widget = mainWidget;
+}
+#endif
+
+void QApplication::setDoubleClickInterval(int ms)
+{
+//	qDebug("Reimplemented: QApplicationPrivate::setDoubleClickInterval - %d\n", ms);	
+#if 0	//change system dblclick interval currently disabled
+	QApplicationPrivate::mouse_double_click_time = ms;
+	bigtime_t	interval = ms*1000;
+	set_click_speed(interval);
+#endif
+}
+
+int QApplication::doubleClickInterval()
+{
+	bigtime_t	interval;
+	get_click_speed(&interval);
+		
+	QApplicationPrivate::mouse_double_click_time = (int)(interval/1000);
+	
+	return QApplicationPrivate::mouse_double_click_time;
+}
+
+void QApplication::setKeyboardInputInterval(int ms)
+{
+    QApplicationPrivate::keyboard_input_time = ms;
+}
+
+int QApplication::keyboardInputInterval()
+{
+    // FIXME: get from the system
+    return QApplicationPrivate::keyboard_input_time;
+}
+
+void QApplication::setWheelScrollLines(int n)
+{
+    QApplicationPrivate::wheel_scroll_lines = n;
+}
+
+int QApplication::wheelScrollLines()
+{
+    return QApplicationPrivate::wheel_scroll_lines;
+}
+
+void QApplication::setOverrideCursor(const QCursor &cursor)
+{
+	Q_UNUSED(cursor);
+	qDebug("Unimplemented: QApplication::setOverrideCursor\n");
+}
+
+void QApplication::restoreOverrideCursor()
+{
+	qDebug("Unimplemented: QApplication::restoreOverrideCursor\n");
+}
+
+void QApplication::setEffectEnabled(Qt::UIEffect effect, bool enable)
+{
+	Q_UNUSED(effect);
+	Q_UNUSED(enable);
+//	qDebug("Unimplemented: QApplication::setEffectEnabled\n");
+}
+
+bool QApplication::isEffectEnabled(Qt::UIEffect effect)
+{
+	Q_UNUSED(effect);
+//	qDebug("Unimplemented: QApplication::isEffectEnabled\n");
+	return false;
+}
+
+void  QApplication::setCursorFlashTime(int msecs)
+{
+	QApplicationPrivate::cursor_flash_time = msecs;
+}
+
+int QApplication::cursorFlashTime()
+{
+	return QApplicationPrivate::cursor_flash_time;
+}
+
+QWidget *QApplication::topLevelAt(const QPoint &point)
+{
+    QWidget *found = 0;
+    int lowestZ = INT_MAX;
+    QWidgetList list = QApplication::topLevelWidgets();
+    for (int i = 0; i < list.count(); ++i) {
+        QWidget *widget = list.at(i);
+        if (widget->isVisible() && !(widget->windowType() == Qt::Desktop)) {
+            if (widget->geometry().adjusted(0,0,1,1).contains(point)) {            	    
+                    found = widget;			//TODO: check for z-order needed!
+                   	if(widget->nativeView()->Window()->IsActive())
+                   		break;
+            }
+        }
+    }
+    return found;
+}
+
+void QApplication::beep()
+{
+}
+
+void QApplication::alert(QWidget *widget, int duration)
+{
+}
+
+void QApplicationPrivate::initializeMultitouch_sys()
+{
+}
+
+void QApplicationPrivate::cleanupMultitouch_sys()
+{
+}
diff -rupN qt-everywhere-opensource-src-4.7.3/src/gui/kernel/qapplication_p.h qt-everywhere-opensource-src-4.7.3_haiku/src/gui/kernel/qapplication_p.h
--- qt-everywhere-opensource-src-4.7.3/src/gui/kernel/qapplication_p.h	2011-03-30 05:19:04.050331648 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/gui/kernel/qapplication_p.h	2011-06-13 22:06:43.293339136 +0000
@@ -302,6 +302,8 @@ public:
 #elif defined(Q_WS_QWS)
     static bool qws_apply_settings();
     static QWidget *findWidget(const QObjectList&, const QPoint &, bool rec);
+#elif defined(Q_WS_HAIKU)
+    static bool haiku_apply_settings();    
 #endif
     static bool quitOnLastWindowClosed;
     static void emitLastWindowClosed();
@@ -349,6 +351,10 @@ public:
     static void x11_initialize_style();
 #endif
 
+#if defined(Q_WS_HAIKU)
+    static void haiku_initialize_style();
+#endif
+
     enum KeyPlatform {
         KB_Win = 1,
         KB_Mac = 2,
@@ -499,7 +505,7 @@ public:
     static Qt::NavigationMode navigationMode;
 #endif
 
-#if defined(Q_WS_MAC) || defined(Q_WS_X11)
+#if defined(Q_WS_MAC) || defined(Q_WS_X11) || defined(Q_WS_HAIKU)
     void _q_alertTimeOut();
     QHash<QWidget *, QTimer *> alertTimerHash;
 #endif
diff -rupN qt-everywhere-opensource-src-4.7.3/src/gui/kernel/qclipboard_haiku.cpp qt-everywhere-opensource-src-4.7.3_haiku/src/gui/kernel/qclipboard_haiku.cpp
--- qt-everywhere-opensource-src-4.7.3/src/gui/kernel/qclipboard_haiku.cpp	1970-01-01 00:00:00.000000000 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/gui/kernel/qclipboard_haiku.cpp	2011-06-13 22:06:43.295174144 +0000
@@ -0,0 +1,105 @@
+#include "qplatformdefs.h"
+#include "qclipboard.h"
+#include "qdebug.h"
+#include "qtextcodec.h"
+#include "qclipboard_p.h"
+#include "qstringlist.h"
+#include <stdio.h>
+
+#include <String.h>
+#include <Clipboard.h>
+
+bool QClipboard::event(QEvent *e)
+{
+	return true;
+}
+
+void QClipboard::connectNotify(const char *)
+{ }
+
+void QClipboard::ownerDestroyed()
+{ }
+
+const QMimeData *QClipboard::mimeData(Mode mode) const
+{
+	extern QTextCodec *qt_input_mapper; // from qapplication_haiku.cpp
+	
+	QMimeData *md = new QMimeData();
+	if(mode == Clipboard) {		
+		BMessage* clip = (BMessage *)NULL;
+	  	if (be_clipboard->Lock()) {
+	    	if( clip = be_clipboard->Data()) {
+	    		BMessage *msg = (BMessage*)(be_clipboard->Data());
+	    		
+				char *name;
+				uint32 type;
+				int32 count;
+
+				for ( int i = 0; msg->GetInfo(B_MIME_TYPE, i, &name, &type, &count) == B_OK; i++ ) {
+					const void *data;
+					int32 dataLen = 0;
+					qDebug() << "mimeData " << name;
+					status_t stat = msg->FindData(name,B_MIME_TYPE,&data,&dataLen);
+					if(dataLen && stat==B_OK)	{
+						QString mime(name);
+						if(mime=="text/plain") {
+							QString text((const char*)data);
+						    if (qt_input_mapper)
+        						text = qt_input_mapper->toUnicode((const char*)data, dataLen, 0);
+							md->setText(text);
+						} else if(mime=="text/html") {
+							QString html((const char*)data);
+						    if (qt_input_mapper)
+        						html = qt_input_mapper->toUnicode((const char*)data, dataLen, 0);
+							md->setHtml(html);
+						} else {
+							QByteArray clip_data((const char*)data, dataLen);
+							md->setData(mime,clip_data);
+						}
+
+					}
+				}								
+				be_clipboard->Unlock();
+	    	}
+		}			
+	} 
+	return md;
+}
+
+void QClipboard::setMimeData(QMimeData *src, Mode mode)
+{	
+	if(mode != Clipboard)
+		return;
+	if (be_clipboard->Lock()) {
+		be_clipboard->Clear();
+		if (src){
+			BMessage* clip = (BMessage *)NULL;
+	    	if( clip = be_clipboard->Data()) {
+	    		QStringList formats = src->formats();
+				for(int f = 0; f < formats.size(); ++f) {
+            		QString mimeType = formats.at(f);	    			
+            		qDebug() << "setMimeData " << mimeType;         		
+					clip->AddData(mimeType.toUtf8(), B_MIME_TYPE, src->data(mimeType).data(), src->data(mimeType).count());
+	    		}
+	    	}
+		}
+		be_clipboard->Commit();
+	   	be_clipboard->Unlock();
+	}
+}
+
+void QClipboard::clear(Mode mode)
+{
+    setMimeData(0, mode);
+}
+
+bool QClipboard::supportsMode(QClipboard::Mode mode) const
+{
+	return (mode == Clipboard);
+}
+
+bool QClipboard::ownsMode(QClipboard::Mode) const
+{
+    fprintf(stderr, "Unimplemented: QClipboard::ownsMode\n");
+    return false;
+}
diff -rupN qt-everywhere-opensource-src-4.7.3/src/gui/kernel/qcursor.h qt-everywhere-opensource-src-4.7.3_haiku/src/gui/kernel/qcursor.h
--- qt-everywhere-opensource-src-4.7.3/src/gui/kernel/qcursor.h	2011-03-30 05:19:04.046399488 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/gui/kernel/qcursor.h	2011-06-13 22:06:43.297271296 +0000
@@ -76,6 +76,10 @@ class QCursorData;
 class QBitmap;
 class QPixmap;
 
+#if defined(Q_WS_HAIKU)
+class BCursor;
+#endif
+
 #if defined(Q_WS_MAC)
 void qt_mac_set_cursor(const QCursor *c, const QPoint &p);
 #endif
@@ -130,6 +134,8 @@ public:
     int handle() const;
 #elif defined(Q_OS_SYMBIAN)
     Qt::HANDLE handle() const;
+#elif defined(Q_WS_HAIKU)
+    BCursor *handle() const;    
 #endif
 #endif
 
diff -rupN qt-everywhere-opensource-src-4.7.3/src/gui/kernel/qcursor_haiku.cpp qt-everywhere-opensource-src-4.7.3_haiku/src/gui/kernel/qcursor_haiku.cpp
--- qt-everywhere-opensource-src-4.7.3/src/gui/kernel/qcursor_haiku.cpp	1970-01-01 00:00:00.000000000 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/gui/kernel/qcursor_haiku.cpp	2011-06-13 22:06:43.299630592 +0000
@@ -0,0 +1,93 @@
+#include "qcursor.h"
+#include "qcursor_p.h"
+
+#include <Application.h>
+#include <Cursor.h>
+
+#include <stdio.h>
+
+int	haiku_global_mouse_x = 0;
+int	haiku_global_mouse_y = 0;
+
+BCursor *HaikuCursorCache[32]={NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,
+							   NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL};
+
+int	CursorMapList[]={	Qt::ArrowCursor,		B_CURSOR_ID_SYSTEM_DEFAULT,
+						Qt::UpArrowCursor,		B_CURSOR_ID_RESIZE_NORTH,
+						Qt::CrossCursor,		B_CURSOR_ID_CROSS_HAIR,
+						Qt::WaitCursor,			B_CURSOR_ID_PROGRESS,
+						Qt::IBeamCursor,		B_CURSOR_ID_I_BEAM,
+						Qt::SizeVerCursor,		B_CURSOR_ID_RESIZE_NORTH_SOUTH,
+						Qt::SizeHorCursor,		B_CURSOR_ID_RESIZE_EAST_WEST,
+						Qt::SizeBDiagCursor,	B_CURSOR_ID_RESIZE_NORTH_EAST_SOUTH_WEST,
+						Qt::SizeFDiagCursor,	B_CURSOR_ID_RESIZE_NORTH_WEST_SOUTH_EAST,
+						Qt::SizeAllCursor,		B_CURSOR_ID_MOVE,
+						Qt::BlankCursor,		B_CURSOR_ID_NO_CURSOR,
+						Qt::SplitVCursor,		B_CURSOR_ID_RESIZE_NORTH_SOUTH,
+						Qt::SplitHCursor,		B_CURSOR_ID_RESIZE_EAST_WEST,
+						Qt::PointingHandCursor,	B_CURSOR_ID_FOLLOW_LINK,
+						Qt::ForbiddenCursor,	B_CURSOR_ID_NOT_ALLOWED,
+						Qt::OpenHandCursor,		B_CURSOR_ID_GRAB,
+						Qt::ClosedHandCursor,	B_CURSOR_ID_GRABBING,
+						Qt::WhatsThisCursor,	B_CURSOR_ID_HELP,
+						Qt::BusyCursor,			B_CURSOR_ID_PROGRESS
+};
+
+
+extern QCursorData *qt_cursorTable[Qt::LastCursor + 1]; // qcursor.cpp
+
+QPoint QCursor::pos()
+{
+	return QPoint(haiku_global_mouse_x,haiku_global_mouse_y);
+}
+
+void QCursor::setPos(int x, int y)
+{
+//	haiku_global_mouse_x = x;
+//	haiku_global_mouse_y = y;
+}
+
+BCursor *QCursor::handle() const
+{
+	int i;
+	
+    if (!QCursorData::initialized)
+        QCursorData::initialize();
+	
+	for(i=0;i<sizeof(CursorMapList)/2;i+=2) {
+		if(CursorMapList[i]==d->cshape) {
+			if(HaikuCursorCache[CursorMapList[i+1]])
+				return HaikuCursorCache[CursorMapList[i+1]];
+		}
+	}
+				
+	return (BCursor*)B_CURSOR_SYSTEM_DEFAULT;
+}
+
+QCursorData::QCursorData(Qt::CursorShape s)
+    : cshape(s), bm(0), bmm(0), hx(0), hy(0)
+{
+	int i;
+	for(i=0;i<sizeof(CursorMapList)/2;i+=2) {
+		if(CursorMapList[i]==s) {
+			if(!HaikuCursorCache[CursorMapList[i+1]])
+				HaikuCursorCache[CursorMapList[i+1]] = new BCursor((BCursorID)CursorMapList[i+1]);					
+		}
+	}
+	
+    ref = 1;
+}
+
+QCursorData::~QCursorData()
+{ }
+
+
+QCursorData *QCursorData::setBitmap(const QBitmap &bmp, const QBitmap &mask,  int x, int y)
+{
+    if (!QCursorData::initialized)
+        QCursorData::initialize();
+
+    QCursorData *c = qt_cursorTable[0];
+    c->ref.ref();
+    return c;
+}
diff -rupN qt-everywhere-opensource-src-4.7.3/src/gui/kernel/qdesktopwidget_haiku.cpp qt-everywhere-opensource-src-4.7.3_haiku/src/gui/kernel/qdesktopwidget_haiku.cpp
--- qt-everywhere-opensource-src-4.7.3/src/gui/kernel/qdesktopwidget_haiku.cpp	1970-01-01 00:00:00.000000000 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/gui/kernel/qdesktopwidget_haiku.cpp	2011-06-13 22:06:43.301465600 +0000
@@ -0,0 +1,75 @@
+#include "qdesktopwidget.h"
+#include "interface/Screen.h"
+
+
+#include <stdio.h>
+
+QDesktopWidget::QDesktopWidget()
+    : QWidget(0, Qt::Desktop)
+{
+	//fprintf(stderr, "Unimplemented: QDesktopWidget::QDesktopWidget\n");
+}
+
+QDesktopWidget::~QDesktopWidget()
+{
+	//fprintf(stderr, "Unimplemented: QDesktopWidget::~QDesktopWidget\n");
+}
+
+void
+QDesktopWidget::resizeEvent(QResizeEvent*)
+{
+	fprintf(stderr, "Unimplemented: QDesktopWidget::resizeEvent\n");
+}
+
+const QRect QDesktopWidget::availableGeometry(int screen) const
+{
+	BScreen bscreen(B_MAIN_SCREEN_ID);
+	BRect nsg  = bscreen.Frame();
+	return QRect(nsg.left,nsg.top,nsg.right,nsg.bottom);
+}
+
+const QRect QDesktopWidget::screenGeometry(int screen) const
+{
+	BScreen bscreen(B_MAIN_SCREEN_ID);
+	BRect nsg  = bscreen.Frame();
+	return QRect(nsg.left,nsg.top,nsg.right,nsg.bottom);
+}
+
+int QDesktopWidget::screenNumber(const QWidget *widget) const
+{
+	Q_UNUSED(widget);
+	//fprintf(stderr, "Reimplemented: QDesktopWidget::screenNumber(widget) \n");
+	return 0;
+}
+
+int QDesktopWidget::screenNumber(const QPoint &point) const
+{
+	Q_UNUSED(point);
+	//fprintf(stderr, "Reimplemented: QDesktopWidget::screenNumber\n");
+	return 0;
+}
+
+bool QDesktopWidget::isVirtualDesktop() const
+{
+	//fprintf(stderr, "Unimplemented: QDesktopWidget::isVirtualDesktop\n");
+	return true;
+}
+
+int QDesktopWidget::primaryScreen() const
+{
+	//fprintf(stderr, "Unimplemented: QDesktopWidget::primaryScreen\n");
+	return 0;
+}
+
+int QDesktopWidget::numScreens() const
+{
+	//fprintf(stderr, "Unimplemented: QDesktopWidget::numScreens\n");
+	return 1;
+}
+
+QWidget *QDesktopWidget::screen(int /* screen */)
+{
+	//fprintf(stderr, "Unimplemented: QDesktopWidget::screen\n");
+	// It seems that a Qt::WType_Desktop cannot be moved?
+	return this;
+}
diff -rupN qt-everywhere-opensource-src-4.7.3/src/gui/kernel/qdnd_haiku.cpp qt-everywhere-opensource-src-4.7.3_haiku/src/gui/kernel/qdnd_haiku.cpp
--- qt-everywhere-opensource-src-4.7.3/src/gui/kernel/qdnd_haiku.cpp	1970-01-01 00:00:00.000000000 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/gui/kernel/qdnd_haiku.cpp	2011-06-13 22:06:43.304349184 +0000
@@ -0,0 +1,274 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the QtGui module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** No Commercial Usage
+** This file contains pre-release code and may not be distributed.
+** You may use this file in accordance with the terms and conditions
+** contained in the Technology Preview License Agreement accompanying
+** this package.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights.  These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** If you have questions regarding the use of this file, please contact
+** Nokia at qt-info@nokia.com.
+**
+**
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qapplication.h"
+
+#ifndef QT_NO_DRAGANDDROP
+
+#include "qdebug.h"
+
+#include "qwidget.h"
+#include "qdatetime.h"
+#include "qbitmap.h"
+#include "qcursor.h"
+#include "qevent.h"
+#include "qpainter.h"
+#include "qdnd_p.h"
+
+#include <QCursor>
+
+QT_BEGIN_NAMESPACE
+
+static Qt::DropAction global_accepted_action = Qt::MoveAction;
+static Qt::DropActions possible_actions = Qt::IgnoreAction;
+
+static QDrag *drag_object;
+static bool qt_haiku_dnd_dragging = false;
+
+
+static Qt::KeyboardModifiers oldstate;
+
+void QDragManager::updatePixmap() { }
+void QDragManager::timerEvent(QTimerEvent *) { }
+void QDragManager::move(const QPoint&) { }
+void QDragManager::updateCursor() { }
+
+bool QDragManager::eventFilter(QObject *o, QEvent *e)
+{
+ if (beingCancelled) {
+        return false;
+    }
+    if (!o->isWidgetType())
+        return false;
+
+    switch(e->type()) {
+        case QEvent::MouseButtonPress:
+        {
+        }
+        case QEvent::MouseMove:
+        {
+            if (!object) { //#### this should not happen
+                qWarning("QDragManager::eventFilter: No object");
+                return true;
+            }
+            QDragManager *manager = QDragManager::self();
+            QMimeData *dropData = manager->object ? manager->dragPrivate()->data : manager->dropData;
+            if (manager->object)
+                possible_actions =  manager->dragPrivate()->possible_actions;
+            else
+                possible_actions = Qt::IgnoreAction;
+
+            QMouseEvent *me = (QMouseEvent *)e;
+
+            if (me->buttons()) {
+                Qt::DropAction prevAction = global_accepted_action;
+                QWidget *cw = QApplication::widgetAt(me->globalPos());                
+                // map the Coords relative to the window.
+                if (!cw)
+                    return true;
+
+                while (cw && !cw->acceptDrops() && !cw->isWindow())
+                    cw = cw->parentWidget();
+
+                bool oldWillDrop = willDrop;
+                if (object->target() != cw) {
+                    if (object->target()) {
+                        QDragLeaveEvent dle;
+                        QApplication::sendEvent(object->target(), &dle);
+                        willDrop = false;
+                        global_accepted_action = Qt::IgnoreAction;
+                        if (oldWillDrop != willDrop)
+                            updateCursor();
+                        object->d_func()->target = 0;
+                    }
+                    if (cw && cw->acceptDrops()) {
+                        object->d_func()->target = cw;
+                        QDragEnterEvent dee(cw->mapFromGlobal(me->globalPos()), possible_actions, dropData,
+                                            me->buttons(), me->modifiers());
+                        QApplication::sendEvent(object->target(), &dee);
+                        willDrop = dee.isAccepted() && dee.dropAction() != Qt::IgnoreAction;
+                        global_accepted_action = willDrop ? dee.dropAction() : Qt::IgnoreAction;
+                        if (oldWillDrop != willDrop)
+                            updateCursor();
+                    }
+                } else if (cw) {
+                    QDragMoveEvent dme(cw->mapFromGlobal(me->globalPos()), possible_actions, dropData,
+                                       me->buttons(), me->modifiers());
+                    if (global_accepted_action != Qt::IgnoreAction) {
+                        dme.setDropAction(global_accepted_action);
+                        dme.accept();
+                    }
+                    QApplication::sendEvent(cw, &dme);
+                    willDrop = dme.isAccepted();
+                    global_accepted_action = willDrop ? dme.dropAction() : Qt::IgnoreAction;
+                    if (oldWillDrop != willDrop) {
+                        updatePixmap();
+                        updateCursor();
+                    }
+                }
+                if (global_accepted_action != prevAction)
+                    emitActionChanged(global_accepted_action);
+            }
+            return true; // Eat all mouse events
+        }
+
+        case QEvent::MouseButtonRelease:
+        {
+            qApp->removeEventFilter(this);
+#ifndef QT_NO_CURSOR
+            if (restoreCursor) {
+                QApplication::restoreOverrideCursor();
+                willDrop = false;
+                restoreCursor = false;
+            }
+#endif
+            if (object && object->target()) {
+
+                QMouseEvent *me = (QMouseEvent *)e;
+
+                QDragManager *manager = QDragManager::self();
+                QMimeData *dropData = manager->object ? manager->dragPrivate()->data : manager->dropData;
+
+                QDropEvent de(object->target()->mapFromGlobal(me->globalPos()), possible_actions, dropData,
+                              me->buttons(), me->modifiers());
+                QApplication::sendEvent(object->target(), &de);
+                if (de.isAccepted())
+                    global_accepted_action = de.dropAction();
+                else
+                    global_accepted_action = Qt::IgnoreAction;
+
+                if (object)
+                    object->deleteLater();
+                drag_object = object = 0;
+            }
+            eventLoop->exit();
+            return true; // Eat all mouse events
+        }
+
+        default:
+             break;
+    }
+    return false;
+}
+
+Qt::DropAction QDragManager::drag(QDrag *o)
+{	
+    if (object == o || !o || !o->source()) {
+         return Qt::IgnoreAction;
+    }
+
+    if (object) {
+        cancel();
+        qApp->removeEventFilter(this);
+        beingCancelled = false;
+    }
+
+    object = drag_object = o;
+
+    oldstate = Qt::NoModifier; // #### Should use state that caused the drag
+    willDrop = false;
+
+    object->d_func()->target = 0;
+
+    qApp->installEventFilter(this);
+
+    global_accepted_action = defaultAction(dragPrivate()->possible_actions, Qt::NoModifier);
+    qt_haiku_dnd_dragging = true;
+
+    eventLoop = new QEventLoop;
+    // block
+    (void) eventLoop->exec(QEventLoop::AllEvents);
+    delete eventLoop;
+    eventLoop = 0;
+
+    qt_haiku_dnd_dragging = false;
+
+    return global_accepted_action;
+}
+
+
+void QDragManager::cancel(bool deleteSource)
+{
+    beingCancelled = true;
+
+    if (object->target()) {
+        QDragLeaveEvent dle;
+        QApplication::sendEvent(object->target(), &dle);
+    }
+
+    if (drag_object) {
+        if (deleteSource)
+            object->deleteLater();
+        drag_object = object = 0;
+    }
+
+    global_accepted_action = Qt::IgnoreAction;
+}
+
+
+void QDragManager::drop()
+{	
+}
+
+QVariant QDropData::retrieveData_sys(const QString &mimetype, QVariant::Type type) const
+{
+    if (!drag_object)
+        return QVariant();
+    QByteArray data =  drag_object->mimeData()->data(mimetype);
+    if (type == QVariant::String)
+        return QString::fromUtf8(data);
+    return data;
+}
+
+bool QDropData::hasFormat_sys(const QString &format) const
+{
+    return formats().contains(format);
+}
+
+QStringList QDropData::formats_sys() const
+{
+    if (drag_object)
+        return drag_object->mimeData()->formats();
+    return QStringList();
+}
+
+QT_END_NAMESPACE
+#endif // QT_NO_DRAGANDDROP
diff -rupN qt-everywhere-opensource-src-4.7.3/src/gui/kernel/qeventdispatcher_haiku.cpp qt-everywhere-opensource-src-4.7.3_haiku/src/gui/kernel/qeventdispatcher_haiku.cpp
--- qt-everywhere-opensource-src-4.7.3/src/gui/kernel/qeventdispatcher_haiku.cpp	1970-01-01 00:00:00.000000000 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/gui/kernel/qeventdispatcher_haiku.cpp	2011-06-13 22:06:43.305922048 +0000
@@ -0,0 +1,94 @@
+#include <private/qabstracteventdispatcher_p.h>
+#include "qeventdispatcher_haiku_p.h"
+#include <private/qcoreapplication_p.h>
+#include <private/qthread_p.h>
+#include <private/qmutexpool_p.h>
+
+#include <Application.h>
+#include <stdio.h>
+
+// Debugging part
+
+#define DEBUG_HAIKU_LEVEL 0
+// 1 Unimplemented
+// 2-4 nothing
+// 5 reimplemented
+
+#if defined(DEBUG_HAIKU_LEVEL) && DEBUG_HAIKU_LEVEL > 0
+void debugprint(int level, const char *msg, ...)
+{
+	va_list args;
+	va_start(args, msg);
+	if (DEBUG_HAIKU_LEVEL >= level)
+		vfprintf(stderr, msg, args);
+	va_end(args);
+}
+#else
+#define debugprint(...)
+#endif
+
+class QEventDispatcherHaikuPrivate : public QEventDispatcherUNIXPrivate
+{
+	QEventDispatcherHaikuPrivate() : QEventDispatcherUNIXPrivate() { }
+	~QEventDispatcherHaikuPrivate() { }
+};
+
+QEventDispatcherHaiku::QEventDispatcherHaiku(QObject *parent)
+		: QEventDispatcherUNIX(*new QEventDispatcherUNIXPrivate, parent)
+{
+	debugprint(5, "Reimp: QEventDispatcherHaiku::QEventDispatcherHaiku \n");
+}
+QEventDispatcherHaiku::~QEventDispatcherHaiku()
+{
+	debugprint(5, "Reimp: QEventDispatcherHaiku::~QEventDispatcherHaiku \n");
+}
+
+bool  
+QEventDispatcherHaiku::processEvents(QEventLoop::ProcessEventsFlags  
+flags)
+{
+	Q_D(QEventDispatcherHaiku);
+	debugprint(5, "Reimp: QEventDispatcherHaiku::processEvents\n");
+
+    d->interrupt = false;
+    emit awake();
+
+    bool canWait = false;
+    bool retVal = false;
+    do {
+        QCoreApplicationPrivate::sendPostedEvents(0, 0, d->threadData);
+        QThreadData *data = d->threadData;
+        canWait = (//!retVal
+                    data->canWait
+                   && !d->interrupt
+                   && (flags & QEventLoop::WaitForMoreEvents));
+	} while (false);//canWait);
+
+	if (!d->interrupt) {
+//		fprintf(stderr, "Entering Unix processEvents\n");
+		bool result = QEventDispatcherUNIX::processEvents(flags);
+//		fprintf(stderr, "Exiting Unix processEvents\n");
+		return result;
+	}
+	return true;
+}
+bool QEventDispatcherHaiku::hasPendingEvents()
+{
+	debugprint(5, "Reimp: QEventDispatcherHaiku::hasPendingEvents\n");
+	return false;
+}
+
+void QEventDispatcherHaiku::flush()
+{
+	debugprint(5, "Reimp: QEventDispatcherHaiku::flush\n");
+}
+
+void QEventDispatcherHaiku::startingUp()
+{
+	debugprint(5, "Reimp: QEventDispatcherHaiku::startingUp\n");
+}
+void QEventDispatcherHaiku::closingDown()
+{
+	debugprint(5, "Reimp: QEventDispatcherHaiku::closingDown\n");
+}
+
diff -rupN qt-everywhere-opensource-src-4.7.3/src/gui/kernel/qeventdispatcher_haiku_p.h qt-everywhere-opensource-src-4.7.3_haiku/src/gui/kernel/qeventdispatcher_haiku_p.h
--- qt-everywhere-opensource-src-4.7.3/src/gui/kernel/qeventdispatcher_haiku_p.h	1970-01-01 00:00:00.000000000 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/gui/kernel/qeventdispatcher_haiku_p.h	2011-06-13 22:06:43.307757056 +0000
@@ -0,0 +1,28 @@
+#ifndef FEASOIFESWR
+#define FEASOIFESWR
+#include <private/qabstracteventdispatcher_p.h>
+#include <private/qeventdispatcher_unix_p.h>
+
+class QEventDispatcherHaikuPrivate;
+
+class QEventDispatcherHaiku : public QEventDispatcherUNIX
+{
+	//Q_OBJECT
+	Q_DECLARE_PRIVATE(QEventDispatcherHaiku)
+
+public:
+	explicit QEventDispatcherHaiku(QObject *parent = 0);
+	~QEventDispatcherHaiku();
+
+	bool processEvents(QEventLoop::ProcessEventsFlags flags);
+	bool hasPendingEvents();
+
+	void flush();
+
+	void startingUp();
+	void closingDown();
+
+protected:
+};
+
+#endif
diff -rupN qt-everywhere-opensource-src-4.7.3/src/gui/kernel/qguiplatformplugin.cpp qt-everywhere-opensource-src-4.7.3_haiku/src/gui/kernel/qguiplatformplugin.cpp
--- qt-everywhere-opensource-src-4.7.3/src/gui/kernel/qguiplatformplugin.cpp	2011-03-30 05:19:04.050069504 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/gui/kernel/qguiplatformplugin.cpp	2011-06-13 22:06:43.310378496 +0000
@@ -156,6 +156,8 @@ QString QGuiPlatformPlugin::styleName()
     return QLatin1String("Plastique");                  // default style for X11 and small devices
 #elif defined(Q_WS_MAC)
     return QLatin1String("Macintosh");              // default style for all Mac's
+#elif defined(Q_WS_HAIKU)
+    return QLatin1String("Haiku");              	// default style for Haiku    
 #elif defined(Q_WS_X11)
     QString stylename;
     switch(X11->desktopEnvironment) {
diff -rupN qt-everywhere-opensource-src-4.7.3/src/gui/kernel/qkeymapper_haiku.cpp qt-everywhere-opensource-src-4.7.3_haiku/src/gui/kernel/qkeymapper_haiku.cpp
--- qt-everywhere-opensource-src-4.7.3/src/gui/kernel/qkeymapper_haiku.cpp	1970-01-01 00:00:00.000000000 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/gui/kernel/qkeymapper_haiku.cpp	2011-06-13 22:06:43.312475648 +0000
@@ -0,0 +1,208 @@
+/****************************************************************************
+**
+** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the QtGui of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** No Commercial Usage
+** This file contains pre-release code and may not be distributed.
+** You may use this file in accordance with the terms and conditions
+** contained in the Technology Preview License Agreement accompanying
+** this package.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain
+** additional rights.  These rights are described in the Nokia Qt LGPL
+** Exception version 1.1, included in the file LGPL_EXCEPTION.txt in this
+** package.
+**
+** If you have questions regarding the use of this file, please contact
+** Nokia at qt-info@nokia.com.
+**
+**
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qkeymapper_p.h"
+
+#include <stdio.h>
+
+QKeyMapperPrivate::QKeyMapperPrivate()
+{
+ uint32 scan_codes[] = {
+        Qt::Key_Escape,		0x01,
+        Qt::Key_F1,			0x02,
+        Qt::Key_F2,			0x03,
+        Qt::Key_F3,			0x04,
+        Qt::Key_F4,			0x05,
+        Qt::Key_F5,			0x06,
+        Qt::Key_F6,			0x07,
+        Qt::Key_F7,			0x08,
+        Qt::Key_F8,			0x09,
+        Qt::Key_F9,			0x0A,
+        Qt::Key_F10,		0x0B,
+        Qt::Key_F11,		0x0C,
+        Qt::Key_F12,		0x0D,
+        Qt::Key_Print,		0x0E,
+//      Qt::Key_ScrollLock = 0x0F,  //modificator
+        Qt::Key_Pause,		0x22,
+
+		Qt::Key_AsciiTilde, 0x11,
+        Qt::Key_1,			0x12,
+        Qt::Key_2,			0x13,
+        Qt::Key_3,			0x14,
+        Qt::Key_4,			0x15,
+        Qt::Key_5,			0x16,
+        Qt::Key_6,			0x17,
+        Qt::Key_7,			0x18,
+        Qt::Key_8,			0x19,
+        Qt::Key_9,			0x1A,
+        Qt::Key_0,			0x1B,
+        Qt::Key_Minus,		0x1C,
+        Qt::Key_Plus,		0x1D,
+        Qt::Key_Backspace,	0x1E,
+        Qt::Key_Insert,		0x1F,
+        Qt::Key_Home,		0x20,
+        Qt::Key_PageUp,		0x21,
+//		Qt::Key_NumLock,	0x22,   //modificator    
+		Qt::Key_Slash,		0x23,
+		Qt::Key_Asterisk,	0x24,
+		Qt::Key_Minus,		0x25,		
+		                
+        Qt::Key_Tab,		0x26,        
+        Qt::Key_Q,			0x27,
+        Qt::Key_W,			0x28,
+        Qt::Key_E,			0x29,
+        Qt::Key_R,			0x2A,
+        Qt::Key_T,			0x2B,
+        Qt::Key_Y,			0x2C,
+        Qt::Key_U,			0x2D,
+        Qt::Key_I,			0x2E,
+        Qt::Key_O,			0x2F,
+        Qt::Key_P,			0x30,      
+        Qt::Key_BracketLeft,0x31,
+        Qt::Key_BracketRight,0x32,
+		Qt::Key_Backslash,	0x33,
+        Qt::Key_Delete,		0x34,
+        Qt::Key_End,		0x35,
+        Qt::Key_PageDown,	0x36, 
+		Qt::Key_Home,		0x37, //numpad		      
+        Qt::Key_Up,			0x38, //numpad
+        Qt::Key_PageUp,		0x39, //numpad
+        Qt::Key_Plus,		0x3A, //numpad
+
+//		Qt::Key_CapsLock,	0x3B, //modificator
+        Qt::Key_A,			0x3C,
+        Qt::Key_S,			0x3D,
+        Qt::Key_D,			0x3E,
+        Qt::Key_F,			0x3F,
+        Qt::Key_G,			0x40,
+        Qt::Key_H,			0x41,
+        Qt::Key_J,			0x42,
+        Qt::Key_K,			0x43,
+        Qt::Key_L,			0x44,
+        Qt::Key_Colon,		0x45,
+        Qt::Key_QuoteDbl,	0x46,
+        Qt::Key_Return,		0x47,              
+        Qt::Key_Left,		0x48, //numpad
+		Qt::Key_5,			0x49, //numpad ???
+        Qt::Key_Right,		0x4A, //numpad
+
+        Qt::Key_Z,			0x4C,
+        Qt::Key_X,			0x4D,
+        Qt::Key_C,			0x4E,
+        Qt::Key_V,			0x4F,
+        Qt::Key_B,			0x50,
+        Qt::Key_N,			0x51,
+        Qt::Key_M,			0x51,
+        Qt::Key_Less,		0x52,
+        Qt::Key_Greater,	0x54,
+        Qt::Key_Question,	0x55,
+        Qt::Key_Up,			0x57,	//cursor
+        Qt::Key_End,		0x58,	//numpad
+        Qt::Key_Down,		0x59,   //numpad
+        Qt::Key_PageDown,	0x5A,   //numpad
+		Qt::Key_Enter,		0x5B,   //numpad
+
+		Qt::Key_Space,		0x5E,
+		Qt::Key_Left,		0x61,   //cursor
+		Qt::Key_Down,		0x62,   //cursor
+		Qt::Key_Right,		0x63,   //cursor
+		Qt::Key_Insert,		0x64,   //cursor
+		Qt::Key_Delete,		0x65,   //numpad
+		0,					0x00
+	};
+
+uint32 scan_codes_numlock[] = {
+		Qt::Key_7,			0x37,
+        Qt::Key_8,			0x38,
+        Qt::Key_9,			0x39,
+        Qt::Key_Plus,		0x3A,
+        Qt::Key_4,			0x48,
+		Qt::Key_5,			0x49,
+        Qt::Key_6,			0x4A,
+        Qt::Key_1,			0x58,
+        Qt::Key_2,			0x59,
+        Qt::Key_3,			0x5A,
+		Qt::Key_Enter,		0x5B,
+		Qt::Key_Comma,		0x65,
+		0,					0x00
+	};
+	
+	memcpy(ScanCodes,scan_codes,sizeof(scan_codes));
+	memcpy(ScanCodes_Numlock,scan_codes_numlock,sizeof(scan_codes_numlock));
+}
+
+QKeyMapperPrivate::~QKeyMapperPrivate()
+{ }
+
+void QKeyMapperPrivate::clearMappings()
+{ }
+
+QList<int> QKeyMapperPrivate::possibleKeys(QKeyEvent *)
+{
+	return QList<int>();
+}
+
+uint32 QKeyMapperPrivate::translateKeyCode(int32 key)
+{
+	uint32 code = 0;
+	int i = 0;
+	if(modifiers()&&B_NUM_LOCK) {
+	    while (ScanCodes_Numlock[i]) {
+	      		if ( key == ScanCodes_Numlock[i+1]) {
+	            code = ScanCodes_Numlock[i];
+	      		    break;
+	        	}
+	       	i += 2;
+	  	}	
+		if(code>0)
+			return code;   
+	}
+	
+	i = 0;
+    while (ScanCodes[i]) {
+      		if ( key == ScanCodes[i+1]) {
+            code = ScanCodes[i];
+      		    break;
+        	}
+       	i += 2;
+  	}	
+	return code;   
+}
diff -rupN qt-everywhere-opensource-src-4.7.3/src/gui/kernel/qkeymapper_p.h qt-everywhere-opensource-src-4.7.3_haiku/src/gui/kernel/qkeymapper_p.h
--- qt-everywhere-opensource-src-4.7.3/src/gui/kernel/qkeymapper_p.h	2011-03-30 05:19:04.003145728 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/gui/kernel/qkeymapper_p.h	2011-06-13 22:06:43.314572800 +0000
@@ -213,6 +213,10 @@ public:
     int mapS60ScanCodesToQt(TUint s60key);
     int mapQtToS60Key(int qtKey);
     int mapQtToS60ScanCodes(int qtKey);
+#elif defined(Q_WS_HAIKU)
+	uint32	translateKeyCode(int32 key);
+	uint32  ScanCodes[256];
+	uint32  ScanCodes_Numlock[16];    
 #endif
 };
 
diff -rupN qt-everywhere-opensource-src-4.7.3/src/gui/kernel/qsound_haiku.cpp qt-everywhere-opensource-src-4.7.3_haiku/src/gui/kernel/qsound_haiku.cpp
--- qt-everywhere-opensource-src-4.7.3/src/gui/kernel/qsound_haiku.cpp	1970-01-01 00:00:00.000000000 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/gui/kernel/qsound_haiku.cpp	2011-06-13 22:06:43.316932096 +0000
@@ -0,0 +1,26 @@
+#include "qapplication.h"
+#include "qsound.h"
+#include "qsound_p.h"
+
+class QAuServerNull : public QAuServer
+{
+public:
+    QAuServerNull(QObject* parent);
+
+    void play(const QString&) { }
+    void play(QSound*s) { while(decLoop(s) > 0) /* nothing */ ; }
+    void stop(QSound*) { }
+    bool okay() { return false; }
+};
+
+QAuServerNull::QAuServerNull(QObject* parent)
+    : QAuServer(parent)
+{
+}
+
+QAuServer* qt_new_audio_server()
+{
+//	fprintf(stderr, "Unimplemented: qt_new_audio_server()\n");
+	return new QAuServerNull(qApp); 
+}
+
diff -rupN qt-everywhere-opensource-src-4.7.3/src/gui/kernel/qwidget.cpp qt-everywhere-opensource-src-4.7.3_haiku/src/gui/kernel/qwidget.cpp
--- qt-everywhere-opensource-src-4.7.3/src/gui/kernel/qwidget.cpp	2011-03-30 05:19:04.060030976 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/gui/kernel/qwidget.cpp	2011-06-13 22:06:43.326107136 +0000
@@ -1466,6 +1466,18 @@ void QWidget::create(WId window, bool in
     setAttribute(Qt::WA_WState_Created);                        // set created flag
     d->create_sys(window, initializeWindow, destroyOldWindow);
 
+#ifdef Q_WS_HAIKU
+if (windowType() != Qt::Desktop){ //temporary hack, Desktop don't have native view
+	QObject::connect((const QObject *)d->nativeView, SIGNAL(sendUpdateWidget()),this,SLOT(slot_updateWidget()), Qt::QueuedConnection);
+	QObject::connect((const QObject *)d->nativeView, SIGNAL(sendUpdateWidgetRect(QRect)),this,SLOT(slot_updateWidgetRect(QRect)), Qt::QueuedConnection);
+	QObject::connect((const QObject *)d->nativeView, SIGNAL(sendHaikuEvent(QObject *, QEvent *)),this,SLOT(slot_sendEvent(QObject *, QEvent *)),Qt::QueuedConnection);
+	QObject::connect((const QObject *)d->nativeView, SIGNAL(sendResizeWidget(int, int)),this,SLOT(slot_sendResizeWidget(int, int)), Qt::QueuedConnection);
+	QObject::connect((const QObject *)d->nativeView, SIGNAL(sendMoveWidget(int, int)),this,SLOT(slot_sendMoveWidget(int, int)), Qt::QueuedConnection);
+	QObject::connect((const QObject *)d->nativeView, SIGNAL(sendSetActiveWindow(QWidget *)),this,SLOT(slot_sendSetActiveWindow(QWidget *)), Qt::QueuedConnection);
+	QObject::connect((const QObject *)d->nativeView, SIGNAL(sendCloseWindow(QWidget *)),this,SLOT(slot_sendCloseWindow(QWidget *)), Qt::QueuedConnection);
+}
+#endif  
+
     // a real toplevel window needs a backing store
     if (isWindow() && windowType() != Qt::Desktop) {
         d->topData()->backingStore.destroy();
@@ -12547,6 +12559,53 @@ void QWidgetPrivate::syncUnifiedMode() {
 
 #endif // QT_MAC_USE_COCOA
 
+/*
+	Trap slot functions for Haiku events
+*/
+void QWidget::slot_updateWidget()
+{
+	update();
+}
+
+void QWidget::slot_updateWidgetRect(QRect r)
+{
+	update(r);
+}
+
+void QWidget::slot_sendEvent(QObject *receiver, QEvent *event)
+{
+	// close all active popup window 
+	if (event->type() == QEvent::MouseButtonPress &&
+		qApp->activePopupWidget() &&
+		qApp->activePopupWidget()->nativeView()->Window() != nativeView()->Window())
+			qApp->activePopupWidget()->close();
+
+	QApplication::sendSpontaneousEvent(receiver, event);
+	delete event;
+}
+
+void QWidget::slot_sendResizeWidget(int width, int height)
+{
+	resize(width, height);
+}
+
+void QWidget::slot_sendMoveWidget(int x, int y)
+{
+	move(x,y);
+}
+
+void QWidget::slot_sendSetActiveWindow(QWidget *widget)
+{
+	if (/*!d->inPopupMode() && */ widget || (!widget && QApplicationPrivate::active_window == this)) 
+		qApp->setActiveWindow(widget);
+}
+
+void QWidget::slot_sendCloseWindow(QWidget *widget)
+{
+    QWidgetPrivate *widget_private = widget->d_func();
+	widget_private->close_helper(QWidgetPrivate::CloseWithSpontaneousEvent);
+}
+
 QT_END_NAMESPACE
 
 #include "moc_qwidget.cpp"
diff -rupN qt-everywhere-opensource-src-4.7.3/src/gui/kernel/qwidget.h qt-everywhere-opensource-src-4.7.3_haiku/src/gui/kernel/qwidget.h
--- qt-everywhere-opensource-src-4.7.3/src/gui/kernel/qwidget.h	2011-03-30 05:19:04.063963136 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/gui/kernel/qwidget.h	2011-06-13 22:06:43.328466432 +0000
@@ -100,6 +100,9 @@ class QGraphicsEffect;
 #if defined(Q_WS_X11)
 class QX11Info;
 #endif
+#if defined(Q_WS_HAIKU) && !defined(BUILD_WEBKIT)
+#include "qwidget_haiku.h"
+#endif
 
 class QWidgetData
 {
@@ -254,6 +257,17 @@ public Q_SLOTS:
     void setEnabled(bool);
     void setDisabled(bool);
     void setWindowModified(bool);
+    
+//#ifdef Q_WS_HAIKU // Its all for moc, but moc does not support #ifdef
+// Remove! break cross-platform! 
+	void slot_updateWidget();
+	void slot_updateWidgetRect(QRect r);
+	void slot_sendEvent(QObject *receiver, QEvent *event);
+	void slot_sendResizeWidget(int width, int height);
+	void slot_sendMoveWidget(int x, int y);
+	void slot_sendSetActiveWindow(QWidget *widget);
+	void slot_sendCloseWindow(QWidget *widget);
+//#endif    
 
     // Widget coordinates
 
@@ -604,6 +618,10 @@ public:
     Qt::HANDLE handle() const;
 #endif
 
+#if defined(Q_WS_HAIKU)
+	BView* nativeView() const;
+#endif
+
     void setAttribute(Qt::WidgetAttribute, bool on = true);
     inline bool testAttribute(Qt::WidgetAttribute) const;
 
diff -rupN qt-everywhere-opensource-src-4.7.3/src/gui/kernel/qwidget_haiku.cpp qt-everywhere-opensource-src-4.7.3_haiku/src/gui/kernel/qwidget_haiku.cpp
--- qt-everywhere-opensource-src-4.7.3/src/gui/kernel/qwidget_haiku.cpp	1970-01-01 00:00:00.000000000 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/gui/kernel/qwidget_haiku.cpp	2011-06-13 22:06:43.333185024 +0000
@@ -0,0 +1,1457 @@
+#include "qwidget_haiku.h"
+#include <qdebug.h>
+#include "qapplication_p.h"
+#include "private/qkeymapper_p.h"
+#include "qdesktopwidget.h"
+#include "qwidget.h"
+#include "qwidget_p.h"
+#include "qtextcodec.h"
+
+#include <assert.h>
+#include <stdio.h>
+#include "qevent_p.h"
+#include "private/qwindowsurface_raster_p.h"
+#include "qapplication.h"
+#include "qfileinfo.h"
+#include <Application.h>
+#include <Cursor.h>
+#include <interface/Screen.h>
+
+extern	int	haiku_global_mouse_x;
+extern	int	haiku_global_mouse_y;
+
+static  QWidget *keyboardGrb = 0;
+static  QWidget *mouseGrb    = 0;
+
+QtHaikuView::QtHaikuView(BRect frame, const char *name, uint32  resizingMode, uint32 flags)
+		:	QObject(), BView(frame, name, resizingMode, flags),
+			isVisible(true), fWidget(0), fWidgetPrivate(0), 
+			last_down_buttons(0), last_clicked_buttons(0), last_mouse_x(-1), last_mouse_y(-1), last_click_time(0), last_draw_event(0)
+{
+
+}
+
+Qt::MouseButton 
+QtHaikuView::translateMouseButton(uint32 s)
+{
+    Qt::MouseButton ret = Qt::NoButton;
+    if (s & B_PRIMARY_MOUSE_BUTTON)
+        ret = Qt::LeftButton;
+    if (s & B_SECONDARY_MOUSE_BUTTON)
+        ret = Qt::RightButton;
+    if (s & B_TERTIARY_MOUSE_BUTTON)
+        ret = Qt::MidButton;
+    return ret;
+}
+
+Qt::MouseButtons 
+QtHaikuView::translateMouseButtons(uint32 s)
+{
+    Qt::MouseButtons ret = 0;
+    if (s & B_PRIMARY_MOUSE_BUTTON)
+        ret |= Qt::LeftButton;
+    if (s & B_SECONDARY_MOUSE_BUTTON)
+        ret |= Qt::RightButton;
+    if (s & B_TERTIARY_MOUSE_BUTTON)
+        ret |= Qt::MidButton;
+    return ret;
+}
+
+void 
+QtHaikuView::sendWheelEvent(int delta_x, int delta_y)
+{
+	BPoint 		  mouse_pos;
+	uint32 		  buttons;
+    uint32 		  mod = modifiers();
+	
+	GetMouse(&mouse_pos,&buttons);
+    Qt::KeyboardModifiers qt_mod = translateModifiers(mod);
+	Qt::MouseButtons qt_buttons = translateMouseButtons(buttons);
+	
+	BPoint screen_pos = ConvertToScreen(mouse_pos);
+    const QPoint globalPos = QPoint(screen_pos.x,screen_pos.y);
+    QPoint pos = QPoint(mouse_pos.x,mouse_pos.y);   
+    
+	if(delta_x!=0)
+		emit sendHaikuEvent(fWidget, new QWheelEvent(pos, globalPos, -delta_x, qt_buttons, qt_mod, Qt::Horizontal));
+	if(delta_y!=0)
+		emit sendHaikuEvent(fWidget, new QWheelEvent(pos, globalPos, -delta_y, qt_buttons, qt_mod, Qt::Vertical));
+}
+
+Qt::KeyboardModifiers 
+QtHaikuView::translateModifiers(uint32 s)
+{
+    Qt::KeyboardModifiers ret = 0;
+    if (s & B_SHIFT_KEY)
+        ret |= Qt::ShiftModifier;
+    if (s & B_CONTROL_KEY)
+        ret |= Qt::AltModifier;
+    if (s & B_COMMAND_KEY)
+        ret |= Qt::ControlModifier;
+    return ret;
+}
+
+void QtHaikuView::FrameResized(float width, float height)
+{
+	QSize widgetSize = fWidget->size();
+	QSize newSize = QSize(width, height);
+	if (widgetSize == newSize)
+		return;
+	fWidgetPrivate->data.fstrut_dirty = true;
+
+    emit sendUpdateWidget();
+}
+
+void
+QtHaikuView::Hide()
+{
+	if (!isVisible) return;
+	if (Window() && Window()->LockLooper()){
+		BView::Hide();
+		isVisible = false;
+		Window()->UnlockLooper();
+	}
+}
+
+void
+QtHaikuView::Show()
+{
+	if (isVisible) return; 
+	if (Window() && Window()->LockLooper()){
+		BView::Show();
+		isVisible = true;
+		Window()->UnlockLooper();
+	}
+}
+
+void
+QtHaikuWindow::Hide()
+{
+	if (LockLooper()){
+	if (!IsHidden())
+		BWindow::Hide();
+		UnlockLooper();
+	}
+}
+
+void
+QtHaikuWindow::Show()
+{
+	if (LockLooper()){
+	if (IsHidden())
+		BWindow::Show();
+		UnlockLooper();
+	}
+}
+
+
+QtHaikuView::~QtHaikuView()
+{
+//	debugprint(5, "Reimplemented: QtHaikuView::~QtHaikuView\n");
+}
+
+inline void QtHaikuView::setWidget(QWidget *widget, QWidgetPrivate  *widgetPrivate)
+{
+	fWidget = widget;
+	fWidgetPrivate = widgetPrivate;
+}
+
+void QtHaikuView::MouseUp(BPoint point)
+{
+	BPoint	point2;
+	uint32 	h_mod=modifiers();
+	uint32 	h_buttons = 0;
+	uint32 	h_button = last_down_buttons;
+	last_down_buttons = 0;
+
+	Qt::MouseButton qt_button = translateMouseButton(h_button);
+	Qt::MouseButtons qt_buttons = translateMouseButtons(h_buttons);
+	Qt::KeyboardModifiers qt_mod = translateModifiers(h_mod);
+
+	BPoint glob_pos = ConvertToScreen(point);
+	haiku_global_mouse_x = glob_pos.x;
+	haiku_global_mouse_y = glob_pos.y;
+	
+	QWidget *widget = fWidget->mouseGrabber();
+	if(!widget)
+		widget = fWidget;
+		
+	QWidget *wat = QApplication::widgetAt(QPoint(glob_pos.x,glob_pos.y));
+	
+//	qDebug() << "MouseUp " << fWidget << widget << wat;
+	if(wat && wat!=widget) {
+		QPoint lpoint = wat->mapFromGlobal(QPoint(glob_pos.x,glob_pos.y));
+		if(fWidget->nativeView()->Window()==wat->nativeView()->Window()) {
+			widget = wat;
+			point.x= lpoint.x();
+			point.y= lpoint.y();
+		}
+	}	
+	
+	if (qt_button == Qt::RightButton)
+		emit sendHaikuEvent(widget, new QContextMenuEvent(QContextMenuEvent::Mouse, 
+						QPoint(point.x,point.y), QPoint(haiku_global_mouse_x,haiku_global_mouse_y), qt_mod));
+	else		
+		emit sendHaikuEvent(widget, new QMouseEvent(QEvent::MouseButtonRelease, 
+						QPoint(point.x,point.y), qt_button, qt_buttons, qt_mod));	
+}
+
+void QtHaikuView::MouseDown(BPoint point)
+{
+	uint32 h_mod=modifiers();
+	uint32 h_buttons = Window()->CurrentMessage()->FindInt32("buttons");
+	uint32 h_button = h_buttons;	//TODO: only one button in per time
+	
+	Qt::MouseButton qt_button = translateMouseButton(h_button);
+	Qt::MouseButtons qt_buttons = translateMouseButtons(h_buttons);
+	Qt::KeyboardModifiers qt_mod = translateModifiers(h_mod);
+	
+	BPoint glob_pos = ConvertToScreen(point);
+	haiku_global_mouse_x = glob_pos.x;
+	haiku_global_mouse_y = glob_pos.y;
+	
+	SetMouseEventMask(B_POINTER_EVENTS,B_NO_POINTER_HISTORY);
+
+	QWidget *widget = fWidget->mouseGrabber();
+	if(!widget)
+		widget = fWidget;		
+		
+	QWidget *wat = QApplication::widgetAt(QPoint(glob_pos.x,glob_pos.y));
+	
+//	qDebug() << "MouseDown " << fWidget << widget << wat;
+	if(wat && wat!=widget) {
+		QPoint lpoint = wat->mapFromGlobal(QPoint(glob_pos.x,glob_pos.y));
+		if(fWidget->nativeView()->Window()==wat->nativeView()->Window()) {
+			widget = wat;
+			point.x= lpoint.x();
+			point.y= lpoint.y();
+		}
+	}
+		
+	bigtime_t now=system_time();
+
+	bigtime_t double_click_speed;
+	get_click_speed(&double_click_speed);
+
+	if( now - last_click_time < double_click_speed && 
+		last_clicked_buttons == h_buttons && 
+		last_mouse_x==glob_pos.x && 
+		last_mouse_y==glob_pos.y) {
+			last_clicked_buttons = 0;
+			emit sendHaikuEvent(widget, new QMouseEvent(QEvent::MouseButtonDblClick, 
+								QPoint(point.x,point.y), qt_button, qt_buttons, qt_mod));
+	} else {
+			emit sendHaikuEvent(widget, new QMouseEvent(QEvent::MouseButtonPress, 
+								QPoint(point.x,point.y), qt_button, qt_buttons, qt_mod));					
+	}
+//	qDebug()<<"MouseDown() "<<point.x<<" "<<point.y<<" "<<haiku_global_mouse_x<<" "<<haiku_global_mouse_y;	
+	last_click_time=now;
+	last_down_buttons = h_buttons;
+	last_clicked_buttons = h_buttons;
+	last_mouse_x = glob_pos.x;
+	last_mouse_y = glob_pos.y;
+}
+
+void QtHaikuView::MouseMoved(BPoint point, uint32 transit, const BMessage *message)
+{
+	Q_UNUSED(message);
+	if (!fWidget) return;
+//	qDebug()<<"MouseMoved() "<<fWidget<<"	"<<this<<"	pos:"<<point.x<<" "<<point.y;
+	
+	switch(transit)
+	{
+	 	case B_INSIDE_VIEW:
+	 	case B_ENTERED_VIEW:
+	 		{
+	 			BCursor *curs = fWidget->cursor().handle();	 			
+ 				if(curs)
+	 				SetViewCursor(curs);
+	 			else
+ 					SetViewCursor(B_CURSOR_SYSTEM_DEFAULT);
+	 		}
+	 		break;
+	 	case B_EXITED_VIEW:
+	 		break;
+	}
+	
+	uint32 	h_mod=modifiers();
+	uint32 	h_buttons = last_down_buttons;
+	uint32 	h_button = h_buttons;	//TODO: only one button in per time
+
+	Qt::MouseButton qt_button = translateMouseButton(h_button);
+	Qt::MouseButtons qt_buttons = translateMouseButtons(h_buttons);
+	Qt::KeyboardModifiers qt_mod = translateModifiers(h_mod);
+	
+	BPoint glob_pos = ConvertToScreen(point);
+	
+	haiku_global_mouse_x = glob_pos.x;
+	haiku_global_mouse_y = glob_pos.y;
+	
+	QWidget *widget = fWidget->mouseGrabber();
+	if(!widget)
+		widget = fWidget;
+			
+
+	/*QWidget *wat = QApplication::widgetAt(QPoint(glob_pos.x,glob_pos.y));
+	
+	if(wat && wat!=widget) {
+		QPoint lpoint = wat->mapFromGlobal(QPoint(glob_pos.x,glob_pos.y));
+		widget = wat;
+		point.x= lpoint.x();
+		point.y= lpoint.y();
+	}*/
+			
+	emit sendHaikuEvent(widget, new QMouseEvent(QEvent::MouseMove, QPoint(point.x,point.y), Qt::NoButton, qt_buttons, qt_mod));
+//	qDebug()<<"MouseMove()"<<point.x<<" "<<point.y<<" "<<haiku_global_mouse_x<<" "<<haiku_global_mouse_y;	
+}
+
+void QtHaikuView::Draw(BRect updateRect)
+{
+	QRect r = QRect(updateRect.left-1, updateRect.top-1, updateRect.Width()+2,  updateRect.Height()+2);		
+	emit sendUpdateWidgetRect(r);
+}
+
+void QtHaikuView::MessageReceived(BMessage *msg)
+{
+	switch(msg->what) {
+	default:
+		BView::MessageReceived(msg);
+		break;
+	}
+}
+
+QtHaikuWindow::QtHaikuWindow(BRect frame, const char *title,  window_look look, window_feel feel, uint32 flags)
+		: BWindow(frame, title, look, feel, flags)
+{
+}
+
+QtHaikuWindow::~QtHaikuWindow()
+{
+}
+
+void 
+QtHaikuWindow::sendKeyEvent(QEvent::Type type, BMessage *msg)
+{
+    int32 		  key = 0;
+    uint32        code = 0;
+    uint32 		  mod = modifiers();
+	extern 		  QTextCodec *qt_input_mapper; // from qapplication_haiku.cpp
+    QChar 		  converted;
+	const char	  *bytes;
+	QString 	  text;
+
+    if ( msg ) {
+      if(msg->FindString("bytes", &bytes) == B_OK) {
+	    if (qt_input_mapper)
+    	    text = qt_input_mapper->toUnicode(bytes, strlen(bytes), 0);    	
+	  }	
+      if(msg->FindInt32("key", &key) == B_OK) {
+		code = qt_keymapper_private()->translateKeyCode(key);
+	  }	
+    }
+	
+    if (text.isEmpty()) {
+            text.fromLatin1(bytes);
+    }
+	
+    Qt::KeyboardModifiers qt_mod = fView->translateModifiers(mod);
+    
+    QWidget *widget;
+    widget = QWidget::keyboardGrabber();
+    if (!widget) {
+        if (QApplicationPrivate::popupWidgets != 0) {
+            widget = QApplication::activePopupWidget()->focusWidget();
+            if (!widget) {
+                widget = QApplication::activePopupWidget();
+            }
+        } else {
+            widget = QApplicationPrivate::focus_widget;
+            if (!widget) {
+                widget = fView->fWidget;
+            }
+        }
+    }    
+    
+//    qDebug() << "KeyEvent: " << code << " (" <<text<<")";
+        	   
+    emit fView->sendHaikuEvent(widget, new QKeyEvent(type, code, qt_mod, text, false, text.length()));
+}
+
+void
+QtHaikuWindow::DispatchMessage(BMessage *msg, BHandler *handler)
+{
+	switch(msg->what) {
+		case B_UNMAPPED_KEY_DOWN:
+		case B_KEY_DOWN:
+			{
+				sendKeyEvent(QEvent::KeyPress, msg);				
+				break;	
+			}
+		case B_UNMAPPED_KEY_UP:
+		case B_KEY_UP:
+			{
+				sendKeyEvent(QEvent::KeyRelease, msg);				
+				break;
+			}	
+	default:
+		break;
+	}			
+	BWindow::DispatchMessage(msg, handler);
+}
+
+void QtHaikuWindow::MessageReceived(BMessage* msg)
+{
+	switch(msg->what) {
+	case B_MOUSE_WHEEL_CHANGED:
+		{
+			 float shift_x=0;
+			 float shift_y=0;
+			 if(msg->FindFloat("be:wheel_delta_x",&shift_x)!=B_OK)
+			 	shift_x = 0;
+			 if(msg->FindFloat("be:wheel_delta_y",&shift_y)!=B_OK)			 	
+			 	shift_y = 0;
+			 
+			 if(shift_x != 0 || shift_y !=0) {
+				BView *view = LastMouseMovedView();
+				QtHaikuView *widget_view = (QtHaikuView*)view;
+				widget_view->sendWheelEvent(shift_x*120, shift_y*120);
+			 }
+			 break;
+		}		
+	default:
+		BWindow::MessageReceived(msg);
+		break;
+	}
+}
+
+void QtHaikuWindow::FrameResized(float width, float height)
+{
+	QRect cr = fView->fWidget->geometry();
+	
+	QSize widgetSize = fView->fWidget->size();
+	QSize newSize = QSize(width+1, height+1);
+	if (widgetSize == newSize)
+		return;
+
+	cr.setSize(newSize);
+	fView->fWidgetPrivate->data.crect = cr;
+	fView->fWidgetPrivate->data.fstrut_dirty = true;
+    emit fView->sendHaikuEvent(fView->fWidget, new QResizeEvent(newSize, widgetSize));
+}
+
+void QtHaikuWindow::FrameMoved(BPoint point)
+{
+	QRect cr = fView->fWidget->geometry();
+	QPoint oldPos = cr.topLeft();
+	QPoint newCPos(point.x,point.y);
+	
+	if(oldPos==newCPos)
+		return;
+
+	while (qApp->activePopupWidget())
+		qApp->activePopupWidget()->close();		
+
+	fView->fWidgetPrivate->data.fstrut_dirty = true;
+	
+	cr.moveTopLeft(newCPos);
+	fView->fWidgetPrivate->data.crect = cr;
+	
+	emit fView->sendHaikuEvent(fView->fWidget, new QMoveEvent(newCPos,oldPos));
+}
+
+void QtHaikuWindow::WindowActivated(bool active)
+{
+	if (active) {
+		emit fView->sendSetActiveWindow(fView->fWidget);
+	} else {
+		while (qApp->activePopupWidget())	// App(window) become inactive - we must close all popup
+			qApp->activePopupWidget()->close();
+		emit fView->sendSetActiveWindow(0);
+	}
+}
+
+bool QtHaikuWindow::QuitRequested()
+{
+	emit fView->sendCloseWindow(fView->fWidget);
+	return false;
+}
+
+inline void QtHaikuWindow::setView(QtHaikuView *view)
+{
+	fView = view;
+	AddChild(view);
+
+	fView->MoveTo(0,0);
+	fView->ResizeTo(Bounds().Width(),Bounds().Height());
+	fView->SetResizingMode(B_FOLLOW_ALL_SIDES);	
+}
+
+void QtHaikuWindow::updateWindowFlags(Qt::WindowFlags flags)
+{
+	Qt::WindowType type =  static_cast<Qt::WindowType>(int(flags & Qt::WindowType_Mask)) ;
+	
+	bool popup = (type == Qt::Popup);
+	bool splash = (type == Qt::SplashScreen);
+	bool dialog = (type == Qt::Dialog
+                   || type == Qt::Sheet
+                   || (flags & Qt::MSWindowsFixedSizeDialogHint));
+//    bool desktop = (type == Qt::Desktop);
+	bool tool = (type == Qt::Tool || type == Qt::Drawer);
+	bool tooltip = (type == Qt::ToolTip);
+
+	window_look wlook = B_TITLED_WINDOW_LOOK;
+	window_feel wfeel = B_NORMAL_WINDOW_FEEL;
+	uint32 wflag = B_NO_WORKSPACE_ACTIVATION | B_NOT_ANCHORED_ON_ACTIVATE ;
+	
+	if(tool) {
+		wlook = B_FLOATING_WINDOW_LOOK;	
+		wflag |= B_WILL_ACCEPT_FIRST_CLICK;			
+	}
+	
+	if(splash) {
+		wlook = B_NO_BORDER_WINDOW_LOOK;			
+	}
+	
+	if(popup) {
+		wlook = B_NO_BORDER_WINDOW_LOOK;			
+		wflag |= B_WILL_ACCEPT_FIRST_CLICK|B_AVOID_FRONT|B_AVOID_FOCUS;
+		flags |= Qt::WindowStaysOnTopHint;
+	}
+		
+	if (dialog) {
+//					if (q->parentWidget())
+//						wfeel = B_MODAL_SUBSET_WINDOW_FEEL;
+//					else
+		//wfeel = B_MODAL_APP_WINDOW_FEEL;								
+	}
+	
+	if (tooltip) {
+		wlook = B_NO_BORDER_WINDOW_LOOK;
+		wflag |= B_WILL_ACCEPT_FIRST_CLICK|B_AVOID_FOCUS;
+		flags |= Qt::WindowStaysOnTopHint;
+	}
+
+    if (flags & Qt::FramelessWindowHint)
+    	wlook = B_NO_BORDER_WINDOW_LOOK;
+	if (flags & Qt::MSWindowsFixedSizeDialogHint)// (dialog)
+    	wflag |= B_NOT_RESIZABLE | B_NOT_ZOOMABLE;               
+
+	if (flags & Qt::CustomizeWindowHint){
+		//if (flags & Qt::WindowTitleHint)
+			//{ };
+		//if (flags & Qt::WindowSystemMenuHint)
+			//{ };
+		if (!(flags & Qt::WindowMinimizeButtonHint))
+    		wflag |= B_NOT_MINIMIZABLE;
+		if (!(flags & Qt::WindowMaximizeButtonHint))
+			wflag |= B_NOT_ZOOMABLE;					
+		if (!(flags & Qt::WindowCloseButtonHint))
+			wflag |= B_NOT_CLOSABLE;
+		//if (flags & Qt::WindowContextHelpButtonHint)
+	//  	exsty |= WS_EX_CONTEXTHELP;
+	}
+
+	if (flags & Qt::WindowStaysOnTopHint)
+		wfeel = B_FLOATING_ALL_WINDOW_FEEL;	
+
+//	if (flags & Qt::WindowStaysOnBottomHint)
+//		wfeel = B_FLOATING_ALL_WINDOW_FEEL;	
+	
+	SetLook(wlook);
+	SetFeel(wfeel);
+	SetFlags(wflag);
+}
+
+// Qt reimplementation
+
+void QWidgetPrivate::create_sys(WId window, bool initializeWindow, bool destroyOldWindow)
+{
+    Q_Q(QWidget);
+//    qDebug()<<"create_sys:"<<q<<"	Wid:"<<Wid;
+	WId id = 0;
+	WId destroyw = 0;
+	bool topLevel = (data.window_flags & Qt::Window);
+    bool desktop = (q->windowType() == Qt::Desktop);
+
+   	BScreen bscreen(B_MAIN_SCREEN_ID);
+	BRect screen_frame  = bscreen.Frame();
+   
+    if (!window)                                // always initialize
+        initializeWindow = true;
+
+    q->setAttribute(Qt::WA_WState_Created, false);
+    
+    if (desktop){ 
+    }
+
+    if (window) {                                // override the old window
+        if (destroyOldWindow)
+            destroyw = data.winid;
+        id = window;
+        nativeView = (QtHaikuView *)window;        
+       	((QtHaikuWindow *)(window->Window()))->updateWindowFlags(data.window_flags);
+    } 
+    else 
+    if (desktop) {                        // desktop widget
+    	if (!q->testAttribute(Qt::WA_DontShowOnScreen)) {
+	        //popup = false;                                // force this flags off
+			data.crect.setRect(screen_frame.left,screen_frame.top,screen_frame.right,screen_frame.bottom);
+    	}
+//        id = GetDesktopWindow();
+//        setWinId(id);
+    } 
+    else 
+    {
+    	if (topLevel) {                       // create top-level widget
+		int x=data.crect.left(),
+			y=data.crect.top(),
+			w=data.crect.width(),
+			h=data.crect.height();
+			
+        const bool wasMoved = q->testAttribute(Qt::WA_Moved);
+        const bool wasResized = q->testAttribute(Qt::WA_Resized);
+        
+        if(!wasResized) {
+    		w = screen_frame.right / 2;
+	        h = (4 * screen_frame.bottom) / 10;
+	        data.crect.setSize(QSize(w, h));
+        }
+        
+        if(!wasMoved) {
+        	srand(time(0));
+        	int dx = (screen_frame.right - w)/4;
+        	int dy = (screen_frame.bottom - h)/4;        	
+        	x = dx==0?0:rand() % dx + (dx/2);
+        	y = dy==0?0:rand() % dy + (dy/2);
+        	data.crect.moveTo(x,y);
+        }        			
+  			
+		QString title = q->windowTitle();
+		if (title.isEmpty())
+			title = QFileInfo(QApplication::applicationFilePath()).fileName();
+		nativeWindow = new QtHaikuWindow(BRect(x,y,x+w-1,y+h-1), title.toUtf8(), B_NO_BORDER_WINDOW_LOOK, B_NORMAL_WINDOW_FEEL, 0);
+		nativeWindow->updateWindowFlags(data.window_flags);
+		nativeView = new QtHaikuView(BRect(0,0,w,h), "RootView",  B_FOLLOW_ALL_SIDES, B_WILL_DRAW);
+		nativeWindow->setView(nativeView);
+    } else {
+		nativeView = new QtHaikuView(BRect(data.crect.x(),data.crect.y(),data.crect.x()+data.crect.width(),data.crect.y()+data.crect.height()),
+							   "WidgetView",  B_FOLLOW_NONE, B_WILL_DRAW/* | B_NAVIGABLE*/);
+	    q->parentWidget()->d_func()->nativeView->AddChild(nativeView);
+		nativeWindow = q->parentWidget()->d_func()->nativeWindow;
+	}
+
+	nativeView->setWidget(q, this);
+	if (nativeView->LockLooper()){
+		nativeView->SetViewColor(B_TRANSPARENT_32_BIT);
+		nativeView->UnlockLooper();
+	}
+	if (q->isWindow()) { }//nativeWindow->Hide(); // BWindow created hidden (?)
+	else 
+		nativeView->Hide();
+    }
+
+	setWinId(nativeView);	
+    
+    if (desktop) {
+        q->setAttribute(Qt::WA_WState_Visible);
+    } else if (topLevel && !q->testAttribute(Qt::WA_DontShowOnScreen)) {
+/*        RECT  cr;
+        GetClientRect(id, &cr);
+        // one cannot trust cr.left and cr.top, use a correction POINT instead
+        POINT pt;
+        pt.x = 0;
+        pt.y = 0;
+        ClientToScreen(id, &pt);
+
+        if (data.crect.width() == 0 || data.crect.height() == 0) {
+            data.crect = QRect(pt.x, pt.y, data.crect.width(), data.crect.height());
+        } else {
+            data.crect = QRect(QPoint(pt.x, pt.y),
+                               QPoint(pt.x + cr.right - 1, pt.y + cr.bottom - 1));
+        }
+
+        if (data.fstrut_dirty) {
+            // be nice to activeqt
+            updateFrameStrut();
+        }*/
+    }
+
+		
+    q->setAttribute(Qt::WA_WState_Created);                // accept move/resize events
+    q->setAttribute(Qt::WA_WState_Visible, false);   
+
+    if (window) {                                // got window from outside
+//        if (IsWindowVisible(window))
+//            q->setAttribute(Qt::WA_WState_Visible);
+//        else
+//            q->setAttribute(Qt::WA_WState_Visible, false);
+    }
+
+    if (extra && !extra->mask.isEmpty())
+        setMask_sys(extra->mask);
+
+    if (q->hasFocus() && q->testAttribute(Qt::WA_InputMethodEnabled)) {
+		q->setFocus();		
+    }
+ 
+    //if (destroyw) {
+        //BWindow *win = destroyw->Window();
+        //if(win->Lock()) {
+        //	win->Quit();
+        //	win->Unlock();
+        //}
+    //}
+
+//    if (q != qt_tablet_widget && QWidgetPrivate::mapper)
+//        qt_tablet_init();
+
+    if (q->testAttribute(Qt::WA_DropSiteRegistered))
+        registerDropSite(true);
+
+//    if (maybeTopData() && maybeTopData()->opacity != 255)
+//        q->setWindowOpacity(maybeTopData()->opacity/255.);
+
+    if (topLevel && (data.crect.width() == 0 || data.crect.height() == 0)) {
+        q->setAttribute(Qt::WA_OutsideWSRange, true);
+    }
+
+    if (!topLevel && q->testAttribute(Qt::WA_NativeWindow) && q->testAttribute(Qt::WA_Mapped)) {
+		nativeView->Window()->Show();
+    }
+    
+//   qDebug() << "=< QWidgetPrivate::create_sys();  QWidget = "<< q ;
+}
+
+void QWidgetPrivate::hide_sys()
+{
+	Q_Q(QWidget);
+    deactivateWidgetCleanup();
+    Q_ASSERT(q->testAttribute(Qt::WA_WState_Created));
+
+    if (q->isWindow())
+    	nativeWindow->Hide();
+    else
+    	nativeView->Hide();
+    q->setAttribute(Qt::WA_Mapped, false);
+}
+
+void QWidgetPrivate::show_sys()
+{
+	Q_Q(QWidget);
+	Q_ASSERT(q->testAttribute(Qt::WA_WState_Created));
+
+	if (q->testAttribute(Qt::WA_OutsideWSRange)){
+		qDebug("Qt::WA_OutsideWSRange");
+		return;
+	}
+	
+	if (q->testAttribute(Qt::WA_DontShowOnScreen)) {
+		qDebug("Qt::WA_DontShowOnScreen");
+		invalidateBuffer(q->rect());
+		return;
+	}
+
+	//hack for native resize holder for window
+	if(q->inherits("QSizeGrip")) {
+		nativeView->Window()->SetLook(B_DOCUMENT_WINDOW_LOOK);
+		q->setAttribute(Qt::WA_WState_Visible, false);
+		return;
+	}
+
+	if (q->isWindow()) {
+		if (q->isMinimized()) {
+			// ### TODO: Should handle
+		} else if (q->isMaximized()) {
+			// ### TODO: Should handle
+		}
+	}
+	if (q->testAttribute(Qt::WA_ShowWithoutActivating)
+		|| (q->windowType() == Qt::Popup)
+		|| (q->windowType() == Qt::ToolTip)
+		|| (q->windowType() == Qt::Tool)) {
+		// ### TODO: Should Handle
+	}
+
+//	if (data.fstrut_dirty)
+//		updateFrameStrut();
+    if (q->isWindow())
+    	nativeWindow->Show();
+    else
+    	nativeView->Show();
+
+	q->setAttribute(Qt::WA_Mapped);
+			
+	invalidateBuffer(q->rect());
+}
+
+void QWidgetPrivate::setParent_sys(QWidget* parent, Qt::WindowFlags f)
+{
+	Q_Q(QWidget);
+	
+    bool wasCreated = q->testAttribute(Qt::WA_WState_Created);
+    if (q->isVisible() && q->parentWidget() && parent != q->parentWidget())
+        q->parentWidget()->d_func()->invalidateBuffer(q->geometry());
+
+    WId old_winid = data.winid;
+	bool old_w = q->isWindow();
+    bool widgetTypeChanged = false;
+
+    if (wasCreated && q->isVisible()) {
+		if (q->isWindow())
+			nativeWindow->Hide();
+			else
+			nativeView->Hide();
+    }
+
+    bool dropSiteWasRegistered = false;
+    if (q->testAttribute(Qt::WA_DropSiteRegistered)) {
+        dropSiteWasRegistered = true;
+        q->setAttribute(Qt::WA_DropSiteRegistered, false); // ole dnd unregister (we will register again below)
+    }
+
+    if ((q->windowType() == Qt::Desktop))
+        old_winid = 0;
+
+    QObjectPrivate::setParent_helper(parent);
+
+    bool explicitlyHidden = q->testAttribute(Qt::WA_WState_Hidden) && q->testAttribute(Qt::WA_WState_ExplicitShowHide);
+
+    data.window_flags = f;
+    data.fstrut_dirty = true;
+    q->setAttribute(Qt::WA_WState_Created, false);
+    q->setAttribute(Qt::WA_WState_Visible, false);
+    q->setAttribute(Qt::WA_WState_Hidden, false);
+    adjustFlags(data.window_flags, q);
+	widgetTypeChanged = old_w != q->isWindow(); // widget type changed (widget<->window)
+
+	if (wasCreated){
+		if (parent && !parent->testAttribute(Qt::WA_WState_Created))
+			parent->createWinId();
+
+		if (widgetTypeChanged){
+			
+			BWindow *win = nativeView->Window();
+			if (win && win->LockLooper()){
+				nativeView->RemoveSelf();
+				if (old_w)
+					win->Quit();
+				else
+					win->UnlockLooper();
+			}
+
+			if (old_w){ //was Window, become Widget(non-Window)
+				bool wasLocked = parent->nativeView()->Looper()->IsLocked();
+				if (wasLocked || parent->nativeView()->LockLooper() )
+				{
+					parent->nativeView()->AddChild(nativeView);
+					nativeView->Hide();
+	
+					nativeView->SetResizingMode(B_FOLLOW_NONE);
+					nativeView->MoveTo(data.crect.x(),data.crect.y());
+					nativeView->ResizeTo(data.crect.x()+data.crect.width(),data.crect.y()+data.crect.height());
+					if (!wasLocked)
+						parent->nativeView()->UnlockLooper();
+				}
+				nativeWindow = (QtHaikuWindow *)parent->nativeView()->Window();
+
+				q->setAttribute(Qt::WA_WState_Created, true);
+			}
+			else{// become Window (topLevel)
+				createWinId();
+			
+				nativeView->RemoveSelf(); //Delete new view created in create_sys. We need only BWindow
+				delete nativeView;
+				
+				nativeView = (QtHaikuView *)old_winid;
+				nativeWindow->setView(nativeView);
+
+				nativeView->Show();					
+				setWinId(nativeView);
+			}
+		}
+		else // widgetTypeChanged == false
+		{
+		if (q->isWindow())
+			nativeWindow->updateWindowFlags(data.window_flags);
+		else{//already created widget change parent widget from one to another
+				BWindow *win = nativeView->Window();
+				if (win && win->LockLooper()){
+					nativeView->RemoveSelf();
+					win->UnlockLooper();
+				}
+
+				if (parent->nativeView()->LockLooper()){
+					parent->nativeView()->AddChild(nativeView);
+					parent->nativeView()->UnlockLooper();
+					nativeWindow = (QtHaikuWindow *)parent->nativeView()->Window();
+				}
+		}
+		q->setAttribute(Qt::WA_WState_Created, true);
+		}
+	}
+	else
+		if (!q->isWindow() && parent->testAttribute(Qt::WA_WState_Created))
+			createWinId();
+
+    if (q->isWindow() || (!parent || parent->isVisible()) || explicitlyHidden)
+        q->setAttribute(Qt::WA_WState_Hidden);
+    q->setAttribute(Qt::WA_WState_ExplicitShowHide, explicitlyHidden);
+
+    if (extra && !extra->mask.isEmpty()) {
+        QRegion r = extra->mask;
+        extra->mask = QRegion();
+        q->setMask(r);
+    }
+    if (extra && extra->topextra && !extra->topextra->caption.isEmpty()) {
+        //setWindowIcon_sys(true);
+        setWindowTitle_helper(extra->topextra->caption);
+    }
+
+    if (q->testAttribute(Qt::WA_AcceptDrops) || dropSiteWasRegistered
+        || (!q->isWindow() && q->parentWidget() && q->parentWidget()->testAttribute(Qt::WA_DropSiteRegistered)))
+        q->setAttribute(Qt::WA_DropSiteRegistered, true);
+
+    invalidateBuffer(q->rect());
+}
+
+void QWidgetPrivate::raise_sys()
+{
+//	Q_Q(QWidget);
+//	qDebug() << "Unimplemented: QWidgetPrivate::raise_sys() "<<  q ;
+}
+
+void QWidgetPrivate::lower_sys()
+{
+//	Q_Q(QWidget);
+//	qDebug() << "Unimplemented: QWidgetPrivate::lower_sys() "<<  q ;
+}
+
+void QWidgetPrivate::stackUnder_sys(QWidget* widget)
+{
+//	Q_Q(QWidget);
+//	qDebug() << "Unimplemented: QWidgetPrivate::stackUnder_sys() "<<  q << "	top:"<<widget;
+}
+
+void QWidgetPrivate::setWindowIcon_sys(bool)
+{
+//	Q_Q(QWidget);
+//	qDebug() << "Unimplemented: QWidgetPrivate::setWindowIcon_sys() "<<  q ;
+}
+
+void QWidgetPrivate::setWindowTitle_sys(const QString &title)
+{
+	if (q_func()->isWindow() && nativeWindow)
+		nativeWindow->SetTitle(title.toUtf8());
+}
+
+void QWidgetPrivate::updateSystemBackground()
+{
+//	Q_Q(QWidget);
+//	qDebug() << "Unimplemented: QWidgetPrivate::UpdateSystemBackground() "<<  q ;
+}
+
+void QWidgetPrivate::setModal_sys()
+{
+	Q_Q(QWidget);
+//	qDebug() << "Unimplemented: QWidgetPrivate::setModal_sys() "<<  q ;
+}
+
+void QWidgetPrivate::setConstraints_sys()
+{
+	Q_Q(QWidget);
+//	qDebug() << "QWidgetPrivate::setConstraints_sys() "<<  q ;
+	if (!q->isWindow() || !q->testAttribute(Qt::WA_WState_Created) || !extra)
+		return;
+	float minw = 0, minh = 0;
+	float maxw = 10000, maxh = 10000;
+	if (extra->minw > 0 || extra->minh > 0) {
+    	// add minimum size hints
+		minw  = qMin(10000, extra->minw);
+		minh = qMin(10000, extra->minh);
+	}
+	if (extra->maxw < QWIDGETSIZE_MAX || extra->maxh < QWIDGETSIZE_MAX) {
+		// add maximum size hints
+		maxw = qMin(10000, extra->maxw);
+		maxh = qMin(10000, extra->maxh);
+	}
+	nativeWindow->SetSizeLimits(minw,maxw,minh,maxh);
+}
+
+void QWidgetPrivate::setCursor_sys(const QCursor& cursor)
+{
+       Q_UNUSED(cursor);
+}
+
+void QWidgetPrivate::unsetCursor_sys()
+{
+}
+
+void QWidgetPrivate::setWSGeometry(bool dontShow, const QRect &)
+{
+	Q_UNUSED(dontShow);
+	Q_Q(QWidget);
+//	qDebug() << "Unimplemented: QWidgetPrivate::setWSGeomerty() "<<  q ;
+}
+
+void QWidgetPrivate::setGeometry_sys(int x,int y,int w,int h,bool  isMove)
+{
+	Q_Q(QWidget);
+//	qDebug()<<"setGeometry_sys() "<<q<<" "<<x<<" "<<y<<" "<<w<<" "<<h<<" "<<isMove;    		
+	BRect nativeFrame;
+	
+	if (q->isWindow())
+	{
+		nativeFrame = nativeView->Window()->Frame();
+	}
+	else
+	{ 
+		if(nativeView->LockLooper()) {
+			nativeFrame = nativeView->Frame();
+			nativeView->UnlockLooper();
+		}
+	}
+	
+	QPoint oldPos(nativeFrame.left, nativeFrame.top);
+	QPoint newPos(x,y);
+	QSize oldSize(nativeFrame.IntegerWidth(), nativeFrame.IntegerHeight());
+	QSize newSize(w,h);
+
+	isMove = oldPos != newPos;
+	bool isResize = oldSize != newSize;
+	
+	if (!isResize && !isMove)
+		return;
+
+	data.crect.setRect(x, y, w, h);
+	
+    QTLWExtra *tlwExtra = q->window()->d_func()->maybeTopData();
+    const bool inTopLevelResize = tlwExtra ? tlwExtra->inTopLevelResize : false;
+		
+	if (q->isWindow()){
+        if (w == 0 || h == 0) {
+            q->setAttribute(Qt::WA_OutsideWSRange, true);
+            if (q->isVisible() && q->testAttribute(Qt::WA_Mapped))
+                hide_sys();
+        } else if (q->isVisible() && q->testAttribute(Qt::WA_OutsideWSRange)) {
+            q->setAttribute(Qt::WA_OutsideWSRange, false);
+
+            // put the window in its place and show it
+            if (data.winid){
+            	nativeView->Window()->MoveTo(x, y);
+				nativeView->Window()->ResizeTo(w-1, h-1);
+            }	
+			setConstraints_sys();//do_size_hints(q, extra);
+            show_sys();
+        } else {
+			if (isMove){	
+				nativeView->Window()->MoveTo(x, y);
+      		}
+			if (isResize){	
+				nativeView->Window()->ResizeTo(w-1, h-1);
+			}
+        }
+		updateFrameStrut();
+	} else {	//not Window	
+		if (isResize) {
+			if(nativeView->LockLooper()) {
+				nativeView->ResizeTo(w, h);
+				nativeView->UnlockLooper();
+			}
+		}
+		if (isMove)
+		{
+			if(nativeView->LockLooper()) {
+				nativeView->MoveTo(x, y);
+				nativeView->UnlockLooper();
+			}
+		}
+	}
+
+    if (q->isWindow() && q->isVisible() && isResize && !inTopLevelResize) {
+        invalidateBuffer(q->rect()); //after the resize
+    }
+	
+	if (q->isVisible()) {
+        if (isMove && q->pos() != oldPos) {
+            QMoveEvent e(q->pos(), oldPos);
+            QApplication::sendEvent(q, &e);
+        }
+        if (isResize) {
+//            static bool slowResize = qgetenv("QT_SLOW_TOPLEVEL_RESIZE").toInt();
+            // If we have a backing store with static contents, we have to disable the top-level
+            // resize optimization in order to get invalidated regions for resized widgets.
+            // The optimization discards all invalidateBuffer() calls since we're going to
+            // repaint everything anyways, but that's not the case with static contents.
+//            const bool setTopLevelResize = !slowResize && q->isWindow() && extra && extra->topextra
+//                                           && !extra->topextra->inTopLevelResize
+//                                           && (!extra->topextra->backingStore
+//                                               || !extra->topextra->backingStore->hasStaticContents());
+//            if (setTopLevelResize)
+//                extra->topextra->inTopLevelResize = true;
+            QResizeEvent e(q->size(), oldSize);
+            QApplication::sendEvent(q, &e);
+//            if (setTopLevelResize)
+  //              extra->topextra->inTopLevelResize = false;
+        }
+    } else {
+        if (isMove && q->pos() != oldPos)
+            q->setAttribute(Qt::WA_PendingMoveEvent, true);
+        if (isResize)
+            q->setAttribute(Qt::WA_PendingResizeEvent, true);
+    }
+}
+
+void QWidgetPrivate::registerDropSite(bool)
+{
+	//debugprint(1, "Unimplemented: QWidgetPrivate::registerDropSite\n");
+}
+
+void QWidgetPrivate::setWindowOpacity_sys(qreal)
+{
+	//debugprint(1, "Unimplemented: QWidgetPrivate::setWindowOpacity_sys \n");
+}
+/*
+void QWidgetPrivate::createTLExtra()
+{
+//	fprintf(stderr, "Unimplemented: QWidgetPrivate::createTLExtra\n");
+}
+*/
+void QWidgetPrivate::deleteSysExtra()
+{
+//	debugprint(1, "Unimplemented: QWidgetPrivate::deleteSysExtra\n");
+}
+
+void QWidgetPrivate::deleteTLSysExtra()
+{
+	//debugprint(1, "Unimplemented: QWidgetPrivate::deleteTLSysExtra\n");
+}
+
+void QWidgetPrivate::createSysExtra()
+{
+//	debugprint(1, "Unimplemented: QWidgetPrivate::createSysExtra\n");
+}
+
+void QWidgetPrivate::createTLSysExtra()
+{
+//	debugprint(1, "Unimplemented: QWidgetPrivate::createTLSysExtra\n");
+}
+
+void QWidgetPrivate::setWindowIconText_sys(const QString&)
+{
+//	debugprint(1, "Unimplemented: QWidgetPrivate::setWindowIconText_sys \n");
+}
+
+void QWidgetPrivate::scroll_sys(int,int, const QRect& r)
+{
+//	debugprint(1, "Reimplemented: QWidgetPrivate::scroll(int,int,const  QRect&\n");
+	Q_Q(QWidget);
+	q->update(r);
+}
+
+void QWidgetPrivate::scroll_sys(int, int)
+{
+//	debugprint(1, "Reimplemented: QWidgetPrivate::scroll(int,int)\n");
+	Q_Q(QWidget);
+	q->update();
+}
+
+void QWidgetPrivate::updateFrameStrut()
+{
+//	debugprint(5, "Reimplemented: QWidgetPrivate::updateFrameStrut\n");
+	QTLWExtra* top = this->topData();
+	if(nativeView->LockLooper()) {
+		BRect frame = nativeView->Bounds();
+		top->frameStrut.setCoords(frame.left, frame.top, frame.right,  frame.bottom);
+		nativeView->UnlockLooper();
+	}
+	data.fstrut_dirty = false;
+}
+
+void QWidgetPrivate::setFocus_sys()
+{
+}
+
+QWindowSurface *QWidgetPrivate::createDefaultWindowSurface_sys()
+{
+	Q_Q(QWidget);
+	return new QRasterWindowSurface(q);
+}
+
+void QWidgetPrivate::setMask_sys(const QRegion &region)
+{
+	Q_UNUSED(region);
+//	debugprint(1, "Unimplemented: QWidgetPrivate::setMask_sys()\n");
+}
+
+int QWidget::metric(PaintDeviceMetric m) const
+{
+//qDebug() << "QWidget::metric("<< m <<")";
+	int val = 0;
+	if (m == PdmWidth) {
+		val = data->crect.width();
+	} else if (m == PdmHeight) {
+		val = data->crect.height();
+	} else {
+		switch (m) {
+		case PdmDpiX:
+		case PdmPhysicalDpiX:
+		case PdmDpiY:
+		case PdmPhysicalDpiY:
+			val = 72;
+			break;
+		case PdmWidthMM:
+		case PdmHeightMM:
+		case PdmNumColors:
+		case PdmDepth:
+//			qWarning("QWidget::metric Unknown metric type requested\n");
+			break;
+		default:
+			val = 0;
+			qWarning("QWidget::metric: Invalid metric command");
+		}
+	}
+
+	return val;
+}
+
+QPaintEngine *QWidget::paintEngine() const
+{
+	return 0;
+}
+
+QPoint QWidget::mapToGlobal(const QPoint &pos) const
+{
+	//Q_D(QWidget);
+//	qDebug()<<"QWidget::mapToGlobal() pos:"<<pos;
+    if (!testAttribute(Qt::WA_WState_Created) || !internalWinId()) {
+        QPoint p = pos + data->crect.topLeft();
+        //cannot trust that !isWindow() implies parentWidget() before create
+        return (isWindow() || !parentWidget()) ?  p : parentWidget()->mapToGlobal(p);
+    }
+
+	if (nativeView()->LockLooper())
+	{
+		BPoint p = nativeView()->ConvertToScreen(BPoint(pos.x(),pos.y()));
+		nativeView()->UnlockLooper();
+		return QPoint(p.x,p.y);
+	}
+	return QPoint(); // ???
+}
+
+QPoint QWidget::mapFromGlobal(const QPoint &pos) const
+{
+//		qDebug()<<"QWidget::mapFromGlobal() pos:"<<pos;
+    if (!testAttribute(Qt::WA_WState_Created) || !internalWinId()) {
+        //cannot trust that !isWindow() implies parentWidget() before create
+        QPoint p = (isWindow() || !parentWidget()) ?  pos : parentWidget()->mapFromGlobal(pos);
+        return p - data->crect.topLeft();
+    }
+
+	if (nativeView()->LockLooper())
+	{
+		BPoint p = nativeView()->ConvertFromScreen(BPoint(pos.x(),pos.y()));
+		nativeView()->UnlockLooper();
+		return QPoint(p.x,p.y);
+	}
+	return QPoint(); // ???
+}
+
+void QWidget::activateWindow()
+{
+	Q_D(QWidget);
+    if (isWindow()) {
+       d->nativeView->Window()->Activate();
+    }   
+}
+
+void QWidget::setWindowState(Qt::WindowStates newstate)
+{
+//	qDebug() << "QWidgetPrivate::setWindowState() "<<  this<<"	"<<newstate ;
+
+	Q_D(QWidget);
+	Qt::WindowStates oldstate = windowState();
+	if (oldstate == newstate)
+		return;
+
+    if (isWindow()) {
+        createWinId();
+//        Q_ASSERT(testAttribute(Qt::WA_WState_Created));
+
+        // Ensure the initial size is valid, since we store it as normalGeometry below.
+        if (!testAttribute(Qt::WA_Resized) && !isVisible())
+            adjustSize();
+		// Qt::WindowMaximized
+        if ((oldstate & Qt::WindowMaximized) != (newstate & Qt::WindowMaximized)) {
+            if (newstate & Qt::WindowMaximized && !(oldstate & Qt::WindowFullScreen))
+                d->topData()->normalGeometry = geometry();
+            if (isVisible() && !(newstate & Qt::WindowMinimized)) {
+//TODO: Qt::WindowMaximized not supported yet.
+				d->nativeView->Window()->Show();
+								
+                if (!(newstate & Qt::WindowFullScreen)) {
+                    QRect r = d->topData()->normalGeometry;
+                    if (!(newstate & Qt::WindowMaximized) && r.width() >= 0) {
+                        if (pos() != r.topLeft() || size() !=r.size()) {
+                            d->topData()->normalGeometry = QRect(0,0,-1,-1);
+                            setGeometry(r);
+                        }
+                    }
+                } else {
+                    d->updateFrameStrut();
+                }
+            }
+        }
+
+		// Qt::WindowFullScreen
+        if ((oldstate & Qt::WindowFullScreen) != (newstate & Qt::WindowFullScreen)) {
+            if (newstate & Qt::WindowFullScreen) { // save current window flags and geometry and go to FullScreen
+                if (d->topData()->normalGeometry.width() < 0 && !(oldstate & Qt::WindowMaximized))
+                    d->topData()->normalGeometry = geometry();
+                d->topData()->savedFlags = d->data.window_flags;
+
+
+				d->data.window_flags |= Qt::SplashScreen;				
+				d->nativeWindow->updateWindowFlags(d->data.window_flags);
+
+    	    	QRect r = qApp->desktop()->screenGeometry(this);
+				d->nativeView->Window()->Zoom(BPoint(r.left(),r.top()),r.width(),r.height());
+				d->updateFrameStrut();
+            }
+            else { //back from FullScreen (to saved flags and geomerty)
+				d->data.window_flags = d->topData()->savedFlags;
+				d->nativeWindow->updateWindowFlags(d->data.window_flags);
+
+                if (!(newstate & Qt::WindowMaximized)) {
+                    QRect r = d->topData()->normalGeometry;
+                    d->topData()->normalGeometry = QRect(0,0,-1,-1);
+                    if (r.isValid())
+                        setGeometry(r);
+                }
+                d->updateFrameStrut();				
+            }
+            }
+        }
+        
+		//Qt::WindowMinimized
+        if ((oldstate & Qt::WindowMinimized) != (newstate & Qt::WindowMinimized)) {
+            if (isVisible())
+//TODO: Qt::WindowMinimized state changed...
+				d->nativeView->Window()->Minimize((newstate & Qt::WindowMinimized) ? true :
+                                    (newstate & Qt::WindowMaximized) ? false : false);
+    }
+
+	data->window_state = newstate;
+	QWindowStateChangeEvent e(oldstate);
+	QApplication::sendEvent(this, &e);
+}
+
+void QWidget::grabMouse()
+{
+   if (mouseGrb)
+        mouseGrb->releaseMouse();
+   mouseGrb = this;
+}
+
+void QWidget::grabMouse(const QCursor &cursor)
+{
+	Q_UNUSED(cursor);
+	if (mouseGrb)
+		mouseGrb->releaseMouse();
+	mouseGrb = this;
+}
+
+void QWidget::releaseMouse()
+{
+   if(mouseGrb == this) {
+        mouseGrb = 0;
+   }
+}
+
+QWidget *QWidget::mouseGrabber()
+{
+    return mouseGrb;
+}
+
+void QWidget::grabKeyboard()
+{
+    if (keyboardGrb)
+        keyboardGrb->releaseKeyboard();
+    keyboardGrb = this;	
+}
+
+void QWidget::releaseKeyboard()
+{
+    if (keyboardGrb == this) {
+        keyboardGrb = 0;
+    }	
+}
+
+QWidget *QWidget::keyboardGrabber()
+{
+    return keyboardGrb;
+}
+
+void QWidget::destroy(bool destroyWindow, bool destroySubWindows)
+{
+    Q_D(QWidget);
+//	qDebug() << "Reimplemented: QWidgetPrivate::destroy() "<<  this ;	    
+    if (!isWindow() && parentWidget())
+        parentWidget()->d_func()->invalidateBuffer(geometry());
+    d->deactivateWidgetCleanup();
+    if (testAttribute(Qt::WA_WState_Created)) {
+        setAttribute(Qt::WA_WState_Created, false);
+        QObjectList childList = children();
+        for (int i = 0; i < childList.size(); ++i) { // destroy all widget children
+            register QObject *obj = childList.at(i);
+            if (obj->isWidgetType())
+                static_cast<QWidget*>(obj)->destroy(destroySubWindows,
+                                                    destroySubWindows);
+        }
+
+        if (mouseGrb == this)
+            releaseMouse();
+            
+        if (keyboardGrb == this)
+            releaseKeyboard();
+
+//        if (testAttribute(Qt::WA_ShowModal))                // just be sure we leave modal
+//            QApplicationPrivate::leaveModal(this);
+//        else 
+		if ((windowType() == Qt::Popup))
+            qApp->d_func()->closePopup(this);
+        
+        if (isWindow()) {
+            if ((windowType() != Qt::Desktop) && destroyWindow){
+                BWindow *win = d->nativeView->Window();
+					
+				if (win->LockLooper()){
+					for (int i =0;i<=win->CountChildren()-1;i++){
+						BView *w = win->ChildAt(i);
+						w->RemoveSelf();
+						delete w;
+					}
+					win->Quit();
+				}
+			}
+	    } else {
+	    	BWindow *win =d->nativeView->Window();
+			bool wasLocked = win->Looper()->IsLocked();
+			if (win && (wasLocked || win->LockLooper()) ){
+	    		d->nativeView->RemoveSelf();
+	    		if (!wasLocked)
+	    			win->UnlockLooper();
+			}
+	    	delete d->nativeView;
+	    }
+
+		d->nativeView = NULL;
+		d->nativeWindow = NULL;
+	    d->setWinId(0);     
+    }
+}
+
+BView* QWidget::nativeView() const
+{
+	Q_D(const QWidget);
+	return d->nativeView;
+}
diff -rupN qt-everywhere-opensource-src-4.7.3/src/gui/kernel/qwidget_haiku.h qt-everywhere-opensource-src-4.7.3_haiku/src/gui/kernel/qwidget_haiku.h
--- qt-everywhere-opensource-src-4.7.3/src/gui/kernel/qwidget_haiku.h	1970-01-01 00:00:00.000000000 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/gui/kernel/qwidget_haiku.h	2011-06-13 22:06:43.334495744 +0000
@@ -0,0 +1,105 @@
+#ifndef QWIDGET_HAIKU_H
+#define QWIDGET_HAIKU_H
+
+#include <Window.h>
+#include <View.h>
+#include <Message.h>
+#include "qevent.h"
+
+#include "qwidget.h"
+//#include "qwidget_p.h"
+//#include "qtextcodec.h"
+
+//#include <stdio.h>
+//#include "qevent_p.h"
+//#include "private/qwindowsurface_raster_p.h"
+//#include "qapplication.h"
+//#include "qfileinfo.h"
+
+
+QT_BEGIN_HEADER
+
+QT_BEGIN_NAMESPACE
+
+QT_MODULE(Gui)
+
+class QWidgetPrivate;
+
+class QtHaikuView :  public QObject, public BView
+{
+	Q_OBJECT
+	
+public:
+	QtHaikuView(BRect frame, const char *name, uint32 resizingMode,  uint32 flags);
+	~QtHaikuView();
+
+	virtual void MessageReceived(BMessage* msg);
+	virtual void FrameResized(float width, float height);
+	virtual void MouseDown(BPoint point);
+	virtual void MouseUp(BPoint point);
+	virtual void MouseMoved(BPoint where, uint32 code, const BMessage *message);
+	virtual void Hide();
+	virtual void Show();
+	virtual void Draw(BRect rect);
+
+	inline void setWidget(QWidget *widget, QWidgetPrivate *widgetPrivate);
+	void sendWheelEvent(int delta_x, int delta_y);
+	
+	Qt::KeyboardModifiers translateModifiers(uint32 s);
+	bool isVisible;		
+Q_SIGNALS:
+	void sendHaikuEvent(QObject *receiver, QEvent *event);
+	void sendUpdateWidget();
+	void sendUpdateWidgetRect(QRect r);
+	void sendResizeWidget(int width, int height);
+	void sendMoveWidget(int x, int y);
+	void sendSetActiveWindow(QWidget *widget);
+	void sendCloseWindow(QWidget *widget);
+		
+private:
+	friend class QtHaikuWindow;
+	Qt::MouseButton translateMouseButton(uint32 s);
+	Qt::MouseButtons translateMouseButtons(uint32 s);
+	
+	QWidget* fWidget;
+	QWidgetPrivate* fWidgetPrivate;
+	
+	int	last_down_buttons;
+	int last_clicked_buttons;
+	int last_mouse_x;
+	int last_mouse_y;
+	
+	bigtime_t last_click_time;
+	bigtime_t last_draw_event;
+};
+
+class QtHaikuWindow : public BWindow
+{
+public:
+	QtHaikuWindow(BRect frame, const char *title, window_look look, window_feel feel, uint32 flags);
+	~QtHaikuWindow();
+
+	void FrameResized(float width, float height);
+	void FrameMoved(BPoint point);
+	void MessageReceived(BMessage* msg);
+	virtual void DispatchMessage(BMessage *, BHandler *);	
+	virtual void WindowActivated(bool active);
+	virtual bool QuitRequested();
+	virtual void Hide();
+	virtual void Show();
+
+	inline void setView(QtHaikuView *view);
+
+	void sendKeyEvent(QEvent::Type type, BMessage *msg);
+	bool isVisible;		
+	bool inDestroy;
+	void updateWindowFlags(Qt::WindowFlags f);
+private:
+	QtHaikuView *fView;
+};
+
+QT_END_NAMESPACE
+
+QT_END_HEADER
+
+#endif
diff -rupN qt-everywhere-opensource-src-4.7.3/src/gui/kernel/qwidget_p.h qt-everywhere-opensource-src-4.7.3_haiku/src/gui/kernel/qwidget_p.h
--- qt-everywhere-opensource-src-4.7.3/src/gui/kernel/qwidget_p.h	2011-03-30 05:19:04.055836672 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/gui/kernel/qwidget_p.h	2011-06-13 22:06:43.337117184 +0000
@@ -877,6 +877,9 @@ public:
     void s60UpdateIsOpaque();
     void reparentChildren();
     void registerTouchWindow();
+#elif defined(Q_WS_HAIKU) // <--------------------------------------------------------- HAIKU
+	QtHaikuWindow *nativeWindow;
+	QtHaikuView *nativeView;    
 #endif
 
 };
diff -rupN qt-everywhere-opensource-src-4.7.3/src/gui/kernel/qwindowdefs.h qt-everywhere-opensource-src-4.7.3_haiku/src/gui/kernel/qwindowdefs.h
--- qt-everywhere-opensource-src-4.7.3/src/gui/kernel/qwindowdefs.h	2011-03-30 05:19:04.046923776 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/gui/kernel/qwindowdefs.h	2011-06-13 22:06:43.338952192 +0000
@@ -110,6 +110,10 @@ typedef long WId;
 #include <QtGui/qwindowdefs_win.h>
 #endif // Q_WS_WIN
 
+#if defined(Q_WS_HAIKU)
+#include <QtGui/qwindowdefs_haiku.h>
+#endif
+
 #if defined(Q_WS_X11)
 
 typedef struct _XDisplay Display;
diff -rupN qt-everywhere-opensource-src-4.7.3/src/gui/kernel/qwindowdefs_haiku.h qt-everywhere-opensource-src-4.7.3_haiku/src/gui/kernel/qwindowdefs_haiku.h
--- qt-everywhere-opensource-src-4.7.3/src/gui/kernel/qwindowdefs_haiku.h	1970-01-01 00:00:00.000000000 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/gui/kernel/qwindowdefs_haiku.h	2011-06-13 22:06:43.341311488 +0000
@@ -0,0 +1,72 @@
+/****************************************************************************
+**
+** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: Qt Software Information (qt-info@nokia.com)
+**
+** This file is part of the QtGui module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial Usage
+** Licensees holding valid Qt Commercial licenses may use this file in
+** accordance with the Qt Commercial License Agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Nokia.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain
+** additional rights. These rights are described in the Nokia Qt LGPL
+** Exception version 1.0, included in the file LGPL_EXCEPTION.txt in this
+** package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+** If you are unsure which license is appropriate for your use, please
+** contact the sales department at qt-sales@nokia.com.
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QWINDOWDEFS_HAIKU_H
+#define QWINDOWDEFS_HAIKU_H
+
+#include <QtCore/qglobal.h>
+
+QT_BEGIN_HEADER
+
+QT_BEGIN_NAMESPACE
+
+QT_MODULE(Gui)
+
+QT_END_NAMESPACE
+#ifndef BUILD_WEBKIT
+#include <interface/Point.h>
+#include <interface/Size.h>
+#include <interface/Rect.h>
+#include <interface/Gradient.h>
+#include <interface/Font.h>
+#include <interface/View.h>
+#else
+class BView;
+#endif
+typedef BView *WId;
+
+QT_BEGIN_NAMESPACE
+//?
+QT_END_NAMESPACE
+
+QT_END_HEADER
+
+#endif // QWINDOWDEFS_HAIKU_H
diff -rupN qt-everywhere-opensource-src-4.7.3/src/gui/painting/painting.pri qt-everywhere-opensource-src-4.7.3_haiku/src/gui/painting/painting.pri
--- qt-everywhere-opensource-src-4.7.3/src/gui/painting/painting.pri	2011-03-30 05:19:07.043515904 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/gui/painting/painting.pri	2011-06-13 22:06:43.343408640 +0000
@@ -164,7 +164,7 @@ unix:!mac:!symbian {
                 painting/qprinterinfo_unix.cpp
 }
 
-win32|x11|mac|embedded|symbian {
+win32|x11|mac|embedded|symbian|haiku {
         SOURCES += painting/qbackingstore.cpp
         HEADERS += painting/qbackingstore_p.h
 }
@@ -248,6 +248,12 @@ symbian {
         QMAKE_CXXFLAGS.ARMCC *= -O3
 }
 
+haiku {
+		SOURCES += \
+#			painting/qpaintdevice_haiku.cpp  \
+			painting/qcolormap_haiku.cpp
+}
+
 NEON_SOURCES += painting/qdrawhelper_neon.cpp
 NEON_HEADERS += painting/qdrawhelper_neon_p.h
 NEON_ASM += ../3rdparty/pixman/pixman-arm-neon-asm.S painting/qdrawhelper_neon_asm.S
diff -rupN qt-everywhere-opensource-src-4.7.3/src/gui/painting/qcolormap_haiku.cpp qt-everywhere-opensource-src-4.7.3_haiku/src/gui/painting/qcolormap_haiku.cpp
--- qt-everywhere-opensource-src-4.7.3/src/gui/painting/qcolormap_haiku.cpp	1970-01-01 00:00:00.000000000 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/gui/painting/qcolormap_haiku.cpp	2011-06-13 22:06:43.345767936 +0000
@@ -0,0 +1,189 @@
+/****************************************************************************
+**
+** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: Qt Software Information (qt-info@nokia.com)
+**
+** This file is part of the QtGui module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial Usage
+** Licensees holding valid Qt Commercial licenses may use this file in
+** accordance with the Qt Commercial License Agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Nokia.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain
+** additional rights. These rights are described in the Nokia Qt LGPL
+** Exception version 1.0, included in the file LGPL_EXCEPTION.txt in this
+** package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+** If you are unsure which license is appropriate for your use, please
+** contact the sales department at qt-sales@nokia.com.
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qcolormap.h"
+
+#include "qapplication.h"
+#include "qdebug.h"
+#include "qdesktopwidget.h"
+#include "qvarlengtharray.h"
+
+#include <limits.h>
+
+QT_BEGIN_NAMESPACE
+
+class QColormapPrivate
+{
+public:
+    QColormapPrivate()
+        : ref(1), mode(QColormap::Direct), depth(0),
+          defaultColormap(true),
+          defaultVisual(true),
+          r_max(0), g_max(0), b_max(0),
+          r_shift(0), g_shift(0), b_shift(0)
+    {}
+
+    QAtomicInt ref;
+
+    QColormap::Mode mode;
+    int depth;
+
+//    Colormap colormap;
+    bool defaultColormap;
+
+//    Visual *visual;
+    bool defaultVisual;
+
+    int r_max;
+    int g_max;
+    int b_max;
+
+    uint r_shift;
+    uint g_shift;
+    uint b_shift;
+
+    QVector<QColor> colors;
+    QVector<int> pixels;
+};
+
+
+static QColormap **cmaps = 0;
+
+/*! \internal
+*/
+void QColormap::initialize()
+{
+}
+
+/*! \internal
+*/
+void QColormap::cleanup()
+{
+ //   Display *display = QX11Info::display();
+    const int screens = 0;//ScreenCount(display);
+
+    for (int i = 0; i < screens; ++i)
+        delete cmaps[i];
+
+    delete [] cmaps;
+    cmaps = 0;
+}
+
+QColormap QColormap::instance(int screen)
+{
+    //if (screen == -1)
+      //  screen = QX11Info::appScreen();
+      QColormap cm;
+    return cm;//*cmaps[screen];
+}
+
+/*! \internal
+    Constructs a new colormap.
+*/
+QColormap::QColormap()
+    : d(new QColormapPrivate)
+{}
+
+QColormap::QColormap(const QColormap &colormap)
+    :d (colormap.d)
+{ d->ref.ref(); }
+
+QColormap::~QColormap()
+{
+    if (!d->ref.deref()) {
+        if (!d->defaultColormap) {}
+//            XFreeColormap(QX11Info::display(), d->colormap);
+        delete d;
+    }
+}
+
+QColormap::Mode QColormap::mode() const
+{ return d->mode; }
+
+int QColormap::depth() const
+{ return d->depth; }
+
+int QColormap::size() const
+{
+    return (d->mode == Gray
+            ? d->r_max
+            : (d->mode == Indexed
+               ? d->r_max * d->g_max * d->b_max
+               : -1));
+}
+
+uint QColormap::pixel(const QColor &color) const
+{
+    const QColor c = color.toRgb();
+    const uint r = (c.ct.argb.red   * d->r_max) >> 16;
+    const uint g = (c.ct.argb.green * d->g_max) >> 16;
+    const uint b = (c.ct.argb.blue  * d->b_max) >> 16;
+    if (d->mode != Direct) {
+        if (d->mode == Gray)
+            return d->pixels.at((r * 30 + g * 59 + b * 11) / 100);
+        return d->pixels.at(r * d->g_max * d->b_max + g * d->b_max + b);
+    }
+    return (r << d->r_shift) + (g << d->g_shift) + (b << d->b_shift);
+}
+
+const QColor QColormap::colorAt(uint pixel) const
+{
+    if (d->mode != Direct) {
+        Q_ASSERT(pixel <= (uint)d->colors.size());
+        return d->colors.at(pixel);
+    }
+
+    //const int r = (((pixel & d->visual->red_mask)   >> d->r_shift) << 8) / d->r_max;
+    //const int g = (((pixel & d->visual->green_mask) >> d->g_shift) << 8) / d->g_max;
+    //const int b = (((pixel & d->visual->blue_mask)  >> d->b_shift) << 8) / d->b_max;
+    return QColor(0, 0, 0);
+}
+
+const QVector<QColor> QColormap::colormap() const
+{ return d->colors; }
+
+QColormap &QColormap::operator=(const QColormap &colormap)
+{
+    qAtomicAssign(d, colormap.d);
+    return *this;
+}
+
+QT_END_NAMESPACE
diff -rupN qt-everywhere-opensource-src-4.7.3/src/gui/painting/qgraphicssystem.cpp qt-everywhere-opensource-src-4.7.3_haiku/src/gui/painting/qgraphicssystem.cpp
--- qt-everywhere-opensource-src-4.7.3/src/gui/painting/qgraphicssystem.cpp	2011-03-30 05:19:07.046661632 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/gui/painting/qgraphicssystem.cpp	2011-06-13 22:06:43.346816512 +0000
@@ -44,7 +44,7 @@
 #ifdef Q_WS_X11
 # include <private/qpixmap_x11_p.h>
 #endif
-#if defined(Q_WS_WIN)
+#if defined(Q_WS_WIN) || defined(Q_WS_HAIKU)
 # include <private/qpixmap_raster_p.h>
 #endif
 #ifdef Q_WS_MAC
@@ -72,7 +72,9 @@ QPixmapData *QGraphicsSystem::createDefa
 #elif defined(Q_WS_MAC)
     return new QMacPixmapData(type);
 #elif defined(Q_OS_SYMBIAN)
-    return new QS60PixmapData(type);    
+    return new QS60PixmapData(type);
+#elif defined(Q_WS_HAIKU)
+    return new QRasterPixmapData(type);
 #elif !defined(Q_WS_QWS)
 #error QGraphicsSystem::createDefaultPixmapData() not implemented
 #endif
diff -rupN qt-everywhere-opensource-src-4.7.3/src/gui/painting/qpaintengine_raster.cpp qt-everywhere-opensource-src-4.7.3_haiku/src/gui/painting/qpaintengine_raster.cpp
--- qt-everywhere-opensource-src-4.7.3/src/gui/painting/qpaintengine_raster.cpp	2011-03-30 05:19:07.039583744 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/gui/painting/qpaintengine_raster.cpp	2011-06-13 22:06:43.351010816 +0000
@@ -96,6 +96,8 @@
 #  include <private/qabstractfontengine_p.h>
 #elif defined(Q_OS_SYMBIAN) && defined(QT_NO_FREETYPE)
 #  include <private/qfontengine_s60_p.h>
+#elif defined(Q_WS_HAIKU)
+#  include <private/qfontengine_ft_p.h>
 #endif
 
 #if defined(Q_WS_WIN64)
@@ -3408,7 +3410,7 @@ void QRasterPaintEngine::drawTextItem(co
     }
 #endif // Q_WS_QWS
 
-#if (defined(Q_WS_X11) || defined(Q_WS_QWS) || defined(Q_OS_SYMBIAN)) && !defined(QT_NO_FREETYPE)
+#if (defined(Q_WS_X11) || defined(Q_WS_QWS) || defined(Q_OS_SYMBIAN) || defined(Q_WS_HAIKU)) && !defined(QT_NO_FREETYPE)
 
 #if defined(Q_WS_QWS) && !defined(QT_NO_QWS_QPF2)
     if (fontEngine->type() == QFontEngine::QPF2) {
diff -rupN qt-everywhere-opensource-src-4.7.3/src/gui/painting/qregion.cpp qt-everywhere-opensource-src-4.7.3_haiku/src/gui/painting/qregion.cpp
--- qt-everywhere-opensource-src-4.7.3/src/gui/painting/qregion.cpp	2011-03-30 05:19:07.052953088 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/gui/painting/qregion.cpp	2011-06-13 22:06:43.354156544 +0000
@@ -1620,7 +1620,7 @@ QT_END_INCLUDE_NAMESPACE
 QT_BEGIN_INCLUDE_NAMESPACE
 # include "qregion_win.cpp"
 QT_END_INCLUDE_NAMESPACE
-#elif defined(Q_WS_QWS)
+#elif defined(Q_WS_QWS) || defined(Q_WS_HAIKU)
 static QRegionPrivate qrp;
 QRegion::QRegionData QRegion::shared_empty = {Q_BASIC_ATOMIC_INITIALIZER(1), &qrp};
 #endif
diff -rupN qt-everywhere-opensource-src-4.7.3/src/gui/painting/qregion.h qt-everywhere-opensource-src-4.7.3_haiku/src/gui/painting/qregion.h
--- qt-everywhere-opensource-src-4.7.3/src/gui/painting/qregion.h	2011-03-30 05:19:07.041156608 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/gui/painting/qregion.h	2011-06-13 22:06:43.355729408 +0000
@@ -59,7 +59,7 @@ QT_MODULE(Gui)
 template <class T> class QVector;
 class QVariant;
 
-#if defined(Q_WS_QWS) || defined(Q_WS_X11) || defined(Q_WS_MAC) || defined(Q_WS_WIN) || defined(Q_OS_SYMBIAN)
+#if defined(Q_WS_QWS) || defined(Q_WS_X11) || defined(Q_WS_MAC) || defined(Q_WS_WIN) || defined(Q_OS_SYMBIAN) || defined(Q_WS_HAIKU)
 struct QRegionPrivate;
 #endif
 
@@ -203,7 +203,7 @@ private:
 #elif defined(Q_WS_MAC) && !defined(QT_MAC_USE_COCOA)
         mutable RgnHandle unused; // Here for binary compatibility reasons. ### Qt 5 remove.
 #endif
-#if defined(Q_WS_QWS) || defined(Q_WS_X11) || defined(Q_WS_MAC) || defined(Q_WS_WIN) || defined(Q_OS_SYMBIAN)
+#if defined(Q_WS_QWS) || defined(Q_WS_X11) || defined(Q_WS_MAC) || defined(Q_WS_WIN) || defined(Q_OS_SYMBIAN) || defined(Q_WS_HAIKU)
         QRegionPrivate *qt_rgn;
 #endif
     };
diff -rupN qt-everywhere-opensource-src-4.7.3/src/gui/painting/qwindowsurface_raster.cpp qt-everywhere-opensource-src-4.7.3_haiku/src/gui/painting/qwindowsurface_raster.cpp
--- qt-everywhere-opensource-src-4.7.3/src/gui/painting/qwindowsurface_raster.cpp	2011-03-30 05:19:07.048496640 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/gui/painting/qwindowsurface_raster.cpp	2011-06-13 22:06:43.357302272 +0000
@@ -66,6 +66,10 @@
 #include <private/qt_cocoa_helpers_mac_p.h>
 #endif
 
+#ifdef Q_WS_HAIKU
+#include <Window.h>
+#endif
+
 QT_BEGIN_NAMESPACE
 
 class QRasterWindowSurfacePrivate
@@ -298,6 +302,24 @@ void QRasterWindowSurface::flush(QWidget
 #endif
 #endif // Q_WS_MAC
 
+#ifdef Q_WS_HAIKU
+	// d->image is the image to be painted
+	// widget is the widget to be painted on
+	BView *view = widget->nativeView();
+	BLooper* looper = view->Looper();
+
+	if (looper->IsLocked())
+		return;
+	if(view->LockLooper()) {
+		QRect r = rgn.boundingRect();
+		BRect dst_region = BRect(r.x(), r.y(), r.x()+r.width(), r.y()+r.height());
+		BRect src_region = dst_region;
+		src_region.OffsetBy(offset.x(),offset.y());
+		view->DrawBitmap(d->image->bitmap, src_region, dst_region);
+		view->UnlockLooper();
+	}
+#endif
+
 #ifdef Q_OS_SYMBIAN
     Q_UNUSED(widget);
     Q_UNUSED(rgn);
diff -rupN qt-everywhere-opensource-src-4.7.3/src/gui/styles/qhaikustyle.cpp qt-everywhere-opensource-src-4.7.3_haiku/src/gui/styles/qhaikustyle.cpp
--- qt-everywhere-opensource-src-4.7.3/src/gui/styles/qhaikustyle.cpp	1970-01-01 00:00:00.000000000 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/gui/styles/qhaikustyle.cpp	2011-06-13 22:06:43.365428736 +0000
@@ -0,0 +1,3928 @@
+/****************************************************************************
+**
+** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: Qt Software Information (qt-info@nokia.com)
+**
+** This file is part of the QtGui module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial Usage
+** Licensees holding valid Qt Commercial licenses may use this file in
+** accordance with the Qt Commercial License Agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Nokia.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain
+** additional rights. These rights are described in the Nokia Qt LGPL
+** Exception version 1.0, included in the file LGPL_EXCEPTION.txt in this
+** package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+** If you are unsure which license is appropriate for your use, please
+** contact the sales department at qt-sales@nokia.com.
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qhaikustyle.h"
+#include "qhaikustyle_p.h"
+
+#if !defined(QT_NO_STYLE_HAIKU) || defined(QT_PLUGIN)
+
+#include "qwindowsstyle_p.h"
+#include <qcombobox.h>
+#include <qimage.h>
+#include <qpushbutton.h>
+#include <qpainter.h>
+#include <qdebug.h>
+#include <qdir.h>
+#include <qhash.h>
+#include <qstyleoption.h>
+#include <qapplication.h>
+#include <qmainwindow.h>
+#include <qfont.h>
+#include <qgroupbox.h>
+#include <qprocess.h>
+#include <qpixmapcache.h>
+#include <qdialogbuttonbox.h>
+#include <qscrollbar.h>
+#include <qspinbox.h>
+#include <qslider.h>
+#include <qsplitter.h>
+#include <qprogressbar.h>
+#include <qtoolbar.h>
+#include <qwizard.h>
+#include <qlibrary.h>
+
+#include <AppKit.h>
+#include <StorageKit.h>
+#include <InterfaceKit.h>
+#include <NodeInfo.h>
+#include <Bitmap.h>
+#include <ControlLook.h>
+#include <View.h>
+
+#define CL_MAX(a,b) (a)>(b) ? (a):(b) // ### qMin/qMax does not work for vc6
+#define CL_MIN(a,b) (a)<(b) ? (a):(b) // remove this when it is working
+
+QT_BEGIN_NAMESPACE
+
+static const bool UsePixmapCache = true;
+
+enum Direction {
+    TopDown,
+    FromLeft,
+    BottomUp,
+    FromRight
+};
+
+// from windows style
+static const int windowsItemFrame        =  2; // menu item frame width
+static const int windowsSepHeight        =  6; // separator item height
+static const int windowsItemHMargin      =  3; // menu item hor text margin
+static const int windowsItemVMargin      =  8; // menu item ver text margin
+static const int windowsArrowHMargin     =  6; // arrow horizontal margin
+static const int windowsTabSpacing       = 12; // space between text and tab
+static const int windowsCheckMarkHMargin =  2; // horiz. margins of check mark
+static const int windowsRightBorder      = 15; // right border on windows
+static const int windowsCheckMarkWidth   = 12; // checkmarks width on windows
+
+/* XPM */
+static const char * const dock_widget_close_xpm[] = {
+    "11 13 7 1",
+    " 	c None",
+    ".	c #D5CFCB",
+    "+	c #8F8B88",
+    "@	c #6C6A67",
+    "#	c #ABA6A3",
+    "$	c #B5B0AC",
+    "%	c #A4A09D",
+    "           ",
+    " +@@@@@@@+ ",
+    "+#       #+",
+    "@ $@   @$ @",
+    "@ @@@ @@@ @",
+    "@  @@@@@  @",
+    "@   @@@   @",
+    "@  @@@@@  @",
+    "@ @@@ @@@ @",
+    "@ $@   @$ @",
+    "+%       #+",
+    " +@@@@@@@+ ",
+    "           "};
+
+
+static const char * const dock_widget_restore_xpm[] = {
+    "11 13 7 1",
+    " 	c None",
+    ".	c #D5CFCB",
+    "+	c #8F8B88",
+    "@	c #6C6A67",
+    "#	c #ABA6A3",
+    "$	c #B5B0AC",
+    "%	c #A4A09D",
+    "           ",
+    " +@@@@@@@+ ",
+    "+#       #+",
+    "@   #@@@# @",
+    "@   @   @ @",
+    "@ #@@@# @ @",
+    "@ @   @ @ @",
+    "@ @   @@@ @",
+    "@ @   @   @",
+    "@ #@@@#   @",
+    "+%       #+",
+    " +@@@@@@@+ ",
+    "           "};
+
+static const char * const workspace_minimize[] = {
+    "11 13 7 1",
+    " 	c None",
+    ".	c #D5CFCB",
+    "+	c #8F8B88",
+    "@	c #6C6A67",
+    "#	c #ABA6A3",
+    "$	c #B5B0AC",
+    "%	c #A4A09D",
+    "           ",
+    " +@@@@@@@+ ",
+    "+#       #+",
+    "@         @",
+    "@         @",
+    "@         @",
+    "@ @@@@@@@ @",
+    "@ @@@@@@@ @",
+    "@         @",
+    "@         @",
+    "+%       #+",
+    " +@@@@@@@+ ",
+    "           "};
+
+
+static const char * const qt_titlebar_context_help[] = {
+    "10 10 3 1",
+    "  c None",
+    "# c #000000",
+    "+ c #444444",
+    "  +####+  ",
+    " ###  ### ",
+    " ##    ## ",
+    "     +##+ ",
+    "    +##   ",
+    "    ##    ",
+    "    ##    ",
+    "          ",
+    "    ##    ",
+    "    ##    "};
+
+
+static const char * const qt_scrollbar_button_arrow_left[] = {
+"6 7 18 1",
+"d c #303030",
+"g c #333333",
+"c c #3d3d3d",
+"j c #4d4d4d",
+"l c #626262",
+"h c #656565",
+"p c #8b8b8b",
+"a c #919191",
+"k c #9a9a9a",
+"f c #9e9e9e",
+"n c #9f9f9f",
+"e c #a5a5a5",
+"m c #b3b3b3",
+"i c #b4b4b4",
+"b c #bababa",
+"o c #c6c6c6",
+"# c #cfcfcf",
+". c None",
+"...#a.",
+"..bcde",
+".fgdh.",
+"iddj..",
+".kgdl.",
+"..mcdn",
+"...op."};
+
+static const char * const qt_scrollbar_button_arrow_right[] = {
+"6 7 19 1",
+"c c #303030",
+"g c #333333",
+"n c #3d3d3d",
+"d c #3e3e3e",
+"i c #4d4d4d",
+"k c #626262",
+"f c #646464",
+"p c #8b8b8b",
+"# c #919191",
+"l c #9b9b9b",
+"h c #9e9e9e",
+"m c #9f9f9f",
+"b c #a5a5a5",
+"o c #b3b3b3",
+"j c #b4b4b4",
+"e c #bababa",
+"q c #c6c6c6",
+"a c #cfcfcf",
+". c None",
+".#a...",
+"bcde..",
+".fcgh.",
+"..iccj",
+".kcgl.",
+"mcno..",
+".pq..."};
+
+static const char * const qt_scrollbar_button_arrow_up[] = {
+"7 6 17 1",
+"b c #303030",
+"e c #333333",
+"h c #3d3d3d",
+"i c #4c4c4c",
+"m c #626262",
+"l c #656565",
+"n c #8a8a8a",
+"k c #919191",
+"c c #9a9a9a",
+"a c #9e9e9e",
+"o c #a4a4a4",
+"# c #afafaf",
+"f c #b3b3b3",
+"d c #b9b9b9",
+"j c #c5c5c5",
+"g c #cecece",
+". c None",
+"...#...",
+"..abc..",
+".debef.",
+"ghbibhj",
+"kbl.mbn",
+".o...a."};
+
+static const char * const qt_scrollbar_button_arrow_down[] = {
+"7 6 17 1",
+"c c #303030",
+"l c #333333",
+"h c #3d3d3d",
+"i c #4c4c4c",
+"e c #626262",
+"d c #656565",
+"f c #8a8a8a",
+"b c #919191",
+"n c #9a9a9a",
+"a c #9e9e9e",
+"# c #a4a4a4",
+"o c #afafaf",
+"m c #b3b3b3",
+"k c #b9b9b9",
+"j c #c5c5c5",
+"g c #cecece",
+". c None",
+".#...a.",
+"bcd.ecf",
+"ghcichj",
+".klclm.",
+"..acn..",
+"...o..."};
+
+static const char * const qt_scrollbar_buttons[] = {
+"15 15 31 1",
+"  c None",
+"n c #303030",
+"q c #333333",
+"t c #3d3d3d",
+"u c #4c4c4c",
+"y c #626262",
+"x c #656565",
+"z c #8a8a8a",
+"w c #919191",
+". c #989898",
+"o c #9a9a9a",
+"m c #9e9e9e",
+"A c #a4a4a4",
+"l c #afafaf",
+"r c #b3b3b3",
+"p c #b9b9b9",
+"v c #c5c5c5",
+"k c #c6c6c6",
+"s c #cecece",
+"B c #d4d4d4",
+"j c #dbdbdb",
+"i c #dcdcdc",
+"h c #dedede",
+"g c #dfdfdf",
+"f c #e0e0e0",
+"e c #e6e6e6",
+"a c #e7e7e7",
+"d c #e8e8e8",
+"c c #e9e9e9",
+"b c #eaeaea",
+"# c #f7f7f7",
+"...............",
+".############a.",
+".#           k.",
+".#           k.",
+".#           k.",
+".#           k.",
+".#           k.",
+".#           k.",
+".#           k.",
+".#           k.",
+".#           k.",
+".#           k.",
+".#           k.",
+".akkkkkkkkkkkk.",
+"..............."};	
+
+
+static const char * const qt_haiku_menuitem_checkbox_checked[] = {
+"9 9 31 1",
+"d c #000000",
+"t c #020202",
+"m c #060606",
+"e c #0b0b0b",
+"w c #0e0e0e",
+"j c #191919",
+"z c #1a1a1a",
+"s c #2b2b2b",
+"p c #2d2d2d",
+"# c #4d4d4d",
+"r c #555555",
+"o c #636363",
+"x c #646464",
+"a c #707070",
+"k c #808080",
+"y c #828282",
+"h c #838383",
+"c c #9a9a9a",
+"B c #9c9c9c",
+"g c #a7a7a7",
+"u c #b5b5b5",
+"l c #bfbfbf",
+"n c #c0c0c0",
+"f c #c8c8c8",
+"C c #c9c9c9",
+"v c #cdcdcd",
+"i c #d5d5d5",
+"A c #d6d6d6",
+"b c #d9d9d9",
+"q c #dedede",
+". c None",
+"......#ab",
+".....cdef",
+".gh.ijdk.",
+"ldmnodpq.",
+".rdsttu..",
+".vwddx...",
+"..ydzA...",
+"..qsB....",
+"...C....."};
+
+class TemporarySurface
+{
+public:
+	TemporarySurface(const BRect& bounds)
+		: mBitmap(bounds, B_BITMAP_ACCEPTS_VIEWS, B_RGBA32)
+		, mView(bounds, "Qt temporary surface", 0, 0)
+		, mImage(reinterpret_cast<const uchar*>(mBitmap.Bits()),
+			bounds.IntegerWidth() + 1, bounds.IntegerHeight() + 1,
+			mBitmap.BytesPerRow(), QImage::Format_ARGB32)
+	{
+		mBitmap.Lock();
+		mBitmap.AddChild(&mView);
+	}
+
+	~TemporarySurface()
+	{
+		mBitmap.RemoveChild(&mView);
+		mBitmap.Unlock();
+	}
+
+	BView* view()
+	{
+		return &mView;
+	}
+
+	QImage& image()
+	{
+		if(mView.Window())
+			mView.Sync();
+		return mImage;
+	}
+
+private:
+	BBitmap		mBitmap;
+	BView		mView;
+	QImage		mImage;
+};
+
+
+static QColor mkQColor(rgb_color rgb)
+{
+	return QColor(rgb.red, rgb.green, rgb.blue);
+}
+
+static void qt_haiku_draw_button(QPainter *painter, const QRect &qrect, bool def, bool flat, bool pushed, bool focus, bool enabled)
+{
+	QRect rect = qrect;
+	if (be_control_look != NULL) {
+		// TODO: If this button is embedded within a different color background, it would be
+		// nice to tell this function so the frame can be smoothly blended into the background.
+		rgb_color background = ui_color(B_PANEL_BACKGROUND_COLOR);
+		rgb_color base = background;
+		uint32 flags = 0;
+		if (pushed)
+			flags |= BControlLook::B_ACTIVATED;
+		if (focus)
+			flags |= BControlLook::B_FOCUSED;
+		if (def) {
+			flags |= BControlLook::B_DEFAULT_BUTTON;
+			rect = rect.adjusted(-2,-2,2,2);
+		}
+		if (!enabled)
+			flags |= BControlLook::B_DISABLED;
+
+		BRect bRect(0.0f, 0.0f, rect.width() - 1, rect.height() - 1);
+
+		TemporarySurface surface(bRect);
+
+		be_control_look->DrawButtonFrame(surface.view(), bRect, bRect, base, background, flags);
+		be_control_look->DrawButtonBackground(surface.view(), bRect, bRect, base, flags);
+
+		painter->drawImage(rect, surface.image());
+
+		return;
+	}
+}
+
+static void qt_haiku_draw_gradient(QPainter *painter, const QRect &rect, const QColor &gradientStart,
+                                        const QColor &gradientStop, Direction direction = TopDown, QBrush bgBrush = QBrush())
+{
+        int x = rect.center().x();
+        int y = rect.center().y();
+        QLinearGradient *gradient;
+        switch(direction) {
+            case FromLeft:
+                gradient = new QLinearGradient(rect.left(), y, rect.right(), y);
+                break;
+            case FromRight:
+                gradient = new QLinearGradient(rect.right(), y, rect.left(), y);
+                break;
+            case BottomUp:
+                gradient = new QLinearGradient(x, rect.bottom(), x, rect.top());
+                break;
+            case TopDown:
+            default:
+                gradient = new QLinearGradient(x, rect.top(), x, rect.bottom());
+                break;
+        }
+        if (bgBrush.gradient())
+            gradient->setStops(bgBrush.gradient()->stops());
+        else {
+            gradient->setColorAt(0, gradientStart);
+            gradient->setColorAt(1, gradientStop);
+        }
+        painter->fillRect(rect, *gradient);
+        delete gradient;
+}
+
+static QString uniqueName(const QString &key, const QStyleOption *option, const QSize &size)
+{
+    QString tmp;
+    const QStyleOptionComplex *complexOption = qstyleoption_cast<const QStyleOptionComplex *>(option);
+    tmp.sprintf("%s-%d-%d-%lld-%dx%d-%d", key.toLatin1().constData(), uint(option->state),
+                complexOption ? uint(complexOption->activeSubControls) : uint(0),
+                option->palette.cacheKey(), size.width(), size.height(), option->direction);
+#ifndef QT_NO_SPINBOX
+    if (const QStyleOptionSpinBox *spinBox = qstyleoption_cast<const QStyleOptionSpinBox *>(option)) {
+        tmp.append(QLatin1Char('-'));
+        tmp.append(QString::number(spinBox->buttonSymbols));
+        tmp.append(QLatin1Char('-'));
+        tmp.append(QString::number(spinBox->stepEnabled));
+        tmp.append(QLatin1Char('-'));
+        tmp.append(QLatin1Char(spinBox->frame ? '1' : '0'));
+    }
+#endif // QT_NO_SPINBOX
+    return tmp;
+}
+
+static void qt_haiku_draw_mdibutton(QPainter *painter, const QStyleOptionTitleBar *option, const QRect &tmp, bool hover, bool sunken)
+{
+    QColor dark;
+    dark.setHsv(option->palette.button().color().hue(),
+                CL_MIN(255, (int)(option->palette.button().color().saturation()*1.9)),
+                CL_MIN(255, (int)(option->palette.button().color().value()*0.7)));
+
+    QColor highlight = option->palette.highlight().color();
+
+    bool active = (option->titleBarState & QStyle::State_Active);
+    QColor titleBarHighlight(255, 255, 255, 60);
+
+    if (sunken)
+        painter->fillRect(tmp.adjusted(1, 1, -1, -1), option->palette.highlight().color().darker(120));
+    else if (hover)
+        painter->fillRect(tmp.adjusted(1, 1, -1, -1), QColor(255, 255, 255, 20));
+
+    QColor mdiButtonGradientStartColor;
+    QColor mdiButtonGradientStopColor;
+
+    mdiButtonGradientStartColor = QColor(0, 0, 0, 40);
+    mdiButtonGradientStopColor = QColor(255, 255, 255, 60);
+
+    if (sunken)
+        titleBarHighlight = highlight.darker(130);
+
+    QLinearGradient gradient(tmp.center().x(), tmp.top(), tmp.center().x(), tmp.bottom());
+    gradient.setColorAt(0, mdiButtonGradientStartColor);
+    gradient.setColorAt(1, mdiButtonGradientStopColor);
+    QColor mdiButtonBorderColor(active ? option->palette.highlight().color().darker(180): dark.darker(110));
+
+    painter->setPen(QPen(mdiButtonBorderColor, 1));
+    painter->drawLine(tmp.left() + 2, tmp.top(), tmp.right() - 2, tmp.top());
+    painter->drawLine(tmp.left() + 2, tmp.bottom(), tmp.right() - 2, tmp.bottom());
+    painter->drawLine(tmp.left(), tmp.top() + 2, tmp.left(), tmp.bottom() - 2);
+    painter->drawLine(tmp.right(), tmp.top() + 2, tmp.right(), tmp.bottom() - 2);
+    painter->drawPoint(tmp.left() + 1, tmp.top() + 1);
+    painter->drawPoint(tmp.right() - 1, tmp.top() + 1);
+    painter->drawPoint(tmp.left() + 1, tmp.bottom() - 1);
+    painter->drawPoint(tmp.right() - 1, tmp.bottom() - 1);
+
+    painter->setPen(titleBarHighlight);
+    painter->drawLine(tmp.left() + 2, tmp.top() + 1, tmp.right() - 2, tmp.top() + 1);
+    painter->drawLine(tmp.left() + 1, tmp.top() + 2, tmp.left() + 1, tmp.bottom() - 2);
+
+    painter->setPen(QPen(gradient, 1));
+    painter->drawLine(tmp.right() + 1, tmp.top() + 2, tmp.right() + 1, tmp.bottom() - 2);
+    painter->drawPoint(tmp.right() , tmp.top() + 1);
+
+    painter->drawLine(tmp.left() + 2, tmp.bottom() + 1, tmp.right() - 2, tmp.bottom() + 1);
+    painter->drawPoint(tmp.left() + 1, tmp.bottom());
+    painter->drawPoint(tmp.right() - 1, tmp.bottom());
+    painter->drawPoint(tmp.right() , tmp.bottom() - 1);
+}
+
+/*!
+    \class QHaikuStyle
+    \brief The QHaikuStyle class provides a widget style similar to the
+    Clearlooks style available in GNOME.
+    \since 4.2
+
+    The Haiku style provides a look and feel for widgets
+    that closely resembles the Clearlooks style, introduced by Richard
+    Stellingwerff and Daniel Borgmann.
+
+    \sa {Haiku Style Widget Gallery}, QWindowsXPStyle, QMacStyle, QWindowsStyle,
+        QCDEStyle, QMotifStyle, QPlastiqueStyle
+*/
+
+/*!
+    Constructs a QHaikuStyle object.
+*/
+QHaikuStyle::QHaikuStyle() : QWindowsStyle(*new QHaikuStylePrivate)
+{
+    setObjectName(QLatin1String("Haiku"));
+}
+
+/*!
+    \internal
+
+    Constructs a QHaikuStyle object.
+*/
+QHaikuStyle::QHaikuStyle(QHaikuStylePrivate &dd) : QWindowsStyle(dd)
+{
+}
+
+/*!
+    Destroys the QHaikuStyle object.
+*/
+QHaikuStyle::~QHaikuStyle()
+{
+}
+
+/*!
+    \fn void QHaikuStyle::drawItemText(QPainter *painter, const QRect &rectangle, int alignment, const QPalette &palette,
+                                    bool enabled, const QString& text, QPalette::ColorRole textRole) const
+
+    Draws the given \a text in the specified \a rectangle using the
+    provided \a painter and \a palette.
+
+    Text is drawn using the painter's pen. If an explicit \a textRole
+    is specified, then the text is drawn using the \a palette's color
+    for the specified role.  The \a enabled value indicates whether or
+    not the item is enabled; when reimplementing, this value should
+    influence how the item is drawn.
+
+    The text is aligned and wrapped according to the specified \a
+    alignment.
+
+    \sa Qt::Alignment
+*/
+void QHaikuStyle::drawItemText(QPainter *painter, const QRect &rect, int alignment, const QPalette &pal,
+                                    bool enabled, const QString& text, QPalette::ColorRole textRole) const
+{
+    if (text.isEmpty())
+        return;
+
+    QPen savedPen = painter->pen();
+    if (textRole != QPalette::NoRole) {
+        painter->setPen(QPen(pal.brush(textRole), savedPen.widthF()));
+    }
+    if (!enabled) {
+        QPen pen = painter->pen();
+        painter->setPen(pen);
+    }
+    painter->drawText(rect, alignment, text);
+    painter->setPen(savedPen);
+}
+
+static QColor mergedColors(const QColor &colorA, const QColor &colorB, int factor = 50)
+{
+    const int maxFactor = 100;
+    QColor tmp = colorA;
+    tmp.setRed((tmp.red() * factor) / maxFactor + (colorB.red() * (maxFactor - factor)) / maxFactor);
+    tmp.setGreen((tmp.green() * factor) / maxFactor + (colorB.green() * (maxFactor - factor)) / maxFactor);
+    tmp.setBlue((tmp.blue() * factor) / maxFactor + (colorB.blue() * (maxFactor - factor)) / maxFactor);
+    return tmp;
+}
+
+/*!
+    \reimp
+*/
+void QHaikuStyle::drawPrimitive(PrimitiveElement elem,
+                        const QStyleOption *option,
+                        QPainter *painter, const QWidget *widget) const
+{
+    Q_ASSERT(option);
+    QRect rect = option->rect;
+    int state = option->state;
+    QColor button = option->palette.button().color();
+    QColor buttonShadow = option->palette.button().color().darker(110);
+    QColor buttonShadowAlpha = buttonShadow;
+    buttonShadowAlpha.setAlpha(128);
+    QColor darkOutline;
+    QColor dark;
+    darkOutline.setHsv(button.hue(),
+                CL_MIN(255, (int)(button.saturation()*3.0)),
+                CL_MIN(255, (int)(button.value()*0.6)));
+    dark.setHsv(button.hue(),
+                CL_MIN(255, (int)(button.saturation()*1.9)),
+                CL_MIN(255, (int)(button.value()*0.7)));
+    QColor tabFrameColor = mergedColors(option->palette.background().color(),
+                                                dark.lighter(135), 60);
+
+    switch(elem) {
+#ifndef QT_NO_TABBAR
+    case PE_FrameTabBarBase:
+        if (const QStyleOptionTabBarBase *tbb
+                = qstyleoption_cast<const QStyleOptionTabBarBase *>(option)) {
+            painter->save();
+            painter->setPen(QPen(darkOutline.lighter(110), 0));
+            switch (tbb->shape) {
+            case QTabBar::RoundedNorth: {
+                QRegion region(tbb->rect);
+                region -= tbb->selectedTabRect;
+                painter->drawLine(tbb->rect.topLeft(), tbb->rect.topRight());
+                painter->setClipRegion(region);
+                painter->setPen(option->palette.light().color());
+                painter->drawLine(tbb->rect.topLeft() + QPoint(0, 1),
+                                  tbb->rect.topRight()  + QPoint(0, 1));
+            }
+                break;
+            case QTabBar::RoundedWest:
+                painter->drawLine(tbb->rect.left(), tbb->rect.top(), tbb->rect.left(), tbb->rect.bottom());
+                break;
+            case QTabBar::RoundedSouth:
+                painter->drawLine(tbb->rect.left(), tbb->rect.bottom(),
+                            tbb->rect.right(), tbb->rect.bottom());
+                break;
+            case QTabBar::RoundedEast:
+                painter->drawLine(tbb->rect.topRight(), tbb->rect.bottomRight());
+                break;
+            case QTabBar::TriangularNorth:
+            case QTabBar::TriangularEast:
+            case QTabBar::TriangularWest:
+            case QTabBar::TriangularSouth:
+                painter->restore();
+                QWindowsStyle::drawPrimitive(elem, option, painter, widget);
+                return;
+            }
+            painter->restore();
+        }
+        return;
+#endif // QT_NO_TABBAR
+    case PE_IndicatorViewItemCheck:
+        {
+            QStyleOptionButton button;
+            button.QStyleOption::operator=(*option);
+            button.state &= ~State_MouseOver;
+            drawPrimitive(PE_IndicatorCheckBox, &button, painter, widget);
+        }
+        return;
+    case PE_IndicatorHeaderArrow:
+        if (const QStyleOptionHeader *header = qstyleoption_cast<const QStyleOptionHeader *>(option)) {
+            QRect r = header->rect;
+            QImage arrow;
+            if (header->sortIndicator & QStyleOptionHeader::SortUp)
+                arrow = QImage(qt_scrollbar_button_arrow_up);
+            else if (header->sortIndicator & QStyleOptionHeader::SortDown)
+                arrow = QImage(qt_scrollbar_button_arrow_down);
+            if (!arrow.isNull()) {
+                r.setSize(arrow.size());
+                r.moveCenter(header->rect.center());
+                arrow.setColor(1, header->palette.foreground().color().rgba());
+                painter->drawImage(r, arrow);
+            }
+        }
+        break;
+    case PE_IndicatorButtonDropDown:
+        drawPrimitive(PE_PanelButtonCommand, option, painter, widget);
+        break;
+    case PE_IndicatorToolBarSeparator:
+        {
+            QRect rect = option->rect;
+            const int margin = 6;
+            if (option->state & State_Horizontal) {
+                const int offset = rect.width()/2;
+                painter->setPen(QPen(option->palette.background().color().darker(110)));
+                painter->drawLine(rect.bottomLeft().x() + offset,
+                            rect.bottomLeft().y() - margin,
+                            rect.topLeft().x() + offset,
+                            rect.topLeft().y() + margin);
+                painter->setPen(QPen(option->palette.background().color().lighter(110)));
+                painter->drawLine(rect.bottomLeft().x() + offset + 1,
+                            rect.bottomLeft().y() - margin,
+                            rect.topLeft().x() + offset + 1,
+                            rect.topLeft().y() + margin);
+            } else { //Draw vertical separator
+                const int offset = rect.height()/2;
+                painter->setPen(QPen(option->palette.background().color().darker(110)));
+                painter->drawLine(rect.topLeft().x() + margin ,
+                            rect.topLeft().y() + offset,
+                            rect.topRight().x() - margin,
+                            rect.topRight().y() + offset);
+                painter->setPen(QPen(option->palette.background().color().lighter(110)));
+                painter->drawLine(rect.topLeft().x() + margin ,
+                            rect.topLeft().y() + offset + 1,
+                            rect.topRight().x() - margin,
+                            rect.topRight().y() + offset + 1);
+            }
+        }
+        break;
+    case PE_Frame:
+        painter->save();
+        painter->setPen(dark.lighter(108));
+        painter->drawRect(option->rect.adjusted(0, 0, -1, -1));
+        painter->restore();
+        break;
+    case PE_FrameMenu:
+        painter->save();
+        {
+            painter->setPen(QPen(darkOutline, 1));
+            painter->drawRect(option->rect.adjusted(0, 0, -1, -1));
+            QColor frameLight = option->palette.background().color().lighter(160);
+            QColor frameShadow = option->palette.background().color().darker(110);
+
+            //paint beveleffect
+            QRect frame = option->rect.adjusted(1, 1, -1, -1);
+            painter->setPen(frameLight);
+            painter->drawLine(frame.topLeft(), frame.bottomLeft());
+            painter->drawLine(frame.topLeft(), frame.topRight());
+
+            painter->setPen(frameShadow);
+            painter->drawLine(frame.topRight(), frame.bottomRight());
+            painter->drawLine(frame.bottomLeft(), frame.bottomRight());
+        }
+        painter->restore();
+        break;
+    case PE_FrameDockWidget:
+
+        painter->save();
+        {
+            QColor softshadow = option->palette.background().color().darker(120);
+
+            QRect rect= option->rect;
+            painter->setPen(softshadow);
+            painter->drawRect(option->rect.adjusted(0, 0, -1, -1));
+            painter->setPen(QPen(option->palette.light(), 0));
+            painter->drawLine(QPoint(rect.left() + 1, rect.top() + 1), QPoint(rect.left() + 1, rect.bottom() - 1));
+            painter->setPen(QPen(option->palette.background().color().darker(120), 0));
+            painter->drawLine(QPoint(rect.left() + 1, rect.bottom() - 1), QPoint(rect.right() - 2, rect.bottom() - 1));
+            painter->drawLine(QPoint(rect.right() - 1, rect.top() + 1), QPoint(rect.right() - 1, rect.bottom() - 1));
+
+        }
+        painter->restore();
+        break;
+    case PE_PanelButtonTool:
+        painter->save();
+        if ((option->state & State_Enabled || option->state & State_On) || !(option->state & State_AutoRaise)) {
+            QRect rect = option->rect;
+            QPen oldPen = painter->pen();
+
+            if (widget && widget->inherits("QDockWidgetTitleButton")) {
+                   if (option->state & State_MouseOver)
+                       drawPrimitive(PE_PanelButtonCommand, option, painter, widget);
+            } else {
+                drawPrimitive(PE_PanelButtonCommand, option, painter, widget);
+            }
+        }
+        painter->restore();
+        break;
+    case PE_IndicatorDockWidgetResizeHandle:
+        {
+            QStyleOption dockWidgetHandle = *option;
+            bool horizontal = option->state & State_Horizontal;
+            if (horizontal)
+                dockWidgetHandle.state &= ~State_Horizontal;
+            else
+                dockWidgetHandle.state |= State_Horizontal;
+            drawControl(CE_Splitter, &dockWidgetHandle, painter, widget);
+        }
+        break;
+    case PE_FrameWindow:
+        painter->save();
+        {
+            QRect rect= option->rect;
+            painter->setPen(QPen(dark.darker(150), 0));
+            painter->drawRect(option->rect.adjusted(0, 0, -1, -1));
+            painter->setPen(QPen(option->palette.light(), 0));
+            painter->drawLine(QPoint(rect.left() + 1, rect.top() + 1),
+                              QPoint(rect.left() + 1, rect.bottom() - 1));
+            painter->setPen(QPen(option->palette.background().color().darker(120), 0));
+            painter->drawLine(QPoint(rect.left() + 1, rect.bottom() - 1),
+                              QPoint(rect.right() - 2, rect.bottom() - 1));
+            painter->drawLine(QPoint(rect.right() - 1, rect.top() + 1),
+                              QPoint(rect.right() - 1, rect.bottom() - 1));
+        }
+        painter->restore();
+        break;
+#ifndef QT_NO_LINEDIT
+    case PE_FrameLineEdit:
+        // fall through
+#endif // QT_NO_LINEEDIT
+#ifdef QT3_SUPPORT
+        if (widget && widget->inherits("Q3ToolBar")) {
+            drawPrimitive(PE_Q3Separator, option, painter, widget);
+            break;
+        }
+#endif
+        {
+            QPen oldPen = painter->pen();
+            if (option->state & State_Enabled) {
+            	if(option->state & State_HasFocus)
+	                painter->setPen(QPen(mkQColor(ui_color(B_NAVIGATION_BASE_COLOR)), 0));
+	            else
+		            painter->setPen(QPen(QColor(129,129,129), 0));
+                painter->drawRect(rect.adjusted(1, 1, -1, -1));
+            } else {
+                painter->fillRect(rect, option->palette.background());
+                painter->setPen(QPen(QColor(129,129,129), 0));
+                painter->drawRect(rect.adjusted(1, 1, -1, -1));
+            }                                   
+        }
+        break;
+    case PE_IndicatorCheckBox:
+        painter->save();
+        if (const QStyleOptionButton *checkbox = qstyleoption_cast<const QStyleOptionButton*>(option)) {
+            
+            rect = rect.adjusted(-2, -2, 1, 1);
+			BRect bRect(0.0f, 0.0f, rect.width() - 1, rect.height() - 1);
+			TemporarySurface surface(bRect);
+			rgb_color base = ui_color(B_PANEL_BACKGROUND_COLOR);
+			uint32 flags = 0;
+
+			if (!(state & State_Enabled))
+				flags |= BControlLook::B_DISABLED;
+			if (checkbox->state & State_On)
+				flags |= BControlLook::B_ACTIVATED;
+			if (checkbox->state & State_HasFocus)
+				flags |= BControlLook::B_FOCUSED;
+			if (checkbox->state & State_Sunken)
+				flags |= BControlLook::B_CLICKED;
+			if (checkbox->state & State_NoChange)
+				flags |= BControlLook::B_DISABLED | BControlLook::B_ACTIVATED;
+
+			be_control_look->DrawCheckBox(surface.view(), bRect, bRect, base, flags);
+			painter->drawImage(rect, surface.image());
+        }
+        painter->restore();
+        break;
+    case PE_IndicatorRadioButton:
+        painter->save();
+        {
+            painter->setRenderHint(QPainter::SmoothPixmapTransform);
+            QRect checkRect = rect.adjusted(0, 0, 0, 0);
+
+            painter->setRenderHint(QPainter::Antialiasing);
+            if (state & State_Sunken)
+            	painter->setBrush(mkQColor(ui_color(B_PANEL_BACKGROUND_COLOR)));
+            else
+            	painter->setBrush(QColor(255,255,255));
+
+			if(state & State_HasFocus)
+				painter->setPen(QPen(mkQColor(ui_color(B_NAVIGATION_BASE_COLOR)), 0));
+            else
+	            painter->setPen(QColor(129,129,129));
+            painter->drawEllipse(rect);
+
+            if (state & (State_On )) {
+                painter->setBrush(QColor(27,82,140));
+                painter->setPen(Qt::NoPen);
+                painter->drawEllipse(rect.adjusted(3, 3, -3, -3));            	
+            }
+        }
+        painter->restore();
+    break;
+    case PE_IndicatorToolBarHandle:
+        painter->save();
+        if (option->state & State_Horizontal) {
+            for (int i = rect.height()/5; i <= 4*(rect.height()/5) ; ++i) {
+                int y = rect.topLeft().y() + i + 1;
+                int x1 = rect.topLeft().x() + 3;
+                int x2 = rect.topRight().x() - 2;
+
+                if (i % 2 == 0)
+                    painter->setPen(QPen(option->palette.light(), 0));
+                else
+                    painter->setPen(QPen(dark.lighter(110), 0));
+                painter->drawLine(x1, y, x2, y);
+            }
+        }
+        else { //vertical toolbar
+            for (int i = rect.width()/5; i <= 4*(rect.width()/5) ; ++i) {
+                int x = rect.topLeft().x() + i + 1;
+                int y1 = rect.topLeft().y() + 3;
+                int y2 = rect.topLeft().y() + 5;
+
+                if (i % 2 == 0)
+                    painter->setPen(QPen(option->palette.light(), 0));
+                else
+                    painter->setPen(QPen(dark.lighter(110), 0));
+                painter->drawLine(x, y1, x, y2);
+            }
+        }
+        painter->restore();
+        break;
+    case PE_FrameDefaultButton:
+        case PE_FrameFocusRect:
+        if (const QStyleOptionFocusRect *focusFrame = qstyleoption_cast<const QStyleOptionFocusRect *>(option)) {
+            if (!(focusFrame->state & State_KeyboardFocusChange))
+                return;
+            QRect rect = focusFrame->rect;
+            painter->save();
+            painter->setBackgroundMode(Qt::TransparentMode);
+            painter->setBrush(QBrush(dark.darker(120), Qt::Dense4Pattern));
+            painter->setBrushOrigin(rect.topLeft());
+            painter->setPen(Qt::NoPen);
+            painter->drawRect(rect.left(), rect.top(), rect.width(), 1);    // Top
+            painter->drawRect(rect.left(), rect.bottom(), rect.width(), 1); // Bottom
+            painter->drawRect(rect.left(), rect.top(), 1, rect.height());   // Left
+            painter->drawRect(rect.right(), rect.top(), 1, rect.height());  // Right
+            painter->restore();
+        }
+        break;
+    case PE_PanelButtonCommand:
+        painter->save();
+        {   
+	        if (const QStyleOptionButton *btn = qstyleoption_cast<const QStyleOptionButton *>(option)) {
+	            QStyleOptionButton copy = *btn;
+	            
+	            bool enabled = option->state & State_Enabled;
+	            bool pushed = (option->state & State_Sunken) || (option->state & State_On);
+	            bool focus = option->state & State_HasFocus;
+	            bool flat = btn->features & QStyleOptionFrameV2::Flat;
+                bool def = (btn->features & QStyleOptionButton::DefaultButton) && (btn->state & State_Enabled);
+            	            
+				qt_haiku_draw_button(painter, option->rect.adjusted(1,1,-1,-1), def, flat, pushed, focus, enabled);
+	        }
+	     painter->restore();
+        }        
+        break;
+#ifndef QT_NO_TABBAR
+        case PE_FrameTabWidget:
+            painter->save();
+        {
+            painter->fillRect(option->rect, tabFrameColor);
+        }
+#ifndef QT_NO_TABWIDGET
+        if (const QStyleOptionTabWidgetFrame *twf = qstyleoption_cast<const QStyleOptionTabWidgetFrame *>(option)) {
+            QColor borderColor = darkOutline.lighter(110);
+            QColor alphaCornerColor = mergedColors(borderColor, option->palette.background().color());
+            QColor innerShadow = mergedColors(borderColor, option->palette.base().color());
+
+            int borderThickness = pixelMetric(PM_TabBarBaseOverlap, twf, widget);
+            bool reverse = (twf->direction == Qt::RightToLeft);
+            QRect tabBarRect;
+
+            switch (twf->shape) {
+            case QTabBar::RoundedNorth:
+                if (reverse) {
+                    tabBarRect = QRect(twf->rect.right() - twf->leftCornerWidgetSize.width()
+                                       - twf->tabBarSize.width() + 1,
+                                       twf->rect.top(),
+                                       twf->tabBarSize.width(), borderThickness);
+                } else {
+                    tabBarRect = QRect(twf->rect.left() + twf->leftCornerWidgetSize.width(),
+                                       twf->rect.top(),
+                                       twf->tabBarSize.width(), borderThickness);
+                }
+                break ;
+            case QTabBar::RoundedWest:
+                tabBarRect = QRect(twf->rect.left(),
+                                   twf->rect.top() + twf->leftCornerWidgetSize.height(),
+                                   borderThickness,
+                                   twf->tabBarSize.height());
+                tabBarRect = tabBarRect; //adjust
+                break ;
+            case QTabBar::RoundedEast:
+                tabBarRect = QRect(twf->rect.right() - borderThickness + 1,
+                                   twf->rect.top()  + twf->leftCornerWidgetSize.height(),
+                                   0,
+                                   twf->tabBarSize.height());
+                break ;
+            case QTabBar::RoundedSouth:
+                if (reverse) {
+                    tabBarRect = QRect(twf->rect.right() - twf->leftCornerWidgetSize.width() - twf->tabBarSize.width() + 1,
+                                       twf->rect.bottom() + 1,
+                                       twf->tabBarSize.width(),
+                                       borderThickness);
+                } else {
+                    tabBarRect = QRect(twf->rect.left() + twf->leftCornerWidgetSize.width(),
+                                       twf->rect.bottom() + 1,
+                                       twf->tabBarSize.width(),
+                                       borderThickness);
+                }
+                break;
+            default:
+                break;
+            }
+
+            QRegion region(twf->rect);
+            region -= tabBarRect;
+            painter->setClipRegion(region);
+
+            // Outer border
+            QLine leftLine = QLine(twf->rect.topLeft() + QPoint(0, 2), twf->rect.bottomLeft() - QPoint(0, 2));
+            QLine rightLine = QLine(twf->rect.topRight(), twf->rect.bottomRight() - QPoint(0, 2));
+            QLine bottomLine = QLine(twf->rect.bottomLeft() + QPoint(2, 0), twf->rect.bottomRight() - QPoint(2, 0));
+            QLine topLine = QLine(twf->rect.topLeft(), twf->rect.topRight());
+
+            painter->setPen(borderColor);
+            painter->drawLine(topLine);
+
+            // Inner border
+            QLine innerLeftLine = QLine(leftLine.p1() + QPoint(1, 0), leftLine.p2() + QPoint(1, 0));
+            QLine innerRightLine = QLine(rightLine.p1() - QPoint(1, -1), rightLine.p2() - QPoint(1, 0));
+            QLine innerBottomLine = QLine(bottomLine.p1() - QPoint(0, 1), bottomLine.p2() - QPoint(0, 1));
+            QLine innerTopLine = QLine(topLine.p1() + QPoint(0, 1), topLine.p2() + QPoint(-1, 1));
+
+            // Rounded Corner
+            QPoint leftBottomOuterCorner = QPoint(innerLeftLine.p2() + QPoint(0, 1));
+            QPoint leftBottomInnerCorner1 = QPoint(leftLine.p2() + QPoint(0, 1));
+            QPoint leftBottomInnerCorner2 = QPoint(bottomLine.p1() - QPoint(1, 0));
+            QPoint rightBottomOuterCorner = QPoint(innerRightLine.p2() + QPoint(0, 1));
+            QPoint rightBottomInnerCorner1 = QPoint(rightLine.p2() + QPoint(0, 1));
+            QPoint rightBottomInnerCorner2 = QPoint(bottomLine.p2() + QPoint(1, 0));
+            QPoint leftTopOuterCorner = QPoint(innerLeftLine.p1() - QPoint(0, 1));
+            QPoint leftTopInnerCorner1 = QPoint(leftLine.p1() - QPoint(0, 1));
+            QPoint leftTopInnerCorner2 = QPoint(topLine.p1() - QPoint(1, 0));
+
+            painter->setPen(borderColor);
+            painter->drawLine(leftLine);
+            painter->drawLine(rightLine);
+            painter->drawLine(bottomLine);
+            painter->drawPoint(leftBottomOuterCorner);
+            painter->drawPoint(rightBottomOuterCorner);
+            painter->drawPoint(leftTopOuterCorner);
+
+            painter->setPen(option->palette.light().color());
+            painter->drawLine(innerLeftLine);
+            painter->drawLine(innerTopLine);
+
+            painter->setPen(buttonShadowAlpha);
+            painter->drawLine(innerRightLine);
+            painter->drawLine(innerBottomLine);
+
+            painter->setPen(alphaCornerColor);
+            painter->drawPoint(leftBottomInnerCorner1);
+            painter->drawPoint(leftBottomInnerCorner2);
+            painter->drawPoint(rightBottomInnerCorner1);
+            painter->drawPoint(rightBottomInnerCorner2);
+            painter->drawPoint(leftTopInnerCorner1);
+            painter->drawPoint(leftTopInnerCorner2);
+        }
+#endif // QT_NO_TABWIDGET
+    painter->restore();
+    break ;
+
+    case PE_FrameStatusBarItem:
+        break;
+    case PE_IndicatorTabClose:
+        {
+            Q_D(const QHaikuStyle);
+            if (d->tabBarcloseButtonIcon.isNull())
+                d->tabBarcloseButtonIcon = standardIcon(SP_DialogCloseButton, option, widget);
+            if ((option->state & State_Enabled) && (option->state & State_MouseOver))
+                drawPrimitive(PE_PanelButtonCommand, option, painter, widget);
+            QPixmap pixmap = d->tabBarcloseButtonIcon.pixmap(QSize(16, 16), QIcon::Normal, QIcon::On);
+            drawItemPixmap(painter, option->rect, Qt::AlignCenter, pixmap);
+        }
+        break;
+
+#endif // QT_NO_TABBAR
+    default:
+        QWindowsStyle::drawPrimitive(elem, option, painter, widget);
+        break;
+    }
+}
+
+/*!
+  \reimp
+*/
+void QHaikuStyle::drawControl(ControlElement element, const QStyleOption *option, QPainter *painter,
+                                   const QWidget *widget) const
+{
+    QColor button = option->palette.button().color();
+    QColor dark;
+    dark.setHsv(button.hue(),
+                CL_MIN(255, (int)(button.saturation()*1.9)),
+                CL_MIN(255, (int)(button.value()*0.7)));
+    QColor darkOutline;
+    darkOutline.setHsv(button.hue(),
+                CL_MIN(255, (int)(button.saturation()*2.0)),
+                CL_MIN(255, (int)(button.value()*0.6)));
+    QRect rect = option->rect;
+    QColor shadow = mergedColors(option->palette.background().color().darker(120),
+                                 dark.lighter(130), 60);
+    QColor tabFrameColor = mergedColors(option->palette.background().color(),
+                                                dark.lighter(135), 60);
+
+    QColor highlight = option->palette.highlight().color();
+    QColor highlightText = option->palette.highlightedText().color();
+
+    switch(element) {
+     case CE_RadioButton: //fall through
+     case CE_CheckBox:
+        if (const QStyleOptionButton *btn = qstyleoption_cast<const QStyleOptionButton *>(option)) {
+            bool hover = (btn->state & State_MouseOver && btn->state & State_Enabled);
+            if (hover)
+                painter->fillRect(rect, btn->palette.background().color().lighter(104));
+            QStyleOptionButton copy = *btn;
+            copy.rect.adjust(2, 0, -2, 0);
+            QWindowsStyle::drawControl(element, &copy, painter, widget);
+        }
+        break;
+    case CE_Splitter:
+        painter->save();
+        {
+        	orientation orient = (option->state & State_Horizontal)?B_HORIZONTAL:B_VERTICAL;
+        	
+			if (be_control_look != NULL) {
+				QRect r = option->rect;
+				rgb_color base = ui_color(B_PANEL_BACKGROUND_COLOR);;
+				uint32 flags = 0;            
+		        BRect bRect(0.0f, 0.0f, r.width() - 1, r.height() - 1);
+				TemporarySurface surface(bRect);
+				be_control_look->DrawSplitter(surface.view(), bRect, bRect, base, orient, flags);
+				painter->drawImage(r, surface.image());			    
+			}
+        }
+        painter->restore();
+        break;
+    case CE_SizeGrip:
+        painter->save();
+       	painter->fillRect(option->rect, option->palette.background().color());
+        painter->restore();
+        break;        
+#ifndef QT_NO_TOOLBAR
+    case CE_ToolBar:
+        painter->save();
+        if (const QStyleOptionToolBar *toolbar = qstyleoption_cast<const QStyleOptionToolBar *>(option)) {
+            QRect rect = option->rect;
+
+            bool paintLeftBorder = true;
+            bool paintRightBorder = true;
+            bool paintBottomBorder = true;
+
+            switch (toolbar->toolBarArea) {
+            case Qt::BottomToolBarArea:
+                switch(toolbar->positionOfLine) {
+                case QStyleOptionToolBar::Beginning:
+                case QStyleOptionToolBar::OnlyOne:
+                    paintBottomBorder = false;
+                default:
+                    break;
+                }
+            case Qt::TopToolBarArea:
+                switch (toolbar->positionWithinLine) {
+                case QStyleOptionToolBar::Beginning:
+                    paintLeftBorder = false;
+                    break;
+                case QStyleOptionToolBar::End:
+                    paintRightBorder = false;
+                    break;
+                case QStyleOptionToolBar::OnlyOne:
+                    paintRightBorder = false;
+                    paintLeftBorder = false;
+                default:
+                    break;
+                }
+                if (QApplication::layoutDirection() == Qt::RightToLeft) { //reverse layout changes the order of Beginning/end
+                    bool tmp = paintLeftBorder;
+                    paintRightBorder=paintLeftBorder;
+                    paintLeftBorder=tmp;
+                }
+                break;
+            case Qt::RightToolBarArea:
+                switch (toolbar->positionOfLine) {
+                case QStyleOptionToolBar::Beginning:
+                case QStyleOptionToolBar::OnlyOne:
+                    paintRightBorder = false;
+                    break;
+                default:
+                    break;
+                }
+                break;
+            case Qt::LeftToolBarArea:
+                switch (toolbar->positionOfLine) {
+                case QStyleOptionToolBar::Beginning:
+                case QStyleOptionToolBar::OnlyOne:
+                    paintLeftBorder = false;
+                    break;
+                default:
+                    break;
+                }
+                break;
+            default:
+                break;
+            }
+
+            QColor light = option->palette.background().color().lighter(110);
+
+            //draw top border
+            painter->setPen(QPen(light));
+            painter->drawLine(rect.topLeft().x(),
+                        rect.topLeft().y(),
+                        rect.topRight().x(),
+                        rect.topRight().y());
+
+            if (paintLeftBorder) {
+                painter->setPen(QPen(light));
+                painter->drawLine(rect.topLeft().x(),
+                            rect.topLeft().y(),
+                            rect.bottomLeft().x(),
+                            rect.bottomLeft().y());
+            }
+
+            if (paintRightBorder) {
+                painter->setPen(QPen(shadow));
+                painter->drawLine(rect.topRight().x(),
+                            rect.topRight().y(),
+                            rect.bottomRight().x(),
+                            rect.bottomRight().y());
+            }
+
+            if (paintBottomBorder) {
+                painter->setPen(QPen(shadow));
+                painter->drawLine(rect.bottomLeft().x(),
+                            rect.bottomLeft().y(),
+                            rect.bottomRight().x(),
+                            rect.bottomRight().y());
+            }
+        }
+        painter->restore();
+        break;
+#endif // QT_NO_TOOLBAR
+#ifndef QT_NO_DOCKWIDGET
+    case CE_DockWidgetTitle:
+        painter->save();
+        if (const QStyleOptionDockWidget *dwOpt = qstyleoption_cast<const QStyleOptionDockWidget *>(option)) {
+            const QStyleOptionDockWidgetV2 *v2
+                = qstyleoption_cast<const QStyleOptionDockWidgetV2*>(dwOpt);
+            bool verticalTitleBar = v2 == 0 ? false : v2->verticalTitleBar;
+
+            QRect rect = dwOpt->rect;
+            QRect titleRect = subElementRect(SE_DockWidgetTitleBarText, option, widget);
+            QRect r = rect.adjusted(0, 0, -1, 0);
+            if (verticalTitleBar)
+                r.adjust(0, 0, 0, -1);
+            painter->setPen(option->palette.light().color());
+            painter->drawRect(r.adjusted(1, 1, 1, 1));
+            painter->setPen(shadow);
+            painter->drawRect(r);
+
+            if (verticalTitleBar) {
+                QRect r = rect;
+                QSize s = r.size();
+                s.transpose();
+                r.setSize(s);
+
+                titleRect = QRect(r.left() + rect.bottom()
+                                    - titleRect.bottom(),
+                                r.top() + titleRect.left() - rect.left(),
+                                titleRect.height(), titleRect.width());
+
+                painter->translate(r.left(), r.top() + r.width());
+                painter->rotate(-90);
+                painter->translate(-r.left(), -r.top());
+
+                rect = r;
+            }
+
+            if (!dwOpt->title.isEmpty()) {
+                QString titleText
+                    = painter->fontMetrics().elidedText(dwOpt->title,
+                                            Qt::ElideRight, titleRect.width());
+                drawItemText(painter,
+                             titleRect,
+                             Qt::AlignLeft | Qt::AlignVCenter | Qt::TextShowMnemonic, dwOpt->palette,
+                             dwOpt->state & State_Enabled, titleText,
+                             QPalette::WindowText);
+                }
+        }
+        painter->restore();
+        break;
+#endif // QT_NO_DOCKWIDGET
+    case CE_HeaderSection:
+        painter->save();
+        // Draws the header in tables.
+        if (const QStyleOptionHeader *header = qstyleoption_cast<const QStyleOptionHeader *>(option)) {
+            QPixmap cache;
+            QString pixmapName = uniqueName(QLatin1String("headersection"), option, option->rect.size());
+            pixmapName += QLatin1String("-") + QString::number(int(header->position));
+            pixmapName += QLatin1String("-") + QString::number(int(header->orientation));
+            QRect r = option->rect;
+            QColor gradientStopColor;
+            QColor gradientStartColor = option->palette.button().color();
+            gradientStopColor.setHsv(gradientStartColor.hue(),
+                                     CL_MIN(255, (int)(gradientStartColor.saturation()*2)),
+                                     CL_MIN(255, (int)(gradientStartColor.value()*0.96)));
+            QLinearGradient gradient(rect.topLeft(), rect.bottomLeft());
+            if (option->palette.background().gradient()) {
+                gradient.setStops(option->palette.background().gradient()->stops());
+            } else {
+                gradient.setColorAt(0, gradientStartColor);
+                gradient.setColorAt(0.8, gradientStartColor);
+                gradient.setColorAt(1, gradientStopColor);
+            }
+            painter->fillRect(r, gradient);
+
+            if (!UsePixmapCache || !QPixmapCache::find(pixmapName, cache)) {
+                cache = QPixmap(r.size());
+                cache.fill(Qt::transparent);
+                QRect pixmapRect(0, 0, r.width(), r.height());
+                QPainter cachePainter(&cache);
+                if (header->orientation == Qt::Vertical) {
+                    cachePainter.setPen(QPen(dark));
+                    cachePainter.drawLine(pixmapRect.topRight(), pixmapRect.bottomRight());
+                    if (header->position != QStyleOptionHeader::End) {
+                        cachePainter.setPen(QPen(shadow));
+                        cachePainter.drawLine(pixmapRect.bottomLeft() + QPoint(3, -1), pixmapRect.bottomRight() + QPoint(-3, -1));                                cachePainter.setPen(QPen(option->palette.light().color()));
+                        cachePainter.drawLine(pixmapRect.bottomLeft() + QPoint(3, 0), pixmapRect.bottomRight() + QPoint(-3, 0));                              }
+                } else {
+                    cachePainter.setPen(QPen(dark));
+                    cachePainter.drawLine(pixmapRect.bottomLeft(), pixmapRect.bottomRight());
+                    cachePainter.setPen(QPen(shadow));
+                    cachePainter.drawLine(pixmapRect.topRight() + QPoint(-1, 3), pixmapRect.bottomRight() + QPoint(-1, -3));                                  cachePainter.setPen(QPen(option->palette.light().color()));
+                    cachePainter.drawLine(pixmapRect.topRight() + QPoint(0, 3), pixmapRect.bottomRight() + QPoint(0, -3));                                }
+                cachePainter.end();
+                if (UsePixmapCache)
+                    QPixmapCache::insert(pixmapName, cache);
+            }
+            painter->drawPixmap(r.topLeft(), cache);
+        }
+        painter->restore();
+        break;
+    case CE_ProgressBarGroove:
+        painter->save();
+        {
+            painter->fillRect(rect, option->palette.base());
+            QColor borderColor = dark.lighter(110);
+            painter->setPen(QPen(borderColor, 0));
+            painter->drawLine(QPoint(rect.left() + 1, rect.top()), QPoint(rect.right() - 1, rect.top()));
+            painter->drawLine(QPoint(rect.left() + 1, rect.bottom()), QPoint(rect.right() - 1, rect.bottom()));
+            painter->drawLine(QPoint(rect.left(), rect.top() + 1), QPoint(rect.left(), rect.bottom() - 1));
+            painter->drawLine(QPoint(rect.right(), rect.top() + 1), QPoint(rect.right(), rect.bottom() - 1));
+            QColor alphaCorner = mergedColors(borderColor, option->palette.background().color());
+            QColor innerShadow = mergedColors(borderColor, option->palette.base().color());
+
+            //corner smoothing
+            painter->setPen(alphaCorner);
+            painter->drawPoint(rect.topRight());
+            painter->drawPoint(rect.topLeft());
+            painter->drawPoint(rect.bottomRight());
+            painter->drawPoint(rect.bottomLeft());
+
+            //inner shadow
+            painter->setPen(innerShadow);
+            painter->drawLine(QPoint(rect.left() + 1, rect.top() + 1),
+                              QPoint(rect.right() - 1, rect.top() + 1));
+            painter->drawLine(QPoint(rect.left() + 1, rect.top() + 1),
+                              QPoint(rect.left() + 1, rect.bottom() + 1));
+
+        }
+        painter->restore();
+        break;
+    case CE_ProgressBarContents:
+        painter->save();
+        if (const QStyleOptionProgressBar *bar = qstyleoption_cast<const QStyleOptionProgressBar *>(option)) {
+            QRect rect = bar->rect;
+            bool vertical = false;
+            bool inverted = false;
+            bool indeterminate = (bar->minimum == 0 && bar->maximum == 0);
+
+            // Get extra style options if version 2
+            if (const QStyleOptionProgressBarV2 *bar2 = qstyleoption_cast<const QStyleOptionProgressBarV2 *>(option)) {
+                vertical = (bar2->orientation == Qt::Vertical);
+                inverted = bar2->invertedAppearance;
+            }
+
+            // If the orientation is vertical, we use a transform to rotate
+            // the progress bar 90 degrees clockwise.  This way we can use the
+            // same rendering code for both orientations.
+            if (vertical) {
+                rect = QRect(rect.left(), rect.top(), rect.height(), rect.width()); // flip width and height
+                QTransform m;
+                m.translate(rect.height()-1, -1.0);
+                m.rotate(90.0);
+                painter->setTransform(m, true);
+            }
+
+            int maxWidth = rect.width() - 4;
+            int minWidth = 4;
+			qint64 progress = (qint64)qMax(bar->progress, bar->minimum); // workaround for bug in QProgressBar
+			double vc6_workaround = ((progress - qint64(bar->minimum)) / qMax(double(1.0), double(qint64(bar->maximum) - qint64(bar->minimum))) * maxWidth);
+			int progressBarWidth = (int(vc6_workaround) > minWidth ) ? int(vc6_workaround) : minWidth;
+			int width = indeterminate ? maxWidth : progressBarWidth;
+
+            bool reverse = (!vertical && (bar->direction == Qt::RightToLeft)) || vertical;
+            if (inverted)
+                reverse = !reverse;
+
+            QRect progressBar;
+            if (!indeterminate) {
+                if (!reverse) {
+                    progressBar.setRect(rect.left() + 1, rect.top() + 1, width + 1, rect.height() - 3);
+                } else {
+                    progressBar.setRect(rect.right() - 1 - width, rect.top() + 1, width + 1, rect.height() - 3);
+                }
+            } else {
+                Q_D(const QHaikuStyle);
+                int slideWidth = ((rect.width() - 4) * 2) / 3;
+                int step = ((d->animateStep * slideWidth) / d->animationFps) % slideWidth;
+                if ((((d->animateStep * slideWidth) / d->animationFps) % (2 * slideWidth)) >= slideWidth)
+                    step = slideWidth - step;
+                progressBar.setRect(rect.left() + 1 + step, rect.top() + 1,
+                                    slideWidth / 2, rect.height() - 3);
+            }
+            QColor highlight = option->palette.color(QPalette::Normal, QPalette::Highlight);
+            painter->setPen(QPen(highlight.darker(140), 0));
+
+            QColor highlightedGradientStartColor = highlight.lighter(100);
+            QColor highlightedGradientStopColor  = highlight.lighter(130);
+
+            QLinearGradient gradient(rect.topLeft(), QPoint(rect.bottomLeft().x(),
+                                                            rect.bottomLeft().y()*2));
+
+            gradient.setColorAt(0, highlightedGradientStartColor);
+            gradient.setColorAt(1, highlightedGradientStopColor);
+
+            painter->setBrush(gradient);
+            painter->drawRect(progressBar);
+
+            painter->setPen(QPen(highlight.lighter(120), 0));
+            painter->drawLine(QPoint(progressBar.left() + 1, progressBar.top() + 1),
+                              QPoint(progressBar.right(), progressBar.top() + 1));
+            painter->drawLine(QPoint(progressBar.left() + 1, progressBar.top() + 1),
+                              QPoint(progressBar.left() + 1, progressBar.bottom() - 1));
+
+            painter->setPen(QPen(highlightedGradientStartColor, 7.0));//QPen(option->palette.highlight(), 3));
+
+            painter->save();
+            painter->setClipRect(progressBar.adjusted(2, 2, -1, -1));
+            for (int x = progressBar.left() - 32; x < rect.right() ; x+=18) {
+                painter->drawLine(x, progressBar.bottom() + 1, x + 23, progressBar.top() - 2);
+            }
+            painter->restore();
+
+        }
+        painter->restore();
+        break;
+    case CE_MenuBarItem:
+        painter->save();
+        if (const QStyleOptionMenuItem *mbi = qstyleoption_cast<const QStyleOptionMenuItem *>(option))
+        {
+            QStyleOptionMenuItem item = *mbi;
+            item.rect = mbi->rect.adjusted(0, 0, 0, 0);
+			if (be_control_look != NULL) {
+				QRect r = rect.adjusted(0,-1,0,0);
+				rgb_color base = ui_color(B_MENU_BACKGROUND_COLOR);;
+				uint32 flags = 0;            
+		        BRect bRect(0.0f, 0.0f, r.width() - 1, r.height() - 1);
+				TemporarySurface surface(bRect);
+				be_control_look->DrawMenuBarBackground(surface.view(), bRect, bRect, base, flags, 8);
+				painter->drawImage(r, surface.image());			    
+			}
+			
+            bool act = mbi->state & State_Selected && mbi->state & State_Sunken;
+            bool dis = !(mbi->state & State_Enabled);
+
+            QRect r = option->rect;
+            if (act) {
+                qt_haiku_draw_gradient(painter, r.adjusted(1, 1, -1, -1),
+                                            QColor(150,150,150),
+                                            QColor(168,168,168), TopDown,
+                                            QColor(168,168,168));
+
+                painter->setPen(QPen(QColor(168,168,168), 0));
+                painter->drawLine(QPoint(r.left(), r.top()), QPoint(r.left(), r.bottom()));
+                painter->drawLine(QPoint(r.right(), r.top()), QPoint(r.right(), r.bottom()));
+                painter->drawLine(QPoint(r.left(), r.bottom()), QPoint(r.right(), r.bottom()));
+                painter->drawLine(QPoint(r.left(), r.top()), QPoint(r.right(), r.top()));
+            }
+
+            QPalette::ColorRole textRole = QPalette::Text;
+            uint alignment = Qt::AlignCenter  | Qt::TextHideMnemonic | Qt::TextDontClip | Qt::TextSingleLine;
+            drawItemText(painter, item.rect, alignment, mbi->palette, mbi->state & State_Enabled, mbi->text, textRole);            
+        }
+        painter->restore();
+        break;
+    case CE_MenuItem:
+        painter->save();
+        // Draws one item in a popup menu.
+        if (const QStyleOptionMenuItem *menuItem = qstyleoption_cast<const QStyleOptionMenuItem *>(option)) {
+            QColor highlightOutline = QColor(168,168,168);
+            QColor menuBackground = option->palette.background().color().lighter(104);
+            QColor borderColor = option->palette.background().color().darker(160);
+            QColor alphaCornerColor;
+
+            if (widget) {
+                // ### backgroundrole/foregroundrole should be part of the style option
+                alphaCornerColor = mergedColors(option->palette.color(widget->backgroundRole()), borderColor);
+            } else {
+                alphaCornerColor = mergedColors(option->palette.background().color(), borderColor);
+            }
+            QColor alphaTextColor = mergedColors(option->palette.background().color(), option->palette.text().color());
+            if (menuItem->menuItemType == QStyleOptionMenuItem::Separator) {
+                painter->fillRect(menuItem->rect, menuBackground);
+                int w = 0;
+                if (!menuItem->text.isEmpty()) {
+                    painter->setFont(menuItem->font);
+                    drawItemText(painter, menuItem->rect.adjusted(5, 0, -5, 0), Qt::AlignLeft | Qt::AlignVCenter,
+                                 menuItem->palette, menuItem->state & State_Enabled, menuItem->text,
+                                 QPalette::Text);
+                    w = menuItem->fontMetrics.width(menuItem->text) + 5;
+                }
+                painter->setPen(shadow.lighter(106));
+                bool reverse = menuItem->direction == Qt::RightToLeft;
+                painter->drawLine(menuItem->rect.left() + 5 + (reverse ? 0 : w), menuItem->rect.center().y(),
+                                  menuItem->rect.right() - 5 - (reverse ? w : 0), menuItem->rect.center().y());
+                painter->restore();
+                break;
+            }
+            bool selected = menuItem->state & State_Selected; //&& menuItem->state & State_Enabled;
+            if (selected) {
+                QRect r = option->rect.adjusted(1, 0, -2, -1);
+                qt_haiku_draw_gradient(painter, r, QColor(150,150,150),
+                                            QColor(168,168,168), TopDown,
+                                            QColor(168,168,168));
+                r = r.adjusted(-1, 0, 1, 0);
+                painter->setPen(QPen(QColor(168,168,168), 0));
+                painter->drawLine(QPoint(r.left(), r.top()), QPoint(r.left(), r.bottom()));
+                painter->drawLine(QPoint(r.right(), r.top()), QPoint(r.right(), r.bottom()));
+                painter->drawLine(QPoint(r.left(), r.bottom()), QPoint(r.right(), r.bottom()));
+                painter->drawLine(QPoint(r.left(), r.top()), QPoint(r.right(), r.top()));
+            } else {
+                painter->fillRect(option->rect, menuBackground);
+            }
+
+            bool checkable = menuItem->checkType != QStyleOptionMenuItem::NotCheckable;
+            bool checked = menuItem->checked;
+            bool sunken = menuItem->state & State_Sunken;
+            bool enabled = menuItem->state & State_Enabled;
+
+            bool ignoreCheckMark = false;
+            int checkcol = qMax(menuItem->maxIconWidth, 20);
+
+#ifndef QT_NO_COMBOBOX
+            if (qobject_cast<const QComboBox*>(widget))
+                ignoreCheckMark = true; //ignore the checkmarks provided by the QComboMenuDelegate
+#endif
+
+            if (!ignoreCheckMark) {
+                // Check
+                QRect checkRect(option->rect.left() + 7, option->rect.center().y() - 6, 13, 13);
+                checkRect = visualRect(menuItem->direction, menuItem->rect, checkRect);
+                if (checkable) {
+                    if (menuItem->checkType & QStyleOptionMenuItem::Exclusive) {
+                        // Radio button
+                        if (checked || sunken) {
+                            painter->setRenderHint(QPainter::Antialiasing);
+                            painter->setPen(Qt::NoPen);
+
+                            QPalette::ColorRole textRole = !enabled ? QPalette::Text:
+                                                        selected ? QPalette::HighlightedText : QPalette::ButtonText;
+                            painter->setBrush(option->palette.brush( option->palette.currentColorGroup(), textRole));
+                            painter->drawEllipse(checkRect.adjusted(4, 4, -4, -4));
+                        }
+                    } else {
+                        // Check box
+                        if (menuItem->icon.isNull()) {
+                            if (checked || sunken) {
+                                QImage image(qt_haiku_menuitem_checkbox_checked);
+                                if (enabled && (menuItem->state & State_Selected)) {
+                                    image.setColor(1, 0x55ffffff);
+                                    image.setColor(2, 0xAAffffff);
+                                    image.setColor(3, 0xBBffffff);
+                                    image.setColor(4, 0xFFffffff);
+                                    image.setColor(5, 0x33ffffff);
+                                } else {
+                                    image.setColor(1, 0x55000000);
+                                    image.setColor(2, 0xAA000000);
+                                    image.setColor(3, 0xBB000000);
+                                    image.setColor(4, 0xFF000000);
+                                    image.setColor(5, 0x33000000);
+                                }
+                                painter->drawImage(QPoint(checkRect.center().x() - image.width() / 2,
+                                                        checkRect.center().y() - image.height() / 2), image);
+                            }
+                        }
+                    }
+                }
+            } else { //ignore checkmark
+                if (menuItem->icon.isNull())
+                    checkcol = 0;
+                else
+                    checkcol = menuItem->maxIconWidth;
+            }
+
+            // Text and icon, ripped from windows style
+            bool dis = !(menuItem->state & State_Enabled);
+            bool act = menuItem->state & State_Selected;
+            const QStyleOption *opt = option;
+            const QStyleOptionMenuItem *menuitem = menuItem;
+
+            QPainter *p = painter;
+            QRect vCheckRect = visualRect(opt->direction, menuitem->rect,
+                                          QRect(menuitem->rect.x(), menuitem->rect.y(),
+                                                checkcol, menuitem->rect.height()));
+            if (!menuItem->icon.isNull()) {
+                QIcon::Mode mode = dis ? QIcon::Disabled : QIcon::Normal;
+                if (act && !dis)
+                    mode = QIcon::Active;
+                QPixmap pixmap;
+
+                int smallIconSize = pixelMetric(PM_SmallIconSize, option, widget);
+                QSize iconSize(smallIconSize, smallIconSize);
+#ifndef QT_NO_COMBOBOX
+                if (const QComboBox *combo = qobject_cast<const QComboBox*>(widget))
+                    iconSize = combo->iconSize();
+#endif // QT_NO_COMBOBOX
+                if (checked)
+                    pixmap = menuItem->icon.pixmap(iconSize, mode, QIcon::On);
+                else
+                    pixmap = menuItem->icon.pixmap(iconSize, mode);
+
+                int pixw = pixmap.width();
+                int pixh = pixmap.height();
+
+                QRect pmr(0, 0, pixw, pixh);
+                pmr.moveCenter(vCheckRect.center());
+                painter->setPen(menuItem->palette.text().color());
+                if (checkable && checked) {
+                    QStyleOption opt = *option;
+                    if (act) {
+                        QColor activeColor = mergedColors(option->palette.background().color(),
+                                                        option->palette.highlight().color());
+                        opt.palette.setBrush(QPalette::Button, activeColor);
+                    }
+                    opt.state |= State_Sunken;
+                    opt.rect = vCheckRect;
+		            bool enabled = opt.state & State_Enabled;
+	    	        bool focus = opt.state & State_HasFocus;            	            
+					qt_haiku_draw_button(painter, opt.rect, false, false, true, focus, enabled);                    
+                }
+                painter->drawPixmap(pmr.topLeft(), pixmap);
+            }
+
+            painter->setPen(menuItem->palette.text().color());
+
+            int x, y, w, h;
+            menuitem->rect.getRect(&x, &y, &w, &h);
+            int tab = menuitem->tabWidth;
+            QColor discol;
+            if (dis) {
+                discol = menuitem->palette.text().color();
+                p->setPen(discol);
+            }
+            int xm = windowsItemFrame + checkcol + windowsItemHMargin;
+            int xpos = menuitem->rect.x() + xm;
+
+            QRect textRect(xpos, y + windowsItemVMargin, w - xm - windowsRightBorder - tab + 1, h - 2 * windowsItemVMargin);
+            QRect vTextRect = visualRect(opt->direction, menuitem->rect, textRect);
+            QString s = menuitem->text;
+            if (!s.isEmpty()) {                     // draw text
+                p->save();
+                int t = s.indexOf(QLatin1Char('\t'));
+                int text_flags = Qt::AlignVCenter | Qt::TextShowMnemonic | Qt::TextDontClip | Qt::TextSingleLine;
+                if (!styleHint(SH_UnderlineShortcut, menuitem, widget))
+                    text_flags |= Qt::TextHideMnemonic;
+                text_flags |= Qt::AlignLeft;
+                if (t >= 0) {
+                	QString sText = s.mid(t + 1);
+                	sText.replace("Ctrl+","Alt+");
+                    QRect vShortcutRect = visualRect(opt->direction, menuitem->rect,
+                                                     QRect(textRect.topRight(), QPoint(menuitem->rect.right(), textRect.bottom())));
+                    if (dis && !act && styleHint(SH_EtchDisabledText, option, widget)) {
+                        p->setPen(menuitem->palette.light().color());
+                        p->drawText(vShortcutRect.adjusted(1, 1, 1, 1), text_flags, sText);
+                        p->setPen(discol);
+                    }
+                    p->drawText(vShortcutRect, text_flags, sText);
+                    s = s.left(t);
+                }
+                QFont font = menuitem->font;
+
+                if (menuitem->menuItemType == QStyleOptionMenuItem::DefaultItem)
+                    font.setBold(true);
+
+                p->setFont(font);
+                if (dis && !act && styleHint(SH_EtchDisabledText, option, widget)) {
+                    p->setPen(menuitem->palette.light().color());
+                    p->drawText(vTextRect.adjusted(1, 1, 1, 1), text_flags, s.left(t));
+                    p->setPen(discol);
+                }
+                p->drawText(vTextRect, text_flags, s.left(t));
+                p->restore();
+            }
+
+            // Arrow
+            if (menuItem->menuItemType == QStyleOptionMenuItem::SubMenu) {// draw sub menu arrow
+                int dim = (menuItem->rect.height() - 4) / 2;
+                PrimitiveElement arrow;
+                arrow = QApplication::isRightToLeft() ? PE_IndicatorArrowLeft : PE_IndicatorArrowRight;
+                int xpos = menuItem->rect.left() + menuItem->rect.width() - 3 - dim;
+                QRect  vSubMenuRect = visualRect(option->direction, menuItem->rect,
+                                                 QRect(xpos, menuItem->rect.top() + menuItem->rect.height() / 2 - dim / 2, dim, dim));
+                QStyleOptionMenuItem newMI = *menuItem;
+                newMI.rect = vSubMenuRect;
+                newMI.state = !enabled ? State_None : State_Enabled;
+                if (selected)
+                    newMI.palette.setColor(QPalette::ButtonText,
+                                           newMI.palette.highlightedText().color());
+                drawPrimitive(arrow, &newMI, painter, widget);
+            }
+        }
+        painter->restore();
+        break;
+    case CE_MenuHMargin:
+    case CE_MenuVMargin:
+        break;
+    case CE_MenuEmptyArea:
+        break;
+    case CE_PushButtonLabel:
+        if (const QStyleOptionButton *button = qstyleoption_cast<const QStyleOptionButton *>(option)) {
+        	bool pushed = (option->state & State_Sunken) || (option->state & State_On);
+        	
+            QRect ir = button->rect;
+            uint tf = Qt::AlignVCenter;
+            if (styleHint(SH_UnderlineShortcut, button, widget))
+                tf |= Qt::TextShowMnemonic;
+            else
+               tf |= Qt::TextHideMnemonic;
+
+            if (!button->icon.isNull() && button->text.isEmpty()) {
+                //Center both icon and text
+                QPoint point;
+
+                QIcon::Mode mode = button->state & State_Enabled ? QIcon::Normal
+                                                              : QIcon::Disabled;
+                if (mode == QIcon::Normal && button->state & State_HasFocus)
+                    mode = QIcon::Active;
+                QIcon::State state = QIcon::Off;
+                if (button->state & State_On)
+                    state = QIcon::On;
+
+                QPixmap pixmap = button->icon.pixmap(button->iconSize, mode, state);
+                int w = pixmap.width();
+                int h = pixmap.height();
+
+                if (!button->text.isEmpty())
+                    w += button->fontMetrics.boundingRect(option->rect, tf, button->text).width() + 2;
+
+                point = QPoint(ir.x() + ir.width() / 2 - w / 2,
+                               ir.y() + ir.height() / 2 - h / 2);
+
+                if (button->direction == Qt::RightToLeft)
+                    point.rx() += pixmap.width();
+
+                painter->drawPixmap(visualPos(button->direction, button->rect, point), pixmap);
+
+                if (button->direction == Qt::RightToLeft)
+                    ir.translate(-point.x() - 2, 0);
+                else
+                    ir.translate(point.x() + pixmap.width(), 0);
+
+                // left-align text if there is
+                if (!button->text.isEmpty())
+                    tf |= Qt::AlignLeft;
+
+            } else {
+                tf |= Qt::AlignHCenter;
+            }
+
+            if (button->features & QStyleOptionButton::HasMenu)
+                ir = ir.adjusted(0, 0, -pixelMetric(PM_MenuButtonIndicator, button, widget), 0);
+            if(pushed)
+            	ir = ir.adjusted(1,1,0,0);
+            drawItemText(painter, ir, tf, button->palette, (button->state & State_Enabled),
+                         button->text, QPalette::ButtonText);
+        }
+        break;
+    case CE_MenuBarEmptyArea:
+        painter->save();
+        {
+			if (be_control_look != NULL) {
+				QRect r = rect.adjusted(0,0,0,-1);
+				rgb_color base = ui_color(B_MENU_BACKGROUND_COLOR);;
+				uint32 flags = 0;            
+		        BRect bRect(0.0f, 0.0f, r.width() - 1, r.height() - 1);
+				TemporarySurface surface(bRect);
+				be_control_look->DrawMenuBarBackground(surface.view(), bRect, bRect, base, flags);
+				painter->drawImage(r, surface.image());			    
+			}
+			
+   	        painter->setPen(QPen(QColor(152,152,152)));
+            painter->drawLine(rect.bottomLeft(), rect.bottomRight());			
+        }
+        painter->restore();
+        break;
+#ifndef QT_NO_TABBAR
+	case CE_TabBarTabShape:
+        painter->save();
+        if (const QStyleOptionTab *tab = qstyleoption_cast<const QStyleOptionTab *>(option)) {
+
+            bool rtlHorTabs = (tab->direction == Qt::RightToLeft
+                               && (tab->shape == QTabBar::RoundedNorth
+                                   || tab->shape == QTabBar::RoundedSouth));
+            bool selected = tab->state & State_Selected;
+            bool lastTab = ((!rtlHorTabs && tab->position == QStyleOptionTab::End)
+                            || (rtlHorTabs
+                                && tab->position == QStyleOptionTab::Beginning));
+            bool onlyTab = tab->position == QStyleOptionTab::OnlyOneTab;
+            bool leftCornerWidget = (tab->cornerWidgets & QStyleOptionTab::LeftCornerWidget);
+
+            bool atBeginning = ((tab->position == (tab->direction == Qt::LeftToRight ?
+                                QStyleOptionTab::Beginning : QStyleOptionTab::End)) || onlyTab);
+
+            bool onlyOne = tab->position == QStyleOptionTab::OnlyOneTab;
+            bool previousSelected =
+                ((!rtlHorTabs
+                  && tab->selectedPosition == QStyleOptionTab::PreviousIsSelected)
+                 || (rtlHorTabs
+                     && tab->selectedPosition == QStyleOptionTab::NextIsSelected));
+            bool nextSelected =
+                ((!rtlHorTabs
+                  && tab->selectedPosition == QStyleOptionTab::NextIsSelected)
+                 || (rtlHorTabs
+                     && tab->selectedPosition
+                     == QStyleOptionTab::PreviousIsSelected));
+            int tabBarAlignment = styleHint(SH_TabBar_Alignment, tab, widget);
+            bool leftAligned = (!rtlHorTabs && tabBarAlignment == Qt::AlignLeft)
+                               || (rtlHorTabs
+                                   && tabBarAlignment == Qt::AlignRight);
+
+            bool rightAligned = (!rtlHorTabs && tabBarAlignment == Qt::AlignRight)
+                                || (rtlHorTabs
+                                    && tabBarAlignment == Qt::AlignLeft);
+
+            QColor light = tab->palette.light().color();
+            QColor midlight = tab->palette.midlight().color();
+
+            QColor background = tab->palette.background().color();
+            int borderThinkness = pixelMetric(PM_TabBarBaseOverlap, tab, widget);
+            if (selected)
+                borderThinkness /= 2;
+            QRect r2(option->rect);
+            int x1 = r2.left();
+            int x2 = r2.right();
+            int y1 = r2.top()+2;
+            int y2 = r2.bottom();
+
+            QTransform rotMatrix;
+            bool flip = false;
+            painter->setPen(shadow);
+            QColor activeHighlight = option->palette.color(QPalette::Normal, QPalette::Highlight);
+            switch (tab->shape) {
+            case QTabBar::RoundedNorth:
+                break;
+            case QTabBar::RoundedSouth:
+                rotMatrix.rotate(180);
+                rotMatrix.translate(0, -rect.height() + 1);
+                rotMatrix.scale(-1, 1);
+                painter->setTransform(rotMatrix, true);
+                break;
+            case QTabBar::RoundedWest:
+                rotMatrix.rotate(180 + 90);
+                rotMatrix.scale(-1, 1);
+                flip = true;
+                painter->setTransform(rotMatrix, true);
+                break;
+            case QTabBar::RoundedEast:
+                rotMatrix.rotate(90);
+                rotMatrix.translate(0, - rect.width() + 1);
+                flip = true;
+                painter->setTransform(rotMatrix, true);
+                break;
+            default:
+                painter->restore();
+                QWindowsStyle::drawControl(element, tab, painter, widget);
+                return;
+            }
+
+            if (flip) {
+                QRect tmp = rect;
+                rect = QRect(tmp.y(), tmp.x(), tmp.height(), tmp.width());
+                int temp = x1;
+                x1 = y1;
+                y1 = temp;
+                temp = x2;
+                x2 = y2;
+                y2 = temp;
+            }
+
+            QLinearGradient gradient(rect.topLeft(), rect.bottomLeft());
+            if (option->palette.button().gradient()) {
+                if (selected)
+                    gradient.setStops(option->palette.background().gradient()->stops());
+                else
+                    gradient.setStops(option->palette.background().gradient()->stops());
+            }
+            else if (selected) {
+                gradient.setColorAt(0, option->palette.background().color().lighter(104));
+                gradient.setColorAt(1, tabFrameColor);
+                painter->fillRect(rect.adjusted(0, 2, 0, -2), gradient);
+            } else {
+                y1 += 2;
+                gradient.setColorAt(0, option->palette.background().color());
+                gradient.setColorAt(1, dark.lighter(120));
+                painter->fillRect(rect.adjusted(0, 2, 0, -2), gradient);
+            }
+						
+            // Delete border
+            if (selected) {            	
+            	painter->setPen(QColor(200,200,200));
+            	painter->drawLine(x1 + 2, y2 - 1, x2 - 2, y2 - 1);
+            } else {
+                painter->setPen(dark);
+                painter->drawLine(x1, y2 - 1, x2 + 2, y2 - 1 );
+                if (tab->shape == QTabBar::RoundedNorth || tab->shape == QTabBar::RoundedWest) {
+                    painter->setPen(light);
+                    painter->drawLine(x1, y2 , x2, y2 );
+                }
+            }
+            // Left
+            if (atBeginning || selected ) {
+                painter->setPen(light);
+                painter->drawLine(x1 + 1, y1 + 2 + 1, x1 + 1, y2 - ((onlyOne || atBeginning) && selected && leftAligned ? 0 : borderThinkness) - (atBeginning && leftCornerWidget ? 1 : 0));
+                //painter->drawPoint(x1 + 1, y1 + 1);
+                painter->setPen(dark);
+                painter->drawLine(x1, y1 + 2, x1, y2 - ((onlyOne || atBeginning)  && leftAligned ? 0 : borderThinkness) - (atBeginning && leftCornerWidget ? 1 : 0));
+            }
+            // Top
+            {
+                int beg = x1 + (previousSelected ? 0 : 1);
+                int end = x2 - (nextSelected ? 0 : 2);
+                //painter->setPen(light);
+
+               // if (!selected)painter->drawLine(beg - 3, y1 + 1, end, y1 + 1);
+
+/*                if (selected)
+                  	painter->setPen(QPen(activeHighlight.darker(150), 0));
+                else
+                    painter->setPen(darkOutline);*/
+                
+                painter->setPen(darkOutline);
+                painter->drawLine(beg, y1 , end, y1);
+
+                if (atBeginning|| selected) {
+                    painter->drawPoint(beg - 1, y1 + 1);
+                } else if (!atBeginning) {
+                    painter->drawPoint(beg - 1, y1);
+                    painter->drawPoint(beg - 2, y1);
+                    if (!lastTab) {
+                        painter->setPen(dark.lighter(130));
+                        painter->drawPoint(end + 1, y1);
+                        painter->drawPoint(end + 2 , y1);
+                        painter->drawPoint(end + 3, y1);
+                    }
+                }
+            }
+            // Right
+            if (lastTab || selected || onlyOne || !nextSelected) {
+                painter->setPen(darkOutline);
+                
+                if (selected) {
+                	painter->drawLine(x2, y1 + 2, x2, y2 - ((onlyOne || lastTab) && selected && rightAligned ? 0 : borderThinkness));
+                    painter->setPen(QPen(activeHighlight.darker(150), 0));
+                    painter->drawPoint(x2 - 1, y1 + 1);
+                } else {
+                	painter->drawLine(x2, y1 + 1, x2, y2 - ((onlyOne || lastTab) && selected && rightAligned ? 0 : borderThinkness));
+                	painter->drawPoint(x2 - 1, y1);
+                }
+
+                if (selected) {
+                    painter->setPen(background.darker(110));
+                    painter->drawLine(x2 - 1, y1 + 2, x2 - 1, y2 - ((onlyOne || lastTab) && selected && rightAligned ? 0 : borderThinkness));
+                }
+            }
+        }
+        painter->restore();
+        break;
+
+#endif // QT_NO_TABBAR
+    default:
+        QWindowsStyle::drawControl(element,option,painter,widget);
+        break;
+    }
+}
+
+/*!
+  \reimp
+*/
+
+QPalette QHaikuStyle::standardPalette () const
+{
+    QPalette palette = QWindowsStyle::standardPalette();
+    palette.setBrush(QPalette::Active, QPalette::Highlight, QColor(98, 140, 178));
+    palette.setBrush(QPalette::Inactive, QPalette::Highlight, QColor(145, 141, 126));
+    palette.setBrush(QPalette::Disabled, QPalette::Highlight, QColor(145, 141, 126));
+
+    QColor backGround(mkQColor(ui_color(B_PANEL_BACKGROUND_COLOR)));
+
+    QColor light = backGround.lighter(150);
+    QColor base = Qt::white;
+    QColor dark = QColor(170, 156, 143).darker(110);
+    dark = backGround.darker(150);
+    QColor darkDisabled = QColor(209, 200, 191).darker(110);
+
+    //### Find the correct disabled text color
+    palette.setBrush(QPalette::Disabled, QPalette::Text, QColor(190, 190, 190));
+
+    palette.setBrush(QPalette::Window, backGround);
+    palette.setBrush(QPalette::Mid, backGround.darker(130));
+    palette.setBrush(QPalette::Light, light);
+
+    palette.setBrush(QPalette::Active, QPalette::Base, base);
+    palette.setBrush(QPalette::Inactive, QPalette::Base, base);
+    palette.setBrush(QPalette::Disabled, QPalette::Base, backGround);
+
+    palette.setBrush(QPalette::Midlight, palette.mid().color().lighter(110));
+
+    palette.setBrush(QPalette::All, QPalette::Dark, dark);
+    palette.setBrush(QPalette::Disabled, QPalette::Dark, darkDisabled);
+
+    QColor button = backGround;
+
+    palette.setBrush(QPalette::Button, button);
+
+    QColor shadow = dark.darker(135);
+    palette.setBrush(QPalette::Shadow, shadow);
+    palette.setBrush(QPalette::Disabled, QPalette::Shadow, shadow.lighter(150));
+    palette.setBrush(QPalette::HighlightedText, QColor(QRgb(0xffffffff)));
+    return palette;
+}
+
+/*!
+  \reimp
+*/
+void QHaikuStyle::drawComplexControl(ComplexControl control, const QStyleOptionComplex *option,
+                                         QPainter *painter, const QWidget *widget) const
+{
+    QColor button = option->palette.button().color();
+    QColor dark;
+    QColor grooveColor;
+    QColor darkOutline;
+    dark.setHsv(button.hue(),
+                CL_MIN(255, (int)(button.saturation()*1.9)),
+                CL_MIN(255, (int)(button.value()*0.7)));
+    grooveColor.setHsv(button.hue(),
+                CL_MIN(255, (int)(button.saturation()*2.6)),
+                CL_MIN(255, (int)(button.value()*0.9)));
+    darkOutline.setHsv(button.hue(),
+                CL_MIN(255, (int)(button.saturation()*3.0)),
+                CL_MIN(255, (int)(button.value()*0.6)));
+
+    QColor alphaCornerColor;
+    if (widget) {
+        // ### backgroundrole/foregroundrole should be part of the style option
+        alphaCornerColor = mergedColors(option->palette.color(widget->backgroundRole()), darkOutline);
+    } else {
+        alphaCornerColor = mergedColors(option->palette.background().color(), darkOutline);
+    }
+    QColor gripShadow = grooveColor.darker(110);
+    QColor buttonShadow = option->palette.button().color().darker(110);
+
+    QColor gradientStartColor = option->palette.button().color().lighter(108);
+    QColor gradientStopColor = mergedColors(option->palette.button().color().darker(108), dark.lighter(150), 70);
+
+    QColor highlightedGradientStartColor = option->palette.button().color();
+    QColor highlightedGradientStopColor = mergedColors(option->palette.button().color(), option->palette.highlight().color(), 85);
+
+    QColor highlightedDarkInnerBorderColor = mergedColors(option->palette.button().color(), option->palette.highlight().color(), 35);
+    QColor highlightedLightInnerBorderColor = mergedColors(option->palette.button().color(), option->palette.highlight().color(), 58);
+
+    QColor buttonShadowAlpha = option->palette.background().color().darker(105);
+
+    QPalette palette = option->palette;
+
+    switch (control) {
+#ifndef QT_NO_SPINBOX
+    case CC_SpinBox:
+        if (const QStyleOptionSpinBox *spinBox = qstyleoption_cast<const QStyleOptionSpinBox *>(option)) {
+            QPixmap cache;
+            QString pixmapName = uniqueName(QLatin1String("spinbox"), spinBox, spinBox->rect.size());
+            if (!UsePixmapCache || !QPixmapCache::find(pixmapName, cache)) {
+                cache = QPixmap(spinBox->rect.size());
+                cache.fill(Qt::transparent);
+                QRect pixmapRect(0, 0, spinBox->rect.width(), spinBox->rect.height());
+                QPainter cachePainter(&cache);
+
+                bool isEnabled = (spinBox->state & State_Enabled);
+                //bool focus = isEnabled && (spinBox->state & State_HasFocus);
+                bool hover = isEnabled && (spinBox->state & State_MouseOver);
+                bool sunken = (spinBox->state & State_Sunken);
+                bool upIsActive = (spinBox->activeSubControls == SC_SpinBoxUp);
+                bool downIsActive = (spinBox->activeSubControls == SC_SpinBoxDown);
+
+                QRect rect = pixmapRect;
+                QStyleOptionSpinBox spinBoxCopy = *spinBox;
+                spinBoxCopy.rect = pixmapRect;
+                QRect upRect = subControlRect(CC_SpinBox, &spinBoxCopy, SC_SpinBoxUp, widget);
+                QRect downRect = subControlRect(CC_SpinBox, &spinBoxCopy, SC_SpinBoxDown, widget);
+
+                int fw = spinBoxCopy.frame ? pixelMetric(PM_SpinBoxFrameWidth, &spinBoxCopy, widget) : 0;
+                cachePainter.fillRect(rect.adjusted(1, qMax(fw - 1, 0), -1, -fw),
+                                      option->palette.base());
+
+                QRect r = rect.adjusted(0, 1, 0, -1);
+                if (spinBox->frame) {
+
+                    QColor topShadow = darkOutline;
+                    topShadow.setAlpha(60);
+                    cachePainter.setPen(topShadow);
+
+                    // antialias corners
+                    cachePainter.drawPoint(QPoint(r.right(), r.top() + 1));
+                    cachePainter.drawPoint(QPoint(r.right() - 1, r.top() ));
+                    cachePainter.drawPoint(QPoint(r.right(), r.bottom() - 1));
+                    cachePainter.drawPoint(QPoint(r.right() - 1, r.bottom() ));
+                    cachePainter.drawPoint(QPoint(r.left() + 1, r.bottom()));
+                    cachePainter.drawPoint(QPoint(r.left(), r.bottom() - 1));
+                    cachePainter.drawPoint(QPoint(r.left() + 1, r.top()));
+                    cachePainter.drawPoint(QPoint(r.left(), r.top() + 1));
+
+                    // draw frame
+                    topShadow.setAlpha(30);
+                    cachePainter.setPen(topShadow);
+                    cachePainter.drawLine(QPoint(r.left() + 2, r.top() - 1), QPoint(r.right() - 2, r.top() - 1));
+
+                    cachePainter.setPen(QPen(option->palette.background().color(), 1));
+                    cachePainter.drawLine(QPoint(r.left() + 2, r.top() + 1), QPoint(r.right() - 2, r.top() + 1));
+                    QColor highlight = Qt::white;
+                    highlight.setAlpha(130);
+                    cachePainter.setPen(option->palette.base().color().darker(120));
+                    cachePainter.drawLine(QPoint(r.left() + 1, r.top() + 1),
+                                  QPoint(r.right() - 1, r.top() + 1));
+                    cachePainter.drawLine(QPoint(r.left() + 1, r.top() + 1),
+                                  QPoint(r.left() + 1, r.bottom() - 1));
+                    cachePainter.setPen(option->palette.base().color());
+                    cachePainter.drawLine(QPoint(r.right() - 1, r.top() + 1),
+                                  QPoint(r.right() - 1, r.bottom() - 1));
+                    cachePainter.drawLine(QPoint(r.left() + 1, r.bottom() - 1),
+                                  QPoint(r.right() - 1, r.bottom() - 1));
+                    cachePainter.setPen(highlight);
+                    cachePainter.drawLine(QPoint(r.left() + 3, r.bottom() + 1),
+                                  QPoint(r.right() - 3, r.bottom() + 1));
+
+                    cachePainter.setPen(QPen(darkOutline, 1));
+
+                    // top and bottom lines
+                    cachePainter.drawLine(QPoint(r.left() + 2, r.bottom()), QPoint(r.right()- 2, r.bottom()));
+                    cachePainter.drawLine(QPoint(r.left() + 2, r.top()), QPoint(r.right() - 2, r.top()));
+                    cachePainter.drawLine(QPoint(r.right(), r.top() + 2), QPoint(r.right(), r.bottom() - 2));
+                    cachePainter.drawLine(QPoint(r.left(), r.top() + 2), QPoint(r.left(), r.bottom() - 2));
+                }
+
+                    // gradients
+                    qt_haiku_draw_gradient(&cachePainter, upRect,
+                                            gradientStartColor.darker(106),
+                                            gradientStopColor, TopDown, option->palette.button());
+                    qt_haiku_draw_gradient(&cachePainter, downRect.adjusted(0, 0, 0, 1),
+                                            gradientStartColor.darker(106),
+                                            gradientStopColor, TopDown, option->palette.button());
+                if (isEnabled) {
+                    if(upIsActive) {
+                        if (sunken) {
+                            cachePainter.fillRect(upRect.adjusted(1, 0, 0, 0), gradientStopColor.darker(110));
+                        } else if (hover) {
+                            qt_haiku_draw_gradient(&cachePainter, upRect.adjusted(1, 0, 0, 0),
+                                                    gradientStartColor.lighter(110),
+                                                    gradientStopColor.lighter(110), TopDown, option->palette.button());
+                        }
+                    }
+                    if(downIsActive) {
+                        if (sunken) {
+                            cachePainter.fillRect(downRect.adjusted(1, 0, 0, 1), gradientStopColor.darker(110));
+
+                        } else if (hover) {
+                                qt_haiku_draw_gradient(&cachePainter, downRect.adjusted(1, 0, 0, 1),
+                                                        gradientStartColor.lighter(110),
+                                                        gradientStopColor.lighter(110), TopDown, option->palette.button());
+                        }
+                    }
+                }
+
+                if (spinBox->frame) {
+                    // rounded corners
+                    cachePainter.drawPoint(QPoint(r.left() + 1, r.bottom() - 1));
+                    cachePainter.drawPoint(QPoint(r.left() + 1, r.top() + 1));
+                    cachePainter.drawPoint(QPoint(r.right() - 1, r.bottom() - 1));
+                    cachePainter.drawPoint(QPoint(r.right() - 1, r.top() + 1));
+
+                    if (option->state & State_HasFocus) {
+                        QColor darkoutline = option->palette.highlight().color().darker(150);
+                        QColor innerline = mergedColors(option->palette.highlight().color(), Qt::white);
+                        cachePainter.setPen(QPen(innerline, 0));
+                        if (spinBox->direction == Qt::LeftToRight) {
+                            cachePainter.drawRect(rect.adjusted(1, 2, -3 -downRect.width(), -3));
+                            cachePainter.setPen(QPen(darkoutline, 0));
+                            cachePainter.drawLine(QPoint(r.left() + 2, r.bottom()), QPoint(r.right()- downRect.width() - 1, r.bottom()));
+                            cachePainter.drawLine(QPoint(r.left() + 2, r.top()), QPoint(r.right() - downRect.width() - 1, r.top()));
+                            cachePainter.drawLine(QPoint(r.right() - downRect.width() - 1, r.top() + 1), QPoint(r.right()- downRect.width() - 1, r.bottom() - 1));
+                            cachePainter.drawLine(QPoint(r.left(), r.top() + 2), QPoint(r.left(), r.bottom() - 2));
+                            cachePainter.drawPoint(QPoint(r.left() + 1, r.bottom() - 1));
+                            cachePainter.drawPoint(QPoint(r.left() + 1, r.top() + 1));
+                            cachePainter.drawLine(QPoint(r.left(), r.top() + 2), QPoint(r.left(), r.bottom() - 2));
+                        } else {
+                            cachePainter.drawRect(rect.adjusted(downRect.width() + 2, 2, -2, -3));
+                            cachePainter.setPen(QPen(darkoutline, 0));
+                            cachePainter.drawLine(QPoint(r.left() + downRect.width(), r.bottom()), QPoint(r.right()- 2 - 1, r.bottom()));
+                            cachePainter.drawLine(QPoint(r.left() + downRect.width(), r.top()), QPoint(r.right() - 2 - 1, r.top()));
+
+                            cachePainter.drawLine(QPoint(r.right(), r.top() + 2), QPoint(r.right(), r.bottom() - 2));
+                            cachePainter.drawPoint(QPoint(r.right() - 1, r.bottom() - 1));
+                            cachePainter.drawPoint(QPoint(r.right() - 1, r.top() + 1));
+                            cachePainter.drawLine(QPoint(r.left() + downRect.width() + 1, r.top()),
+                                                  QPoint(r.left() + downRect.width() + 1, r.bottom()));
+                        }
+                    }
+                }
+
+                // outline the up/down buttons
+                cachePainter.setPen(darkOutline);
+                QColor light = option->palette.light().color().lighter();
+
+                if (spinBox->direction == Qt::RightToLeft) {
+                    cachePainter.drawLine(upRect.right(), upRect.top() - 1, upRect.right(), downRect.bottom() + 1);
+                    cachePainter.setPen(light);
+                    cachePainter.drawLine(upRect.right() - 1, upRect.top() + 3, upRect.right() - 1, downRect.bottom() );
+                } else {
+                    cachePainter.drawLine(upRect.left(), upRect.top() - 1, upRect.left(), downRect.bottom() + 1);
+                    cachePainter.setPen(light);
+                    cachePainter.drawLine(upRect.left() + 1, upRect.top() , upRect.left() + 1, downRect.bottom() );
+                }
+                if (upIsActive && sunken) {
+                    cachePainter.setPen(gradientStopColor.darker(130));
+                    cachePainter.drawLine(upRect.left() + 1, upRect.top(), upRect.left() + 1, upRect.bottom());
+                    cachePainter.drawLine(upRect.left(), upRect.top() - 1, upRect.right(), upRect.top() - 1);
+                } else {
+                    cachePainter.setPen(light);
+                    cachePainter.drawLine(upRect.topLeft() + QPoint(1, -1), upRect.topRight() + QPoint(-1, -1));
+                    cachePainter.setPen(darkOutline);
+                    cachePainter.drawLine(upRect.bottomLeft(), upRect.bottomRight());
+                }
+                if (downIsActive && sunken) {
+                    cachePainter.setPen(gradientStopColor.darker(130));
+                    cachePainter.drawLine(downRect.left() + 1, downRect.top(), downRect.left() + 1, downRect.bottom() + 1);
+                    cachePainter.drawLine(downRect.left(), downRect.top(), downRect.right(), downRect.top());
+                    cachePainter.setPen(gradientStopColor.darker(110));
+                    cachePainter.drawLine(downRect.left(), downRect.bottom() + 1, downRect.right(), downRect.bottom() + 1);
+                } else {
+                    cachePainter.setPen(light);
+                    cachePainter.drawLine(downRect.topLeft() + QPoint(2,0), downRect.topRight());
+                }
+
+                if (spinBox->buttonSymbols == QAbstractSpinBox::PlusMinus) {
+                    int centerX = upRect.center().x();
+                    int centerY = upRect.center().y();
+                    cachePainter.setPen(spinBox->palette.foreground().color());
+
+                    // plus/minus
+                    if (spinBox->activeSubControls == SC_SpinBoxUp && sunken) {
+                        cachePainter.drawLine(1 + centerX - 2, 1 + centerY, 1 + centerX + 2, 1 + centerY);
+                        cachePainter.drawLine(1 + centerX, 1 + centerY - 2, 1 + centerX, 1 + centerY + 2);
+                    } else {
+                        cachePainter.drawLine(centerX - 2, centerY, centerX + 2, centerY);
+                        cachePainter.drawLine(centerX, centerY - 2, centerX, centerY + 2);
+                    }
+
+                    centerX = downRect.center().x();
+                    centerY = downRect.center().y();
+                    if (spinBox->activeSubControls == SC_SpinBoxDown && sunken) {
+                        cachePainter.drawLine(1 + centerX - 2, 1 + centerY, 1 + centerX + 2, 1 + centerY);
+                    } else {
+                        cachePainter.drawLine(centerX - 2, centerY, centerX + 2, centerY);
+                    }
+                } else if (spinBox->buttonSymbols == QAbstractSpinBox::UpDownArrows){
+                    // arrows
+                    QImage upArrow(qt_scrollbar_button_arrow_up);
+                    upArrow.setColor(1, spinBox->palette.foreground().color().rgba());
+
+                    cachePainter.drawImage(upRect.center().x() - upArrow.width() / 2,
+                                            upRect.center().y() - upArrow.height() / 2,
+                                            upArrow);
+
+                    QImage downArrow(qt_scrollbar_button_arrow_down);
+                    downArrow.setColor(1, spinBox->palette.foreground().color().rgba());
+
+                    cachePainter.drawImage(downRect.center().x() - downArrow.width() / 2,
+                                            downRect.center().y() - downArrow.height() / 2 + 1,
+                                            downArrow);
+                }
+
+                QColor disabledColor = option->palette.background().color();
+                disabledColor.setAlpha(150);
+                if (!(spinBox->stepEnabled & QAbstractSpinBox::StepUpEnabled))
+                    cachePainter.fillRect(upRect.adjusted(1, 0, 0, 0), disabledColor);
+                if (!(spinBox->stepEnabled & QAbstractSpinBox::StepDownEnabled)) {
+                    cachePainter.fillRect(downRect.adjusted(1, 0, 0, 0), disabledColor);
+                }
+                cachePainter.end();
+                if (UsePixmapCache)
+                    QPixmapCache::insert(pixmapName, cache);
+            }
+            painter->drawPixmap(spinBox->rect.topLeft(), cache);
+        }
+        break;
+#endif // QT_NO_SPINBOX
+    case CC_TitleBar:
+        painter->save();
+        if (const QStyleOptionTitleBar *titleBar = qstyleoption_cast<const QStyleOptionTitleBar *>(option)) {
+            const int buttonMargin = 5;
+            bool active = (titleBar->titleBarState & State_Active);
+            QRect fullRect = titleBar->rect;
+            QPalette palette = option->palette;
+            QColor highlight = option->palette.highlight().color();
+
+            QColor titleBarFrameBorder(active ? highlight.darker(180): dark.darker(110));
+            QColor titleBarHighlight(active ? highlight.lighter(120): palette.background().color().lighter(120));
+            QColor textColor(active ? 0xffffff : 0xff000000);
+            QColor textAlphaColor(active ? 0xffffff : 0xff000000 );
+
+#ifdef  QT3_SUPPORT
+            if (widget && widget->inherits("Q3DockWindowTitleBar")) {
+                QStyleOptionDockWidgetV2 dockwidget;
+                dockwidget.QStyleOption::operator=(*option);
+                drawControl(CE_DockWidgetTitle, &dockwidget, painter, widget);
+            } else
+#endif // QT3_SUPPORT
+            {
+                // Fill title bar gradient
+                QColor titlebarColor = QColor(active ? highlight: palette.background().color());
+                QColor titleBarGradientStop(active ? highlight.darker(150): palette.background().color().darker(120));
+                QLinearGradient gradient(option->rect.center().x(), option->rect.top(),
+                                         option->rect.center().x(), option->rect.bottom());
+
+                gradient.setColorAt(0, titlebarColor.lighter(114));
+                gradient.setColorAt(0.5, titlebarColor.lighter(102));
+                gradient.setColorAt(0.51, titlebarColor.darker(104));
+                gradient.setColorAt(1, titlebarColor);
+                painter->fillRect(option->rect.adjusted(1, 1, -1, 0), gradient);
+
+                // Frame and rounded corners
+                painter->setPen(titleBarFrameBorder);
+
+                // top outline
+                painter->drawLine(fullRect.left() + 5, fullRect.top(), fullRect.right() - 5, fullRect.top());
+                painter->drawLine(fullRect.left(), fullRect.top() + 4, fullRect.left(), fullRect.bottom());
+                painter->drawPoint(fullRect.left() + 4, fullRect.top() + 1);
+                painter->drawPoint(fullRect.left() + 3, fullRect.top() + 1);
+                painter->drawPoint(fullRect.left() + 2, fullRect.top() + 2);
+                painter->drawPoint(fullRect.left() + 1, fullRect.top() + 3);
+                painter->drawPoint(fullRect.left() + 1, fullRect.top() + 4);
+
+                painter->drawLine(fullRect.right(), fullRect.top() + 4, fullRect.right(), fullRect.bottom());
+                painter->drawPoint(fullRect.right() - 3, fullRect.top() + 1);
+                painter->drawPoint(fullRect.right() - 4, fullRect.top() + 1);
+                painter->drawPoint(fullRect.right() - 2, fullRect.top() + 2);
+                painter->drawPoint(fullRect.right() - 1, fullRect.top() + 3);
+                painter->drawPoint(fullRect.right() - 1, fullRect.top() + 4);
+
+                // draw bottomline
+                painter->drawLine(fullRect.right(), fullRect.bottom(), fullRect.left(), fullRect.bottom());
+
+                // top highlight
+                painter->setPen(titleBarHighlight);
+                painter->drawLine(fullRect.left() + 6, fullRect.top() + 1, fullRect.right() - 6, fullRect.top() + 1);
+            }
+            // draw title
+            QRect textRect = subControlRect(CC_TitleBar, titleBar, SC_TitleBarLabel, widget);
+            QFont font = painter->font();
+            font.setBold(true);
+            painter->setFont(font);
+            painter->setPen(active? (titleBar->palette.text().color().lighter(120)) :
+                                     titleBar->palette.text().color() );
+            // Note workspace also does elliding but it does not use the correct font
+            QString title = QFontMetrics(font).elidedText(titleBar->text, Qt::ElideRight, textRect.width() - 14);
+            painter->drawText(textRect.adjusted(1, 1, 1, 1), title, QTextOption(Qt::AlignHCenter | Qt::AlignVCenter));
+            painter->setPen(Qt::white);
+            if (active)
+                painter->drawText(textRect, title, QTextOption(Qt::AlignHCenter | Qt::AlignVCenter));
+            // min button
+            if ((titleBar->subControls & SC_TitleBarMinButton) && (titleBar->titleBarFlags & Qt::WindowMinimizeButtonHint) &&
+                !(titleBar->titleBarState& Qt::WindowMinimized)) {
+                QRect minButtonRect = subControlRect(CC_TitleBar, titleBar, SC_TitleBarMinButton, widget);
+                if (minButtonRect.isValid()) {
+                    bool hover = (titleBar->activeSubControls & SC_TitleBarMinButton) && (titleBar->state & State_MouseOver);
+                    bool sunken = (titleBar->activeSubControls & SC_TitleBarMinButton) && (titleBar->state & State_Sunken);
+                    qt_haiku_draw_mdibutton(painter, titleBar, minButtonRect, hover, sunken);
+                    QRect minButtonIconRect = minButtonRect.adjusted(buttonMargin ,buttonMargin , -buttonMargin, -buttonMargin);
+                    painter->setPen(textColor);
+                    painter->drawLine(minButtonIconRect.center().x() - 2, minButtonIconRect.center().y() + 3,
+                                    minButtonIconRect.center().x() + 3, minButtonIconRect.center().y() + 3);
+                    painter->drawLine(minButtonIconRect.center().x() - 2, minButtonIconRect.center().y() + 4,
+                                    minButtonIconRect.center().x() + 3, minButtonIconRect.center().y() + 4);
+                    painter->setPen(textAlphaColor);
+                    painter->drawLine(minButtonIconRect.center().x() - 3, minButtonIconRect.center().y() + 3,
+                                    minButtonIconRect.center().x() - 3, minButtonIconRect.center().y() + 4);
+                    painter->drawLine(minButtonIconRect.center().x() + 4, minButtonIconRect.center().y() + 3,
+                                    minButtonIconRect.center().x() + 4, minButtonIconRect.center().y() + 4);
+                }
+            }
+            // max button
+            if ((titleBar->subControls & SC_TitleBarMaxButton) && (titleBar->titleBarFlags & Qt::WindowMaximizeButtonHint) &&
+                !(titleBar->titleBarState & Qt::WindowMaximized)) {
+                QRect maxButtonRect = subControlRect(CC_TitleBar, titleBar, SC_TitleBarMaxButton, widget);
+                if (maxButtonRect.isValid()) {
+                    bool hover = (titleBar->activeSubControls & SC_TitleBarMaxButton) && (titleBar->state & State_MouseOver);
+                    bool sunken = (titleBar->activeSubControls & SC_TitleBarMaxButton) && (titleBar->state & State_Sunken);
+                    qt_haiku_draw_mdibutton(painter, titleBar, maxButtonRect, hover, sunken);
+
+                    QRect maxButtonIconRect = maxButtonRect.adjusted(buttonMargin, buttonMargin, -buttonMargin, -buttonMargin);
+
+                    painter->setPen(textColor);
+                    painter->drawRect(maxButtonIconRect.adjusted(0, 0, -1, -1));
+                    painter->drawLine(maxButtonIconRect.left() + 1, maxButtonIconRect.top() + 1,
+                                    maxButtonIconRect.right() - 1, maxButtonIconRect.top() + 1);
+                    painter->setPen(textAlphaColor);
+                    painter->drawPoint(maxButtonIconRect.topLeft());
+                    painter->drawPoint(maxButtonIconRect.topRight());
+                    painter->drawPoint(maxButtonIconRect.bottomLeft());
+                    painter->drawPoint(maxButtonIconRect.bottomRight());
+                }
+            }
+
+            // close button
+            if ((titleBar->subControls & SC_TitleBarCloseButton) && (titleBar->titleBarFlags & Qt::WindowSystemMenuHint)) {
+                QRect closeButtonRect = subControlRect(CC_TitleBar, titleBar, SC_TitleBarCloseButton, widget);
+                if (closeButtonRect.isValid()) {
+                    bool hover = (titleBar->activeSubControls & SC_TitleBarCloseButton) && (titleBar->state & State_MouseOver);
+                    bool sunken = (titleBar->activeSubControls & SC_TitleBarCloseButton) && (titleBar->state & State_Sunken);
+                    qt_haiku_draw_mdibutton(painter, titleBar, closeButtonRect, hover, sunken);
+                    QRect closeIconRect = closeButtonRect.adjusted(buttonMargin, buttonMargin, -buttonMargin, -buttonMargin);
+                    painter->setPen(textAlphaColor);
+                    painter->drawLine(closeIconRect.left() + 1, closeIconRect.top(),
+                                    closeIconRect.right(), closeIconRect.bottom() - 1);
+                    painter->drawLine(closeIconRect.left(), closeIconRect.top() + 1,
+                                    closeIconRect.right() - 1, closeIconRect.bottom());
+                    painter->drawLine(closeIconRect.right() - 1, closeIconRect.top(),
+                                    closeIconRect.left(), closeIconRect.bottom() - 1);
+                    painter->drawLine(closeIconRect.right(), closeIconRect.top() + 1,
+                                    closeIconRect.left() + 1, closeIconRect.bottom());
+                    painter->drawPoint(closeIconRect.topLeft());
+                    painter->drawPoint(closeIconRect.topRight());
+                    painter->drawPoint(closeIconRect.bottomLeft());
+                    painter->drawPoint(closeIconRect.bottomRight());
+
+                    painter->setPen(textColor);
+                    painter->drawLine(closeIconRect.left() + 1, closeIconRect.top() + 1,
+                                    closeIconRect.right() - 1, closeIconRect.bottom() - 1);
+                    painter->drawLine(closeIconRect.left() + 1, closeIconRect.bottom() - 1,
+                                    closeIconRect.right() - 1, closeIconRect.top() + 1);
+                }
+            }
+
+            // normalize button
+            if ((titleBar->subControls & SC_TitleBarNormalButton) &&
+               (((titleBar->titleBarFlags & Qt::WindowMinimizeButtonHint) &&
+               (titleBar->titleBarState & Qt::WindowMinimized)) ||
+               ((titleBar->titleBarFlags & Qt::WindowMaximizeButtonHint) &&
+               (titleBar->titleBarState & Qt::WindowMaximized)))) {
+                QRect normalButtonRect = subControlRect(CC_TitleBar, titleBar, SC_TitleBarNormalButton, widget);
+                if (normalButtonRect.isValid()) {
+
+                    bool hover = (titleBar->activeSubControls & SC_TitleBarNormalButton) && (titleBar->state & State_MouseOver);
+                    bool sunken = (titleBar->activeSubControls & SC_TitleBarNormalButton) && (titleBar->state & State_Sunken);
+                    QRect normalButtonIconRect = normalButtonRect.adjusted(buttonMargin, buttonMargin, -buttonMargin, -buttonMargin);
+                    qt_haiku_draw_mdibutton(painter, titleBar, normalButtonRect, hover, sunken);
+
+                    QRect frontWindowRect = normalButtonIconRect.adjusted(0, 3, -3, 0);
+                    painter->setPen(textColor);
+                    painter->drawRect(frontWindowRect.adjusted(0, 0, -1, -1));
+                    painter->drawLine(frontWindowRect.left() + 1, frontWindowRect.top() + 1,
+                                    frontWindowRect.right() - 1, frontWindowRect.top() + 1);
+                    painter->setPen(textAlphaColor);
+                    painter->drawPoint(frontWindowRect.topLeft());
+                    painter->drawPoint(frontWindowRect.topRight());
+                    painter->drawPoint(frontWindowRect.bottomLeft());
+                    painter->drawPoint(frontWindowRect.bottomRight());
+
+                    QRect backWindowRect = normalButtonIconRect.adjusted(3, 0, 0, -3);
+                    QRegion clipRegion = backWindowRect;
+                    clipRegion -= frontWindowRect;
+                    painter->save();
+                    painter->setClipRegion(clipRegion);
+                    painter->setPen(textColor);
+                    painter->drawRect(backWindowRect.adjusted(0, 0, -1, -1));
+                    painter->drawLine(backWindowRect.left() + 1, backWindowRect.top() + 1,
+                                    backWindowRect.right() - 1, backWindowRect.top() + 1);
+                    painter->setPen(textAlphaColor);
+                    painter->drawPoint(backWindowRect.topLeft());
+                    painter->drawPoint(backWindowRect.topRight());
+                    painter->drawPoint(backWindowRect.bottomLeft());
+                    painter->drawPoint(backWindowRect.bottomRight());
+                    painter->restore();
+                }
+            }
+
+            // context help button
+            if (titleBar->subControls & SC_TitleBarContextHelpButton
+                && (titleBar->titleBarFlags & Qt::WindowContextHelpButtonHint)) {
+                QRect contextHelpButtonRect = subControlRect(CC_TitleBar, titleBar, SC_TitleBarContextHelpButton, widget);
+                if (contextHelpButtonRect.isValid()) {
+                    bool hover = (titleBar->activeSubControls & SC_TitleBarContextHelpButton) && (titleBar->state & State_MouseOver);
+                    bool sunken = (titleBar->activeSubControls & SC_TitleBarContextHelpButton) && (titleBar->state & State_Sunken);
+                    qt_haiku_draw_mdibutton(painter, titleBar, contextHelpButtonRect, hover, sunken);
+
+                    QColor blend;
+                    QImage image(qt_titlebar_context_help);
+                    QColor alpha = textColor;
+                    alpha.setAlpha(128);
+                    image.setColor(1, textColor.rgba());
+                    image.setColor(2, alpha.rgba());
+                    painter->setRenderHint(QPainter::SmoothPixmapTransform);
+                    painter->drawImage(contextHelpButtonRect.adjusted(4, 4, -4, -4), image);
+                }
+            }
+
+            // shade button
+            if (titleBar->subControls & SC_TitleBarShadeButton && (titleBar->titleBarFlags & Qt::WindowShadeButtonHint)) {
+                QRect shadeButtonRect = subControlRect(CC_TitleBar, titleBar, SC_TitleBarShadeButton, widget);
+                if (shadeButtonRect.isValid()) {
+                    bool hover = (titleBar->activeSubControls & SC_TitleBarShadeButton) && (titleBar->state & State_MouseOver);
+                    bool sunken = (titleBar->activeSubControls & SC_TitleBarShadeButton) && (titleBar->state & State_Sunken);
+                    qt_haiku_draw_mdibutton(painter, titleBar, shadeButtonRect, hover, sunken);
+                    QImage image(qt_scrollbar_button_arrow_up);
+                    image.setColor(1, textColor.rgba());
+                    painter->drawImage(shadeButtonRect.adjusted(5, 7, -5, -7), image);
+                }
+            }
+
+            // unshade button
+            if (titleBar->subControls & SC_TitleBarUnshadeButton && (titleBar->titleBarFlags & Qt::WindowShadeButtonHint)) {
+                QRect unshadeButtonRect = subControlRect(CC_TitleBar, titleBar, SC_TitleBarUnshadeButton, widget);
+                if (unshadeButtonRect.isValid()) {
+                    bool hover = (titleBar->activeSubControls & SC_TitleBarUnshadeButton) && (titleBar->state & State_MouseOver);
+                    bool sunken = (titleBar->activeSubControls & SC_TitleBarUnshadeButton) && (titleBar->state & State_Sunken);
+                    qt_haiku_draw_mdibutton(painter, titleBar, unshadeButtonRect, hover, sunken);
+                    QImage image(qt_scrollbar_button_arrow_down);
+                    image.setColor(1, textColor.rgba());
+                    painter->drawImage(unshadeButtonRect.adjusted(5, 7, -5, -7), image);
+                }
+            }
+
+            if ((titleBar->subControls & SC_TitleBarSysMenu) && (titleBar->titleBarFlags & Qt::WindowSystemMenuHint)) {
+                QRect iconRect = subControlRect(CC_TitleBar, titleBar, SC_TitleBarSysMenu, widget);
+                if (iconRect.isValid()) {
+                    if (!titleBar->icon.isNull()) {
+                        titleBar->icon.paint(painter, iconRect);
+                    } else {
+                        QStyleOption tool(0);
+                        tool.palette = titleBar->palette;
+                        QPixmap pm = standardIcon(SP_TitleBarMenuButton, &tool, widget).pixmap(16, 16);
+                        tool.rect = iconRect;
+                        painter->save();
+                        drawItemPixmap(painter, iconRect, Qt::AlignCenter, pm);
+                        painter->restore();
+                    }
+                }
+            }
+        }
+        painter->restore();
+        break;
+#ifndef QT_NO_SCROLLBAR
+    case CC_ScrollBar:
+        painter->save();
+        if (const QStyleOptionSlider *scrollBar = qstyleoption_cast<const QStyleOptionSlider *>(option)) {
+            bool isEnabled = scrollBar->state & State_Enabled;
+            bool reverse = scrollBar->direction == Qt::RightToLeft;
+            bool horizontal = scrollBar->orientation == Qt::Horizontal;
+            bool sunken = scrollBar->state & State_Sunken;
+
+            painter->fillRect(option->rect, option->palette.background());
+
+            QRect rect = scrollBar->rect;
+            QRect scrollBarSubLine = subControlRect(control, scrollBar, SC_ScrollBarSubLine, widget);
+            QRect scrollBarAddLine = subControlRect(control, scrollBar, SC_ScrollBarAddLine, widget);
+            QRect scrollBarSlider = subControlRect(control, scrollBar, SC_ScrollBarSlider, widget);
+            QRect grooveRect = subControlRect(control, scrollBar, SC_ScrollBarGroove, widget);
+
+            // paint groove
+            if (scrollBar->subControls & SC_ScrollBarGroove) {
+                painter->setBrush(grooveColor);
+                painter->setPen(Qt::NoPen);
+                if (horizontal) {
+                    painter->drawRect(grooveRect);
+                    painter->setPen(darkOutline);
+                    painter->drawLine(grooveRect.topLeft(), grooveRect.topRight());
+                    painter->drawLine(grooveRect.bottomLeft(), grooveRect.bottomRight());
+                } else {
+                    painter->drawRect(grooveRect);
+                    painter->setPen(darkOutline);
+                    painter->drawLine(grooveRect.topLeft(), grooveRect.bottomLeft());
+                    painter->drawLine(grooveRect.topRight(), grooveRect.bottomRight());
+                }
+            }
+            //paint slider
+            if (scrollBar->subControls & SC_ScrollBarSlider) {
+                QRect pixmapRect = scrollBarSlider;
+                if (horizontal)
+                    pixmapRect.adjust(-1, 0, 0, -1);
+                else
+                    pixmapRect.adjust(0, -1, -1, 0);
+
+                if (isEnabled) {
+                    QLinearGradient gradient(pixmapRect.center().x(), pixmapRect.top(),
+                                             pixmapRect.center().x(), pixmapRect.bottom());
+                    if (!horizontal)
+                        gradient = QLinearGradient(pixmapRect.left(), pixmapRect.center().y(),
+                                                   pixmapRect.right(), pixmapRect.center().y());
+
+                    if (option->palette.button().gradient()) {
+                        gradient.setStops(option->palette.button().gradient()->stops());
+                    } else {
+                        if (sunken || (option->state & State_MouseOver &&
+                            (scrollBar->activeSubControls & SC_ScrollBarSlider))) {
+                            gradient.setColorAt(0, gradientStartColor.lighter(110));
+                            gradient.setColorAt(1, gradientStopColor.lighter(110));
+                        } else {
+                            gradient.setColorAt(0, gradientStartColor);
+                            gradient.setColorAt(1, gradientStopColor);
+                        }
+                    }
+                    painter->setPen(QPen(darkOutline, 0));
+                    painter->setBrush(gradient);
+                    painter->drawRect(pixmapRect);
+
+
+                    //calculate offsets used by highlight and shadow
+                    int yoffset, xoffset;
+                    if (option->state & State_Horizontal) {
+                        xoffset = 0;
+                        yoffset = 1;
+                    } else {
+                        xoffset = 1;
+                        yoffset = 0;
+                    }
+                    //draw slider highlights
+                    painter->setPen(QPen(gradientStopColor, 0));
+                    painter->drawLine(scrollBarSlider.left() + xoffset,
+                                      scrollBarSlider.bottom() - yoffset,
+                                      scrollBarSlider.right() - xoffset,
+                                      scrollBarSlider.bottom() - yoffset);
+                    painter->drawLine(scrollBarSlider.right() - xoffset,
+                                      scrollBarSlider.top() + yoffset,
+                                      scrollBarSlider.right() - xoffset,
+                                      scrollBarSlider.bottom() - yoffset);
+
+                    //draw slider shadow
+                    painter->setPen(QPen(gradientStartColor, 0));
+                    painter->drawLine(scrollBarSlider.left() + xoffset,
+                                      scrollBarSlider.top() + yoffset,
+                                      scrollBarSlider.right() - xoffset,
+                                      scrollBarSlider.top() + yoffset);
+                    painter->drawLine(scrollBarSlider.left() + xoffset,
+                                      scrollBarSlider.top() + yoffset,
+                                      scrollBarSlider.left() + xoffset,
+                                      scrollBarSlider.bottom() - yoffset);
+                } else {
+                    QLinearGradient gradient(pixmapRect.center().x(), pixmapRect.top(),
+                                             pixmapRect.center().x(), pixmapRect.bottom());
+                    if (!horizontal) {
+                        gradient = QLinearGradient(pixmapRect.left(), pixmapRect.center().y(),
+                                                   pixmapRect.right(), pixmapRect.center().y());
+                    }
+                    if (sunken) {
+                        gradient.setColorAt(0, gradientStartColor.lighter(110));
+                        gradient.setColorAt(1, gradientStopColor.lighter(110));
+                    } else {
+                        gradient.setColorAt(0, gradientStartColor);
+                        gradient.setColorAt(1, gradientStopColor);
+                    }
+                    painter->setPen(darkOutline);
+                    painter->setBrush(gradient);
+                    painter->drawRect(pixmapRect);
+                }
+                int gripMargin = 4;
+                //draw grips
+                if (horizontal) {
+                    for (int i = -3; i< 6 ; i += 3) {
+                        painter->setPen(QPen(gripShadow, 1));
+                        painter->drawLine(
+                            QPoint(scrollBarSlider.center().x() + i ,
+                                   scrollBarSlider.top() + gripMargin),
+                            QPoint(scrollBarSlider.center().x() + i,
+                                   scrollBarSlider.bottom() - gripMargin));
+                        painter->setPen(QPen(palette.light(), 1));
+                        painter->drawLine(
+                            QPoint(scrollBarSlider.center().x() + i + 1,
+                                   scrollBarSlider.top() + gripMargin  ),
+                            QPoint(scrollBarSlider.center().x() + i + 1,
+                                   scrollBarSlider.bottom() - gripMargin));
+                    }
+                } else {
+                    for (int i = -3; i < 6 ; i += 3) {
+                        painter->setPen(QPen(gripShadow, 1));
+                        painter->drawLine(
+                            QPoint(scrollBarSlider.left() + gripMargin ,
+                                   scrollBarSlider.center().y()+ i),
+                            QPoint(scrollBarSlider.right() - gripMargin,
+                                   scrollBarSlider.center().y()+ i));
+                        painter->setPen(QPen(palette.light(), 1));
+                        painter->drawLine(
+                            QPoint(scrollBarSlider.left() + gripMargin,
+                                   scrollBarSlider.center().y() + 1 + i),
+                            QPoint(scrollBarSlider.right() - gripMargin,
+                                   scrollBarSlider.center().y() + 1 + i));
+                    }
+                }
+            }
+
+            // The SubLine (up/left) buttons
+            if (scrollBar->subControls & SC_ScrollBarSubLine) {
+                //int scrollBarExtent = pixelMetric(PM_ScrollBarExtent, option, widget);
+                QRect pixmapRect = scrollBarSubLine;
+                if (isEnabled ) {
+                    QRect fillRect = pixmapRect.adjusted(1, 1, -1, -1);
+                    // Gradients
+                    if ((scrollBar->activeSubControls & SC_ScrollBarSubLine) && sunken) {
+                        qt_haiku_draw_gradient(painter,
+                                                    QRect(fillRect),
+                                                    gradientStopColor.darker(120),
+                                                    gradientStopColor.darker(120),
+                                                    horizontal ? TopDown : FromLeft, option->palette.button());
+                    } else {
+                        qt_haiku_draw_gradient(painter,
+                                                    QRect(fillRect),
+                                                    gradientStartColor.lighter(105),
+                                                    gradientStopColor,
+                                                    horizontal ? TopDown : FromLeft, option->palette.button());
+                    }
+                }
+                // Details
+                QImage subButton;
+                QImage subButtonArrow;
+                if (horizontal) {
+                    subButton = QImage(reverse ? qt_scrollbar_buttons : qt_scrollbar_buttons);
+                    subButtonArrow = QImage(reverse ? qt_scrollbar_button_arrow_right : qt_scrollbar_button_arrow_left);
+                } else {
+                    subButton = QImage(qt_scrollbar_buttons);
+                    subButtonArrow = QImage(qt_scrollbar_button_arrow_up);                    
+                }
+                subButton.setColor(1, alphaCornerColor.rgba());
+                subButton.setColor(2, darkOutline.rgba());
+                if ((scrollBar->activeSubControls & SC_ScrollBarSubLine) && sunken) {
+                    subButton.setColor(3, gradientStopColor.darker(140).rgba());
+                    subButton.setColor(4, gradientStopColor.darker(120).rgba());
+                } else {
+                    subButton.setColor(3, gradientStartColor.lighter(105).rgba());
+                    subButton.setColor(4, gradientStopColor.rgba());
+                }
+                subButton.setColor(5, scrollBar->palette.text().color().rgba());
+                painter->drawImage(pixmapRect, subButton);
+
+                // Arrows
+                QPoint a_pos = pixmapRect.topLeft()+QPoint(4,4);
+                painter->drawImage(a_pos, subButtonArrow);
+
+                // The AddLine (down/right) button
+                if (scrollBar->subControls & SC_ScrollBarAddLine) {
+                    QString addLinePixmapName = uniqueName(QLatin1String("scrollbar_addline"), option, QSize(16, 16));
+                    QRect pixmapRect = scrollBarAddLine;
+                    if (isEnabled) {
+                        QRect fillRect = pixmapRect.adjusted(1, 1, -1, -1);
+                        // Gradients
+                        if ((scrollBar->activeSubControls & SC_ScrollBarAddLine) && sunken) {
+                            qt_haiku_draw_gradient(painter,
+                                                        fillRect,
+                                                        gradientStopColor.darker(120),
+                                                        gradientStopColor.darker(120),
+                                                        horizontal ? TopDown: FromLeft, option->palette.button());
+                        } else {
+                            qt_haiku_draw_gradient(painter,
+                                                        fillRect,
+                                                        gradientStartColor.lighter(105),
+                                                        gradientStopColor,
+                                                        horizontal ? TopDown : FromLeft, option->palette.button());
+                        }
+                    }
+                    // Details
+                    QImage addButton;
+                    QImage subButtonArrow;
+                    if (horizontal) {
+                        addButton = QImage(reverse ? qt_scrollbar_buttons : qt_scrollbar_buttons);
+                        subButtonArrow = QImage(reverse ? qt_scrollbar_button_arrow_left : qt_scrollbar_button_arrow_right);
+                    } else {
+                        addButton = QImage(qt_scrollbar_buttons);
+                        subButtonArrow = QImage(qt_scrollbar_button_arrow_down);
+                    }
+                    addButton.setColor(1, alphaCornerColor.rgba());
+                    addButton.setColor(2, darkOutline.rgba());
+                    if ((scrollBar->activeSubControls & SC_ScrollBarAddLine) && sunken) {
+                        addButton.setColor(3, gradientStopColor.darker(140).rgba());
+                        addButton.setColor(4, gradientStopColor.darker(120).rgba());
+                    } else {
+                        addButton.setColor(3, gradientStartColor.lighter(105).rgba());
+                        addButton.setColor(4, gradientStopColor.rgba());
+                    }
+                    addButton.setColor(5, scrollBar->palette.text().color().rgba());
+                    painter->drawImage(pixmapRect, addButton);
+
+    	            QPoint a_pos = pixmapRect.topLeft()+QPoint(4,4);
+	                painter->drawImage(a_pos, subButtonArrow);
+                }
+            }
+        }
+        painter->restore();
+        break;;
+#endif // QT_NO_SCROLLBAR
+#ifndef QT_NO_COMBOBOX
+    case CC_ComboBox:
+        painter->save();
+        if (const QStyleOptionComboBox *comboBox = qstyleoption_cast<const QStyleOptionComboBox *>(option)) {
+            bool sunken = comboBox->state & State_On; // play dead, if combobox has no items
+            bool isEnabled = (comboBox->state & State_Enabled);
+            bool focus = isEnabled && (comboBox->state & State_HasFocus);
+            QPixmap cache;
+            QString pixmapName = uniqueName(QLatin1String("combobox"), option, comboBox->rect.size());
+            if (sunken)
+                pixmapName += QLatin1String("-sunken");
+            if (comboBox->editable)
+                pixmapName += QLatin1String("-editable");
+            if (isEnabled)
+                pixmapName += QLatin1String("-enabled");
+
+            if (!UsePixmapCache || !QPixmapCache::find(pixmapName, cache)) {
+                cache = QPixmap(comboBox->rect.size());
+                cache.fill(Qt::transparent);
+                QPainter cachePainter(&cache);
+                QRect pixmapRect(0, 0, comboBox->rect.width(), comboBox->rect.height());
+                QStyleOptionComboBox comboBoxCopy = *comboBox;
+                comboBoxCopy.rect = pixmapRect;
+
+                QRect rect = pixmapRect;
+                QRect downArrowRect = subControlRect(CC_ComboBox, &comboBoxCopy,
+                                                     SC_ComboBoxArrow, widget);
+                QRect editRect = subControlRect(CC_ComboBox, &comboBoxCopy,
+                                                     SC_ComboBoxEditField, widget);
+                // Draw a push button
+                if (comboBox->editable) {
+                    QStyleOptionFrame  buttonOption;
+                    buttonOption.QStyleOption::operator=(*comboBox);
+                    buttonOption.rect = rect;
+                    buttonOption.state = comboBox->state & (State_Enabled | State_MouseOver);
+				
+                    if (sunken) {
+                        buttonOption.state |= State_Sunken;
+                        buttonOption.state &= ~State_MouseOver;
+                    }
+
+                    drawPrimitive(PE_PanelButtonCommand, &buttonOption, &cachePainter, widget);
+
+                    if (isEnabled) {
+		            	if(comboBox->state & State_HasFocus)
+			                cachePainter.setPen(QPen(mkQColor(ui_color(B_NAVIGATION_BASE_COLOR)), 0));
+			            else
+				            cachePainter.setPen(QPen(QColor(129,129,129), 0));
+		                cachePainter.drawRect(rect.adjusted(2, 2, -3, -2));
+		            } else {
+		            	QColor buttonBgColor = mkQColor(tint_color(ui_color(B_PANEL_BACKGROUND_COLOR), B_LIGHTEN_1_TINT));
+						QColor dark1BorderColor = mkQColor(tint_color(ui_color(B_PANEL_BACKGROUND_COLOR), B_DARKEN_1_TINT));		            	
+		                cachePainter.fillRect(rect, option->palette.background());		                
+		                cachePainter.fillRect(rect.adjusted(2, 2, -3, -2), buttonBgColor);		               
+		                cachePainter.setPen(QPen(dark1BorderColor, 0));
+		                cachePainter.drawRect(rect.adjusted(2, 2, -3, -2));
+		            }                                   
+                } else {
+                    QStyleOptionButton buttonOption;
+                    buttonOption.QStyleOption::operator=(*comboBox);
+                    buttonOption.rect = rect;
+                    buttonOption.state = comboBox->state & (State_Enabled | State_MouseOver);
+                    if (sunken) {
+                        buttonOption.state |= State_Sunken;
+                        buttonOption.state &= ~State_MouseOver;
+                    }
+                    drawPrimitive(PE_PanelButtonCommand, &buttonOption, &cachePainter, widget);
+
+                    cachePainter.setPen(buttonShadow.darker(102));
+                    int borderSize = 4;
+
+                    if (!sunken) {
+                        if (comboBox->direction == Qt::RightToLeft) {
+                            cachePainter.drawLine(QPoint(downArrowRect.right() + 1, downArrowRect.top() + borderSize),
+                                                  QPoint(downArrowRect.right() + 1, downArrowRect.bottom() - borderSize));
+                            cachePainter.setPen(option->palette.light().color());
+                            cachePainter.drawLine(QPoint(downArrowRect.right(), downArrowRect.top() + borderSize),
+                                                  QPoint(downArrowRect.right(), downArrowRect.bottom() - borderSize));
+                        } else {
+                            cachePainter.drawLine(QPoint(downArrowRect.left() - 1, downArrowRect.top() + borderSize),
+                                                  QPoint(downArrowRect.left() - 1, downArrowRect.bottom() - borderSize));
+                            cachePainter.setPen(option->palette.light().color());
+                            cachePainter.drawLine(QPoint(downArrowRect.left() , downArrowRect.top() + borderSize),
+                                                  QPoint(downArrowRect.left() , downArrowRect.bottom() - borderSize));
+                        }
+                    } else {
+                        cachePainter.setPen(dark.lighter(110));
+                        if (comboBox->direction == Qt::RightToLeft) {
+                            cachePainter.drawLine(QPoint(downArrowRect.right() + 1, downArrowRect.top() + borderSize),
+                                                  QPoint(downArrowRect.right() + 1, downArrowRect.bottom() - borderSize));
+
+                        } else {
+                            cachePainter.drawLine(QPoint(downArrowRect.left() - 1, downArrowRect.top() + borderSize),
+                                                  QPoint(downArrowRect.left() - 1, downArrowRect.bottom() - borderSize));
+                        }
+                    }
+                }
+
+
+                if (comboBox->subControls & SC_ComboBoxArrow) {
+                    if (comboBox->editable) {
+                        // Draw the down arrow
+                        QImage downArrow(qt_scrollbar_button_arrow_down);
+                        downArrow.setColor(1, comboBox->palette.foreground().color().rgba());
+                        cachePainter.drawImage(downArrowRect.center().x() - downArrow.width() / 2,
+                                               downArrowRect.center().y() - downArrow.height() / 2 + 1, downArrow);
+                    } else {
+                        // Draw the up/down arrow
+                        QImage upArrow(qt_scrollbar_button_arrow_up);
+                        upArrow.setColor(1, comboBox->palette.foreground().color().rgba());
+                        QImage downArrow(qt_scrollbar_button_arrow_down);
+                        downArrow.setColor(1, comboBox->palette.foreground().color().rgba());
+                        cachePainter.drawImage(downArrowRect.center().x() - downArrow.width() / 2,
+                                               downArrowRect.center().y() - upArrow.height() - 1 , upArrow);
+                        cachePainter.drawImage(downArrowRect.center().x() - downArrow.width() / 2,
+                                               downArrowRect.center().y()  + 2, downArrow);
+                    }
+                }
+                // Draw the focus rect
+                if ((focus && (option->state & State_KeyboardFocusChange)) && !comboBox->editable) {
+                    QStyleOptionFocusRect focus;
+                    focus.rect = subControlRect(CC_ComboBox, &comboBoxCopy, SC_ComboBoxEditField, widget)
+                                 .adjusted(0, 2, option->direction == Qt::RightToLeft ? 1 : -1, -2);
+                    drawPrimitive(PE_FrameFocusRect, &focus, &cachePainter, widget);
+                }
+                cachePainter.end();
+                if (UsePixmapCache)
+                    QPixmapCache::insert(pixmapName, cache);
+            }
+            painter->drawPixmap(comboBox->rect.topLeft(), cache);
+        }
+        painter->restore();
+        break;
+#endif // QT_NO_COMBOBOX
+#ifndef QT_NO_GROUPBOX
+    case CC_GroupBox:
+        painter->save();
+        if (const QStyleOptionGroupBox *groupBox = qstyleoption_cast<const QStyleOptionGroupBox *>(option)) {
+            QRect textRect = subControlRect(CC_GroupBox, groupBox, SC_GroupBoxLabel, widget);
+            QRect checkBoxRect = subControlRect(CC_GroupBox, groupBox, SC_GroupBoxCheckBox, widget);
+            bool flat = groupBox->features & QStyleOptionFrameV2::Flat;
+
+            if(!flat) {
+                if (groupBox->subControls & QStyle::SC_GroupBoxFrame) {
+                    QStyleOptionFrameV2 frame;
+                    frame.QStyleOption::operator=(*groupBox);
+                    frame.features = groupBox->features;
+                    frame.lineWidth = groupBox->lineWidth;
+                    frame.midLineWidth = groupBox->midLineWidth;
+                    frame.rect = subControlRect(CC_GroupBox, option, SC_GroupBoxFrame, widget);
+
+                    painter->save();
+                    QRegion region(groupBox->rect);
+                    bool ltr = groupBox->direction == Qt::LeftToRight;
+                    region -= checkBoxRect.united(textRect).adjusted(ltr ? -4 : 0, 0, ltr ? 0 : 4, 0);
+                    if (!groupBox->text.isEmpty() ||  groupBox->subControls & SC_GroupBoxCheckBox)
+                        painter->setClipRegion(region);
+                    frame.palette.setBrush(QPalette::Dark, option->palette.mid().color().lighter(110));
+                    drawPrimitive(PE_FrameGroupBox, &frame, painter);
+                    painter->restore();
+                }
+            }
+            // Draw title
+            if ((groupBox->subControls & QStyle::SC_GroupBoxLabel) && !groupBox->text.isEmpty()) {
+                if (!groupBox->text.isEmpty()) {
+                    QColor textColor = groupBox->textColor;
+                    if (textColor.isValid())
+                        painter->setPen(textColor);
+                    int alignment = int(groupBox->textAlignment);
+                    if (!styleHint(QStyle::SH_UnderlineShortcut, option, widget))
+                        alignment |= Qt::TextHideMnemonic;
+                    if (flat) {
+                        QFont font = painter->font();
+                        font.setBold(true);
+                        painter->setFont(font);
+                        if (groupBox->subControls & SC_GroupBoxCheckBox) {
+                            textRect.adjust(checkBoxRect.right() + 4, 0, checkBoxRect.right() + 4, 0);
+                        }
+                    }
+                    painter->drawText(textRect, Qt::TextShowMnemonic | Qt::AlignLeft| alignment, groupBox->text);
+                }
+            }
+            if (groupBox->subControls & SC_GroupBoxCheckBox) {
+                QStyleOptionButton box;
+                box.QStyleOption::operator=(*groupBox);
+                box.rect = checkBoxRect;
+                drawPrimitive(PE_IndicatorCheckBox, &box, painter, widget);
+            }
+        }
+        painter->restore();
+        break;
+#endif // QT_NO_GROUPBOX
+#ifndef QT_NO_SLIDER
+    case CC_Slider:
+    	painter->save();
+        if (const QStyleOptionSlider *slider = qstyleoption_cast<const QStyleOptionSlider *>(option)) {
+            QRect groove = subControlRect(CC_Slider, option, SC_SliderGroove, widget);
+            QRect handle = subControlRect(CC_Slider, option, SC_SliderHandle, widget);
+            QRect ticks = subControlRect(CC_Slider, option, SC_SliderTickmarks, widget);
+            
+            bool ticksAbove = slider->tickPosition & QSlider::TicksAbove;
+            bool ticksBelow = slider->tickPosition & QSlider::TicksBelow;
+
+			orientation orient = slider->orientation == Qt::Horizontal?B_HORIZONTAL:B_VERTICAL;
+
+			if (be_control_look != NULL) {
+				QRect r = groove;
+				rgb_color base = ui_color(B_PANEL_BACKGROUND_COLOR);
+				rgb_color fill_color = ui_color(B_PANEL_BACKGROUND_COLOR);
+				uint32 flags = 0;            
+
+		        BRect bRect(0.0f, 0.0f, option->rect.width() - 1,  option->rect.height() - 1);
+				TemporarySurface surface(bRect);				
+				
+				surface.view()->SetHighColor(base);
+				surface.view()->SetLowColor(base);
+				surface.view()->FillRect(bRect);
+				
+				if ((option->subControls & SC_SliderGroove) && groove.isValid()) {
+					r = groove;
+					bRect = BRect(r.x(), r.y(), r.x()+r.width(), r.y()+r.height());
+					be_control_look->DrawSliderBar(surface.view(), bRect, bRect, base, fill_color, flags, orient);
+					painter->drawImage(r, surface.image());		
+				}
+
+				if (option->subControls & SC_SliderTickmarks) {
+					int mlocation = B_HASH_MARKS_NONE;
+					if(ticksAbove)mlocation|=B_HASH_MARKS_TOP;
+					if(ticksBelow)mlocation|=B_HASH_MARKS_BOTTOM;
+					int interval =  slider->tickInterval<=0?1:slider->tickInterval;
+					int num = 1+((slider->maximum-slider->minimum)/interval);
+					int len = pixelMetric(PM_SliderLength, slider, widget)/2;
+					r=(orient==B_HORIZONTAL)?option->rect.adjusted(len,0,-len,0):option->rect.adjusted(0,len,0,-len);
+					bRect = BRect(r.x(), r.y(), r.x()+r.width(), r.y()+r.height());						
+					be_control_look->DrawSliderHashMarks(surface.view(), bRect, bRect, base, num, (hash_mark_location)mlocation, flags, orient);						
+				}
+								
+				if (option->subControls & SC_SliderHandle ) {
+					r=handle.adjusted(1,1,0,0);
+					bRect = BRect(r.x(), r.y(), r.x()+r.width(), r.y()+r.height());
+					be_control_look->DrawSliderThumb(surface.view(), bRect, bRect, base, flags, orient);
+				}					    
+								
+				painter->drawImage(slider->rect, surface.image());		
+			}            
+            
+            painter->restore();
+        }
+        break;
+#endif // QT_NO_SLIDER
+		case CC_ToolButton:
+		{	
+        if (const QStyleOptionToolButton *toolbutton
+                = qstyleoption_cast<const QStyleOptionToolButton *>(option)) {
+            QRect button;
+            bool flat = !(widget ? qobject_cast<QToolBar*>(widget->parentWidget()) : 0);
+            bool flat2 = toolbutton->features & QStyleOptionFrameV2::Flat;            
+            bool enabled = toolbutton->state & State_Enabled;
+            bool pushed = (toolbutton->state & State_Sunken) || (toolbutton->state & State_On);
+
+            button = subControlRect(control, toolbutton, SC_ToolButton, widget);
+                        
+			painter->save();
+			if(flat || flat2 || pushed) {
+				qt_haiku_draw_button(painter,button,false,false,pushed,false,enabled);
+			}
+
+			painter->restore();
+        	}
+        	QWindowsStyle::drawComplexControl(control, option, painter, widget);
+		}
+		break;
+        default:
+            QWindowsStyle::drawComplexControl(control, option, painter, widget);
+        break;
+    }
+}
+
+/*!
+  \reimp
+*/
+int QHaikuStyle::pixelMetric(PixelMetric metric, const QStyleOption *option, const QWidget *widget) const
+{
+    int ret = -1;
+    switch (metric) {
+    case PM_ButtonDefaultIndicator:
+        ret = 0;
+        break;
+    case PM_ButtonShiftHorizontal:
+    case PM_ButtonShiftVertical:
+        ret = 0;
+        break;
+    case PM_MessageBoxIconSize:
+        ret = 48;
+        break;
+    case PM_ListViewIconSize:
+        ret = 24;
+        break;
+    case PM_DialogButtonsSeparator:
+    case PM_SplitterWidth:
+        ret = 6;
+        break;
+    case PM_ScrollBarSliderMin:
+        ret = 26;
+        break;
+    case PM_MenuPanelWidth: //menu framewidth
+        ret = 2;
+        break;
+    case PM_TitleBarHeight:
+        ret = 24;
+        break;
+    case PM_ScrollBarExtent:
+        ret = 15;
+        break;
+    case PM_SliderThickness:
+        ret = 14;
+        break;
+    case PM_SliderLength:
+        ret = 18;
+        break;
+    case PM_DockWidgetTitleMargin:
+        ret = 1;
+        break;
+    case PM_MenuBarVMargin:
+        ret = 1;
+        break;
+    case PM_DefaultFrameWidth:
+        ret = 2;
+        break;
+    case PM_SpinBoxFrameWidth:
+        ret = 3;
+        break;
+    case PM_MenuBarItemSpacing:
+        ret = 6;
+    case PM_MenuBarHMargin:
+        ret = 0;
+        break;
+    case PM_ToolBarHandleExtent:
+        ret = 9;
+        break;
+    case PM_ToolBarItemSpacing:
+        ret = 2;
+        break;
+    case PM_ToolBarFrameWidth:
+        ret = 0;
+        break;
+    case PM_ToolBarItemMargin:
+        ret = 1;
+        break;
+    case PM_SmallIconSize:
+        ret = 16;
+        break;
+    case PM_ButtonIconSize:
+        ret = 24;
+        break;
+    case PM_MenuVMargin:
+    case PM_MenuHMargin:
+        ret = 0;
+        break;
+    case PM_DockWidgetTitleBarButtonMargin:
+        ret = 4;
+        break;
+    case PM_MaximumDragDistance:
+        return -1;
+    case PM_TabCloseIndicatorWidth:
+    case PM_TabCloseIndicatorHeight:
+        return 20;
+    default:
+        break;
+    }
+
+    return ret != -1 ? ret : QWindowsStyle::pixelMetric(metric, option, widget);
+}
+
+/*!
+  \reimp
+*/
+QSize QHaikuStyle::sizeFromContents(ContentsType type, const QStyleOption *option,
+                                        const QSize &size, const QWidget *widget) const
+{
+    QSize newSize = QWindowsStyle::sizeFromContents(type, option, size, widget);
+    switch (type) {
+    case CT_PushButton:
+        if (const QStyleOptionButton *btn = qstyleoption_cast<const QStyleOptionButton *>(option)) {
+            if (!btn->text.isEmpty() && newSize.width() < 80)
+                newSize.setWidth(80);
+/*            if (!btn->icon.isNull() && btn->iconSize.height() > 16)
+                newSize -= QSize(0, 2);*/
+        }
+        if (const QPushButton *button = qobject_cast<const QPushButton *>(widget)) {
+            if (qobject_cast<const QDialogButtonBox *>(button->parentWidget())) {
+                if (newSize.height() < 32)
+                    newSize.setHeight(32);
+            }
+        }
+        break;
+    case CT_GroupBox:
+    case CT_RadioButton:
+    case CT_CheckBox:
+        newSize += QSize(3, 2);
+        break;
+    case CT_ToolButton:
+#ifndef QT_NO_TOOLBAR
+        if (widget && qobject_cast<QToolBar *>(widget->parentWidget()))
+            newSize += QSize(4, 6);
+#endif // QT_NO_TOOLBAR
+        break;
+    case CT_SpinBox:
+        newSize += QSize(0, -2);
+        break;
+    case CT_ComboBox:
+        newSize += QSize(1, 4);
+        break;
+    case CT_LineEdit:
+        newSize += QSize(0, 2);
+        break;
+    case CT_MenuBarItem:
+	    newSize += QSize(0, -2);
+	    break;
+    case CT_MenuItem:
+        if (const QStyleOptionMenuItem *menuItem = qstyleoption_cast<const QStyleOptionMenuItem *>(option)) {
+            if (menuItem->menuItemType == QStyleOptionMenuItem::Separator) {
+                if (!menuItem->text.isEmpty()) {
+                    newSize.setHeight(menuItem->fontMetrics.lineSpacing());
+                }
+            }
+#ifndef QT_NO_COMBOBOX
+            else if (!menuItem->icon.isNull()) {
+                if (const QComboBox *combo = qobject_cast<const QComboBox*>(widget)) {
+                    newSize.setHeight(qMax(combo->iconSize().height() + 2, newSize.height()));
+                }
+            }
+#endif // QT_NO_COMBOBOX
+        }
+        break;
+    case CT_MdiControls:
+        if (const QStyleOptionComplex *styleOpt = qstyleoption_cast<const QStyleOptionComplex *>(option)) {
+            int width = 0;
+            if (styleOpt->subControls & SC_MdiMinButton)
+                width += 19 + 1;
+            if (styleOpt->subControls & SC_MdiNormalButton)
+                width += 19 + 1;
+            if (styleOpt->subControls & SC_MdiCloseButton)
+                width += 19 + 1;
+            newSize = QSize(width, 19);
+        } else {
+            newSize = QSize(60, 19);
+        }
+        break;
+    default:
+        break;
+    }
+    return newSize;
+}
+
+/*!
+  \reimp
+*/
+void QHaikuStyle::polish(QApplication *app)
+{
+    QWindowsStyle::polish(app);
+}
+
+/*!
+  \reimp
+*/
+void QHaikuStyle::polish(QWidget *widget)
+{
+    QWindowsStyle::polish(widget);
+    if (qobject_cast<QAbstractButton*>(widget)
+#ifndef QT_NO_COMBOBOX
+        || qobject_cast<QComboBox *>(widget)
+#endif
+#ifndef QT_NO_PROGRESSBAR
+        || qobject_cast<QProgressBar *>(widget)
+#endif
+#ifndef QT_NO_SCROLLBAR
+        || qobject_cast<QScrollBar *>(widget)
+#endif
+#ifndef QT_NO_SPLITTER
+        || qobject_cast<QSplitterHandle *>(widget)
+#endif
+        || qobject_cast<QAbstractSlider *>(widget)
+#ifndef QT_NO_SPINBOX
+        || qobject_cast<QAbstractSpinBox *>(widget)
+#endif
+        || (widget->inherits("QWorkspaceChild"))
+        || (widget->inherits("QDockSeparator"))
+        || (widget->inherits("QDockWidgetSeparator"))
+        ) {
+        widget->setAttribute(Qt::WA_Hover, true);
+    }
+}
+
+/*!
+  \reimp
+*/
+void QHaikuStyle::polish(QPalette &pal)
+{
+    QWindowsStyle::polish(pal);
+    //this is a workaround for some themes such as Human, where the contrast
+    //between text and background is too low.
+    QColor highlight = pal.highlight().color();
+    QColor highlightText = pal.highlightedText().color();
+    if (qAbs(qGray(highlight.rgb()) - qGray(highlightText.rgb())) < 150) {
+        if (qGray(highlightText.rgb()) < 128)
+            pal.setBrush(QPalette::Highlight, highlight.lighter(145));
+    }
+}
+
+/*!
+  \reimp
+*/
+void QHaikuStyle::unpolish(QWidget *widget)
+{
+    QWindowsStyle::unpolish(widget);
+    if (qobject_cast<QAbstractButton*>(widget)
+#ifndef QT_NO_COMBOBOX
+        || qobject_cast<QComboBox *>(widget)
+#endif
+#ifndef QT_NO_PROGRESSBAR
+        || qobject_cast<QProgressBar *>(widget)
+#endif
+#ifndef QT_NO_SCROLLBAR
+        || qobject_cast<QScrollBar *>(widget)
+#endif
+#ifndef QT_NO_SPLITTER
+        || qobject_cast<QSplitterHandle *>(widget)
+#endif
+        || qobject_cast<QAbstractSlider *>(widget)
+#ifndef QT_NO_SPINBOX
+        || qobject_cast<QAbstractSpinBox *>(widget)
+#endif
+        || (widget->inherits("QWorkspaceChild"))
+        || (widget->inherits("QDockSeparator"))
+        || (widget->inherits("QDockWidgetSeparator"))
+        ) {
+        widget->setAttribute(Qt::WA_Hover, false);
+    }
+}
+
+/*!
+  \reimp
+*/
+void QHaikuStyle::unpolish(QApplication *app)
+{
+    QWindowsStyle::unpolish(app);
+}
+
+/*!
+  \reimp
+*/
+QRect QHaikuStyle::subControlRect(ComplexControl control, const QStyleOptionComplex *option,
+                                       SubControl subControl, const QWidget *widget) const
+{
+    QRect rect = QWindowsStyle::subControlRect(control, option, subControl, widget);
+
+    switch (control) {
+#ifndef QT_NO_SLIDER
+    case CC_Slider:
+        if (const QStyleOptionSlider *slider = qstyleoption_cast<const QStyleOptionSlider *>(option)) {
+            int tickSize = pixelMetric(PM_SliderTickmarkOffset, option, widget);
+            switch (subControl) {
+            case SC_SliderHandle: {
+                if (slider->orientation == Qt::Horizontal) {
+                    rect.setHeight(pixelMetric(PM_SliderThickness));
+                    rect.setWidth(pixelMetric(PM_SliderLength));
+                    int centerY = slider->rect.center().y() - rect.height() / 2;
+                    if (slider->tickPosition & QSlider::TicksAbove)
+                        centerY += tickSize;
+                    if (slider->tickPosition & QSlider::TicksBelow)
+                        centerY -= tickSize;
+                    rect.moveTop(centerY);
+                } else {
+                    rect.setWidth(pixelMetric(PM_SliderThickness));
+                    rect.setHeight(pixelMetric(PM_SliderLength));
+                    int centerX = slider->rect.center().x() - rect.width() / 2;
+                    if (slider->tickPosition & QSlider::TicksAbove)
+                        centerX += tickSize;
+                    if (slider->tickPosition & QSlider::TicksBelow)
+                        centerX -= tickSize;
+                    rect.moveLeft(centerX);
+                }
+            }
+                break;
+            case SC_SliderGroove: {
+                QPoint grooveCenter = slider->rect.center();
+                if (slider->orientation == Qt::Horizontal) {
+                    rect.setHeight(7);
+                    if (slider->tickPosition & QSlider::TicksAbove)
+                        grooveCenter.ry() += tickSize;
+                    if (slider->tickPosition & QSlider::TicksBelow)
+                        grooveCenter.ry() -= tickSize;
+                } else {
+                    rect.setWidth(7);
+                    if (slider->tickPosition & QSlider::TicksAbove)
+                        grooveCenter.rx() += tickSize;
+                    if (slider->tickPosition & QSlider::TicksBelow)
+                        grooveCenter.rx() -= tickSize;
+                }
+                rect.moveCenter(grooveCenter);
+                break;
+            }
+            default:
+                break;
+            }
+        }
+        break;
+#endif // QT_NO_SLIDER
+    case CC_ScrollBar:
+        break;
+#ifndef QT_NO_SPINBOX
+    case CC_SpinBox:
+        if (const QStyleOptionSpinBox *spinbox = qstyleoption_cast<const QStyleOptionSpinBox *>(option)) {
+            QSize bs;
+            int center = spinbox->rect.height() / 2;
+            int fw = spinbox->frame ? pixelMetric(PM_SpinBoxFrameWidth, spinbox, widget) : 0;
+            int y = fw;
+            bs.setHeight(qMax(8, spinbox->rect.height()/2 - y));
+            bs.setWidth(15);
+            int x, lx, rx;
+            x = spinbox->rect.width() - y - bs.width() + 2;
+            lx = fw;
+            rx = x - fw;
+            switch (subControl) {
+            case SC_SpinBoxUp:
+                if (spinbox->buttonSymbols == QAbstractSpinBox::NoButtons)
+                    return QRect();
+                rect = QRect(x, fw, bs.width(), center - fw);
+                break;
+            case SC_SpinBoxDown:
+                if (spinbox->buttonSymbols == QAbstractSpinBox::NoButtons)
+                    return QRect();
+
+                rect = QRect(x, center, bs.width(), spinbox->rect.bottom() - center - fw + 1);
+                break;
+            case SC_SpinBoxEditField:
+                if (spinbox->buttonSymbols == QAbstractSpinBox::NoButtons) {
+                    rect = QRect(lx, fw, spinbox->rect.width() - 2*fw, spinbox->rect.height() - 2*fw);
+                } else {
+                    rect = QRect(lx, fw, rx - qMax(fw - 1, 0), spinbox->rect.height() - 2*fw);
+                }
+                break;
+            case SC_SpinBoxFrame:
+                rect = spinbox->rect;
+            default:
+                break;
+            }
+            rect = visualRect(spinbox->direction, spinbox->rect, rect);
+        }
+        break;
+#endif // Qt_NO_SPINBOX
+#ifndef QT_NO_GROUPBOX
+    case CC_GroupBox:
+        if (const QStyleOptionGroupBox *groupBox = qstyleoption_cast<const QStyleOptionGroupBox *>(option)) {
+            int topMargin = 0;
+            int topHeight = 0;
+            int verticalAlignment = styleHint(SH_GroupBox_TextLabelVerticalAlignment, groupBox, widget);
+            bool flat = groupBox->features & QStyleOptionFrameV2::Flat;
+            if (!groupBox->text.isEmpty()) {
+                topHeight = groupBox->fontMetrics.height();
+                if (verticalAlignment & Qt::AlignVCenter)
+                    topMargin = topHeight / 2;
+                else if (verticalAlignment & Qt::AlignTop)
+                    topMargin = topHeight;
+            }
+            QRect frameRect = groupBox->rect;
+            frameRect.setTop(topMargin);
+            if (subControl == SC_GroupBoxFrame) {
+                return rect;
+            }
+            else if (subControl == SC_GroupBoxContents) {
+                if( flat ) {
+                    int margin = 0;
+                    int leftMarginExtension = 16;
+                    rect = frameRect.adjusted(leftMarginExtension + margin, margin + topHeight, -margin, -margin);
+                }
+                break;
+            }
+            if(flat) {
+                if (const QGroupBox *groupBoxWidget = qobject_cast<const QGroupBox *>(widget)) {
+                    //Prepare metrics for a bold font
+                    QFont font = widget->font();
+                    font.setBold(true);
+                    QFontMetrics fontMetrics(font);
+
+                    QSize textRect = fontMetrics.boundingRect(groupBoxWidget->title()).size() + QSize(2, 2);
+                    if (subControl == SC_GroupBoxCheckBox) {
+                        int indicatorWidth = pixelMetric(PM_IndicatorWidth, option, widget);
+                        int indicatorHeight = pixelMetric(PM_IndicatorHeight, option, widget);
+                        rect.setWidth(indicatorWidth);
+                        rect.setHeight(indicatorHeight);
+                        rect.moveTop((fontMetrics.height() - indicatorHeight) / 2 + 2);
+                    } else if (subControl == SC_GroupBoxLabel) {
+                        rect.setSize(textRect);
+                    }
+                }
+            }
+        }
+        return rect;
+#ifndef QT_NO_COMBOBOX
+    case CC_ComboBox:
+        switch (subControl) {
+        case SC_ComboBoxArrow:
+            rect = visualRect(option->direction, option->rect, rect);
+            rect.setRect(rect.right() - 15, rect.top() - 2,
+                         16, rect.height() + 4);
+            rect = visualRect(option->direction, option->rect, rect);
+            break;
+        case SC_ComboBoxEditField: {
+            int frameWidth = pixelMetric(PM_DefaultFrameWidth)+1;
+            rect = visualRect(option->direction, option->rect, rect);
+            rect.setRect(option->rect.left() + frameWidth, option->rect.top() + frameWidth,
+                         option->rect.width() - 16 - 2 * frameWidth,
+                         option->rect.height() - 2 * frameWidth);
+            if (const QStyleOptionComboBox *box = qstyleoption_cast<const QStyleOptionComboBox *>(option)) {
+                if (!box->editable) {
+                    rect.adjust(2, 0, 0, 0);
+                    if (box->state & (State_Sunken | State_On))
+                        rect.translate(1, 1);
+                }
+            }
+            rect = visualRect(option->direction, option->rect, rect);
+            break;
+        }
+        default:
+            break;
+        }
+        break;
+#endif // QT_NO_COMBOBOX
+#endif //QT_NO_GROUPBOX
+        case CC_TitleBar:
+        if (const QStyleOptionTitleBar *tb = qstyleoption_cast<const QStyleOptionTitleBar *>(option)) {
+            SubControl sc = subControl;
+            QRect &ret = rect;
+            const int indent = 3;
+            const int controlTopMargin = 3;
+            const int controlBottomMargin = 3;
+            const int controlWidthMargin = 2;
+            const int controlHeight = tb->rect.height() - controlTopMargin - controlBottomMargin ;
+            const int delta = controlHeight + controlWidthMargin;
+            int offset = 0;
+
+            bool isMinimized = tb->titleBarState & Qt::WindowMinimized;
+            bool isMaximized = tb->titleBarState & Qt::WindowMaximized;
+
+            switch (sc) {
+            case SC_TitleBarLabel:
+                if (tb->titleBarFlags & (Qt::WindowTitleHint | Qt::WindowSystemMenuHint)) {
+                    ret = tb->rect;
+                    if (tb->titleBarFlags & Qt::WindowSystemMenuHint)
+                        ret.adjust(delta, 0, -delta, 0);
+                    if (tb->titleBarFlags & Qt::WindowMinimizeButtonHint)
+                        ret.adjust(0, 0, -delta, 0);
+                    if (tb->titleBarFlags & Qt::WindowMaximizeButtonHint)
+                        ret.adjust(0, 0, -delta, 0);
+                    if (tb->titleBarFlags & Qt::WindowShadeButtonHint)
+                        ret.adjust(0, 0, -delta, 0);
+                    if (tb->titleBarFlags & Qt::WindowContextHelpButtonHint)
+                        ret.adjust(0, 0, -delta, 0);
+                }
+                break;
+            case SC_TitleBarContextHelpButton:
+                if (tb->titleBarFlags & Qt::WindowContextHelpButtonHint)
+                    offset += delta;
+            case SC_TitleBarMinButton:
+                if (!isMinimized && (tb->titleBarFlags & Qt::WindowMinimizeButtonHint))
+                    offset += delta;
+                else if (sc == SC_TitleBarMinButton)
+                    break;
+            case SC_TitleBarNormalButton:
+                if (isMinimized && (tb->titleBarFlags & Qt::WindowMinimizeButtonHint))
+                    offset += delta;
+                else if (isMaximized && (tb->titleBarFlags & Qt::WindowMaximizeButtonHint))
+                    offset += delta;
+                else if (sc == SC_TitleBarNormalButton)
+                    break;
+            case SC_TitleBarMaxButton:
+                if (!isMaximized && (tb->titleBarFlags & Qt::WindowMaximizeButtonHint))
+                    offset += delta;
+                else if (sc == SC_TitleBarMaxButton)
+                    break;
+            case SC_TitleBarShadeButton:
+                if (!isMinimized && (tb->titleBarFlags & Qt::WindowShadeButtonHint))
+                    offset += delta;
+                else if (sc == SC_TitleBarShadeButton)
+                    break;
+            case SC_TitleBarUnshadeButton:
+                if (isMinimized && (tb->titleBarFlags & Qt::WindowShadeButtonHint))
+                    offset += delta;
+                else if (sc == SC_TitleBarUnshadeButton)
+                    break;
+            case SC_TitleBarCloseButton:
+                if (tb->titleBarFlags & Qt::WindowSystemMenuHint)
+                    offset += delta;
+                else if (sc == SC_TitleBarCloseButton)
+                    break;
+                ret.setRect(tb->rect.right() - indent - offset, tb->rect.top() + controlTopMargin,
+                            controlHeight, controlHeight);
+                break;
+            case SC_TitleBarSysMenu:
+                if (tb->titleBarFlags & Qt::WindowSystemMenuHint) {
+                    ret.setRect(tb->rect.left() + controlWidthMargin + indent, tb->rect.top() + controlTopMargin,
+                                controlHeight, controlHeight);
+                }
+                break;
+            default:
+                break;
+            }
+            ret = visualRect(tb->direction, tb->rect, ret);
+        }
+        break;
+    default:
+        break;
+    }
+
+    return rect;
+}
+
+
+/*!
+  \reimp
+*/
+QRect QHaikuStyle::itemPixmapRect(const QRect &r, int flags, const QPixmap &pixmap) const
+{
+    return QWindowsStyle::itemPixmapRect(r, flags, pixmap);
+}
+
+/*!
+  \reimp
+*/
+void QHaikuStyle::drawItemPixmap(QPainter *painter, const QRect &rect,
+                            int alignment, const QPixmap &pixmap) const
+{
+    QWindowsStyle::drawItemPixmap(painter, rect, alignment, pixmap);
+}
+
+/*!
+  \reimp
+*/
+QStyle::SubControl QHaikuStyle::hitTestComplexControl(ComplexControl cc, const QStyleOptionComplex *opt,
+                              const QPoint &pt, const QWidget *w) const
+{
+    return QWindowsStyle::hitTestComplexControl(cc, opt, pt, w);
+}
+
+/*!
+  \reimp
+*/
+QPixmap QHaikuStyle::generatedIconPixmap(QIcon::Mode iconMode, const QPixmap &pixmap,
+                                        const QStyleOption *opt) const
+{
+    return QWindowsStyle::generatedIconPixmap(iconMode, pixmap, opt);
+}
+
+/*!
+  \reimp
+*/
+int QHaikuStyle::styleHint(StyleHint hint, const QStyleOption *option, const QWidget *widget,
+                               QStyleHintReturn *returnData) const
+{
+    int ret = 0;
+    switch (hint) {
+    case SH_ScrollBar_MiddleClickAbsolutePosition:
+        ret = true;
+        break;
+    case SH_EtchDisabledText:
+        ret = 1;
+        break;
+    case SH_Menu_AllowActiveAndDisabled:
+        ret = false;
+        break;
+    case SH_MainWindow_SpaceBelowMenuBar:
+        ret = 0;
+        break;
+    case SH_MenuBar_MouseTracking:
+        ret = 1;
+        break;
+    case SH_TitleBar_AutoRaise:
+        ret = 1;
+        break;
+    case SH_TitleBar_NoBorder:
+        ret = 1;
+        break;
+    case SH_ItemView_ShowDecorationSelected:
+        ret = true;
+        break;
+    case SH_Table_GridLineColor:
+        if (option) {
+            ret = option->palette.background().color().darker(120).rgb();
+            break;
+        }
+    case SH_ComboBox_Popup:
+#ifdef QT3_SUPPORT
+        if (widget && widget->inherits("Q3ComboBox"))
+            return 0;
+#endif
+        if (const QStyleOptionComboBox *cmb = qstyleoption_cast<const QStyleOptionComboBox *>(option))
+            ret = !cmb->editable;
+        else
+            ret = 0;
+        break;
+    case SH_WindowFrame_Mask:
+        ret = 1;
+        if (QStyleHintReturnMask *mask = qstyleoption_cast<QStyleHintReturnMask *>(returnData)) {
+            //left rounded corner
+            mask->region = option->rect;
+            mask->region -= QRect(option->rect.left(), option->rect.top(), 5, 1);
+            mask->region -= QRect(option->rect.left(), option->rect.top() + 1, 3, 1);
+            mask->region -= QRect(option->rect.left(), option->rect.top() + 2, 2, 1);
+            mask->region -= QRect(option->rect.left(), option->rect.top() + 3, 1, 2);
+
+            //right rounded corner
+            mask->region -= QRect(option->rect.right() - 4, option->rect.top(), 5, 1);
+            mask->region -= QRect(option->rect.right() - 2, option->rect.top() + 1, 3, 1);
+            mask->region -= QRect(option->rect.right() - 1, option->rect.top() + 2, 2, 1);
+            mask->region -= QRect(option->rect.right() , option->rect.top() + 3, 1, 2);
+        }
+        break;
+    case SH_MessageBox_TextInteractionFlags:
+        ret = Qt::TextSelectableByMouse | Qt::LinksAccessibleByMouse;
+        break;
+    case SH_DialogButtonBox_ButtonsHaveIcons:
+        ret = true;
+        break;
+    case SH_MessageBox_CenterButtons:
+        ret = false;
+        break;
+#ifndef QT_NO_WIZARD
+    case SH_WizardStyle:
+        ret = QWizard::ClassicStyle;
+        break;
+#endif
+    case SH_ItemView_ArrowKeysNavigateIntoChildren:
+        ret = false;
+        break;
+    case SH_Menu_SubMenuPopupDelay:
+        ret = 225; // default from GtkMenu
+        break;
+    default:
+        ret = QWindowsStyle::styleHint(hint, option, widget, returnData);
+        break;
+    }
+    return ret;
+}
+
+/*! \reimp */
+QRect QHaikuStyle::subElementRect(SubElement sr, const QStyleOption *opt, const QWidget *w) const
+{
+    QRect r = QWindowsStyle::subElementRect(sr, opt, w);
+    switch (sr) {
+    case SE_PushButtonFocusRect:
+        r.adjust(0, 1, 0, -1);
+        break;
+    case SE_DockWidgetTitleBarText: {
+        const QStyleOptionDockWidgetV2 *v2
+            = qstyleoption_cast<const QStyleOptionDockWidgetV2*>(opt);
+        bool verticalTitleBar = v2 == 0 ? false : v2->verticalTitleBar;
+        if (verticalTitleBar) {
+            r.adjust(0, 0, 0, -4);
+        } else {
+            if (QApplication::layoutDirection() == Qt::LeftToRight)
+                r.adjust(4, 0, 0, 0);
+            else
+                r.adjust(0, 0, -4, 0);
+        }
+
+        break;
+    }
+    case SE_ProgressBarContents:
+        r = subElementRect(SE_ProgressBarGroove, opt, w);
+        break;
+    default:
+        break;
+    }
+    return r;
+}
+
+void QHaikuStylePrivate::lookupIconTheme() const
+{
+}
+
+/*!
+    \internal
+*/
+
+QPixmap
+haikuIconFromMime(const char *mime, icon_size which)
+{
+	QPixmap pixmap;
+	BMimeType mtype(mime);
+	BBitmap *bmp = new BBitmap(BRect(0, 0, which - 1, which - 1), B_RGBA32);
+
+	if (mtype.GetIcon(bmp, which) != B_OK) {
+		BMimeType super;
+		mtype.GetSupertype(&super);
+		if (super.GetIcon(bmp, which) != B_OK) {
+			delete bmp;
+			bmp = NULL;			
+		}
+	}
+			
+	if(bmp) {
+		pixmap = QPixmap::fromHaikuBitmap(bmp);
+		delete bmp;
+	}
+				
+	return pixmap;
+}
+
+QIcon QHaikuStyle::standardIconImplementation(StandardPixmap standardIcon,
+                                                  const QStyleOption *option,
+                                                  const QWidget *widget) const
+{    
+    QIcon icon;
+    QPixmap pixmap;
+
+    switch (standardIcon) {
+	    case SP_ComputerIcon:
+	    {
+	        icon.addPixmap(haikuIconFromMime("application/x-vnd.Be-root",B_MINI_ICON));
+	        icon.addPixmap(haikuIconFromMime("application/x-vnd.Be-root",B_LARGE_ICON));
+	        break;    	
+	    }
+    default:
+        break;
+    }
+
+    if (icon.isNull())
+        icon = QCommonStyle::standardIconImplementation(standardIcon, option, widget);
+    return icon;		
+}
+
+/*!
+ \reimp
+ */
+QPixmap QHaikuStyle::standardPixmap(StandardPixmap standardPixmap, const QStyleOption *opt,
+                                      const QWidget *widget) const
+{
+    return QWindowsStyle::standardPixmap(standardPixmap, opt, widget);
+}
+
+QT_END_NAMESPACE
+
+#endif // QT_NO_STYLE_HAIKU || QT_PLUGIN
diff -rupN qt-everywhere-opensource-src-4.7.3/src/gui/styles/qhaikustyle.h qt-everywhere-opensource-src-4.7.3_haiku/src/gui/styles/qhaikustyle.h
--- qt-everywhere-opensource-src-4.7.3/src/gui/styles/qhaikustyle.h	1970-01-01 00:00:00.000000000 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/gui/styles/qhaikustyle.h	2011-06-13 22:06:43.366477312 +0000
@@ -0,0 +1,114 @@
+/****************************************************************************
+**
+** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: Qt Software Information (qt-info@nokia.com)
+**
+** This file is part of the QtGui module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial Usage
+** Licensees holding valid Qt Commercial licenses may use this file in
+** accordance with the Qt Commercial License Agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Nokia.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain
+** additional rights. These rights are described in the Nokia Qt LGPL
+** Exception version 1.0, included in the file LGPL_EXCEPTION.txt in this
+** package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+** If you are unsure which license is appropriate for your use, please
+** contact the sales department at qt-sales@nokia.com.
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QHAIKYSTYLE_H
+#define QHAIKYSTYLE_H
+
+#include <QtGui/qwindowsstyle.h>
+
+QT_BEGIN_HEADER
+
+QT_BEGIN_NAMESPACE
+
+QT_MODULE(Gui)
+
+#if !defined(QT_NO_STYLE_HAIKU)
+
+class QHaikuStylePrivate;
+class Q_GUI_EXPORT QHaikuStyle : public QWindowsStyle
+{
+    Q_OBJECT
+    Q_DECLARE_PRIVATE(QHaikuStyle)
+
+public:
+    QHaikuStyle();
+    ~QHaikuStyle();
+
+    QPalette standardPalette () const;
+    void drawPrimitive(PrimitiveElement elem,
+                        const QStyleOption *option,
+                        QPainter *painter, const QWidget *widget = 0) const;
+    void drawControl(ControlElement ce, const QStyleOption *option, QPainter *painter,
+                                const QWidget *widget) const;
+    int pixelMetric(PixelMetric metric, const QStyleOption *option = 0, const QWidget *widget = 0) const;
+    void drawComplexControl(ComplexControl control, const QStyleOptionComplex *option,
+                            QPainter *painter, const QWidget *widget) const;
+    QRect subElementRect(SubElement r, const QStyleOption *opt, const QWidget *widget = 0) const;
+    QSize sizeFromContents(ContentsType type, const QStyleOption *option,
+                           const QSize &size, const QWidget *widget) const;
+    SubControl hitTestComplexControl(ComplexControl cc, const QStyleOptionComplex *opt,
+                               const QPoint &pt, const QWidget *w = 0) const;
+    QRect subControlRect(ComplexControl cc, const QStyleOptionComplex *opt,
+                         SubControl sc, const QWidget *widget) const;
+    QPixmap generatedIconPixmap(QIcon::Mode iconMode, const QPixmap &pixmap,
+                                        const QStyleOption *opt) const;
+    int styleHint(StyleHint hint, const QStyleOption *option = 0, const QWidget *widget = 0,
+                  QStyleHintReturn *returnData = 0) const;
+    QRect itemPixmapRect(const QRect &r, int flags, const QPixmap &pixmap) const;
+    QPixmap standardPixmap(StandardPixmap standardPixmap, const QStyleOption *opt,
+                           const QWidget *widget = 0) const;
+    void drawItemPixmap(QPainter *painter, const QRect &rect,
+                        int alignment, const QPixmap &pixmap) const;
+    void drawItemText(QPainter *painter, const QRect &rect,
+                              int flags, const QPalette &pal, bool enabled,
+                              const QString &text, QPalette::ColorRole textRole = QPalette::NoRole) const;
+    void polish(QWidget *widget);
+    void polish(QApplication *app);
+    void polish(QPalette &pal);
+    void unpolish(QWidget *widget);
+    void unpolish(QApplication *app);
+
+protected Q_SLOTS:
+    QIcon standardIconImplementation(StandardPixmap standardIcon, const QStyleOption *option,
+                                     const QWidget *widget = 0) const;
+
+protected:
+    QHaikuStyle(QHaikuStylePrivate &dd);
+
+};
+
+#endif // QT_NO_STYLE_HAIKU
+
+QT_END_NAMESPACE
+
+QT_END_HEADER
+
+#endif // QHAIKUSTYLE_H
diff -rupN qt-everywhere-opensource-src-4.7.3/src/gui/styles/qhaikustyle_p.h qt-everywhere-opensource-src-4.7.3_haiku/src/gui/styles/qhaikustyle_p.h
--- qt-everywhere-opensource-src-4.7.3/src/gui/styles/qhaikustyle_p.h	1970-01-01 00:00:00.000000000 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/gui/styles/qhaikustyle_p.h	2011-06-13 22:06:43.367788032 +0000
@@ -0,0 +1,82 @@
+/****************************************************************************
+**
+** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: Qt Software Information (qt-info@nokia.com)
+**
+** This file is part of the QtGui module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial Usage
+** Licensees holding valid Qt Commercial licenses may use this file in
+** accordance with the Qt Commercial License Agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Nokia.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain
+** additional rights. These rights are described in the Nokia Qt LGPL
+** Exception version 1.0, included in the file LGPL_EXCEPTION.txt in this
+** package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+** If you are unsure which license is appropriate for your use, please
+** contact the sales department at qt-sales@nokia.com.
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QHAIKYSTYLE_P_H
+#define QHAIKUSTYLE_P_H
+
+//
+//  W A R N I N G
+//  -------------
+//
+// This file is not part of the Qt API.  It exists for the convenience
+// of qapplication_*.cpp, qwidget*.cpp and qfiledialog.cpp.  This header
+// file may change from version to version without notice, or even be removed.
+//
+// We mean it.
+//
+
+#include "qwindowsstyle.h"
+#include "qwindowsstyle_p.h"
+
+#ifndef QT_NO_STYLE_HAIKU
+
+QT_BEGIN_NAMESPACE
+
+class QHaikuStylePrivate : public QWindowsStylePrivate
+{
+    Q_DECLARE_PUBLIC(QHaikuStyle)
+public:
+    QHaikuStylePrivate()
+        : QWindowsStylePrivate() {
+        animationFps = 24;
+    }
+
+    ~QHaikuStylePrivate() {
+    }
+
+    void lookupIconTheme() const;
+};
+
+QT_END_NAMESPACE
+
+#endif // QT_NO_STYLE_HAIKU
+
+#endif //QHAIKUSTYLE_P_H
diff -rupN qt-everywhere-opensource-src-4.7.3/src/gui/styles/qstylefactory.cpp qt-everywhere-opensource-src-4.7.3_haiku/src/gui/styles/qstylefactory.cpp
--- qt-everywhere-opensource-src-4.7.3/src/gui/styles/qstylefactory.cpp	2011-03-30 05:19:06.011796480 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/gui/styles/qstylefactory.cpp	2011-06-13 22:06:43.383516672 +0000
@@ -54,6 +54,9 @@
 #ifndef QT_NO_STYLE_CLEANLOOKS
 #include "qcleanlooksstyle.h"
 #endif
+#ifndef QT_NO_STYLE_HAIKU
+#include "qhaikustyle.h"
+#endif
 #ifndef QT_NO_STYLE_GTK
 #include "qgtkstyle.h"
 #endif
@@ -172,6 +175,11 @@ QStyle *QStyleFactory::create(const QStr
         ret = new QCleanlooksStyle;
     else
 #endif
+#ifndef QT_NO_STYLE_HAIKU
+    if (style == QLatin1String("haiku"))
+        ret = new QHaikuStyle;
+    else
+#endif
 #ifndef QT_NO_STYLE_GTK
     if (style == QLatin1String("gtk") || style == QLatin1String("gtk+"))
         ret = new QGtkStyle;
@@ -257,6 +265,10 @@ QStringList QStyleFactory::keys()
     if (!list.contains(QLatin1String("Cleanlooks")))
         list << QLatin1String("Cleanlooks");
 #endif
+#ifndef QT_NO_STYLE_HAIKU
+    if (!list.contains(QLatin1String("Haiku")))
+        list << QLatin1String("Haiku");
+#endif
 #ifndef QT_NO_STYLE_MAC
     QString mstyle = QLatin1String("Macintosh");
 # ifdef Q_WS_MAC
diff -rupN qt-everywhere-opensource-src-4.7.3/src/gui/styles/styles.pri qt-everywhere-opensource-src-4.7.3_haiku/src/gui/styles/styles.pri
--- qt-everywhere-opensource-src-4.7.3/src/gui/styles/styles.pri	2011-03-30 05:19:06.011796480 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/gui/styles/styles.pri	2011-06-13 22:06:43.384827392 +0000
@@ -188,3 +188,11 @@ contains( styles, s60 ):contains(QT_CONF
     }
     DEFINES += QT_NO_STYLE_S60
 }
+
+haiku {
+    HEADERS += styles/qhaikustyle.h
+    HEADERS += styles/qhaikustyle_p.h
+    SOURCES += styles/qhaikustyle.cpp
+} else {
+	DEFINES += QT_NO_STYLE_HAIKU
+}
diff -rupN qt-everywhere-opensource-src-4.7.3/src/gui/text/qfont.cpp qt-everywhere-opensource-src-4.7.3_haiku/src/gui/text/qfont.cpp
--- qt-everywhere-opensource-src-4.7.3/src/gui/text/qfont.cpp	2011-03-30 05:19:05.023592960 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/gui/text/qfont.cpp	2011-06-13 22:06:43.387710976 +0000
@@ -202,6 +202,8 @@ Q_GUI_EXPORT int qt_defaultDpiY()
     dpi = qRound(screen->height() / (screen->physicalHeight() / qreal(25.4)));
 #elif defined(Q_OS_SYMBIAN)
     dpi = S60->defaultDpiY;
+#elif defined(Q_WS_HAIKU)
+	dpi = 72;        
 #endif // Q_WS_X11
 
     return dpi;
diff -rupN qt-everywhere-opensource-src-4.7.3/src/gui/text/qfont_haiku.cpp qt-everywhere-opensource-src-4.7.3_haiku/src/gui/text/qfont_haiku.cpp
--- qt-everywhere-opensource-src-4.7.3/src/gui/text/qfont_haiku.cpp	1970-01-01 00:00:00.000000000 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/gui/text/qfont_haiku.cpp	2011-06-13 22:06:43.389021696 +0000
@@ -0,0 +1,149 @@
+/****************************************************************************
+**
+** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: Qt Software Information (qt-info@nokia.com)
+**
+** This file is part of the QtGui module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial Usage
+** Licensees holding valid Qt Commercial licenses may use this file in
+** accordance with the Qt Commercial License Agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Nokia.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain
+** additional rights. These rights are described in the Nokia Qt LGPL
+** Exception version 1.0, included in the file LGPL_EXCEPTION.txt in this
+** package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+** If you are unsure which license is appropriate for your use, please
+** contact the sales department at qt-sales@nokia.com.
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qfont.h"
+#include "qfont_p.h"
+#include "qfontengine_p.h"
+#include "qfontinfo.h"
+#include "qfontmetrics.h"
+#include "qpaintdevice.h"
+#include "qstring.h"
+#include <private/qtextengine_p.h>
+#include <private/qunicodetables_p.h>
+#include <qapplication.h>
+#include "qfontdatabase.h"
+#include <qpainter.h>
+#include "qtextengine_p.h"
+#include <stdlib.h>
+
+QT_BEGIN_NAMESPACE
+
+float qt_haiku_defaultDpi_x()
+{
+	return 72.0;
+}
+
+int qt_haiku_pixelsize(const QFontDef &def, int dpi)
+{
+    float ret;
+    if(def.pixelSize == -1)
+        ret = def.pointSize *  dpi / qt_haiku_defaultDpi_x();
+    else
+        ret = def.pixelSize;
+    return qRound(ret);
+}
+
+int qt_haiku_pointsize(const QFontDef &def, int dpi)
+{
+    float ret;
+    if(def.pointSize < 0)
+        ret = def.pixelSize * qt_haiku_defaultDpi_x() / float(dpi);
+    else
+        ret = def.pointSize;
+    return qRound(ret);
+}
+
+Q_GUI_EXPORT const char *qt_fontFamilyFromStyleHint(const QFontDef &request)
+{
+    const char *family = 0;
+    switch (request.styleHint) {
+    case QFont::Helvetica:
+        family = "DejaVu Sans";
+        break;
+    case QFont::Times:
+    case QFont::OldEnglish:
+        family = "DejaVu Serif";
+        break;
+    case QFont::Courier:
+        family = "DejaVu Sans Mono";
+        break;
+    case QFont::System:
+        family = "DejaVu Sans";
+        break;
+    case QFont::AnyStyle:
+        if (request.fixedPitch)
+            family = "DejaVu Sans Mono";
+        else
+            family = "DejaVu Sans";
+        break;
+    }
+    return family;
+}
+
+/*****************************************************************************
+  QFont member functions
+ *****************************************************************************/
+
+void QFont::initialize()
+{
+}
+
+void QFont::cleanup()
+{
+    QFontCache::cleanup();
+}
+
+QString QFont::rawName() const
+{
+    return family();
+}
+
+void QFont::setRawName(const QString &name)
+{
+    setFamily(name);
+}
+
+QString QFont::defaultFamily() const
+{
+    return QLatin1String(qt_fontFamilyFromStyleHint(d->request));
+}
+
+QString QFont::lastResortFamily() const
+{
+    return QString::fromLatin1("DejaVu Sans");
+}
+
+QString QFont::lastResortFont() const
+{
+    return QString::fromLatin1("DejaVu Sans");
+}
+
+QT_END_NAMESPACE
diff -rupN qt-everywhere-opensource-src-4.7.3/src/gui/text/qfont_p.h qt-everywhere-opensource-src-4.7.3_haiku/src/gui/text/qfont_p.h
--- qt-everywhere-opensource-src-4.7.3/src/gui/text/qfont_p.h	2011-03-30 05:19:05.022806528 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/gui/text/qfont_p.h	2011-06-13 22:06:43.390332416 +0000
@@ -273,6 +273,10 @@ public:
     int timer_id;
 };
 
+#ifdef Q_WS_HAIKU
+Q_GUI_EXPORT const char *qt_fontFamilyFromStyleHint(const QFontDef &request);
+#endif
+
 QT_END_NAMESPACE
 
 #endif // QFONT_P_H
diff -rupN qt-everywhere-opensource-src-4.7.3/src/gui/text/qfontdatabase.cpp qt-everywhere-opensource-src-4.7.3_haiku/src/gui/text/qfontdatabase.cpp
--- qt-everywhere-opensource-src-4.7.3/src/gui/text/qfontdatabase.cpp	2011-03-30 05:19:05.024903680 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/gui/text/qfontdatabase.cpp	2011-06-13 22:06:43.392953856 +0000
@@ -151,10 +151,10 @@ struct QtFontSize
                                 uint yres = 0, uint avgwidth = 0, bool add = false);
     unsigned short count : 16;
 #endif // Q_WS_X11
-#if defined(Q_WS_QWS) || defined(Q_OS_SYMBIAN)
+#if defined(Q_WS_QWS) || defined(Q_OS_SYMBIAN) || defined(Q_WS_HAIKU)
     QByteArray fileName;
     int fileIndex;
-#endif // defined(Q_WS_QWS) || defined(Q_OS_SYMBIAN)
+#endif // defined(Q_WS_QWS) || defined(Q_OS_SYMBIAN) || defined(Q_WS_HAIKU)
 
     unsigned short pixelSize : 16;
 };
@@ -230,14 +230,14 @@ struct QtFontStyle
         delete [] weightName;
         delete [] setwidthName;
 #endif
-#if defined(Q_WS_X11) || defined(Q_WS_QWS) || defined(Q_OS_SYMBIAN)
+#if defined(Q_WS_X11) || defined(Q_WS_QWS) || defined(Q_OS_SYMBIAN) || defined(Q_WS_HAIKU)
         while (count) {
             // bitfield count-- in while condition does not work correctly in mwccsym2
             count--;
 #ifdef Q_WS_X11
             free(pixelSizes[count].encodings);
 #endif
-#if defined(Q_WS_QWS) || defined(Q_OS_SYMBIAN)
+#if defined(Q_WS_QWS) || defined(Q_OS_SYMBIAN) || defined(Q_WS_HAIKU)
             pixelSizes[count].fileName.~QByteArray();
 #endif
         }
@@ -255,7 +255,7 @@ struct QtFontStyle
     const char *weightName;
     const char *setwidthName;
 #endif // Q_WS_X11
-#if defined(Q_WS_QWS) || defined(Q_OS_SYMBIAN)
+#if defined(Q_WS_QWS) || defined(Q_OS_SYMBIAN) || defined(Q_WS_HAIKU)
     bool antialiased;
 #endif
 
@@ -301,7 +301,7 @@ QtFontSize *QtFontStyle::pixelSize(unsig
     pixelSizes[count].count = 0;
     pixelSizes[count].encodings = 0;
 #endif
-#if defined(Q_WS_QWS) || defined(Q_OS_SYMBIAN)
+#if defined(Q_WS_QWS) || defined(Q_OS_SYMBIAN) || defined(Q_WS_HAIKU)
     new (&pixelSizes[count].fileName) QByteArray;
     pixelSizes[count].fileIndex = 0;
 #endif
@@ -474,7 +474,7 @@ QtFontFoundry *QtFontFamily::foundry(con
 
 // ### copied to tools/makeqpf/qpf2.cpp
 
-#if (defined(Q_WS_QWS) && !defined(QT_NO_FREETYPE)) || defined(Q_WS_WIN)  || defined(Q_OS_SYMBIAN) || (defined(Q_WS_MAC) && !defined(QT_MAC_USE_COCOA))
+#if (defined(Q_WS_QWS) && !defined(QT_NO_FREETYPE)) || defined(Q_WS_WIN)  || defined(Q_OS_SYMBIAN) || defined(Q_WS_HAIKU) || (defined(Q_WS_MAC) && !defined(QT_MAC_USE_COCOA))
 // see the Unicode subset bitfields in the MSDN docs
 static int requiredUnicodeBits[QFontDatabase::WritingSystemsCount][2] = {
         // Any,
@@ -994,7 +994,7 @@ static void initFontDef(const QtFontDesc
 #endif
 #endif
 
-#if defined(Q_WS_X11) || defined(Q_WS_WIN) || defined(Q_OS_SYMBIAN)
+#if defined(Q_WS_X11) || defined(Q_WS_WIN) || defined(Q_OS_SYMBIAN) || defined(Q_WS_HAIKU)
 static void getEngineData(const QFontPrivate *d, const QFontCache::Key &key)
 {
     // look for the requested font in the engine data cache
@@ -1057,6 +1057,8 @@ QT_BEGIN_INCLUDE_NAMESPACE
 #  include "qfontdatabase_qws.cpp"
 #elif defined(Q_OS_SYMBIAN)
 #  include "qfontdatabase_s60.cpp"
+#elif defined(Q_WS_HAIKU)
+#  include "qfontdatabase_haiku.cpp"
 #endif
 QT_END_INCLUDE_NAMESPACE
 
diff -rupN qt-everywhere-opensource-src-4.7.3/src/gui/text/qfontdatabase_haiku.cpp qt-everywhere-opensource-src-4.7.3_haiku/src/gui/text/qfontdatabase_haiku.cpp
--- qt-everywhere-opensource-src-4.7.3/src/gui/text/qfontdatabase_haiku.cpp	1970-01-01 00:00:00.000000000 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/gui/text/qfontdatabase_haiku.cpp	2011-06-13 22:06:43.395051008 +0000
@@ -0,0 +1,373 @@
+#include "qfontdatabase.h"
+#include <qabstractfileengine.h> //to get qfontdatabase.cpp compiling
+#include "qfont_p.h"
+#include "qfontengine_p.h"
+#include "qfontengine_ft_p.h"
+#include "qfontengine_haiku_p.h"
+#include "qpaintdevice.h"
+#include "qlibrary.h"
+#include "qabstractfileengine.h"
+#include "qendian.h"
+
+#include <stdio.h>
+
+#include <Path.h>
+#include <Entry.h>
+#include <File.h>
+#include <Directory.h>
+#include <FindDirectory.h>
+
+#include <ft2build.h>
+#include FT_FREETYPE_H
+#include FT_TYPES_H
+#include FT_TRUETYPE_TABLES_H
+#include FT_LCD_FILTER_H
+
+struct FaceData
+{
+    int index;
+    QString familyName;
+    QtFontStyle::Key styleKey;
+    QList<QFontDatabase::WritingSystem> systems;
+    bool fixedPitch;
+    bool smoothScalable;
+    QList<unsigned short> pixelSizes;
+};
+
+// from qfont_haiku.cpp
+extern int qt_haiku_pixelsize(const QFontDef &def, int dpi);
+extern int qt_haiku_pointsize(const QFontDef &def, int dpi);
+extern float qt_haiku_defaultDpi_x();
+
+static void initializeDb()
+{
+    QFontDatabasePrivate *db = privateDb();
+    if(!db || db->count)
+        return;
+
+    extern FT_Library qt_getFreetype(); // qfontengine_ft.cpp
+    FT_Library lib = qt_getFreetype();
+
+	directory_which FontDirs[] = {
+		B_BEOS_FONTS_DIRECTORY,
+		B_COMMON_FONTS_DIRECTORY,
+		B_USER_FONTS_DIRECTORY
+	};
+	
+	
+	for(int nfont=0;nfont<3;nfont++)
+	{	
+		BPath fontDir;
+		find_directory(FontDirs[nfont],&fontDir);
+		fontDir.Append("ttfonts");
+		
+		BDirectory dir(fontDir.Path());
+		if (dir.InitCheck() != B_OK)
+			continue;
+			
+	 	BEntry ent;
+	 	char filename[B_FILE_NAME_LENGTH];
+	 	int file_index_value = 0;
+	
+	 	while (dir.GetNextEntry(&ent) == B_NO_ERROR)
+	 	{
+	 		QList<FaceData> facedata;
+	
+			ent.GetName(filename);
+	 		BPath path = BPath(&dir, filename);	
+			
+	        FT_Long numFaces = 0;
+	        FT_Face face;
+	
+	        FT_Error rc = FT_New_Face(lib, path.Path(), -1, &face);
+	        if (rc == 0) {
+	            numFaces = face->num_faces; 
+	        	FT_Done_Face(face);                                   
+	        }
+	        
+	        for (FT_Long idx = 0; idx < numFaces; ++idx) {
+	                rc = FT_New_Face(lib, path.Path(), idx, &face);
+	                FaceData fdata;
+	                fdata.index = idx;
+	                fdata.familyName = QString::fromLatin1(face->family_name);
+	                fdata.familyName = fdata.familyName.trimmed();
+	                
+	                fdata.styleKey.style = face->style_flags & FT_STYLE_FLAG_ITALIC ? QFont::StyleItalic : QFont::StyleNormal;
+	
+	                TT_OS2 *os2_table = 0;
+	                if (face->face_flags & FT_FACE_FLAG_SFNT) {
+	                    os2_table = (TT_OS2 *)FT_Get_Sfnt_Table(face, ft_sfnt_os2);
+	                }
+	                if (os2_table) {
+	                    // map weight and width values
+	                    if (os2_table->usWeightClass < 400)
+	                        fdata.styleKey.weight = QFont::Light;
+	                    else if (os2_table->usWeightClass < 600)
+	                        fdata.styleKey.weight = QFont::Normal;
+	                    else if (os2_table->usWeightClass < 700)
+	                        fdata.styleKey.weight = QFont::DemiBold;
+	                    else if (os2_table->usWeightClass < 800)
+	                        fdata.styleKey.weight = QFont::Bold;
+	                    else
+	                        fdata.styleKey.weight = QFont::Black;
+	
+	                    switch (os2_table->usWidthClass) {
+	                        case 1: fdata.styleKey.stretch = QFont::UltraCondensed; break;
+	                        case 2: fdata.styleKey.stretch = QFont::ExtraCondensed; break;
+	                        case 3: fdata.styleKey.stretch = QFont::Condensed; break;
+	                        case 4: fdata.styleKey.stretch = QFont::SemiCondensed; break;
+	                        case 5: fdata.styleKey.stretch = QFont::Unstretched; break;
+	                        case 6: fdata.styleKey.stretch = QFont::SemiExpanded; break;
+	                        case 7: fdata.styleKey.stretch = QFont::Expanded; break;
+	                        case 8: fdata.styleKey.stretch = QFont::ExtraExpanded; break;
+	                        case 9: fdata.styleKey.stretch = QFont::UltraExpanded; break;
+	                        default: fdata.styleKey.stretch = QFont::Unstretched; break;
+	                    }                  
+	                    quint32 unicodeRange[4] = {
+	                        os2_table->ulUnicodeRange1, os2_table->ulUnicodeRange2,
+	                        os2_table->ulUnicodeRange3, os2_table->ulUnicodeRange4
+	                    };
+	                    quint32 codePageRange[2] = {
+	                        os2_table->ulCodePageRange1, os2_table->ulCodePageRange2
+	                    };
+	                    fdata.systems = determineWritingSystemsFromTrueTypeBits(unicodeRange, codePageRange);                          
+	                } else {
+	                    fdata.styleKey.weight = face->style_flags & FT_STYLE_FLAG_BOLD ? QFont::Bold : QFont::Normal;
+	                    fdata.styleKey.stretch = QFont::Unstretched;
+	                }
+	                
+	                fdata.fixedPitch = face->face_flags & FT_FACE_FLAG_FIXED_WIDTH;
+	                fdata.smoothScalable = face->face_flags & FT_FACE_FLAG_SCALABLE;
+	
+	                if (face->face_flags & FT_FACE_FLAG_FIXED_SIZES) {
+	                    for (FT_Int i = 0; i < face->num_fixed_sizes; ++i) {
+	                        fdata.pixelSizes << face->available_sizes[i].height;
+	                    }
+	                }
+	            	facedata << fdata;            	
+	    		
+	    		    if(face)
+		        		FT_Done_Face(face);            	
+	        }
+	     
+	      	foreach(FaceData cached, facedata) {
+		 		const QString foundryName;
+		 		QtFontFamily *family = privateDb()->family(cached.familyName, true);
+		 		family->fixedPitch = cached.fixedPitch;
+		 		
+		 		for (int i = 0; i < cached.systems.count(); ++i)
+	               family->writingSystems[cached.systems.at(i)] = QtFontFamily::Supported;
+		 		
+		 		QtFontFoundry *foundry = family->foundry(foundryName, true);
+		 		QtFontStyle *style = foundry->style(cached.styleKey, true);
+	
+		 		style->antialiased = true;
+	
+		        QByteArray file((const char *)path.Path());
+	            
+	            if (cached.smoothScalable && !style->smoothScalable) {
+	                style->smoothScalable = true;
+	                QtFontSize *size = style->pixelSize(SMOOTH_SCALABLE, true);
+	                size->fileName = file;
+	                size->fileIndex = cached.index;
+	            }
+		        
+	            foreach(unsigned short pixelSize, cached.pixelSizes) {
+	                QtFontSize *size = style->pixelSize(pixelSize, true);
+	                // the first bitmap style with a given pixel and point size wins
+	                if (!size->fileName.isEmpty())
+	                    continue;
+	                size->fileName = file;
+	                size->fileIndex = cached.index;
+	            }            
+	 		} 
+	 		file_index_value++;
+	 	}
+	}
+}
+
+static inline void load(const QString &family = QString(), int = -1)
+{                
+}
+
+static void registerFont(QFontDatabasePrivate::ApplicationFont *fnt)
+{
+}
+
+static QFontDef fontDescToFontDef(const QFontDef &req, const QtFontDesc &desc)
+{
+    static long dpi = qt_haiku_defaultDpi_x();
+
+    QFontDef fontDef;
+
+    fontDef.family = desc.family->name;
+
+    if (desc.size->pixelSize == SMOOTH_SCALABLE) {
+        // scalable font matched, calculate the missing size (points or pixels)
+        fontDef.pointSize = req.pointSize;
+        fontDef.pixelSize = req.pixelSize;
+        if (req.pointSize < 0) {
+            fontDef.pointSize = req.pixelSize * 72. / dpi;
+        } else if (req.pixelSize == -1) {
+            fontDef.pixelSize = qRound(req.pointSize * dpi / 72.);
+        }
+    } else {
+        // non-scalable font matched, calculate both point and pixel size
+        fontDef.pixelSize = desc.size->pixelSize;
+        fontDef.pointSize = desc.size->pixelSize * 72. / dpi;
+    }
+
+    fontDef.styleStrategy = req.styleStrategy;
+    fontDef.styleHint = req.styleHint;
+
+    fontDef.weight = desc.style->key.weight;
+    fontDef.fixedPitch = desc.family->fixedPitch;
+    fontDef.style = desc.style->key.style;
+    fontDef.stretch = desc.style->key.stretch;
+
+    return fontDef;
+}
+
+static QFontEngine *loadEngine(const QFontDef &req, const QtFontDesc &desc)
+{
+    // @todo all these fixed so far; make configurable through the Registry
+    // on per-family basis
+    QFontEngineHaiku::HintStyle hintStyle = QFontEngineHaiku::HintFull;
+    bool autoHint = true;
+    QFontEngineFT::SubpixelAntialiasingType subPixel = QFontEngineFT::Subpixel_None;
+    int lcdFilter = FT_LCD_FILTER_DEFAULT;
+    bool useEmbeddedBitmap = true;
+
+    QFontEngine::FaceId faceId;
+    faceId.filename = desc.size->fileName;
+    faceId.index = desc.size->fileIndex;
+
+    QFontEngineFT *fe = new QFontEngineHaiku(fontDescToFontDef(req, desc), faceId,
+                                            desc.style->antialiased, hintStyle,
+                                            autoHint, subPixel, lcdFilter,
+                                            useEmbeddedBitmap);
+    Q_ASSERT(fe);
+    if (fe && fe->invalid()) {
+        FM_DEBUG("   --> invalid!\n");
+        delete fe;
+        fe = 0;
+    }
+    return fe;
+}
+
+static QFontEngine *loadHaikuFT(const QFontPrivate *d, int script, const QFontDef &req)
+{
+    // list of families to try
+    QStringList families = familyList(req);
+
+    const char *styleHint = qt_fontFamilyFromStyleHint(d->request);
+    if (styleHint)
+        families << QLatin1String(styleHint);
+
+    // add the default family
+    QString defaultFamily = QApplication::font().family();
+    if (! families.contains(defaultFamily))
+        families << defaultFamily;
+
+    // add QFont::defaultFamily() to the list, for compatibility with
+    // previous versions
+    families << QApplication::font().defaultFamily();
+
+    // null family means find the first font matching the specified script
+    families << QString();
+
+    QtFontDesc desc;
+    QFontEngine *fe = 0;
+    QList<int> blacklistedFamilies;
+
+    while (!fe) {
+        for (int i = 0; i < families.size(); ++i) {
+            QString family, foundry;
+            parseFontName(families.at(i), foundry, family);
+            QT_PREPEND_NAMESPACE(match)(script, req, family, foundry, -1, &desc, blacklistedFamilies);
+            if (desc.family)
+                break;
+        }
+        if (!desc.family)
+            break;
+        fe = loadEngine(req, desc);
+        if (!fe)
+            blacklistedFamilies.append(desc.familyIndex);
+    }
+    return fe;
+}
+
+void QFontDatabase::load(const QFontPrivate *d, int script)
+{
+    Q_ASSERT(script >= 0 && script < QUnicodeTables::ScriptCount);
+
+    // normalize the request to get better caching
+    QFontDef req = d->request;
+
+    if (req.pixelSize <= 0)
+        req.pixelSize = qMax(1, qRound(req.pointSize * d->dpi / qt_haiku_defaultDpi_x()));
+    req.pointSize = 0;
+    if (req.weight == 0)
+        req.weight = QFont::Normal;
+    if (req.stretch == 0)
+        req.stretch = 100;
+
+    QFontCache::Key key(req, d->rawMode ? QUnicodeTables::Common : script, d->screen);
+    if (!d->engineData)
+        getEngineData(d, key);
+
+    // the cached engineData could have already loaded the engine we want
+    if (d->engineData->engines[script])
+        return;
+
+    // set it to the actual pointsize, so QFontInfo will do the right thing
+    req.pointSize = req.pixelSize * qt_haiku_defaultDpi_x() / d->dpi;
+
+    QFontEngine *fe = QFontCache::instance()->findEngine(key);
+
+ //   qDebug()<<"QFontDatabase::load(2) pixelsize:"<<req.pixelSize <<" pointSize:"<< req.pointSize<< " weight:"<< req.weight<< " family:"<< req.family ;
+
+    if (!fe) {
+        if (qt_enable_test_font && req.family == QLatin1String("__Qt__Box__Engine__")) {
+            fe = new QTestFontEngine(req.pixelSize);
+            fe->fontDef = req;
+        } else {
+            QMutexLocker locker(fontDatabaseMutex());
+            if (!privateDb()->count)
+                initializeDb();
+            fe = loadHaikuFT(d, script, req);
+        }
+        if (!fe) {
+            fe = new QFontEngineBox(req.pixelSize);
+            fe->fontDef = QFontDef();
+        }
+    }
+    if (fe->symbol || (d->request.styleStrategy & QFont::NoFontMerging)) {
+        for (int i = 0; i < QUnicodeTables::ScriptCount; ++i) {
+            if (!d->engineData->engines[i]) {
+                d->engineData->engines[i] = fe;
+                fe->ref.ref();
+            }
+        }
+    } else {
+        d->engineData->engines[script] = fe;
+        fe->ref.ref();
+    }
+    QFontCache::instance()->insertEngine(key, fe);
+}
+
+
+bool QFontDatabase::removeApplicationFont(int handle)
+{
+    return false;
+}
+
+bool QFontDatabase::removeAllApplicationFonts()
+{
+    return false;
+}
+
+bool QFontDatabase::supportsThreadedFontRendering()
+{
+    return true;
+}
diff -rupN qt-everywhere-opensource-src-4.7.3/src/gui/text/qfontengine.cpp qt-everywhere-opensource-src-4.7.3_haiku/src/gui/text/qfontengine.cpp
--- qt-everywhere-opensource-src-4.7.3/src/gui/text/qfontengine.cpp	2011-03-30 05:19:05.028311552 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/gui/text/qfontengine.cpp	2011-06-13 22:06:43.396623872 +0000
@@ -737,7 +737,7 @@ QFontEngineGlyphCache *QFontEngine::glyp
     return 0;
 }
 
-#if defined(Q_WS_WIN) || defined(Q_WS_X11) || defined(Q_WS_QWS) || defined(Q_OS_SYMBIAN)
+#if defined(Q_WS_WIN) || defined(Q_WS_X11) || defined(Q_WS_QWS) || defined(Q_OS_SYMBIAN) || defined(Q_WS_HAIKU)
 static inline QFixed kerning(int left, int right, const QFontEngine::KernPair *pairs, int numPairs)
 {
     uint left_right = (left << 16) + right;
diff -rupN qt-everywhere-opensource-src-4.7.3/src/gui/text/qfontengine_haiku.cpp qt-everywhere-opensource-src-4.7.3_haiku/src/gui/text/qfontengine_haiku.cpp
--- qt-everywhere-opensource-src-4.7.3/src/gui/text/qfontengine_haiku.cpp	1970-01-01 00:00:00.000000000 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/gui/text/qfontengine_haiku.cpp	2011-06-13 22:06:43.397934592 +0000
@@ -0,0 +1,93 @@
+/****************************************************************************
+**
+** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: Qt Software Information (qt-info@nokia.com)
+**
+** Copyright (C) 2009 netlabs.org. OS/2 parts.
+**
+** This file is part of the QtGui module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial Usage
+** Licensees holding valid Qt Commercial licenses may use this file in
+** accordance with the Qt Commercial License Agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Nokia.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain
+** additional rights. These rights are described in the Nokia Qt LGPL
+** Exception version 1.0, included in the file LGPL_EXCEPTION.txt in this
+** package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+** If you are unsure which license is appropriate for your use, please
+** contact the sales department at qt-sales@nokia.com.
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qfontengine_p.h"
+#include "qtextengine_p.h"
+
+#include "qfontengine_haiku_p.h"
+
+QT_BEGIN_NAMESPACE
+
+#ifndef QT_NO_FREETYPE
+
+// ------------------------------------------------------------------
+// PM FT engine
+// ------------------------------------------------------------------
+
+QFontEngineHaiku::QFontEngineHaiku(const QFontDef &fd, const FaceId &faceId,
+                                 bool antialias, HintStyle hintStyle,
+                                 bool autoHint, SubpixelAntialiasingType subPixel,
+                                 int lcdFilter, bool useEmbeddedBitmap)
+    : QFontEngineFT(fd)
+{
+    subpixelType = subPixel;
+
+    default_hint_style = (QFontEngineFT::HintStyle)hintStyle;
+
+#if defined(FT_LOAD_FORCE_AUTOHINT)
+    if (autoHint)
+        default_load_flags |= FT_LOAD_FORCE_AUTOHINT;
+#endif
+
+    lcdFilterType = lcdFilter;
+    embeddedbitmap = useEmbeddedBitmap;
+
+    GlyphFormat defaultFormat = Format_None;
+    if (subpixelType != QFontEngineFT::Subpixel_None)
+        defaultFormat = Format_A32;
+    else if (antialias)
+        defaultFormat = Format_A8;
+    else
+        defaultFormat = Format_Mono;
+
+    init(faceId, antialias, defaultFormat);
+}
+
+QFontEngineHaiku::~QFontEngineHaiku()
+{
+    freeGlyphSets();
+}
+
+#endif // QT_NO_FREETYPE
+
+QT_END_NAMESPACE
diff -rupN qt-everywhere-opensource-src-4.7.3/src/gui/text/qfontengine_haiku_p.h qt-everywhere-opensource-src-4.7.3_haiku/src/gui/text/qfontengine_haiku_p.h
--- qt-everywhere-opensource-src-4.7.3/src/gui/text/qfontengine_haiku_p.h	1970-01-01 00:00:00.000000000 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/gui/text/qfontengine_haiku_p.h	2011-06-13 22:06:43.398983168 +0000
@@ -0,0 +1,90 @@
+/****************************************************************************
+**
+** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: Qt Software Information (qt-info@nokia.com)
+**
+** Copyright (C) 2009 netlabs.org. OS/2 parts.
+**
+** This file is part of the QtGui module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial Usage
+** Licensees holding valid Qt Commercial licenses may use this file in
+** accordance with the Qt Commercial License Agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Nokia.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain
+** additional rights. These rights are described in the Nokia Qt LGPL
+** Exception version 1.0, included in the file LGPL_EXCEPTION.txt in this
+** package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+** If you are unsure which license is appropriate for your use, please
+** contact the sales department at qt-sales@nokia.com.
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QFONTENGINE_HAIKU_P_H
+#define QFONTENGINE_HAIKU_P_H
+
+//
+//  W A R N I N G
+//  -------------
+//
+// This file is not part of the Qt API.  It exists purely as an
+// implementation detail.  This header file may change from version to
+// version without notice, or even be removed.
+//
+// We mean it.
+//
+
+#include <private/qfontengine_ft_p.h>
+
+#ifdef QT_NO_FREETYPE
+# error "The OS/2 version of Qt requires FreeType support, but QT_NO_FREETYPE " \
+        "is defined!"
+#endif
+
+QT_BEGIN_NAMESPACE
+
+#ifndef QT_NO_FREETYPE
+
+class Q_GUI_EXPORT QFontEngineHaiku : public QFontEngineFT
+{
+public:
+    enum HintStyle {
+        HintNone = QFontEngineFT::HintNone,
+        HintLight = QFontEngineFT::HintLight,
+        HintMedium = QFontEngineFT::HintMedium,
+        HintFull = QFontEngineFT::HintFull
+    };
+
+    explicit QFontEngineHaiku(const QFontDef &fd, const FaceId &faceId,
+                             bool antialias, HintStyle hintStyle,
+                             bool autoHint, SubpixelAntialiasingType subPixel,
+                             int lcdFilter, bool useEmbeddedBitmap);
+    ~QFontEngineHaiku();
+};
+
+#endif
+
+QT_END_NAMESPACE
+
+#endif // QFONTENGINE_HAIKU_P_H
diff -rupN qt-everywhere-opensource-src-4.7.3/src/gui/text/qfontengine_p.h qt-everywhere-opensource-src-4.7.3_haiku/src/gui/text/qfontengine_p.h
--- qt-everywhere-opensource-src-4.7.3/src/gui/text/qfontengine_p.h	2011-03-30 05:19:05.031457280 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/gui/text/qfontengine_p.h	2011-06-13 22:06:43.400556032 +0000
@@ -168,7 +168,7 @@ public:
     virtual void recalcAdvances(QGlyphLayout *, QTextEngine::ShaperFlags) const {}
     virtual void doKerning(QGlyphLayout *, QTextEngine::ShaperFlags) const;
 
-#if !defined(Q_WS_X11) && !defined(Q_WS_WIN) && !defined(Q_WS_MAC) && !defined(Q_OS_SYMBIAN)
+#if !defined(Q_WS_X11) && !defined(Q_WS_WIN) && !defined(Q_WS_MAC) && !defined(Q_OS_SYMBIAN) && !defined(Q_WS_HAIKU)
     virtual void draw(QPaintEngine *p, qreal x, qreal y, const QTextItemInt &si) = 0;
 #endif
     virtual void addGlyphsToPath(glyph_t *glyphs, QFixedPoint *positions, int nglyphs,
@@ -237,7 +237,7 @@ public:
     bool symbol;
     mutable HB_FontRec hbFont;
     mutable HB_Face hbFace;
-#if defined(Q_WS_WIN) || defined(Q_WS_X11) || defined(Q_WS_QWS) || defined(Q_OS_SYMBIAN)
+#if defined(Q_WS_WIN) || defined(Q_WS_X11) || defined(Q_WS_QWS) || defined(Q_OS_SYMBIAN) || defined(Q_WS_HAIKU)
     struct KernPair {
         uint left_right;
         QFixed adjust;
diff -rupN qt-everywhere-opensource-src-4.7.3/src/gui/text/text.pri qt-everywhere-opensource-src-4.7.3_haiku/src/gui/text/text.pri
--- qt-everywhere-opensource-src-4.7.3/src/gui/text/text.pri	2011-03-30 05:19:05.029622272 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/gui/text/text.pri	2011-06-13 22:06:43.401866752 +0000
@@ -203,5 +203,15 @@ contains(QT_CONFIG, fontconfig) {
     CONFIG += opentype
 }
 
+haiku*: {
+	HEADERS += \
+		text/qfontengine_ft_p.h \
+		text/qfontengine_haiku_p.h		
+	SOURCES += \
+		text/qfont_haiku.cpp \
+		text/qfontengine_ft.cpp \
+		text/qfontengine_haiku.cpp
+}
+
 DEFINES += QT_NO_OPENTYPE
 INCLUDEPATH += ../3rdparty/harfbuzz/src
diff -rupN qt-everywhere-opensource-src-4.7.3/src/gui/util/qdesktopservices.cpp qt-everywhere-opensource-src-4.7.3_haiku/src/gui/util/qdesktopservices.cpp
--- qt-everywhere-opensource-src-4.7.3/src/gui/util/qdesktopservices.cpp	2011-03-30 05:19:06.001310720 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/gui/util/qdesktopservices.cpp	2011-06-13 22:06:43.403439616 +0000
@@ -55,6 +55,8 @@
 #include "qdesktopservices_mac.cpp"
 #elif defined(Q_OS_SYMBIAN)
 #include "qdesktopservices_s60.cpp"
+#elif defined(Q_WS_HAIKU)
+#include "qdesktopservices_haiku.cpp"
 #endif
 
 #include <qhash.h>
diff -rupN qt-everywhere-opensource-src-4.7.3/src/gui/util/qdesktopservices_haiku.cpp qt-everywhere-opensource-src-4.7.3_haiku/src/gui/util/qdesktopservices_haiku.cpp
--- qt-everywhere-opensource-src-4.7.3/src/gui/util/qdesktopservices_haiku.cpp	1970-01-01 00:00:00.000000000 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/gui/util/qdesktopservices_haiku.cpp	2011-06-13 22:06:43.404750336 +0000
@@ -0,0 +1,81 @@
+#include "qdesktopservices.h"
+#include "qdir.h"
+#include "qurl.h"
+
+#ifndef QT_NO_DESKTOPSERVICES
+
+#include <stdio.h>
+
+QT_BEGIN_NAMESPACE
+
+static bool openDocument(const QUrl &file)
+{
+	QString cmd = QLatin1String("open ") + file.toString();
+	system((cmd.toUtf8()).data());
+	return true;
+}
+
+static bool launchWebBrowser(const QUrl &url)
+{
+	QString cmd = QLatin1String("open ") + url.toString();
+	system((cmd.toUtf8()).data());
+	return true;
+}
+
+QString QDesktopServices::storageLocation(StandardLocation type)
+{
+    if (type == QDesktopServices::HomeLocation)
+        return QLatin1String("/boot/home");
+    if (type == QDesktopServices::TempLocation)
+        return QDir::tempPath();
+
+    if (type == QDesktopServices::CacheLocation) {
+            return QDir::homePath() + QLatin1String("/cache");
+    }
+
+    if (type == QDesktopServices::DataLocation) {
+            return QDir::homePath() + QLatin1String("/data");
+    }
+
+    QDir emptyDir;
+    QString path;
+    switch (type) {
+    case DesktopLocation:
+        path = QLatin1String("/boot/home/Desktop");
+        break;
+    case DocumentsLocation:
+        path = QLatin1String("/boot/home/Documents");
+       break;
+    case PicturesLocation:
+        path = QLatin1String("/boot/home/Pictures");
+        break;
+
+    case FontsLocation:
+        path = QLatin1String("/boot/system/data/fonts/ttfonts");
+        break;
+
+    case MusicLocation:
+        path = QLatin1String("/boot/home/Music");
+        break;
+
+    case MoviesLocation:
+        path = QLatin1String("/boot/home/Videos");
+        break;
+
+    case ApplicationsLocation:
+    default:
+        break;
+    }
+    return path;
+}
+
+QString QDesktopServices::displayName(StandardLocation type)
+{
+    Q_UNUSED(type);
+    return QString();
+}
+
+
+QT_END_NAMESPACE
+
+#endif // QT_NO_DESKTOPSERVICES
diff -rupN qt-everywhere-opensource-src-4.7.3/src/gui/util/qsystemtrayicon.cpp qt-everywhere-opensource-src-4.7.3_haiku/src/gui/util/qsystemtrayicon.cpp
--- qt-everywhere-opensource-src-4.7.3/src/gui/util/qsystemtrayicon.cpp	2011-03-30 05:19:06.066584576 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/gui/util/qsystemtrayicon.cpp	2011-06-13 22:06:43.406323200 +0000
@@ -573,7 +573,19 @@ void QBalloonTip::balloon(const QPoint& 
     }
 
     QPainterPath path;
-#if defined(QT_NO_XSHAPE) && defined(Q_WS_X11)
+#if defined(Q_WS_HAIKU)
+    path.moveTo(0, 0);
+    path.lineTo(sz.width() - 1, 0);
+    path.lineTo(sz.width() - 1, sz.height() - 1);
+    path.lineTo(0, sz.height() - 1);
+    path.lineTo(0, 0);
+    int dx = pos.x(),dy = pos.y();
+    if(pos.x()+sz.width() > scr.right())
+    	dx=pos.x()-sz.width();
+    if(pos.y()+sz.height() > scr.bottom())
+    	dy=pos.y()-sz.height();
+    move(dx,dy);
+#elif defined(QT_NO_XSHAPE) && defined(Q_WS_X11)
     // XShape is required for setting the mask, so we just
     // draw an ugly square when its not available
     path.moveTo(0, 0);
@@ -581,7 +593,7 @@ void QBalloonTip::balloon(const QPoint& 
     path.lineTo(sz.width() - 1, sz.height() - 1);
     path.lineTo(0, sz.height() - 1);
     path.lineTo(0, 0);
-    move(qMax(pos.x() - sz.width(), scr.left()), pos.y());
+    move(qMax(pos.x() - sz.width(), scr.left()), pos.y());    
 #else
     path.moveTo(ml + rc, mt);
     if (arrowAtTop && arrowAtLeft) {
diff -rupN qt-everywhere-opensource-src-4.7.3/src/gui/util/qsystemtrayicon_haiku.cpp qt-everywhere-opensource-src-4.7.3_haiku/src/gui/util/qsystemtrayicon_haiku.cpp
--- qt-everywhere-opensource-src-4.7.3/src/gui/util/qsystemtrayicon_haiku.cpp	1970-01-01 00:00:00.000000000 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/gui/util/qsystemtrayicon_haiku.cpp	2011-06-13 22:06:43.408158208 +0000
@@ -0,0 +1,482 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the QtGui module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** No Commercial Usage
+** This file contains pre-release code and may not be distributed.
+** You may use this file in accordance with the terms and conditions
+** contained in the Technology Preview License Agreement accompanying
+** this package.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights.  These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** If you have questions regarding the use of this file, please contact
+** Nokia at qt-info@nokia.com.
+**
+**
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qsystemtrayicon_p.h"
+
+#ifndef QT_NO_SYSTEMTRAYICON
+
+QT_BEGIN_NAMESPACE
+
+#include "qapplication.h"
+#include "qsystemtrayicon.h"
+#include "qdebug.h"
+#include "qcolor.h"
+#include "qfileinfo.h"
+
+#include <OS.h>
+#include <Application.h>
+#include <Window.h>
+#include <Message.h>
+#include <Deskbar.h>
+#include <View.h>
+#include <String.h>
+#include <Roster.h>
+#include <Screen.h>
+#include <Resources.h>
+#include <Bitmap.h>
+#include <Looper.h>
+
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+
+#define TRAY_MOUSEDOWN 	1
+#define TRAY_MOUSEUP	2
+
+#define NF_NONE		0
+#define NF_QT		1
+#define NF_NATIVE	2
+
+#define maxTipLength 	128
+
+#define DBAR_SIGNATURE 	"application/x-vnd.Be-TSKB"
+
+static 	int32 notifyMode = NF_NONE;
+
+QSystemTrayIconLooper::QSystemTrayIconLooper() : QObject(), BLooper("traylooper")
+{	
+}
+
+thread_id 
+QSystemTrayIconLooper::Run(void)
+{
+	thread_id Thread = BLooper::Run();	
+	return Thread;
+}
+
+void 
+QSystemTrayIconLooper::MessageReceived(BMessage* theMessage)
+{
+	if( theMessage->what == 'TRAY' || 
+		theMessage->what == 'PULS' || 
+		theMessage->what == 'LIVE') {
+		BMessage *mes = new BMessage(*theMessage);
+		emit sendHaikuMessage(mes);
+	}
+	BLooper::MessageReceived(theMessage);
+} 
+
+QSystemTrayIconSys::QSystemTrayIconSys(QSystemTrayIcon *object)
+    : ReplicantId(0), q(object), ignoreNextMouseRelease(false), LiveFactor(0)
+{
+	Looper = new QSystemTrayIconLooper();
+	Looper->Run();		
+	
+	pulse = new BMessageRunner(BMessenger(NULL, Looper),new BMessage('PULS'),1000000);
+		
+	InstallIcon();
+	
+	QObject::connect(Looper,SIGNAL(sendHaikuMessage(BMessage *)),this,SLOT(HaikuEvent(BMessage *)),Qt::QueuedConnection);
+}
+
+QSystemTrayIconSys::~QSystemTrayIconSys()
+{
+	BDeskbar deskbar;
+	if(ReplicantId>0)
+		deskbar.RemoveItem(ReplicantId);
+	if(pulse)
+		delete pulse;	
+	if(Looper->Lock())
+		Looper->Quit();
+}
+
+void
+QSystemTrayIconSys::InstallIcon(void)
+{
+	ReplicantId = DeskBarLoadIcon();
+
+	QString appName = QFileInfo(QApplication::applicationFilePath()).fileName();
+	BString app_name((const char *)(appName.toUtf8()));
+
+	BMessage mes('MSGR');
+	QSystemTrayIconSys *sys=this;
+	mes.AddMessenger("messenger",BMessenger(NULL,Looper));
+	mes.AddData("qtrayobject",B_ANY_TYPE,&sys,sizeof(void*));
+	mes.AddString( "application_name",app_name);
+
+	SendMessageToReplicant(&mes);
+}
+
+void QSystemTrayIconSys::HaikuEvent(BMessage *m)
+{	
+	if(m->what == 'PULS') {
+		LiveFactor--;
+		if(LiveFactor<-5) {		//Reinstallation time
+			LiveFactor = 0;
+			ReplicantId = 0;
+			InstallIcon();
+			LiveFactor = 0;
+			UpdateIcon();
+			UpdateTooltip();
+		}		
+	}
+	if(m->what == 'LIVE') {
+		LiveFactor++;		
+		BRect rect;
+		if(m->FindRect("rect",&rect)==B_OK) {
+			shelfRect.setRect(rect.left, rect.top, rect.Width(), rect.Height());
+		}		
+	}
+	if(m->what == 'TRAY') {
+		int32 event = 0;
+		BPoint point(0,0);
+		int32 buttons = 0,
+			  clicks = 0;
+	
+		m->FindInt32("event",&event);
+		m->FindPoint("point",&point);
+		m->FindInt32("buttons",&buttons);
+		m->FindInt32("clicks",&clicks);
+		
+		switch(event) {
+			case TRAY_MOUSEUP:
+				{				                
+					if(buttons==B_PRIMARY_MOUSE_BUTTON) {
+					if (ignoreNextMouseRelease)
+	                    ignoreNextMouseRelease = false;
+	                else
+	                    emit q->activated(QSystemTrayIcon::Trigger);
+						break;
+					}
+					if(buttons==B_TERTIARY_MOUSE_BUTTON) {
+						emit q->activated(QSystemTrayIcon::MiddleClick);
+						break;
+					}
+					if(buttons==B_SECONDARY_MOUSE_BUTTON) {
+						QPoint gpos = QPoint(point.x,point.y);
+		                if (q->contextMenu()) {
+		                    q->contextMenu()->popup(gpos);
+		
+							BScreen screen(NULL);
+		                    QRect desktopRect( screen.Frame().left, screen.Frame().top,
+		                    				   screen.Frame().right, screen.Frame().bottom);
+		                    int maxY = desktopRect.y() + desktopRect.height() - q->contextMenu()->height();
+		                    if (gpos.y() > maxY) {
+		                        gpos.ry() = maxY;
+		                        q->contextMenu()->move(gpos);
+		                    }
+		                }
+		                emit q->activated(QSystemTrayIcon::Context);		
+		             	break;   			
+					}
+				}
+				break;
+			case TRAY_MOUSEDOWN:
+				{				
+					if(buttons==B_PRIMARY_MOUSE_BUTTON && clicks==2) {
+						ignoreNextMouseRelease = true;
+						emit q->activated(QSystemTrayIcon::DoubleClick);
+						break;
+					}
+				}
+				break;
+			default:
+				break;
+		}
+	}
+}
+
+void QSystemTrayIconSys::UpdateTooltip()
+{   	
+    QString tip = q->toolTip();
+
+    BString tipStr("");
+    
+    if (!tip.isNull()) {
+    	tip = tip.left(maxTipLength - 1) + QChar();        
+    	const char *str = (const char *)(tip.toUtf8());
+    	tipStr.SetTo(str);
+    }
+	
+	BMessage *mes = new BMessage('TTIP');		
+	mes->AddString("tooltip",tipStr.String());	
+	SendMessageToReplicant(mes);
+}
+
+void QSystemTrayIconSys::UpdateIcon()
+{    
+    QIcon qicon = q->icon();
+    if (qicon.isNull())
+        return;
+
+    QSize size = qicon.actualSize(QSize(16, 16));
+    QPixmap pm = qicon.pixmap(size);
+    if (pm.isNull())
+        return;
+	
+	BBitmap *icon = pm.toHaikuBitmap();
+	if(icon) {
+		BMessage	bits(B_ARCHIVED_OBJECT);
+		icon->Archive(&bits);	
+		BMessage *mes = new BMessage('BITS');
+		mes->AddMessage("icon",&bits);
+		bits.MakeEmpty();
+		SendMessageToReplicant(mes);
+		delete icon;
+	}	
+	UpdateTooltip();
+}
+
+BMessenger 
+QSystemTrayIconSys::GetShelfMessenger(void)
+{
+	BMessenger aResult;
+	status_t aErr = B_OK;
+	BMessenger aDeskbar(DBAR_SIGNATURE, -1, &aErr);
+	if (aErr != B_OK)return aResult;
+
+	BMessage aMessage(B_GET_PROPERTY);
+	
+	aMessage.AddSpecifier("Messenger");
+	aMessage.AddSpecifier("Shelf");
+	aMessage.AddSpecifier("View", "Status");
+	aMessage.AddSpecifier("Window", "Deskbar");
+	
+	BMessage aReply;
+
+	if (aDeskbar.SendMessage(&aMessage, &aReply, 500000, 500000) == B_OK)
+		aReply.FindMessenger("result", &aResult);
+	return aResult;
+}
+
+status_t 
+QSystemTrayIconSys::SendMessageToReplicant(BMessage *msg)
+{
+	if(ReplicantId<=0)
+		return B_ERROR;
+		
+	BMessage aReply;
+	status_t aErr = B_OK;
+	
+	msg->AddInt32( "what2", msg->what );
+	msg->what = B_SET_PROPERTY;
+
+	BMessage	uid_specifier(B_ID_SPECIFIER);
+	
+	msg->AddSpecifier("View");
+	uid_specifier.AddInt32("id", ReplicantId);
+	uid_specifier.AddString("property", "Replicant");
+	msg->AddSpecifier(&uid_specifier);
+		
+	aErr = GetShelfMessenger().SendMessage( msg, (BHandler*)NULL, 500000 );
+	return aErr;
+}
+
+int32	
+QSystemTrayIconSys::ExecuteCommand(char *command)
+{
+   FILE *fpipe;
+   char line[256];
+   if ( !(fpipe = (FILE*)popen(command,"r")) )
+   		return -1;
+
+   fgets( line, sizeof line, fpipe);
+   pclose(fpipe);
+   
+   int res = atoi(line);
+   return res;
+}
+
+int32 
+QSystemTrayIconSys::DeskBarLoadIcon(team_id tid)
+{
+	char cmd[256];
+	sprintf(cmd,"qsystray %d",(int)tid);	
+	int32 id = ExecuteCommand(cmd);
+	return id;
+}
+
+int32 
+QSystemTrayIconSys::DeskBarLoadIcon(void)
+{
+	thread_info threadInfo;
+	status_t error = get_thread_info(find_thread(NULL), &threadInfo);
+	if (error != B_OK) {
+		fprintf(stderr, "Failed to get info for the current thread: %s\n", strerror(error));
+		return -1;	
+	}
+	team_id sTeam = threadInfo.team;
+	
+	return DeskBarLoadIcon(sTeam);
+}
+
+void QSystemTrayIconPrivate::install_sys()
+{
+	fprintf(stderr, "Reimplemented: QSystemTrayIconPrivate::install_sys \n");
+    Q_Q(QSystemTrayIcon);
+    if (!sys) {
+        sys = new QSystemTrayIconSys(q);		
+        sys->UpdateIcon();
+    }
+    supportsMessages_sys();    
+}
+
+void QSystemTrayIconPrivate::showMessage_sys(const QString &title,  const QString &message, QSystemTrayIcon::MessageIcon type, int timeOut)
+{
+	fprintf(stderr, "Reimplemented:  QSystemTrayIconPrivate::showMessage_sys()\n");	
+		
+	if(notifyMode == NF_QT) {
+		QPoint point(sys->shelfRect.x(),sys->shelfRect.y());
+				
+		BDeskbar deskbar;
+		BRect deskRect = deskbar.Frame();
+		BScreen  screen(B_MAIN_SCREEN_ID);
+		
+		switch(deskbar.Location())
+		{
+			case B_DESKBAR_TOP:
+				point.setX(screen.Frame().Width()-8);
+				point.setY(deskRect.Height()+8);
+				break;
+			case B_DESKBAR_RIGHT_TOP:		
+				point.setX(screen.Frame().Width()-deskRect.Width()-8);
+				point.setY(8);
+				break;
+			case B_DESKBAR_BOTTOM:
+				point.setX(screen.Frame().Width()-8);
+				point.setY(screen.Frame().Height()-deskRect.Height()-8);
+				break;	
+			case B_DESKBAR_LEFT_BOTTOM:
+				point.setX(deskRect.Width()+8);
+				point.setY(screen.Frame().Height()-8);
+				break;				
+			case B_DESKBAR_RIGHT_BOTTOM:		
+				point.setX(deskRect.Width()-deskRect.Width()-8);
+				point.setY(screen.Frame().Height()-8);
+				break;				
+			case B_DESKBAR_LEFT_TOP:
+				point.setX(deskRect.Width()+8);
+				point.setY(8);
+				break;				
+		}
+	    QBalloonTip::showBalloon(type, title, message, sys->q, point, timeOut, false);
+	}
+	if(notifyMode == NF_NATIVE) {
+		QString cmd;
+		QString stitle(title);
+		stitle.replace(L'"',"''");
+		stitle.remove(L'\r');
+		stitle.remove(L'\n');
+		
+		QString smessage(message);
+		smessage.replace(L'"',"''");
+		smessage.remove(L'\r');
+		smessage.remove(L'\n');
+		
+		cmd = QString("notify --app \"%1\" --type %2 --title \"%3\" --timeout %4 \"%5\"")
+					.arg(QFileInfo(QApplication::applicationFilePath()).fileName())
+					.arg(type==QSystemTrayIcon::Warning?"important":type==QSystemTrayIcon::Critical?"error":"information")
+					.arg(stitle)
+					.arg(timeOut/1000)
+					.arg(smessage);
+					
+		const char *str = (const char *)(cmd.toUtf8());		
+		system(str);
+	}
+}
+
+QRect QSystemTrayIconPrivate::geometry_sys() const
+{
+	fprintf(stderr, "Reimplemented: QSystemTrayIconPrivate::geometry_sys \n");
+	return sys->shelfRect;
+}
+
+void QSystemTrayIconPrivate::remove_sys()
+{
+	fprintf(stderr, "Reimplemented: QSystemTrayIconPrivate::remove_sys \n");
+	if(sys) {    
+    	delete sys;
+    	sys = NULL;
+	}
+}
+
+void QSystemTrayIconPrivate::updateIcon_sys()
+{
+	fprintf(stderr, "Reimplemented:  QSystemTrayIconPrivate::updateIcon_sys\n");	
+    if (sys) {
+	    sys->UpdateIcon();
+    }
+}
+
+void QSystemTrayIconPrivate::updateMenu_sys()
+{
+	fprintf(stderr, "Unimplemented:  QSystemTrayIconPrivate::updateMenu_sys\n");
+}
+
+void QSystemTrayIconPrivate::updateToolTip_sys()
+{
+	fprintf(stderr, "Reimplemented:  QSystemTrayIconPrivate::updateToolTip_sys\n");
+	if (sys) {
+		sys->UpdateTooltip();
+	}
+}
+
+bool QSystemTrayIconPrivate::isSystemTrayAvailable_sys()
+{	
+	supportsMessages_sys();	
+	QFileInfo qsystrayfile("/boot/common/bin/qsystray");	
+	return qsystrayfile.exists();
+}
+
+bool QSystemTrayIconPrivate::supportsMessages_sys()
+{
+	QFileInfo notifyfile("/bin/notify");
+	if(notifyfile.exists()) {
+		notifyMode = NF_NATIVE;
+	} else {
+		notifyMode = NF_QT;
+	}	
+	return true;
+}
+
+QT_END_NAMESPACE
+
+#endif // QT_NO_SYSTEMTRAYICON
diff -rupN qt-everywhere-opensource-src-4.7.3/src/gui/util/qsystemtrayicon_haiku.h qt-everywhere-opensource-src-4.7.3_haiku/src/gui/util/qsystemtrayicon_haiku.h
--- qt-everywhere-opensource-src-4.7.3/src/gui/util/qsystemtrayicon_haiku.h	1970-01-01 00:00:00.000000000 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/gui/util/qsystemtrayicon_haiku.h	2011-06-13 22:06:43.408944640 +0000
@@ -0,0 +1,116 @@
+/****************************************************************************
+**
+** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the QtGui module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** No Commercial Usage
+** This file contains pre-release code and may not be distributed.
+** You may use this file in accordance with the terms and conditions
+** contained in the Technology Preview License Agreement accompanying
+** this package.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights.  These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** If you have questions regarding the use of this file, please contact
+** Nokia at qt-info@nokia.com.
+**
+**
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QSYSTRAYICONHAIKU_H
+#define QSYSTRAYICONHAIKU_H
+
+#include <QtCore/qcoreapplication.h>
+#include <QtCore/qobject.h>
+#include <qwidget.h>
+#include "qsystemtrayicon.h"
+
+#include <Application.h>
+#include <Bitmap.h>
+#include <Message.h>
+#include <Looper.h>
+#include <OS.h>
+#include <MessageRunner.h>
+
+QT_BEGIN_HEADER
+
+QT_BEGIN_NAMESPACE
+
+QT_MODULE(Gui)
+
+
+class QSystemTrayIconLooper :public QObject, public BLooper
+{
+	Q_OBJECT
+public:
+	QSystemTrayIconLooper();
+	virtual void MessageReceived(BMessage* theMessage);
+	thread_id Run(void);
+Q_SIGNALS:
+	void sendHaikuMessage(BMessage *);
+};
+
+class QSystemTrayIconSys : public QWidget
+{
+	Q_OBJECT
+public:
+    QSystemTrayIconSys(QSystemTrayIcon *object);
+    ~QSystemTrayIconSys();
+    
+    void UpdateIcon();
+    void UpdateTooltip();
+	status_t SendMessageToReplicant(BMessage *msg);	
+     
+    QSystemTrayIcon *q;
+	QSystemTrayIconLooper* Looper;
+
+	QRect	shelfRect;
+
+public slots:
+    void HaikuEvent(BMessage *m);
+
+private:	
+	BMessenger GetShelfMessenger(void);	
+	int32	ExecuteCommand(char *command);
+	int32 	DeskBarLoadIcon(team_id tid);
+	int32 	DeskBarLoadIcon(void);	
+	void 	InstallIcon(void);
+
+	int32	ReplicantId;
+	int32	LiveFactor;
+		
+	bool 	ignoreNextMouseRelease;
+	
+	BMessageRunner *pulse;
+	
+    friend class QSystemTrayIconPrivate;
+};    
+
+
+QT_END_NAMESPACE
+
+QT_END_HEADER
+
+#endif //QSYSTRAYICONHAIKU_H 
diff -rupN qt-everywhere-opensource-src-4.7.3/src/gui/util/qsystemtrayicon_p.h qt-everywhere-opensource-src-4.7.3_haiku/src/gui/util/qsystemtrayicon_p.h
--- qt-everywhere-opensource-src-4.7.3/src/gui/util/qsystemtrayicon_p.h	2011-03-30 05:19:06.000262144 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/gui/util/qsystemtrayicon_p.h	2011-06-13 22:06:43.409993216 +0000
@@ -178,6 +178,12 @@ private:
 };
 #endif // Q_WS_X11
 
+#if defined(Q_WS_HAIKU)
+QT_BEGIN_INCLUDE_NAMESPACE
+#include "qsystemtrayicon_haiku.h"
+QT_END_INCLUDE_NAMESPACE
+#endif // Q_WS_HAIKU
+
 QT_END_NAMESPACE
 
 #endif // QT_NO_SYSTEMTRAYICON
diff -rupN qt-everywhere-opensource-src-4.7.3/src/gui/util/util.pri qt-everywhere-opensource-src-4.7.3_haiku/src/gui/util/util.pri
--- qt-everywhere-opensource-src-4.7.3/src/gui/util/util.pri	2011-03-30 05:19:06.002097152 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/gui/util/util.pri	2011-06-13 22:06:43.411303936 +0000
@@ -56,4 +56,11 @@ symbian {
     } else {
         DEFINES += USE_SCHEMEHANDLER
     }
-}
\ No newline at end of file
+}
+
+haiku {
+		HEADERS += \
+				util/qsystemtrayicon_haiku.h
+		SOURCES += \
+				util/qsystemtrayicon_haiku.cpp
+}
diff -rupN qt-everywhere-opensource-src-4.7.3/src/network/kernel/qnetworkinterface_unix.cpp qt-everywhere-opensource-src-4.7.3_haiku/src/network/kernel/qnetworkinterface_unix.cpp
--- qt-everywhere-opensource-src-4.7.3/src/network/kernel/qnetworkinterface_unix.cpp	2011-03-30 05:19:09.012582912 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/network/kernel/qnetworkinterface_unix.cpp	2011-06-13 22:06:43.413138944 +0000
@@ -52,6 +52,10 @@
 #include <sys/types.h>
 #include <sys/socket.h>
 
+#ifdef Q_OS_HAIKU
+# include <sys/sockio.h>
+#endif
+
 #ifdef Q_OS_SOLARIS
 # include <sys/sockio.h>
 #endif
@@ -92,7 +96,9 @@ static QNetworkInterface::InterfaceFlags
 {
     QNetworkInterface::InterfaceFlags flags = 0;
     flags |= (rawFlags & IFF_UP) ? QNetworkInterface::IsUp : QNetworkInterface::InterfaceFlag(0);
+#ifndef Q_OS_HAIKU
     flags |= (rawFlags & IFF_RUNNING) ? QNetworkInterface::IsRunning : QNetworkInterface::InterfaceFlag(0);
+#endif
     flags |= (rawFlags & IFF_BROADCAST) ? QNetworkInterface::CanBroadcast : QNetworkInterface::InterfaceFlag(0);
     flags |= (rawFlags & IFF_LOOPBACK) ? QNetworkInterface::IsLoopBack : QNetworkInterface::InterfaceFlag(0);
 #ifdef IFF_POINTOPOINT //cygwin doesn't define IFF_POINTOPOINT
diff -rupN qt-everywhere-opensource-src-4.7.3/src/network/socket/qnativesocketengine_unix.cpp qt-everywhere-opensource-src-4.7.3_haiku/src/network/socket/qnativesocketengine_unix.cpp
--- qt-everywhere-opensource-src-4.7.3/src/network/socket/qnativesocketengine_unix.cpp	2011-03-30 05:19:09.024379392 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/network/socket/qnativesocketengine_unix.cpp	2011-06-13 22:06:43.414973952 +0000
@@ -705,6 +705,9 @@ qint64 QNativeSocketEnginePrivate::nativ
     memcpy(&sockAddrIPv6.sin6_addr.s6_addr, &tmp, sizeof(tmp));
     sockAddrSize = sizeof(sockAddrIPv6);
     sockAddrPtr = (struct sockaddr *)&sockAddrIPv6;
+#ifdef Q_OS_HAIKU
+	sockAddrIPv6.sin6_len = sockAddrSize;
+#endif    
     } else
 #endif
     if (host.protocol() == QAbstractSocket::IPv4Protocol) {
@@ -714,6 +717,9 @@ qint64 QNativeSocketEnginePrivate::nativ
     sockAddrIPv4.sin_addr.s_addr = htonl(host.toIPv4Address());
     sockAddrSize = sizeof(sockAddrIPv4);
     sockAddrPtr = (struct sockaddr *)&sockAddrIPv4;
+#ifdef Q_OS_HAIKU
+	sockAddrIPv4.sin_len = sockAddrSize;
+#endif    
     }
 
     // ignore the SIGPIPE signal
diff -rupN qt-everywhere-opensource-src-4.7.3/src/tools/uic/qclass_lib_map.h qt-everywhere-opensource-src-4.7.3_haiku/src/tools/uic/qclass_lib_map.h
--- qt-everywhere-opensource-src-4.7.3/src/tools/uic/qclass_lib_map.h	2011-03-30 05:19:08.002883584 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/src/tools/uic/qclass_lib_map.h	2011-06-13 22:06:43.417333248 +0000
@@ -1410,3 +1410,8 @@ QT_CLASS_LIB(Q3PaintDeviceMetrics, Qt3Su
 QT_CLASS_LIB(Q3Painter, Qt3Support, q3painter.h)
 QT_CLASS_LIB(Q3Picture, Qt3Support, q3picture.h)
 QT_CLASS_LIB(Q3PointArray, Qt3Support, q3pointarray.h)
+QT_CLASS_LIB(QtHaikuView, QtGui, qwidget_haiku.h)
+QT_CLASS_LIB(QtHaikuWindow, QtGui, qwidget_haiku.h)
+QT_CLASS_LIB(QHaikuStyle, QtGui, qhaikustyle.h)
+QT_CLASS_LIB(QSystemTrayIconLooper, QtGui, qsystemtrayicon_haiku.h)
+QT_CLASS_LIB(QSystemTrayIconSys, QtGui, qsystemtrayicon_haiku.h)
diff -rupN qt-everywhere-opensource-src-4.7.3/tools/designer/src/designer/designer.pro qt-everywhere-opensource-src-4.7.3_haiku/tools/designer/src/designer/designer.pro
--- qt-everywhere-opensource-src-4.7.3/tools/designer/src/designer/designer.pro	2011-03-30 05:16:34.058720256 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/tools/designer/src/designer/designer.pro	2011-06-13 22:06:43.419168256 +0000
@@ -87,4 +87,4 @@ INSTALLS += target
 
 include(../sharedcomponents.pri)
 
-unix:!mac:LIBS += -lm
+unix:!mac:!haiku:LIBS += -lm
diff -rupN qt-everywhere-opensource-src-4.7.3/tools/qtconfig/mainwindow.cpp qt-everywhere-opensource-src-4.7.3_haiku/tools/qtconfig/mainwindow.cpp
--- qt-everywhere-opensource-src-4.7.3/tools/qtconfig/mainwindow.cpp	2011-03-30 05:16:29.027787264 +0000
+++ qt-everywhere-opensource-src-4.7.3_haiku/tools/qtconfig/mainwindow.cpp	2011-06-13 22:06:43.421265408 +0000
@@ -73,7 +73,9 @@
 #include <phonon/phononnamespace.h>
 #endif
 
+#ifndef Q_OS_HAIKU
 #include <QtGui/private/qt_x11_p.h>
+#endif
 
 QT_BEGIN_NAMESPACE
 
@@ -234,9 +236,11 @@ MainWindow::MainWindow()
     connect(buttonMainColor2, SIGNAL(colorChanged(QColor)),
                 this, SLOT(buildPalette()));
 
+#ifndef Q_OS_HAIKU
     if (X11->desktopEnvironment == DE_KDE)
         colorConfig->hide();
     else
+#endif    
         labelKDENote->hide();
 
     QFontDatabase db;
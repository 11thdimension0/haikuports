Index: gfx/src/beos/nsFontMetricsBeOS.cpp
===================================================================
--- gfx/src/beos/nsFontMetricsBeOS.cpp	(revision 7)
+++ gfx/src/beos/nsFontMetricsBeOS.cpp	(working copy)
@@ -128,12 +128,12 @@
     if (!isgeneric) 
     {
       // non-generic font
-      if (count_font_styles((font_family)family.get()) <= 0) 
+      if (count_font_styles((char *) family.get()) <= 0) 
       {
         // the specified font does not exist on this computer.
         continue;
       }
-      mFontHandle.SetFamilyAndStyle( (font_family)family.get(), NULL );
+      mFontHandle.SetFamilyAndStyle( (char *)family.get(), NULL );
       fontfound = PR_TRUE;
       break;
     } 
@@ -158,9 +158,9 @@
         prefs->GetBranch("font.name.", getter_AddRefs(branch));
         branch->GetCharPref(prop, getter_Copies(real_family));
 
-        if (!real_family.IsEmpty() && real_family.Length() <= B_FONT_FAMILY_LENGTH  && count_font_styles((font_family)real_family.get()) > 0) 
+        if (!real_family.IsEmpty() && real_family.Length() <= B_FONT_FAMILY_LENGTH  && count_font_styles((char *)real_family.get()) > 0) 
         {
-          mFontHandle.SetFamilyAndStyle( (font_family)real_family.get(), NULL );
+          mFontHandle.SetFamilyAndStyle( (char *)real_family.get(), NULL );
           fontfound = PR_TRUE;
           break;        
         }
@@ -414,8 +414,8 @@
 nsFontMetricsBeOS::FamilyExists(const nsString& aName) 
 { 
   NS_ConvertUTF16toUTF8 family(aName);
-  printf("exists? %s", (font_family)family.get()); 
-  return  (count_font_styles((font_family)family.get()) > 0) ? NS_OK : NS_ERROR_FAILURE;
+  printf("exists? %s", (char *)family.get()); 
+  return  (count_font_styles((char *)family.get()) > 0) ? NS_OK : NS_ERROR_FAILURE;
 } 
 
 // useful UTF-8 utility
Index: gfx/src/beos/nsRenderingContextBeOS.cpp
===================================================================
--- gfx/src/beos/nsRenderingContextBeOS.cpp	(revision 7)
+++ gfx/src/beos/nsRenderingContextBeOS.cpp	(working copy)
@@ -351,8 +351,11 @@
 		if (mCurrentBFont == nsnull)
 		{ 
 			if (mFontMetrics)
-				mFontMetrics->GetFontHandle((nsFontHandle)mCurrentBFont);
-
+			{
+				nsFontHandle fontHandle;
+				mFontMetrics->GetFontHandle(fontHandle);
+				mCurrentBFont = (BFont *) fontHandle;
+			}
 			if (mCurrentBFont)
 				mView->SetFont(mCurrentBFont);
 			else
@@ -1127,7 +1130,7 @@
 NS_IMETHODIMP nsRenderingContextBeOS::GetTextDimensions(const PRUnichar* aString,
 	PRInt32 aLength, PRInt32 aAvailWidth, PRInt32* aBreaks, PRInt32 aNumBreaks,
 	nsTextDimensions& aDimensions, PRInt32& aNumCharsFit, nsTextDimensions& aLastWordDimensions,
-	PRInt32* aFontID = nsnull)
+	PRInt32* aFontID)
 {
 	nsresult ret_code = NS_ERROR_FAILURE;	
 	uint8 utf8buf[1024];
@@ -1160,7 +1163,7 @@
 
 NS_IMETHODIMP nsRenderingContextBeOS::GetTextDimensions(const char* aString, PRInt32 aLength,
 	PRInt32 aAvailWidth,PRInt32* aBreaks, PRInt32 aNumBreaks, nsTextDimensions& aDimensions,
-	PRInt32& aNumCharsFit, nsTextDimensions& aLastWordDimensions, PRInt32* aFontID = nsnull)
+	PRInt32& aNumCharsFit, nsTextDimensions& aLastWordDimensions, PRInt32* aFontID)
 {
 	// Code is borrowed from win32 implementation including comments.
 	// Minor changes are introduced due multibyte/utf-8 nature of char* strings handling in BeOS.
Index: toolkit/xre/nsAppRunner.cpp
===================================================================
--- toolkit/xre/nsAppRunner.cpp	(revision 7)
+++ toolkit/xre/nsAppRunner.cpp	(working copy)
@@ -1361,9 +1361,10 @@
 #elif defined(XP_BEOS)
   int32 cookie = 0;
   image_info info;
-
+  do {
   if(get_next_image_info(0, &cookie, &info) != B_OK)
     return NS_ERROR_FAILURE;
+  } while(info.type != B_APP_IMAGE);
 
   rv = NS_NewNativeLocalFile(nsDependentCString(info.name), PR_TRUE,
                              getter_AddRefs(lf));
Index: toolkit/xre/nsXREDirProvider.cpp
===================================================================
--- toolkit/xre/nsXREDirProvider.cpp	(revision 7)
+++ toolkit/xre/nsXREDirProvider.cpp	(working copy)
@@ -76,7 +76,7 @@
 #include "nsILocalFileMac.h"
 #endif
 #ifdef XP_BEOS
-#include <be/kernel/image.h>
+#include <kernel/image.h>
 #include <FindDirectory.h>
 #endif
 #ifdef XP_UNIX
Index: widget/src/beos/nsAppShell.cpp
===================================================================
--- widget/src/beos/nsAppShell.cpp	(revision 7)
+++ widget/src/beos/nsAppShell.cpp	(working copy)
@@ -118,10 +118,28 @@
   // NOTE: this needs to be run from within the main application thread
   char		portname[64];
   char		semname[64];
+  int32 cookie = 0;
+  image_info iinfo;
+  char *leaf = NULL;
+  do {
+    if (get_next_image_info(0, &cookie, &iinfo) == B_OK &&
+        strlen(iinfo.name) > 0 &&
+        (leaf = strrchr(iinfo.name, '/')) != NULL)
+    {
+      leaf++;
+      PR_snprintf(portname, sizeof(portname), "event%lx",
+                  (long unsigned) find_thread(leaf));
+      PR_snprintf(semname, sizeof(semname), "sync%lx", 
+                  (long unsigned) find_thread(leaf));
+    }
+    else
+    {
   PR_snprintf(portname, sizeof(portname), "event%lx", 
-              (long unsigned) PR_GetCurrentThread());
+                  (long unsigned) find_thread(0));
   PR_snprintf(semname, sizeof(semname), "sync%lx", 
-              (long unsigned) PR_GetCurrentThread());
+                  (long unsigned) find_thread(0));
+    }
+  } while(iinfo.type != B_APP_IMAGE);
               
 #ifdef DEBUG              
   printf("nsAppShell::Create portname: %s, semname: %s\n", portname, semname);
@@ -342,8 +360,22 @@
 {
   // should we check for eventport initialization ?
   char  portname[64];
+  int32 cookie = 0;
+  image_info iinfo;
+  char *leaf = NULL;
+  do {
+    if (get_next_image_info(0, &cookie, &iinfo) == B_OK &&
+        strlen(iinfo.name) > 0 &&
+        (leaf = strrchr(iinfo.name, '/')) != NULL)
+    {
+      leaf++;
+      PR_snprintf(portname, sizeof(portname), "event%lx",
+                  (long unsigned) find_thread(leaf));
+    }
+    else
   PR_snprintf(portname, sizeof(portname), "event%lx", 
-              (long unsigned) PR_GetCurrentThread());
+                  (long unsigned) find_thread(0)/*PR_GetCurrentThread()*/);
+  } while(iinfo.type != B_APP_IMAGE);
 
   if((eventport = find_port(portname)) < 0) 
   {
Index: widget/src/beos/nsDragService.cpp
===================================================================
--- widget/src/beos/nsDragService.cpp	(revision 7)
+++ widget/src/beos/nsDragService.cpp	(working copy)
@@ -255,7 +255,7 @@
     bool noBitmap = true;
 
 //This is the code for image-dragging, currently disabled. See comments in beginning of file.
-# ifdef 0
+#if 0
     do
     {
         PRUint32 dataSize;
Index: widget/src/beos/nsToolkit.cpp
===================================================================
--- widget/src/beos/nsToolkit.cpp	(revision 7)
+++ widget/src/beos/nsToolkit.cpp	(working copy)
@@ -42,6 +42,7 @@
 #include "nsSwitchToUIThread.h"
 #include "plevent.h"
 #include "prprf.h"
+#include <image.h>
 
 // 
 // Static thread local storage index of the Toolkit 
@@ -89,10 +90,26 @@
   delete info;
 
   // system wide unique names
+  int32 cookie = 0;
+  image_info iinfo;
+  char *leaf = NULL;
+  do {
+    if (get_next_image_info(0, &cookie, &iinfo) == B_OK &&
+        strlen(iinfo.name) > 0 &&
+        (leaf = strrchr(iinfo.name, '/')) != NULL)
+    {
+      leaf++;
+      PR_snprintf(portname, sizeof(portname), "event%lx",
+                  (long unsigned) find_thread(leaf));
+    }
+    else
+    {
   PR_snprintf(portname, sizeof(portname), "event%lx", 
-              (long unsigned) PR_GetCurrentThread());
+                  (long unsigned) find_thread(0));
+    }
+  } while(iinfo.type != B_APP_IMAGE);
 
-  port_id event = create_port(100, portname);
+  port_id event = create_port(200, portname);
 
   while(read_port(event, &code, &id, sizeof(id)) >= 0)
   {
@@ -130,6 +147,7 @@
 {
   localthread = false;
   mGuiThread  = NULL;
+  mGUIThreadID = 0;
 }
 
 
@@ -188,6 +206,22 @@
     }
   }
     
+  image_info iinfo;
+  int32 cookie = 0;
+  char *leaf = NULL;
+  do {
+    if (get_next_image_info(0, &cookie, &iinfo) == B_OK &&
+        strlen(iinfo.name) > 0 &&
+        (leaf = strrchr(iinfo.name, '/')) != NULL)
+    {
+      leaf++;
+      mGUIThreadID = find_thread(leaf);
+    }
+    else
+    {
+      mGUIThreadID = find_thread(0);
+    }    
+  } while(iinfo.type != B_APP_IMAGE);
   // at this point the thread is running
   PR_ExitMonitor(monitor);
   PR_DestroyMonitor(monitor);
@@ -218,7 +252,22 @@
   }
 
   cached = false;
-
+  image_info iinfo;
+  int32 cookie = 0;
+  char *leaf = NULL;
+  do {
+    if (get_next_image_info(0, &cookie, &iinfo) == B_OK &&
+        strlen(iinfo.name) > 0 &&
+        (leaf = strrchr(iinfo.name, '/')) != NULL)
+    {
+      leaf++;
+      mGUIThreadID = find_thread(leaf);
+    }
+    else
+    {
+      mGUIThreadID = find_thread(0);
+    } 
+  } while(iinfo.type != B_APP_IMAGE);
   return NS_OK;
 }
 
@@ -227,9 +276,8 @@
   if(! cached)
   {
     char portname[64];
-
     PR_snprintf(portname, sizeof(portname), "event%lx", 
-                (long unsigned) mGuiThread);
+                (long unsigned) mGUIThreadID);
 
     eventport = find_port(portname);
 
Index: widget/src/beos/nsToolkit.h
===================================================================
--- widget/src/beos/nsToolkit.h	(revision 7)
+++ widget/src/beos/nsToolkit.h	(working copy)
@@ -71,6 +71,7 @@
 protected:
     // Thread Id of the "main" Gui thread.
     PRThread    *mGuiThread;
+    thread_id   mGUIThreadID;
 	static void	RunPump(void* arg);
 	void		GetInterface();
 	bool		cached;
Index: xpcom/reflect/xptcall/src/md/unix/xptc_platforms_unixish_x86.h
===================================================================
--- xpcom/reflect/xptcall/src/md/unix/xptc_platforms_unixish_x86.h	(revision 7)
+++ xpcom/reflect/xptcall/src/md/unix/xptc_platforms_unixish_x86.h	(working copy)
@@ -138,8 +138,13 @@
 #endif
 
 #elif defined(__BEOS__) 
+#if (__GNUC__ == 2) 
 #define CFRONT_STYLE_THIS_ADJUST
+#else
+#define THUNK_BASED_THIS_ADJUST
+#endif
 
+
 #elif defined(__sun__) || defined(__sun)
 #if defined(__GXX_ABI_VERSION) && __GXX_ABI_VERSION >= 100 /* G++ V3 ABI */
 #define THUNK_BASED_THIS_ADJUST
Index: xpcom/threads/plevent.c
===================================================================
--- xpcom/threads/plevent.c	(revision 7)
+++ xpcom/threads/plevent.c	(working copy)
@@ -66,6 +66,8 @@
 
 #if defined(XP_BEOS)
 #include <kernel/OS.h>
+#include <image.h>
+#include <string.h>
 #endif
 
 #if defined(XP_MACOSX)
@@ -908,10 +910,39 @@
 
     char portname[64];
     char semname[64];
+
+struct _MDThread
+{
+    thread_id   tid;
+    sem_id          joinSem;
+    PRBool  is_joining;
+};
+    struct _MDThread md;
+    
+    
+//#include "private/primpl.h"
+    image_info iinfo;
+    int32 icookie = 0;
+    char *leaf = NULL;
+    do {
+      if (get_next_image_info(0, &icookie, &iinfo) == B_OK &&
+         strlen(iinfo.name) > 0 &&
+         (leaf = strrchr(iinfo.name, '/')) != NULL)
+      {
+        leaf++;
+        PR_snprintf(portname, sizeof(portname), "event%lx",
+                    (long unsigned) find_thread(leaf)); 
+        PR_snprintf(semname, sizeof(semname), "sync%lx", 
+                    (long unsigned) find_thread(leaf));
+      }
+      else
+      {
     PR_snprintf(portname, sizeof(portname), "event%lx", 
-                (long unsigned) self->handlerThread);
+                    (long unsigned) find_thread(0));
     PR_snprintf(semname, sizeof(semname), "sync%lx", 
-                (long unsigned) self->handlerThread);
+                    (long unsigned) find_thread(0));
+      }
+    } while(iinfo.type != B_APP_IMAGE);
 
     self->eventport = find_port(portname);
     while(get_next_sem_info(0, &cookie, &info) == B_OK)
@@ -931,7 +962,7 @@
     {
       delete_port( self->eventport );
     }
-    self->eventport = create_port(200, portname);
+    self->eventport = create_port(512, portname);
         /* We don't use the sem, but it has to be there
          */
         create_sem(0, semname);
@@ -1264,6 +1295,7 @@
     thread_id waitingThread;
 };
 
+
 static PRStatus
 _pl_NativeNotify(PLEventQueue* self)
 {
@@ -1274,6 +1306,7 @@
 
     return PR_SUCCESS;    /* Is this correct? */
 }
+  
 #endif /* XP_BEOS */
 
 #if defined(XP_MACOSX)
Index: xpfe/bootstrap/nsSigHandlers.cpp
===================================================================
--- xpfe/bootstrap/nsSigHandlers.cpp	(revision 7)
+++ xpfe/bootstrap/nsSigHandlers.cpp	(working copy)
@@ -60,7 +60,8 @@
 #endif
 
 #ifdef XP_BEOS
-#include <be/app/Application.h>
+#include <stdlib.h>
+#include <app/Application.h>
 #include <string.h>
 #include "nsCOMPtr.h"
 #include "nsIServiceManager.h"

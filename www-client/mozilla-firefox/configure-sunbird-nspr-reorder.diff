? mozilla/browser/installer/beos
Index: mozilla/configure.in
===================================================================
RCS file: /cvsroot/mozilla/configure.in,v
retrieving revision 1.1503.2.112
diff -u -8 -p -r1.1503.2.112 configure.in
--- mozilla/configure.in	19 Oct 2008 16:14:06 -0000	1.1503.2.112
+++ mozilla/configure.in	9 Feb 2009 04:00:37 -0000
@@ -1333,17 +1333,17 @@ if test "$HAVE_64BIT_OS"; then
 fi
 AC_LANG_RESTORE
 fi # COMPILE_ENVIRONMENT
 
 dnl ========================================================
 dnl System overrides of the defaults for host
 dnl ========================================================
 case "$host" in
-*-beos*)
+*-beos*|*-haiku*)
     HOST_CFLAGS="$HOST_CFLAGS -DXP_BEOS -DBeOS -DBEOS -D_POSIX_SOURCE -DNO_X11"
     HOST_NSPR_MDCPUCFG='\"md/_beos.cfg\"'
     HOST_OPTIMIZE_FLAGS="${HOST_OPTIMIZE_FLAGS=-O3}"
     ;;
 
 *cygwin*|*mingw*|*mks*|*msvc*|*wince)
     if test -n "$_WIN32_MSVC"; then
         HOST_AR=lib
@@ -1477,27 +1477,45 @@ case "$target" in
         ;;
     esac
     if test "$COMPILE_ENVIRONMENT"; then
         AC_CHECK_HEADERS(sys/inttypes.h)
     fi
     AC_DEFINE(NSCAP_DISABLE_DEBUG_PTR_TYPES)
     ;;
 
-*-beos*)
+*-beos*|*-haiku*)
     no_x=yes
-    MKSHLIB='$(CXX) $(CXXFLAGS) $(DSO_LDOPTS) -Wl,-h,$@ -o $@'
     _PLATFORM_DEFAULT_TOOLKIT="beos"
+    TARGET_NSPR_MDCPUCFG='\"md/_beos.cfg\"'
+    TARGET_MD_ARCH=beos
+
+    DSO_PIC_CFLAGS=-fPIC
     DSO_LDOPTS='-nostart'
+    MKSHLIB='$(CXX) $(CXXFLAGS) $(DSO_PIC_CFLAGS) $(DSO_LDOPTS) -Wl,-h,$@ -o $@'
+    MKCSHLIB='$(CC) $(CFLAGS) $(DSO_PIC_CFLAGS) $(DSO_LDOPTS) -Wl,-h,$@ -o $@'
     TK_LIBS='-lbe -lroot'
     LIBS="$LIBS -lbe"
+
+    _HAIKU_BUILD=0
+
     if test "$COMPILE_ENVIRONMENT"; then
-        AC_CHECK_LIB(bind,main,LIBS="$LIBS -lbind")
-        AC_CHECK_LIB(zeta,main,LIBS="$LIBS -lzeta")
+        AC_CHECK_LIB(network,main,_HAIKU_BUILD=1)
     fi
+    if test "$_HAIKU_BUILD" = 1; then
+      LIBS="$LIBS -lnetwork"
+      AC_DEFINE(XP_HAIKU)
+      AC_DEFINE(__BEOS__)
+      AC_DEFINE(BONE_VERSION)
+    else
+      AC_CHECK_LIB(bind,main,LIBS="$LIBS -lbind")
+      AC_CHECK_LIB(zeta,main,LIBS="$LIBS -lzeta")
+      AC_DEFINE(BEOS_ADDON_WORKAROUND)
+    fi
+
     _WARNINGS_CFLAGS="${_WARNINGS_CFLAGS} -Wno-multichar"
     _WARNINGS_CXXFLAGS="${_WARNINGS_CXXFLAGS} -Wno-multichar"
     _MOZ_USE_RTTI=1
     USE_DEPENDENT_LIBS=
     MOZ_USER_DIR="Mozilla"
     ;;
 
 *-bsdi*)
@@ -5235,17 +5253,17 @@ fi
 
 dnl Remove dupes
 MOZ_EXTENSIONS=`${PERL} ${srcdir}/build/unix/uniq.pl ${MOZ_EXTENSIONS}`
 
 dnl ========================================================
 dnl Image decoders
 dnl ========================================================
 case "$target_os" in
-cygwin*|mingw*|msvc*|mks*|os2*|wince*|beos*)
+cygwin*|mingw*|msvc*|mks*|os2*|wince*|beos*|haiku*)
     MOZ_IMG_DECODERS_DEFAULT="$MOZ_IMG_DECODERS_DEFAULT icon"
     ;;
 darwin*)
     if test "$MOZ_WIDGET_TOOLKIT" = "mac" -o "$MOZ_WIDGET_TOOLKIT" = "cocoa";
     then
         MOZ_IMG_DECODERS_DEFAULT="$MOZ_IMG_DECODERS_DEFAULT icon"
     fi
     ;;
@@ -5676,17 +5694,17 @@ MOZ_ARG_ENABLE_STRING(debug,
     fi
   else
     MOZ_DEBUG=
   fi ],
   MOZ_DEBUG=)
 
 MOZ_DEBUG_ENABLE_DEFS="-DDEBUG -D_DEBUG"
  case "${target_os}" in
-    beos*)
+    beos*|haiku*)
         MOZ_DEBUG_ENABLE_DEFS="$MOZ_DEBUG_ENABLE_DEFS -DDEBUG_${USER}"
         ;;
     msvc*|mks*|cygwin*|mingw*|os2*|wince*)
         MOZ_DEBUG_ENABLE_DEFS="$MOZ_DEBUG_ENABLE_DEFS -DDEBUG_`echo ${USERNAME} | sed -e 's| |_|g'`"
         ;;
     *) 
         MOZ_DEBUG_ENABLE_DEFS="$MOZ_DEBUG_ENABLE_DEFS -DDEBUG_`$WHOAMI`"
         ;;
@@ -6712,17 +6730,17 @@ mk_add_options MOZ_CO_MODULE=mozilla/oth
   MOZ_LIBART_CFLAGS='-I${DIST}/include/libart_lgpl'
   case "$target_os" in
   msvc*|mks*|cygwin*|mingw*|wince*)
       MOZ_LIBART_LIBS='$(DIST)/lib/$(LIB_PREFIX)moz_art_lgpl.$(IMPORT_LIB_SUFFIX)' 
       ;;
   os2*)
       MOZ_LIBART_LIBS='-lmoz_art -lm'
       ;;
-  beos*)
+  beos*|haiku*)
       MOZ_LIBART_LIBS='-lmoz_art_lgpl -lroot -lbe'
       ;;
   *)
       MOZ_LIBART_LIBS='-lmoz_art_lgpl -lm'
       ;;
   esac
   AC_FUNC_ALLOCA
 fi
@@ -7363,16 +7381,19 @@ fi # COMPILE_ENVIRONMENT
 dnl Set various defines and substitutions
 dnl ========================================================
 
 if test "$OS_ARCH" = "OS2" -a "$VACPP" = "yes"; then
       LIBS='so32dll.lib tcp32dll.lib'
 elif test "$OS_ARCH" = "BeOS"; then
   AC_DEFINE(XP_BEOS)
   MOZ_MOVEMAIL=1
+elif test "$OS_ARCH" = "Haiku"; then
+  AC_DEFINE(XP_BEOS)
+  MOZ_MOVEMAIL=1	
 elif test "$OS_ARCH" = "Darwin"; then
   AC_DEFINE(XP_UNIX)
   AC_DEFINE(UNIX_ASYNC_DNS)
   MOZ_MOVEMAIL=1
 elif test "$OS_ARCH" = "OpenVMS"; then
   AC_DEFINE(XP_UNIX)
 elif test "$OS_ARCH" != "WINNT" -a "$OS_ARCH" != "OS2" -a "$OS_ARCH" != "WINCE"; then
   AC_DEFINE(XP_UNIX)
Index: mozilla/browser/app/Makefile.in
===================================================================
RCS file: /cvsroot/mozilla/browser/app/Makefile.in,v
retrieving revision 1.85.2.12
diff -u -8 -p -r1.85.2.12 Makefile.in
--- mozilla/browser/app/Makefile.in	12 May 2008 18:25:50 -0000	1.85.2.12
+++ mozilla/browser/app/Makefile.in	9 Feb 2009 04:00:40 -0000
@@ -56,20 +56,24 @@ ifndef MOZ_BRANDING_DIRECTORY
 PREF_JS_EXPORTS += $(srcdir)/firefox-branding.js
 endif
 
 # hardcode en-US for the moment
 AB_CD = en-US
 
 DEFINES += -DAB_CD=$(AB_CD)
 
-ifeq ($(USE_SHORT_LIBNAME), 1)
+ ifeq ($(USE_SHORT_LIBNAME), 1)
+ PROGRAM = firefox$(BIN_SUFFIX)
+ else
+ifeq (,$(filter-out BeOS Haiku, $(OS_ARCH)))
 PROGRAM = firefox$(BIN_SUFFIX)
 else
-PROGRAM = firefox-bin$(BIN_SUFFIX)
+ PROGRAM = firefox-bin$(BIN_SUFFIX)
+ endif
 endif
 
 REQUIRES = \
 	xpcom \
 	$(NULL)
 
 CPPSRCS = nsBrowserApp.cpp
 
@@ -146,17 +150,17 @@ endif
 ifdef BUILD_STATIC_LIBS
 RCFLAGS += -DMOZ_STATIC_BUILD
 endif
 ifdef DEBUG
 RCFLAGS += -DDEBUG
 endif
 endif
 
-ifeq ($(OS_ARCH),BeOS)
+ifeq (,$(filter-out BeOS Haiku, $(OS_ARCH)))
 BEOS_PROGRAM_RESOURCE = $(srcdir)/apprunner-beos.rsrc
 ifdef BUILD_STATIC_LIBS
 OS_LIBS += -ltracker -lgame
 endif
 endif
 
 ifeq ($(OS_ARCH),OS2)
 RESFILE=splashos2.res
@@ -224,17 +228,17 @@ $(EXE_DEF_FILE):
 	@echo 	WinQueryProperty		= PMMERGE.5450 >>$(EXE_DEF_FILE)
 	@echo 	WinRemoveProperty		= PMMERGE.5451 >>$(EXE_DEF_FILE)
 	@echo 	WinSetProperty			= PMMERGE.5452 >>$(EXE_DEF_FILE)
 
 LDFLAGS += -Zlinker /NOE
 endif
 endif
 
-ifneq (,$(filter-out OS2 WINNT,$(OS_ARCH)))
+ifneq (,$(filter-out OS2 WINNT BeOS Haiku,$(OS_ARCH)))
 
 firefox:: mozilla.in Makefile.in Makefile $(DEPTH)/config/autoconf.mk
 	cat $< | sed -e "s|%MOZAPPDIR%|$(mozappdir)|" \
                 -e "s|%MOZ_USER_DIR%|.mozilla/firefox|" \
 		-e "s|%MREDIR%|$(mredir)|" > $@
 	chmod +x $@
 
 libs:: firefox
Index: mozilla/browser/components/migration/src/Makefile.in
===================================================================
RCS file: /cvsroot/mozilla/browser/components/migration/src/Makefile.in,v
retrieving revision 1.20.2.2
diff -u -8 -p -r1.20.2.2 Makefile.in
--- mozilla/browser/components/migration/src/Makefile.in	27 Jan 2006 02:19:00 -0000	1.20.2.2
+++ mozilla/browser/components/migration/src/Makefile.in	9 Feb 2009 04:00:42 -0000
@@ -73,20 +73,23 @@ endif
 
 CPPSRCS  = nsProfileMigrator.cpp \
            nsBrowserProfileMigratorUtils.cpp \
            nsNetscapeProfileMigratorBase.cpp \
            nsSeamonkeyProfileMigrator.cpp \
            nsPhoenixProfileMigrator.cpp \
            $(NULL)
 
-ifneq ($(OS_ARCH),BeOS)
+ifneq (,$(filter-out BeOS Haiku, $(OS_ARCH)))
 CPPSRCS += nsDogbertProfileMigrator.cpp
 endif
 
+
+
+
 ifneq ($(OS_ARCH),OS2)
 CPPSRCS += nsOperaProfileMigrator.cpp
 endif
 
 ifeq ($(OS_ARCH)_$(GNU_CXX),WINNT_)
 DEFINES += -DPSTOREC_DLL=\"$(subst \,\\,$(WINDIR))\\system32\\pstorec.dll\"
 
 CPPSRCS += nsIEProfileMigrator.cpp \
Index: mozilla/browser/installer/Makefile.in
===================================================================
RCS file: /cvsroot/mozilla/browser/installer/Makefile.in,v
retrieving revision 1.19.4.4
diff -u -8 -p -r1.19.4.4 Makefile.in
--- mozilla/browser/installer/Makefile.in	6 Jun 2006 15:35:00 -0000	1.19.4.4
+++ mozilla/browser/installer/Makefile.in	9 Feb 2009 04:00:44 -0000
@@ -57,19 +57,23 @@ include $(topsrcdir)/config/rules.mk
 
 MOZ_PKG_REMOVALS = $(srcdir)/removed-files.in
 
 ifdef BUILD_STATIC_LIBS
 ifeq (WINNT,$(OS_ARCH))
 MOZ_PKG_MANIFEST_P = $(srcdir)/windows/packages-static
 else
 ifneq (,$(filter-out OS2 Darwin,$(OS_ARCH)))
+ifeq (,$(filter-out BeOS Haiku, $(OS_ARCH)))
+MOZ_PKG_MANIFEST_P = $(srcdir)/beos/packages-static
+else
 MOZ_PKG_MANIFEST_P = $(srcdir)/unix/packages-static
 endif
 endif
+endif
 else
 $(error you need a "--enable-static --disable-shared" build to create an installer)
 endif
 
 MOZ_NONLOCALIZED_PKG_LIST = \
 	xpcom \
 	browser \
 	$(NULL)
Index: mozilla/build/autoconf/config.guess
===================================================================
RCS file: /cvsroot/mozilla/build/autoconf/config.guess,v
retrieving revision 1.19
diff -u -8 -p -r1.19 config.guess
--- mozilla/build/autoconf/config.guess	18 Apr 2003 10:20:15 -0000	1.19
+++ mozilla/build/autoconf/config.guess	9 Feb 2009 04:00:51 -0000
@@ -1,34 +1,37 @@
 #! /bin/sh
 # Attempt to guess a canonical system name.
 #   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
-#   2000, 2001, 2002, 2003 Free Software Foundation, Inc.
+#   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
+#   Free Software Foundation, Inc.
 
-timestamp='2003-02-22'
+timestamp='2008-01-08'
 
 # This file is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by
 # the Free Software Foundation; either version 2 of the License, or
 # (at your option) any later version.
 #
 # This program is distributed in the hope that it will be useful, but
 # WITHOUT ANY WARRANTY; without even the implied warranty of
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 # General Public License for more details.
 #
 # You should have received a copy of the GNU General Public License
 # along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
+# 02110-1301, USA.
 #
 # As a special exception to the GNU General Public License, if you
 # distribute this file as part of a program that contains a
 # configuration script generated by Autoconf, you may include it under
 # the same distribution terms that you use for the rest of that program.
 
+
 # Originally written by Per Bothner <per@bothner.com>.
 # Please send patches to <config-patches@gnu.org>.  Submit a context
 # diff and a properly formatted ChangeLog entry.
 #
 # This script attempts to guess a canonical system name similar to
 # config.sub.  If it succeeds, it prints the system name on stdout, and
 # exits with 0.  Otherwise, it exits with 1.
 #
@@ -48,34 +51,34 @@ Operation modes:
   -v, --version      print version number, then exit
 
 Report bugs and patches to <config-patches@gnu.org>."
 
 version="\
 GNU config.guess ($timestamp)
 
 Originally written by Per Bothner.
-Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
-Free Software Foundation, Inc.
+Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
+2002, 2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
 
 This is free software; see the source for copying conditions.  There is NO
 warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
 
 help="
 Try \`$me --help' for more information."
 
 # Parse command line
 while test $# -gt 0 ; do
   case $1 in
     --time-stamp | --time* | -t )
-       echo "$timestamp" ; exit 0 ;;
+       echo "$timestamp" ; exit ;;
     --version | -v )
-       echo "$version" ; exit 0 ;;
+       echo "$version" ; exit ;;
     --help | --h* | -h )
-       echo "$usage"; exit 0 ;;
+       echo "$usage"; exit ;;
     -- )     # Stop option processing
        shift; break ;;
     - )	# Use stdin as input.
        break ;;
     -* )
        echo "$me: invalid option $1$help" >&2
        exit 1 ;;
     * )
@@ -99,35 +102,36 @@ trap 'exit 1' 1 2 15
 # use `HOST_CC' if defined, but it is deprecated.
 
 # Portable tmp directory creation inspired by the Autoconf team.
 
 set_cc_for_build='
 trap "exitcode=\$?; (rm -f \$tmpfiles 2>/dev/null; rmdir \$tmp 2>/dev/null) && exit \$exitcode" 0 ;
 trap "rm -f \$tmpfiles 2>/dev/null; rmdir \$tmp 2>/dev/null; exit 1" 1 2 13 15 ;
 : ${TMPDIR=/tmp} ;
- { tmp=`(umask 077 && mktemp -d -q "$TMPDIR/cgXXXXXX") 2>/dev/null` && test -n "$tmp" && test -d "$tmp" ; } ||
+ { tmp=`(umask 077 && mktemp -d "$TMPDIR/cgXXXXXX") 2>/dev/null` && test -n "$tmp" && test -d "$tmp" ; } ||
  { test -n "$RANDOM" && tmp=$TMPDIR/cg$$-$RANDOM && (umask 077 && mkdir $tmp) ; } ||
+ { tmp=$TMPDIR/cg-$$ && (umask 077 && mkdir $tmp) && echo "Warning: creating insecure temp directory" >&2 ; } ||
  { echo "$me: cannot create a temporary directory in $TMPDIR" >&2 ; exit 1 ; } ;
 dummy=$tmp/dummy ;
 tmpfiles="$dummy.c $dummy.o $dummy.rel $dummy" ;
 case $CC_FOR_BUILD,$HOST_CC,$CC in
  ,,)    echo "int x;" > $dummy.c ;
 	for c in cc gcc c89 c99 ; do
 	  if ($c -c -o $dummy.o $dummy.c) >/dev/null 2>&1 ; then
 	     CC_FOR_BUILD="$c"; break ;
 	  fi ;
 	done ;
 	if test x"$CC_FOR_BUILD" = x ; then
 	  CC_FOR_BUILD=no_compiler_found ;
 	fi
 	;;
  ,,*)   CC_FOR_BUILD=$CC ;;
  ,*,*)  CC_FOR_BUILD=$HOST_CC ;;
-esac ;'
+esac ; set_cc_for_build= ;'
 
 # This is needed to find uname on a Pyramid OSx when run in the BSD universe.
 # (ghazi@noc.rutgers.edu 1994-08-24)
 if (test -f /.attbin/uname) >/dev/null 2>&1 ; then
 	PATH=$PATH:/.attbin ; export PATH
 fi
 
 UNAME_MACHINE=`(uname -m) 2>/dev/null` || UNAME_MACHINE=unknown
@@ -152,16 +156,17 @@ case "${UNAME_MACHINE}:${UNAME_SYSTEM}:$
 	sysctl="sysctl -n hw.machine_arch"
 	UNAME_MACHINE_ARCH=`(/sbin/$sysctl 2>/dev/null || \
 	    /usr/sbin/$sysctl 2>/dev/null || echo unknown)`
 	case "${UNAME_MACHINE_ARCH}" in
 	    armeb) machine=armeb-unknown ;;
 	    arm*) machine=arm-unknown ;;
 	    sh3el) machine=shl-unknown ;;
 	    sh3eb) machine=sh-unknown ;;
+	    sh5el) machine=sh5le-unknown ;;
 	    *) machine=${UNAME_MACHINE_ARCH}-unknown ;;
 	esac
 	# The Operating System including object format, if it has switched
 	# to ELF recently, or will in the future.
 	case "${UNAME_MACHINE_ARCH}" in
 	    arm*|i386|m68k|ns32k|sh3*|sparc|vax)
 		eval $set_cc_for_build
 		if echo __ELF__ | $CC_FOR_BUILD -E - 2>/dev/null \
@@ -190,60 +195,42 @@ case "${UNAME_MACHINE}:${UNAME_SYSTEM}:$
 	    *)
 		release=`echo ${UNAME_RELEASE}|sed -e 's/[-_].*/\./'`
 		;;
 	esac
 	# Since CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM:
 	# contains redundant information, the shorter form:
 	# CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM is used.
 	echo "${machine}-${os}${release}"
-	exit 0 ;;
-    amiga:OpenBSD:*:*)
-	echo m68k-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    arc:OpenBSD:*:*)
-	echo mipsel-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    hp300:OpenBSD:*:*)
-	echo m68k-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    mac68k:OpenBSD:*:*)
-	echo m68k-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    macppc:OpenBSD:*:*)
-	echo powerpc-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    mvme68k:OpenBSD:*:*)
-	echo m68k-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    mvme88k:OpenBSD:*:*)
-	echo m88k-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    mvmeppc:OpenBSD:*:*)
-	echo powerpc-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    pmax:OpenBSD:*:*)
-	echo mipsel-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    sgi:OpenBSD:*:*)
-	echo mipseb-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    sun3:OpenBSD:*:*)
-	echo m68k-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    wgrisc:OpenBSD:*:*)
-	echo mipsel-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     *:OpenBSD:*:*)
-	echo ${UNAME_MACHINE}-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
+	UNAME_MACHINE_ARCH=`arch | sed 's/OpenBSD.//'`
+	echo ${UNAME_MACHINE_ARCH}-unknown-openbsd${UNAME_RELEASE}
+	exit ;;
+    *:ekkoBSD:*:*)
+	echo ${UNAME_MACHINE}-unknown-ekkobsd${UNAME_RELEASE}
+	exit ;;
+    *:SolidBSD:*:*)
+	echo ${UNAME_MACHINE}-unknown-solidbsd${UNAME_RELEASE}
+	exit ;;
+    macppc:MirBSD:*:*)
+	echo powerpc-unknown-mirbsd${UNAME_RELEASE}
+	exit ;;
+    *:MirBSD:*:*)
+	echo ${UNAME_MACHINE}-unknown-mirbsd${UNAME_RELEASE}
+	exit ;;
     alpha:OSF1:*:*)
-	if test $UNAME_RELEASE = "V4.0"; then
+	case $UNAME_RELEASE in
+	*4.0)
 		UNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $3}'`
-	fi
+		;;
+	*5.*)
+	        UNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $4}'`
+		;;
+	esac
 	# According to Compaq, /usr/sbin/psrinfo has been available on
 	# OSF/1 and Tru64 systems produced since 1995.  I hope that
 	# covers most systems running today.  This code pipes the CPU
 	# types through head -n 1, so we only detect the type of CPU 0.
 	ALPHA_CPU_TYPE=`/usr/sbin/psrinfo -v | sed -n -e 's/^  The alpha \(.*\) processor.*$/\1/p' | head -n 1`
 	case "$ALPHA_CPU_TYPE" in
 	    "EV4 (21064)")
 		UNAME_MACHINE="alpha" ;;
@@ -271,147 +258,163 @@ case "${UNAME_MACHINE}:${UNAME_SYSTEM}:$
 		UNAME_MACHINE="alphaev68" ;;
 	    "EV6.9A (21264/EV69A)")
 		UNAME_MACHINE="alphaev69" ;;
 	    "EV7 (21364)")
 		UNAME_MACHINE="alphaev7" ;;
 	    "EV7.9 (21364A)")
 		UNAME_MACHINE="alphaev79" ;;
 	esac
+	# A Pn.n version is a patched version.
 	# A Vn.n version is a released version.
 	# A Tn.n version is a released field test version.
 	# A Xn.n version is an unreleased experimental baselevel.
 	# 1.2 uses "1.2" for uname -r.
-	echo ${UNAME_MACHINE}-dec-osf`echo ${UNAME_RELEASE} | sed -e 's/^[VTX]//' | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`
-	exit 0 ;;
+	echo ${UNAME_MACHINE}-dec-osf`echo ${UNAME_RELEASE} | sed -e 's/^[PVTX]//' | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`
+	exit ;;
     Alpha\ *:Windows_NT*:*)
 	# How do we know it's Interix rather than the generic POSIX subsystem?
 	# Should we change UNAME_MACHINE based on the output of uname instead
 	# of the specific Alpha model?
 	echo alpha-pc-interix
-	exit 0 ;;
+	exit ;;
     21064:Windows_NT:50:3)
 	echo alpha-dec-winnt3.5
-	exit 0 ;;
+	exit ;;
     Amiga*:UNIX_System_V:4.0:*)
 	echo m68k-unknown-sysv4
-	exit 0;;
+	exit ;;
     *:[Aa]miga[Oo][Ss]:*:*)
 	echo ${UNAME_MACHINE}-unknown-amigaos
-	exit 0 ;;
+	exit ;;
     *:[Mm]orph[Oo][Ss]:*:*)
 	echo ${UNAME_MACHINE}-unknown-morphos
-	exit 0 ;;
+	exit ;;
     *:OS/390:*:*)
 	echo i370-ibm-openedition
-	exit 0 ;;
+	exit ;;
+    *:z/VM:*:*)
+	echo s390-ibm-zvmoe
+	exit ;;
+    *:OS400:*:*)
+        echo powerpc-ibm-os400
+	exit ;;
     arm:RISC*:1.[012]*:*|arm:riscix:1.[012]*:*)
 	echo arm-acorn-riscix${UNAME_RELEASE}
-	exit 0;;
+	exit ;;
+    arm:riscos:*:*|arm:RISCOS:*:*)
+	echo arm-unknown-riscos
+	exit ;;
     SR2?01:HI-UX/MPP:*:* | SR8000:HI-UX/MPP:*:*)
 	echo hppa1.1-hitachi-hiuxmpp
-	exit 0;;
+	exit ;;
     Pyramid*:OSx*:*:* | MIS*:OSx*:*:* | MIS*:SMP_DC-OSx*:*:*)
 	# akee@wpdis03.wpafb.af.mil (Earle F. Ake) contributed MIS and NILE.
 	if test "`(/bin/universe) 2>/dev/null`" = att ; then
 		echo pyramid-pyramid-sysv3
 	else
 		echo pyramid-pyramid-bsd
 	fi
-	exit 0 ;;
+	exit ;;
     NILE*:*:*:dcosx)
 	echo pyramid-pyramid-svr4
-	exit 0 ;;
-    DRS?6000:UNIX_SV:4.2*:7*)
+	exit ;;
+    DRS?6000:unix:4.0:6*)
+	echo sparc-icl-nx6
+	exit ;;
+    DRS?6000:UNIX_SV:4.2*:7* | DRS?6000:isis:4.2*:7*)
 	case `/usr/bin/uname -p` in
-	    sparc) echo sparc-icl-nx7 && exit 0 ;;
+	    sparc) echo sparc-icl-nx7; exit ;;
 	esac ;;
     sun4H:SunOS:5.*:*)
 	echo sparc-hal-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
-	exit 0 ;;
+	exit ;;
     sun4*:SunOS:5.*:* | tadpole*:SunOS:5.*:*)
 	echo sparc-sun-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
-	exit 0 ;;
-    i86pc:SunOS:5.*:*)
+	exit ;;
+    i86pc:SunOS:5.*:* | i86xen:SunOS:5.*:*)
 	echo i386-pc-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
-	exit 0 ;;
+	exit ;;
     sun4*:SunOS:6*:*)
 	# According to config.sub, this is the proper way to canonicalize
 	# SunOS6.  Hard to guess exactly what SunOS6 will be like, but
 	# it's likely to be more like Solaris than SunOS4.
 	echo sparc-sun-solaris3`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
-	exit 0 ;;
+	exit ;;
     sun4*:SunOS:*:*)
 	case "`/usr/bin/arch -k`" in
 	    Series*|S4*)
 		UNAME_RELEASE=`uname -v`
 		;;
 	esac
 	# Japanese Language versions have a version number like `4.1.3-JL'.
 	echo sparc-sun-sunos`echo ${UNAME_RELEASE}|sed -e 's/-/_/'`
-	exit 0 ;;
+	exit ;;
     sun3*:SunOS:*:*)
 	echo m68k-sun-sunos${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     sun*:*:4.2BSD:*)
 	UNAME_RELEASE=`(sed 1q /etc/motd | awk '{print substr($5,1,3)}') 2>/dev/null`
 	test "x${UNAME_RELEASE}" = "x" && UNAME_RELEASE=3
 	case "`/bin/arch`" in
 	    sun3)
 		echo m68k-sun-sunos${UNAME_RELEASE}
 		;;
 	    sun4)
 		echo sparc-sun-sunos${UNAME_RELEASE}
 		;;
 	esac
-	exit 0 ;;
+	exit ;;
     aushp:SunOS:*:*)
 	echo sparc-auspex-sunos${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     # The situation for MiNT is a little confusing.  The machine name
     # can be virtually everything (everything which is not
     # "atarist" or "atariste" at least should have a processor
     # > m68000).  The system name ranges from "MiNT" over "FreeMiNT"
     # to the lowercase version "mint" (or "freemint").  Finally
     # the system name "TOS" denotes a system which is actually not
     # MiNT.  But MiNT is downward compatible to TOS, so this should
     # be no problem.
     atarist[e]:*MiNT:*:* | atarist[e]:*mint:*:* | atarist[e]:*TOS:*:*)
         echo m68k-atari-mint${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     atari*:*MiNT:*:* | atari*:*mint:*:* | atarist[e]:*TOS:*:*)
 	echo m68k-atari-mint${UNAME_RELEASE}
-        exit 0 ;;
+        exit ;;
     *falcon*:*MiNT:*:* | *falcon*:*mint:*:* | *falcon*:*TOS:*:*)
         echo m68k-atari-mint${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     milan*:*MiNT:*:* | milan*:*mint:*:* | *milan*:*TOS:*:*)
         echo m68k-milan-mint${UNAME_RELEASE}
-        exit 0 ;;
+        exit ;;
     hades*:*MiNT:*:* | hades*:*mint:*:* | *hades*:*TOS:*:*)
         echo m68k-hades-mint${UNAME_RELEASE}
-        exit 0 ;;
+        exit ;;
     *:*MiNT:*:* | *:*mint:*:* | *:*TOS:*:*)
         echo m68k-unknown-mint${UNAME_RELEASE}
-        exit 0 ;;
+        exit ;;
+    m68k:machten:*:*)
+	echo m68k-apple-machten${UNAME_RELEASE}
+	exit ;;
     powerpc:machten:*:*)
 	echo powerpc-apple-machten${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     RISC*:Mach:*:*)
 	echo mips-dec-mach_bsd4.3
-	exit 0 ;;
+	exit ;;
     RISC*:ULTRIX:*:*)
 	echo mips-dec-ultrix${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     VAX*:ULTRIX*:*:*)
 	echo vax-dec-ultrix${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     2020:CLIX:*:* | 2430:CLIX:*:*)
 	echo clipper-intergraph-clix${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     mips:*:*:UMIPS | mips:*:*:RISCos)
 	eval $set_cc_for_build
 	sed 's/^	//' << EOF >$dummy.c
 #ifdef __cplusplus
 #include <stdio.h>  /* for printf() prototype */
 	int main (int argc, char *argv[]) {
 #else
 	int main (argc, argv) int argc; char *argv[]; {
@@ -425,145 +428,150 @@ case "${UNAME_MACHINE}:${UNAME_SYSTEM}:$
 	#endif
 	#if defined (SYSTYPE_BSD43) || defined(SYSTYPE_BSD)
 	  printf ("mips-mips-riscos%sbsd\n", argv[1]); exit (0);
 	#endif
 	#endif
 	  exit (-1);
 	}
 EOF
-	$CC_FOR_BUILD -o $dummy $dummy.c \
-	  && $dummy `echo "${UNAME_RELEASE}" | sed -n 's/\([0-9]*\).*/\1/p'` \
-	  && exit 0
+	$CC_FOR_BUILD -o $dummy $dummy.c &&
+	  dummyarg=`echo "${UNAME_RELEASE}" | sed -n 's/\([0-9]*\).*/\1/p'` &&
+	  SYSTEM_NAME=`$dummy $dummyarg` &&
+	    { echo "$SYSTEM_NAME"; exit; }
 	echo mips-mips-riscos${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     Motorola:PowerMAX_OS:*:*)
 	echo powerpc-motorola-powermax
-	exit 0 ;;
+	exit ;;
     Motorola:*:4.3:PL8-*)
 	echo powerpc-harris-powermax
-	exit 0 ;;
+	exit ;;
     Night_Hawk:*:*:PowerMAX_OS | Synergy:PowerMAX_OS:*:*)
 	echo powerpc-harris-powermax
-	exit 0 ;;
+	exit ;;
     Night_Hawk:Power_UNIX:*:*)
 	echo powerpc-harris-powerunix
-	exit 0 ;;
+	exit ;;
     m88k:CX/UX:7*:*)
 	echo m88k-harris-cxux7
-	exit 0 ;;
+	exit ;;
     m88k:*:4*:R4*)
 	echo m88k-motorola-sysv4
-	exit 0 ;;
+	exit ;;
     m88k:*:3*:R3*)
 	echo m88k-motorola-sysv3
-	exit 0 ;;
+	exit ;;
     AViiON:dgux:*:*)
         # DG/UX returns AViiON for all architectures
         UNAME_PROCESSOR=`/usr/bin/uname -p`
 	if [ $UNAME_PROCESSOR = mc88100 ] || [ $UNAME_PROCESSOR = mc88110 ]
 	then
 	    if [ ${TARGET_BINARY_INTERFACE}x = m88kdguxelfx ] || \
 	       [ ${TARGET_BINARY_INTERFACE}x = x ]
 	    then
 		echo m88k-dg-dgux${UNAME_RELEASE}
 	    else
 		echo m88k-dg-dguxbcs${UNAME_RELEASE}
 	    fi
 	else
 	    echo i586-dg-dgux${UNAME_RELEASE}
 	fi
- 	exit 0 ;;
+ 	exit ;;
     M88*:DolphinOS:*:*)	# DolphinOS (SVR3)
 	echo m88k-dolphin-sysv3
-	exit 0 ;;
+	exit ;;
     M88*:*:R3*:*)
 	# Delta 88k system running SVR3
 	echo m88k-motorola-sysv3
-	exit 0 ;;
+	exit ;;
     XD88*:*:*:*) # Tektronix XD88 system running UTekV (SVR3)
 	echo m88k-tektronix-sysv3
-	exit 0 ;;
+	exit ;;
     Tek43[0-9][0-9]:UTek:*:*) # Tektronix 4300 system running UTek (BSD)
 	echo m68k-tektronix-bsd
-	exit 0 ;;
+	exit ;;
     *:IRIX*:*:*)
 	echo mips-sgi-irix`echo ${UNAME_RELEASE}|sed -e 's/-/_/g'`
-	exit 0 ;;
+	exit ;;
     ????????:AIX?:[12].1:2)   # AIX 2.2.1 or AIX 2.1.1 is RT/PC AIX.
-	echo romp-ibm-aix      # uname -m gives an 8 hex-code CPU id
-	exit 0 ;;              # Note that: echo "'`uname -s`'" gives 'AIX '
+	echo romp-ibm-aix     # uname -m gives an 8 hex-code CPU id
+	exit ;;               # Note that: echo "'`uname -s`'" gives 'AIX '
     i*86:AIX:*:*)
 	echo i386-ibm-aix
-	exit 0 ;;
+	exit ;;
     ia64:AIX:*:*)
 	if [ -x /usr/bin/oslevel ] ; then
 		IBM_REV=`/usr/bin/oslevel`
 	else
 		IBM_REV=${UNAME_VERSION}.${UNAME_RELEASE}
 	fi
 	echo ${UNAME_MACHINE}-ibm-aix${IBM_REV}
-	exit 0 ;;
+	exit ;;
     *:AIX:2:3)
 	if grep bos325 /usr/include/stdio.h >/dev/null 2>&1; then
 		eval $set_cc_for_build
 		sed 's/^		//' << EOF >$dummy.c
 		#include <sys/systemcfg.h>
 
 		main()
 			{
 			if (!__power_pc())
 				exit(1);
 			puts("powerpc-ibm-aix3.2.5");
 			exit(0);
 			}
 EOF
-		$CC_FOR_BUILD -o $dummy $dummy.c && $dummy && exit 0
-		echo rs6000-ibm-aix3.2.5
+		if $CC_FOR_BUILD -o $dummy $dummy.c && SYSTEM_NAME=`$dummy`
+		then
+			echo "$SYSTEM_NAME"
+		else
+			echo rs6000-ibm-aix3.2.5
+		fi
 	elif grep bos324 /usr/include/stdio.h >/dev/null 2>&1; then
 		echo rs6000-ibm-aix3.2.4
 	else
 		echo rs6000-ibm-aix3.2
 	fi
-	exit 0 ;;
-    *:AIX:*:[45])
+	exit ;;
+    *:AIX:*:[456])
 	IBM_CPU_ID=`/usr/sbin/lsdev -C -c processor -S available | sed 1q | awk '{ print $1 }'`
 	if /usr/sbin/lsattr -El ${IBM_CPU_ID} | grep ' POWER' >/dev/null 2>&1; then
 		IBM_ARCH=rs6000
 	else
 		IBM_ARCH=powerpc
 	fi
 	if [ -x /usr/bin/oslevel ] ; then
 		IBM_REV=`/usr/bin/oslevel`
 	else
 		IBM_REV=${UNAME_VERSION}.${UNAME_RELEASE}
 	fi
 	echo ${IBM_ARCH}-ibm-aix${IBM_REV}
-	exit 0 ;;
+	exit ;;
     *:AIX:*:*)
 	echo rs6000-ibm-aix
-	exit 0 ;;
+	exit ;;
     ibmrt:4.4BSD:*|romp-ibm:BSD:*)
 	echo romp-ibm-bsd4.4
-	exit 0 ;;
+	exit ;;
     ibmrt:*BSD:*|romp-ibm:BSD:*)            # covers RT/PC BSD and
 	echo romp-ibm-bsd${UNAME_RELEASE}   # 4.3 with uname added to
-	exit 0 ;;                           # report: romp-ibm BSD 4.3
+	exit ;;                             # report: romp-ibm BSD 4.3
     *:BOSX:*:*)
 	echo rs6000-bull-bosx
-	exit 0 ;;
+	exit ;;
     DPX/2?00:B.O.S.:*:*)
 	echo m68k-bull-sysv3
-	exit 0 ;;
+	exit ;;
     9000/[34]??:4.3bsd:1.*:*)
 	echo m68k-hp-bsd
-	exit 0 ;;
+	exit ;;
     hp300:4.4BSD:*:* | 9000/[34]??:4.3bsd:2.*:*)
 	echo m68k-hp-bsd4.4
-	exit 0 ;;
+	exit ;;
     9000/[34678]??:HP-UX:*:*)
 	HPUX_REV=`echo ${UNAME_RELEASE}|sed -e 's/[^.]*.[0B]*//'`
 	case "${UNAME_MACHINE}" in
 	    9000/31? )            HP_ARCH=m68000 ;;
 	    9000/[34]?? )         HP_ARCH=m68k ;;
 	    9000/[678][0-9][0-9])
 		if [ -x /usr/bin/getconf ]; then
 		    sc_cpu_version=`/usr/bin/getconf SC_CPU_VERSION 2>/dev/null`
@@ -615,31 +623,41 @@ EOF
               }
 EOF
 		    (CCOPTS= $CC_FOR_BUILD -o $dummy $dummy.c 2>/dev/null) && HP_ARCH=`$dummy`
 		    test -z "$HP_ARCH" && HP_ARCH=hppa
 		fi ;;
 	esac
 	if [ ${HP_ARCH} = "hppa2.0w" ]
 	then
-	    # avoid double evaluation of $set_cc_for_build
-	    test -n "$CC_FOR_BUILD" || eval $set_cc_for_build
-	    if echo __LP64__ | (CCOPTS= $CC_FOR_BUILD -E -) | grep __LP64__ >/dev/null
+	    eval $set_cc_for_build
+
+	    # hppa2.0w-hp-hpux* has a 64-bit kernel and a compiler generating
+	    # 32-bit code.  hppa64-hp-hpux* has the same kernel and a compiler
+	    # generating 64-bit code.  GNU and HP use different nomenclature:
+	    #
+	    # $ CC_FOR_BUILD=cc ./config.guess
+	    # => hppa2.0w-hp-hpux11.23
+	    # $ CC_FOR_BUILD="cc +DA2.0w" ./config.guess
+	    # => hppa64-hp-hpux11.23
+
+	    if echo __LP64__ | (CCOPTS= $CC_FOR_BUILD -E - 2>/dev/null) |
+		grep __LP64__ >/dev/null
 	    then
 		HP_ARCH="hppa2.0w"
 	    else
 		HP_ARCH="hppa64"
 	    fi
 	fi
 	echo ${HP_ARCH}-hp-hpux${HPUX_REV}
-	exit 0 ;;
+	exit ;;
     ia64:HP-UX:*:*)
 	HPUX_REV=`echo ${UNAME_RELEASE}|sed -e 's/[^.]*.[0B]*//'`
 	echo ia64-hp-hpux${HPUX_REV}
-	exit 0 ;;
+	exit ;;
     3050*:HI-UX:*:*)
 	eval $set_cc_for_build
 	sed 's/^	//' << EOF >$dummy.c
 	#include <unistd.h>
 	int
 	main ()
 	{
 	  long cpu = sysconf (_SC_CPU_VERSION);
@@ -657,181 +675,224 @@ EOF
 		}
 	    }
 	  else if (CPU_IS_HP_MC68K (cpu))
 	    puts ("m68k-hitachi-hiuxwe2");
 	  else puts ("unknown-hitachi-hiuxwe2");
 	  exit (0);
 	}
 EOF
-	$CC_FOR_BUILD -o $dummy $dummy.c && $dummy && exit 0
+	$CC_FOR_BUILD -o $dummy $dummy.c && SYSTEM_NAME=`$dummy` &&
+		{ echo "$SYSTEM_NAME"; exit; }
 	echo unknown-hitachi-hiuxwe2
-	exit 0 ;;
+	exit ;;
     9000/7??:4.3bsd:*:* | 9000/8?[79]:4.3bsd:*:* )
 	echo hppa1.1-hp-bsd
-	exit 0 ;;
+	exit ;;
     9000/8??:4.3bsd:*:*)
 	echo hppa1.0-hp-bsd
-	exit 0 ;;
+	exit ;;
     *9??*:MPE/iX:*:* | *3000*:MPE/iX:*:*)
 	echo hppa1.0-hp-mpeix
-	exit 0 ;;
+	exit ;;
     hp7??:OSF1:*:* | hp8?[79]:OSF1:*:* )
 	echo hppa1.1-hp-osf
-	exit 0 ;;
+	exit ;;
     hp8??:OSF1:*:*)
 	echo hppa1.0-hp-osf
-	exit 0 ;;
+	exit ;;
     i*86:OSF1:*:*)
 	if [ -x /usr/sbin/sysversion ] ; then
 	    echo ${UNAME_MACHINE}-unknown-osf1mk
 	else
 	    echo ${UNAME_MACHINE}-unknown-osf1
 	fi
-	exit 0 ;;
+	exit ;;
     parisc*:Lites*:*:*)
 	echo hppa1.1-hp-lites
-	exit 0 ;;
+	exit ;;
     C1*:ConvexOS:*:* | convex:ConvexOS:C1*:*)
 	echo c1-convex-bsd
-        exit 0 ;;
+        exit ;;
     C2*:ConvexOS:*:* | convex:ConvexOS:C2*:*)
 	if getsysinfo -f scalar_acc
 	then echo c32-convex-bsd
 	else echo c2-convex-bsd
 	fi
-        exit 0 ;;
+        exit ;;
     C34*:ConvexOS:*:* | convex:ConvexOS:C34*:*)
 	echo c34-convex-bsd
-        exit 0 ;;
+        exit ;;
     C38*:ConvexOS:*:* | convex:ConvexOS:C38*:*)
 	echo c38-convex-bsd
-        exit 0 ;;
+        exit ;;
     C4*:ConvexOS:*:* | convex:ConvexOS:C4*:*)
 	echo c4-convex-bsd
-        exit 0 ;;
+        exit ;;
     CRAY*Y-MP:*:*:*)
 	echo ymp-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
-	exit 0 ;;
+	exit ;;
     CRAY*[A-Z]90:*:*:*)
 	echo ${UNAME_MACHINE}-cray-unicos${UNAME_RELEASE} \
 	| sed -e 's/CRAY.*\([A-Z]90\)/\1/' \
 	      -e y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/ \
 	      -e 's/\.[^.]*$/.X/'
-	exit 0 ;;
+	exit ;;
     CRAY*TS:*:*:*)
 	echo t90-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
-	exit 0 ;;
+	exit ;;
     CRAY*T3E:*:*:*)
 	echo alphaev5-cray-unicosmk${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
-	exit 0 ;;
+	exit ;;
     CRAY*SV1:*:*:*)
 	echo sv1-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
-	exit 0 ;;
+	exit ;;
     *:UNICOS/mp:*:*)
-	echo nv1-cray-unicosmp${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/' 
-	exit 0 ;;
+	echo craynv-cray-unicosmp${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
+	exit ;;
     F30[01]:UNIX_System_V:*:* | F700:UNIX_System_V:*:*)
 	FUJITSU_PROC=`uname -m | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`
         FUJITSU_SYS=`uname -p | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/\///'`
         FUJITSU_REL=`echo ${UNAME_RELEASE} | sed -e 's/ /_/'`
         echo "${FUJITSU_PROC}-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
-        exit 0 ;;
+        exit ;;
+    5000:UNIX_System_V:4.*:*)
+        FUJITSU_SYS=`uname -p | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/\///'`
+        FUJITSU_REL=`echo ${UNAME_RELEASE} | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/ /_/'`
+        echo "sparc-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
+	exit ;;
     i*86:BSD/386:*:* | i*86:BSD/OS:*:* | *:Ascend\ Embedded/OS:*:*)
 	echo ${UNAME_MACHINE}-pc-bsdi${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     sparc*:BSD/OS:*:*)
 	echo sparc-unknown-bsdi${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     *:BSD/OS:*:*)
 	echo ${UNAME_MACHINE}-unknown-bsdi${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     *:FreeBSD:*:*)
-	# Determine whether the default compiler uses glibc.
-	eval $set_cc_for_build
-	sed 's/^	//' << EOF >$dummy.c
-	#include <features.h>
-	#if __GLIBC__ >= 2
-	LIBC=gnu
-	#else
-	LIBC=
-	#endif
-EOF
-	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep ^LIBC=`
-	echo ${UNAME_MACHINE}-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`${LIBC:+-$LIBC}
-	exit 0 ;;
+	case ${UNAME_MACHINE} in
+	    pc98)
+		echo i386-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'` ;;
+	    amd64)
+		echo x86_64-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'` ;;
+	    *)
+		echo ${UNAME_MACHINE}-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'` ;;
+	esac
+	exit ;;
     i*:CYGWIN*:*)
 	echo ${UNAME_MACHINE}-pc-cygwin
-	exit 0 ;;
-    i*:MINGW*:*)
+	exit ;;
+    *:MINGW*:*)
 	echo ${UNAME_MACHINE}-pc-mingw32
-	exit 0 ;;
-#### MozillaHack 
-# Netscape's hacked uname
-    xx:WINNT:* | xx:WIN95:*)
-	echo i586-pc-msvc
-	exit 0 ;;
-###  End MozillaHack
+	exit ;;
+    i*:windows32*:*)
+    	# uname -m includes "-pc" on this system.
+    	echo ${UNAME_MACHINE}-mingw32
+	exit ;;
     i*:PW*:*)
 	echo ${UNAME_MACHINE}-pc-pw32
-	exit 0 ;;
-    x86:Interix*:3*)
-	echo i586-pc-interix3
-	exit 0 ;;
+	exit ;;
+    *:Interix*:[3456]*)
+    	case ${UNAME_MACHINE} in
+	    x86)
+		echo i586-pc-interix${UNAME_RELEASE}
+		exit ;;
+	    EM64T | authenticamd)
+		echo x86_64-unknown-interix${UNAME_RELEASE}
+		exit ;;
+	    IA64)
+		echo ia64-unknown-interix${UNAME_RELEASE}
+		exit ;;
+	esac ;;
     [345]86:Windows_95:* | [345]86:Windows_98:* | [345]86:Windows_NT:*)
 	echo i${UNAME_MACHINE}-pc-mks
-	exit 0 ;;
+	exit ;;
     i*:Windows_NT*:* | Pentium*:Windows_NT*:*)
 	# How do we know it's Interix rather than the generic POSIX subsystem?
 	# It also conflicts with pre-2.0 versions of AT&T UWIN. Should we
 	# UNAME_MACHINE based on the output of uname instead of i386?
 	echo i586-pc-interix
-	exit 0 ;;
+	exit ;;
     i*:UWIN*:*)
 	echo ${UNAME_MACHINE}-pc-uwin
-	exit 0 ;;
+	exit ;;
+    amd64:CYGWIN*:*:* | x86_64:CYGWIN*:*:*)
+	echo x86_64-unknown-cygwin
+	exit ;;
     p*:CYGWIN*:*)
 	echo powerpcle-unknown-cygwin
-	exit 0 ;;
+	exit ;;
     prep*:SunOS:5.*:*)
 	echo powerpcle-unknown-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
-	exit 0 ;;
+	exit ;;
     *:GNU:*:*)
+	# the GNU system
 	echo `echo ${UNAME_MACHINE}|sed -e 's,[-/].*$,,'`-unknown-gnu`echo ${UNAME_RELEASE}|sed -e 's,/.*$,,'`
-	exit 0 ;;
+	exit ;;
+    *:GNU/*:*:*)
+	# other systems with GNU libc and userland
+	echo ${UNAME_MACHINE}-unknown-`echo ${UNAME_SYSTEM} | sed 's,^[^/]*/,,' | tr '[A-Z]' '[a-z]'``echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`-gnu
+	exit ;;
     i*86:Minix:*:*)
 	echo ${UNAME_MACHINE}-pc-minix
-	exit 0 ;;
+	exit ;;
     arm*:Linux:*:*)
+	eval $set_cc_for_build
+	if echo __ARM_EABI__ | $CC_FOR_BUILD -E - 2>/dev/null \
+	    | grep -q __ARM_EABI__
+	then
+	    echo ${UNAME_MACHINE}-unknown-linux-gnu
+	else
+	    echo ${UNAME_MACHINE}-unknown-linux-gnueabi
+	fi
+	exit ;;
+    avr32*:Linux:*:*)
 	echo ${UNAME_MACHINE}-unknown-linux-gnu
-	exit 0 ;;
+	exit ;;
+    cris:Linux:*:*)
+	echo cris-axis-linux-gnu
+	exit ;;
+    crisv32:Linux:*:*)
+	echo crisv32-axis-linux-gnu
+	exit ;;
+    frv:Linux:*:*)
+    	echo frv-unknown-linux-gnu
+	exit ;;
     ia64:Linux:*:*)
 	echo ${UNAME_MACHINE}-unknown-linux-gnu
-	exit 0 ;;
+	exit ;;
+    m32r*:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	exit ;;
     m68*:Linux:*:*)
 	echo ${UNAME_MACHINE}-unknown-linux-gnu
-	exit 0 ;;
+	exit ;;
     mips:Linux:*:*)
 	eval $set_cc_for_build
 	sed 's/^	//' << EOF >$dummy.c
 	#undef CPU
 	#undef mips
 	#undef mipsel
 	#if defined(__MIPSEL__) || defined(__MIPSEL) || defined(_MIPSEL) || defined(MIPSEL)
 	CPU=mipsel
 	#else
 	#if defined(__MIPSEB__) || defined(__MIPSEB) || defined(_MIPSEB) || defined(MIPSEB)
 	CPU=mips
 	#else
 	CPU=
 	#endif
 	#endif
 EOF
-	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep ^CPU=`
-	test x"${CPU}" != x && echo "${CPU}-unknown-linux-gnu" && exit 0
+	eval "`$CC_FOR_BUILD -E $dummy.c 2>/dev/null | sed -n '
+	    /^CPU/{
+		s: ::g
+		p
+	    }'`"
+	test x"${CPU}" != x && { echo "${CPU}-unknown-linux-gnu"; exit; }
 	;;
     mips64:Linux:*:*)
 	eval $set_cc_for_build
 	sed 's/^	//' << EOF >$dummy.c
 	#undef CPU
 	#undef mips64
 	#undef mips64el
 	#if defined(__MIPSEL__) || defined(__MIPSEL) || defined(_MIPSEL) || defined(MIPSEL)
@@ -839,62 +900,78 @@ EOF
 	#else
 	#if defined(__MIPSEB__) || defined(__MIPSEB) || defined(_MIPSEB) || defined(MIPSEB)
 	CPU=mips64
 	#else
 	CPU=
 	#endif
 	#endif
 EOF
-	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep ^CPU=`
-	test x"${CPU}" != x && echo "${CPU}-unknown-linux-gnu" && exit 0
+	eval "`$CC_FOR_BUILD -E $dummy.c 2>/dev/null | sed -n '
+	    /^CPU/{
+		s: ::g
+		p
+	    }'`"
+	test x"${CPU}" != x && { echo "${CPU}-unknown-linux-gnu"; exit; }
 	;;
+    or32:Linux:*:*)
+	echo or32-unknown-linux-gnu
+	exit ;;
     ppc:Linux:*:*)
 	echo powerpc-unknown-linux-gnu
-	exit 0 ;;
+	exit ;;
     ppc64:Linux:*:*)
 	echo powerpc64-unknown-linux-gnu
-	exit 0 ;;
+	exit ;;
     alpha:Linux:*:*)
 	case `sed -n '/^cpu model/s/^.*: \(.*\)/\1/p' < /proc/cpuinfo` in
 	  EV5)   UNAME_MACHINE=alphaev5 ;;
 	  EV56)  UNAME_MACHINE=alphaev56 ;;
 	  PCA56) UNAME_MACHINE=alphapca56 ;;
 	  PCA57) UNAME_MACHINE=alphapca56 ;;
 	  EV6)   UNAME_MACHINE=alphaev6 ;;
 	  EV67)  UNAME_MACHINE=alphaev67 ;;
 	  EV68*) UNAME_MACHINE=alphaev68 ;;
         esac
 	objdump --private-headers /bin/sh | grep ld.so.1 >/dev/null
 	if test "$?" = 0 ; then LIBC="libc1" ; else LIBC="" ; fi
 	echo ${UNAME_MACHINE}-unknown-linux-gnu${LIBC}
-	exit 0 ;;
+	exit ;;
     parisc:Linux:*:* | hppa:Linux:*:*)
 	# Look for CPU level
 	case `grep '^cpu[^a-z]*:' /proc/cpuinfo 2>/dev/null | cut -d' ' -f2` in
 	  PA7*) echo hppa1.1-unknown-linux-gnu ;;
 	  PA8*) echo hppa2.0-unknown-linux-gnu ;;
 	  *)    echo hppa-unknown-linux-gnu ;;
 	esac
-	exit 0 ;;
+	exit ;;
     parisc64:Linux:*:* | hppa64:Linux:*:*)
 	echo hppa64-unknown-linux-gnu
-	exit 0 ;;
+	exit ;;
     s390:Linux:*:* | s390x:Linux:*:*)
 	echo ${UNAME_MACHINE}-ibm-linux
-	exit 0 ;;
+	exit ;;
+    sh64*:Linux:*:*)
+    	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	exit ;;
     sh*:Linux:*:*)
 	echo ${UNAME_MACHINE}-unknown-linux-gnu
-	exit 0 ;;
+	exit ;;
     sparc:Linux:*:* | sparc64:Linux:*:*)
 	echo ${UNAME_MACHINE}-unknown-linux-gnu
-	exit 0 ;;
+	exit ;;
+    vax:Linux:*:*)
+	echo ${UNAME_MACHINE}-dec-linux-gnu
+	exit ;;
     x86_64:Linux:*:*)
 	echo x86_64-unknown-linux-gnu
-	exit 0 ;;
+	exit ;;
+    xtensa*:Linux:*:*)
+    	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	exit ;;
     i*86:Linux:*:*)
 	# The BFD linker knows what the default object file format is, so
 	# first see if it will tell us. cd to the root directory to prevent
 	# problems with other programs or directories called `ld' in the path.
 	# Set LC_ALL=C to ensure ld outputs messages in English.
 	ld_supported_targets=`cd /; LC_ALL=C ld --help 2>&1 \
 			 | sed -ne '/supported targets:/!d
 				    s/[ 	][ 	]*/ /g
@@ -902,99 +979,113 @@ EOF
 				    s/ .*//
 				    p'`
         case "$ld_supported_targets" in
 	  elf32-i386)
 		TENTATIVE="${UNAME_MACHINE}-pc-linux-gnu"
 		;;
 	  a.out-i386-linux)
 		echo "${UNAME_MACHINE}-pc-linux-gnuaout"
-		exit 0 ;;
+		exit ;;
 	  coff-i386)
 		echo "${UNAME_MACHINE}-pc-linux-gnucoff"
-		exit 0 ;;
+		exit ;;
 	  "")
 		# Either a pre-BFD a.out linker (linux-gnuoldld) or
 		# one that does not give us useful --help.
 		echo "${UNAME_MACHINE}-pc-linux-gnuoldld"
-		exit 0 ;;
+		exit ;;
 	esac
 	# Determine whether the default compiler is a.out or elf
 	eval $set_cc_for_build
 	sed 's/^	//' << EOF >$dummy.c
 	#include <features.h>
 	#ifdef __ELF__
 	# ifdef __GLIBC__
 	#  if __GLIBC__ >= 2
 	LIBC=gnu
 	#  else
 	LIBC=gnulibc1
 	#  endif
 	# else
 	LIBC=gnulibc1
 	# endif
 	#else
-	#ifdef __INTEL_COMPILER
+	#if defined(__INTEL_COMPILER) || defined(__PGI) || defined(__SUNPRO_C) || defined(__SUNPRO_CC)
 	LIBC=gnu
 	#else
 	LIBC=gnuaout
 	#endif
 	#endif
+	#ifdef __dietlibc__
+	LIBC=dietlibc
+	#endif
 EOF
-	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep ^LIBC=`
-	test x"${LIBC}" != x && echo "${UNAME_MACHINE}-pc-linux-${LIBC}" && exit 0
-	test x"${TENTATIVE}" != x && echo "${TENTATIVE}" && exit 0
+	eval "`$CC_FOR_BUILD -E $dummy.c 2>/dev/null | sed -n '
+	    /^LIBC/{
+		s: ::g
+		p
+	    }'`"
+	test x"${LIBC}" != x && {
+		echo "${UNAME_MACHINE}-pc-linux-${LIBC}"
+		exit
+	}
+	test x"${TENTATIVE}" != x && { echo "${TENTATIVE}"; exit; }
 	;;
     i*86:DYNIX/ptx:4*:*)
 	# ptx 4.0 does uname -s correctly, with DYNIX/ptx in there.
 	# earlier versions are messed up and put the nodename in both
 	# sysname and nodename.
 	echo i386-sequent-sysv4
-	exit 0 ;;
+	exit ;;
     i*86:UNIX_SV:4.2MP:2.*)
         # Unixware is an offshoot of SVR4, but it has its own version
         # number series starting with 2...
         # I am not positive that other SVR4 systems won't match this,
 	# I just have to hope.  -- rms.
         # Use sysv4.2uw... so that sysv4* matches it.
 	echo ${UNAME_MACHINE}-pc-sysv4.2uw${UNAME_VERSION}
-	exit 0 ;;
+	exit ;;
     i*86:OS/2:*:*)
 	# If we were able to find `uname', then EMX Unix compatibility
 	# is probably installed.
 	echo ${UNAME_MACHINE}-pc-os2-emx
-	exit 0 ;;
+	exit ;;
     i*86:XTS-300:*:STOP)
 	echo ${UNAME_MACHINE}-unknown-stop
-	exit 0 ;;
+	exit ;;
     i*86:atheos:*:*)
 	echo ${UNAME_MACHINE}-unknown-atheos
-	exit 0 ;;
+	exit ;;
+    i*86:syllable:*:*)
+	echo ${UNAME_MACHINE}-pc-syllable
+	exit ;;
     i*86:LynxOS:2.*:* | i*86:LynxOS:3.[01]*:* | i*86:LynxOS:4.0*:*)
 	echo i386-unknown-lynxos${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     i*86:*DOS:*:*)
 	echo ${UNAME_MACHINE}-pc-msdosdjgpp
-	exit 0 ;;
+	exit ;;
     i*86:*:4.*:* | i*86:SYSTEM_V:4.*:*)
 	UNAME_REL=`echo ${UNAME_RELEASE} | sed 's/\/MP$//'`
 	if grep Novell /usr/include/link.h >/dev/null 2>/dev/null; then
 		echo ${UNAME_MACHINE}-univel-sysv${UNAME_REL}
 	else
 		echo ${UNAME_MACHINE}-pc-sysv${UNAME_REL}
 	fi
-	exit 0 ;;
-    i*86:*:5:[78]*)
+	exit ;;
+    i*86:*:5:[678]*)
+    	# UnixWare 7.x, OpenUNIX and OpenServer 6.
 	case `/bin/uname -X | grep "^Machine"` in
 	    *486*)	     UNAME_MACHINE=i486 ;;
 	    *Pentium)	     UNAME_MACHINE=i586 ;;
 	    *Pent*|*Celeron) UNAME_MACHINE=i686 ;;
 	esac
 	echo ${UNAME_MACHINE}-unknown-sysv${UNAME_RELEASE}${UNAME_SYSTEM}${UNAME_VERSION}
-	exit 0 ;;
+	exit ;;
     i*86:*:3.2:*)
 	if test -f /usr/options/cb.name; then
 		UNAME_REL=`sed -n 's/.*Version //p' </usr/options/cb.name`
 		echo ${UNAME_MACHINE}-pc-isc$UNAME_REL
 	elif /bin/uname -X 2>/dev/null >/dev/null ; then
 		UNAME_REL=`(/bin/uname -X|grep Release|sed -e 's/.*= //')`
 		(/bin/uname -X|grep i80486 >/dev/null) && UNAME_MACHINE=i486
 		(/bin/uname -X|grep '^Machine.*Pentium' >/dev/null) \
@@ -1002,214 +1093,248 @@ EOF
 		(/bin/uname -X|grep '^Machine.*Pent *II' >/dev/null) \
 			&& UNAME_MACHINE=i686
 		(/bin/uname -X|grep '^Machine.*Pentium Pro' >/dev/null) \
 			&& UNAME_MACHINE=i686
 		echo ${UNAME_MACHINE}-pc-sco$UNAME_REL
 	else
 		echo ${UNAME_MACHINE}-pc-sysv32
 	fi
-	exit 0 ;;
+	exit ;;
     pc:*:*:*)
 	# Left here for compatibility:
         # uname -m prints for DJGPP always 'pc', but it prints nothing about
         # the processor, so we play safe by assuming i386.
 	echo i386-pc-msdosdjgpp
-        exit 0 ;;
+        exit ;;
     Intel:Mach:3*:*)
 	echo i386-pc-mach3
-	exit 0 ;;
+	exit ;;
     paragon:*:*:*)
 	echo i860-intel-osf1
-	exit 0 ;;
+	exit ;;
     i860:*:4.*:*) # i860-SVR4
 	if grep Stardent /usr/include/sys/uadmin.h >/dev/null 2>&1 ; then
 	  echo i860-stardent-sysv${UNAME_RELEASE} # Stardent Vistra i860-SVR4
 	else # Add other i860-SVR4 vendors below as they are discovered.
 	  echo i860-unknown-sysv${UNAME_RELEASE}  # Unknown i860-SVR4
 	fi
-	exit 0 ;;
+	exit ;;
     mini*:CTIX:SYS*5:*)
 	# "miniframe"
 	echo m68010-convergent-sysv
-	exit 0 ;;
+	exit ;;
     mc68k:UNIX:SYSTEM5:3.51m)
 	echo m68k-convergent-sysv
-	exit 0 ;;
+	exit ;;
     M680?0:D-NIX:5.3:*)
 	echo m68k-diab-dnix
-	exit 0 ;;
-    M68*:*:R3V[567]*:*)
-	test -r /sysV68 && echo 'm68k-motorola-sysv' && exit 0 ;;
-    3[34]??:*:4.0:3.0 | 3[34]??A:*:4.0:3.0 | 3[34]??,*:*:4.0:3.0 | 3[34]??/*:*:4.0:3.0 | 4400:*:4.0:3.0 | 4850:*:4.0:3.0 | SKA40:*:4.0:3.0 | SDS2:*:4.0:3.0)
+	exit ;;
+    M68*:*:R3V[5678]*:*)
+	test -r /sysV68 && { echo 'm68k-motorola-sysv'; exit; } ;;
+    3[345]??:*:4.0:3.0 | 3[34]??A:*:4.0:3.0 | 3[34]??,*:*:4.0:3.0 | 3[34]??/*:*:4.0:3.0 | 4400:*:4.0:3.0 | 4850:*:4.0:3.0 | SKA40:*:4.0:3.0 | SDS2:*:4.0:3.0 | SHG2:*:4.0:3.0 | S7501*:*:4.0:3.0)
 	OS_REL=''
 	test -r /etc/.relid \
 	&& OS_REL=.`sed -n 's/[^ ]* [^ ]* \([0-9][0-9]\).*/\1/p' < /etc/.relid`
 	/bin/uname -p 2>/dev/null | grep 86 >/dev/null \
-	  && echo i486-ncr-sysv4.3${OS_REL} && exit 0
+	  && { echo i486-ncr-sysv4.3${OS_REL}; exit; }
 	/bin/uname -p 2>/dev/null | /bin/grep entium >/dev/null \
-	  && echo i586-ncr-sysv4.3${OS_REL} && exit 0 ;;
+	  && { echo i586-ncr-sysv4.3${OS_REL}; exit; } ;;
     3[34]??:*:4.0:* | 3[34]??,*:*:4.0:*)
         /bin/uname -p 2>/dev/null | grep 86 >/dev/null \
-          && echo i486-ncr-sysv4 && exit 0 ;;
+          && { echo i486-ncr-sysv4; exit; } ;;
     m68*:LynxOS:2.*:* | m68*:LynxOS:3.0*:*)
 	echo m68k-unknown-lynxos${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     mc68030:UNIX_System_V:4.*:*)
 	echo m68k-atari-sysv4
-	exit 0 ;;
+	exit ;;
     TSUNAMI:LynxOS:2.*:*)
 	echo sparc-unknown-lynxos${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     rs6000:LynxOS:2.*:*)
 	echo rs6000-unknown-lynxos${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     PowerPC:LynxOS:2.*:* | PowerPC:LynxOS:3.[01]*:* | PowerPC:LynxOS:4.0*:*)
 	echo powerpc-unknown-lynxos${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     SM[BE]S:UNIX_SV:*:*)
 	echo mips-dde-sysv${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     RM*:ReliantUNIX-*:*:*)
 	echo mips-sni-sysv4
-	exit 0 ;;
+	exit ;;
     RM*:SINIX-*:*:*)
 	echo mips-sni-sysv4
-	exit 0 ;;
+	exit ;;
     *:SINIX-*:*:*)
 	if uname -p 2>/dev/null >/dev/null ; then
 		UNAME_MACHINE=`(uname -p) 2>/dev/null`
 		echo ${UNAME_MACHINE}-sni-sysv4
 	else
 		echo ns32k-sni-sysv
 	fi
-	exit 0 ;;
+	exit ;;
     PENTIUM:*:4.0*:*) # Unisys `ClearPath HMP IX 4000' SVR4/MP effort
                       # says <Richard.M.Bartel@ccMail.Census.GOV>
         echo i586-unisys-sysv4
-        exit 0 ;;
-#### MozillaHack 
-    *:*OpenVMS*:*:*)
-        case "${UNAME_SYSTEM}" in
-            POSIX_for_OpenVMS_AXP) echo alpha-dec-openvmsposix ;;
-            POSIX_for_OpenVMS_VAX) echo vax-dec-openvmsposix ;;
-            OpenVMS) echo alpha-dec-openvms ;;
-            *) echo unknown-dec-openvms ;;
-        esac
-        exit 0 ;;
-#### End MozillaHack 
+        exit ;;
     *:UNIX_System_V:4*:FTX*)
 	# From Gerald Hewes <hewes@openmarket.com>.
 	# How about differentiating between stratus architectures? -djm
 	echo hppa1.1-stratus-sysv4
-	exit 0 ;;
+	exit ;;
     *:*:*:FTX*)
 	# From seanf@swdc.stratus.com.
 	echo i860-stratus-sysv4
-	exit 0 ;;
+	exit ;;
+    i*86:VOS:*:*)
+	# From Paul.Green@stratus.com.
+	echo ${UNAME_MACHINE}-stratus-vos
+	exit ;;
     *:VOS:*:*)
 	# From Paul.Green@stratus.com.
 	echo hppa1.1-stratus-vos
-	exit 0 ;;
+	exit ;;
     mc68*:A/UX:*:*)
 	echo m68k-apple-aux${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     news*:NEWS-OS:6*:*)
 	echo mips-sony-newsos6
-	exit 0 ;;
+	exit ;;
     R[34]000:*System_V*:*:* | R4000:UNIX_SYSV:*:* | R*000:UNIX_SV:*:*)
 	if [ -d /usr/nec ]; then
 	        echo mips-nec-sysv${UNAME_RELEASE}
 	else
 	        echo mips-unknown-sysv${UNAME_RELEASE}
 	fi
-        exit 0 ;;
+        exit ;;
     BeBox:BeOS:*:*)	# BeOS running on hardware made by Be, PPC only.
 	echo powerpc-be-beos
-	exit 0 ;;
+	exit ;;
     BeMac:BeOS:*:*)	# BeOS running on Mac or Mac clone, PPC only.
 	echo powerpc-apple-beos
-	exit 0 ;;
+	exit ;;
     BePC:BeOS:*:*)	# BeOS running on Intel PC compatible.
 	echo i586-pc-beos
-	exit 0 ;;
+	exit ;;
+    BeMac:Haiku:*:*)
+	echo powerpc-apple-haiku
+	exit ;;
+    BePC:Haiku:*:*)
+	echo i586-pc-haiku
+	exit ;;
     SX-4:SUPER-UX:*:*)
 	echo sx4-nec-superux${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     SX-5:SUPER-UX:*:*)
 	echo sx5-nec-superux${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     SX-6:SUPER-UX:*:*)
 	echo sx6-nec-superux${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
+    SX-7:SUPER-UX:*:*)
+	echo sx7-nec-superux${UNAME_RELEASE}
+	exit ;;
+    SX-8:SUPER-UX:*:*)
+	echo sx8-nec-superux${UNAME_RELEASE}
+	exit ;;
+    SX-8R:SUPER-UX:*:*)
+	echo sx8r-nec-superux${UNAME_RELEASE}
+	exit ;;
     Power*:Rhapsody:*:*)
 	echo powerpc-apple-rhapsody${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     *:Rhapsody:*:*)
 	echo ${UNAME_MACHINE}-apple-rhapsody${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     *:Darwin:*:*)
-	case `uname -p` in
-	    *86) UNAME_PROCESSOR=i686 ;;
-	    powerpc) UNAME_PROCESSOR=powerpc ;;
+	UNAME_PROCESSOR=`uname -p` || UNAME_PROCESSOR=unknown
+	case $UNAME_PROCESSOR in
+	    unknown) UNAME_PROCESSOR=powerpc ;;
 	esac
 	echo ${UNAME_PROCESSOR}-apple-darwin${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     *:procnto*:*:* | *:QNX:[0123456789]*:*)
 	UNAME_PROCESSOR=`uname -p`
 	if test "$UNAME_PROCESSOR" = "x86"; then
 		UNAME_PROCESSOR=i386
 		UNAME_MACHINE=pc
 	fi
 	echo ${UNAME_PROCESSOR}-${UNAME_MACHINE}-nto-qnx${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     *:QNX:*:4*)
 	echo i386-pc-qnx
-	exit 0 ;;
-    NSR-[DGKLNPTVW]:NONSTOP_KERNEL:*:*)
+	exit ;;
+    NSE-?:NONSTOP_KERNEL:*:*)
+	echo nse-tandem-nsk${UNAME_RELEASE}
+	exit ;;
+    NSR-?:NONSTOP_KERNEL:*:*)
 	echo nsr-tandem-nsk${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     *:NonStop-UX:*:*)
 	echo mips-compaq-nonstopux
-	exit 0 ;;
+	exit ;;
     BS2000:POSIX*:*:*)
 	echo bs2000-siemens-sysv
-	exit 0 ;;
+	exit ;;
     DS/*:UNIX_System_V:*:*)
 	echo ${UNAME_MACHINE}-${UNAME_SYSTEM}-${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     *:Plan9:*:*)
 	# "uname -m" is not consistent, so use $cputype instead. 386
 	# is converted to i386 for consistency with other x86
 	# operating systems.
 	if test "$cputype" = "386"; then
 	    UNAME_MACHINE=i386
 	else
 	    UNAME_MACHINE="$cputype"
 	fi
 	echo ${UNAME_MACHINE}-unknown-plan9
-	exit 0 ;;
+	exit ;;
     *:TOPS-10:*:*)
 	echo pdp10-unknown-tops10
-	exit 0 ;;
+	exit ;;
     *:TENEX:*:*)
 	echo pdp10-unknown-tenex
-	exit 0 ;;
+	exit ;;
     KS10:TOPS-20:*:* | KL10:TOPS-20:*:* | TYPE4:TOPS-20:*:*)
 	echo pdp10-dec-tops20
-	exit 0 ;;
+	exit ;;
     XKL-1:TOPS-20:*:* | TYPE5:TOPS-20:*:*)
 	echo pdp10-xkl-tops20
-	exit 0 ;;
+	exit ;;
     *:TOPS-20:*:*)
 	echo pdp10-unknown-tops20
-	exit 0 ;;
+	exit ;;
     *:ITS:*:*)
 	echo pdp10-unknown-its
-	exit 0 ;;
+	exit ;;
+    SEI:*:*:SEIUX)
+        echo mips-sei-seiux${UNAME_RELEASE}
+	exit ;;
+    *:DragonFly:*:*)
+	echo ${UNAME_MACHINE}-unknown-dragonfly`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`
+	exit ;;
+    *:*VMS:*:*)
+    	UNAME_MACHINE=`(uname -p) 2>/dev/null`
+	case "${UNAME_MACHINE}" in
+	    A*) echo alpha-dec-vms ; exit ;;
+	    I*) echo ia64-dec-vms ; exit ;;
+	    V*) echo vax-dec-vms ; exit ;;
+	esac ;;
+    *:XENIX:*:SysV)
+	echo i386-pc-xenix
+	exit ;;
+    i*86:skyos:*:*)
+	echo ${UNAME_MACHINE}-pc-skyos`echo ${UNAME_RELEASE}` | sed -e 's/ .*$//'
+	exit ;;
+    i*86:rdos:*:*)
+	echo ${UNAME_MACHINE}-pc-rdos
+	exit ;;
 esac
 
 #echo '(No uname command or uname output not recognized.)' 1>&2
 #echo "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" 1>&2
 
 eval $set_cc_for_build
 cat >$dummy.c <<EOF
 #ifdef _SEQUENT_
@@ -1231,17 +1356,17 @@ main ()
 #else
 	  ""
 #endif
          ); exit (0);
 #endif
 #endif
 
 #if defined (__arm) && defined (__acorn) && defined (__unix)
-  printf ("arm-acorn-riscix"); exit (0);
+  printf ("arm-acorn-riscix\n"); exit (0);
 #endif
 
 #if defined (hp300) && !defined (hpux)
   printf ("m68k-hp-bsd\n"); exit (0);
 #endif
 
 #if defined (NeXT)
 #if !defined (__ARCHITECTURE__)
@@ -1320,56 +1445,59 @@ main ()
 #if defined (alliant) && defined (i860)
   printf ("i860-alliant-bsd\n"); exit (0);
 #endif
 
   exit (1);
 }
 EOF
 
-$CC_FOR_BUILD -o $dummy $dummy.c 2>/dev/null && $dummy && exit 0
+$CC_FOR_BUILD -o $dummy $dummy.c 2>/dev/null && SYSTEM_NAME=`$dummy` &&
+	{ echo "$SYSTEM_NAME"; exit; }
 
 # Apollos put the system type in the environment.
 
-test -d /usr/apollo && { echo ${ISP}-apollo-${SYSTYPE}; exit 0; }
+test -d /usr/apollo && { echo ${ISP}-apollo-${SYSTYPE}; exit; }
 
 # Convex versions that predate uname can use getsysinfo(1)
 
 if [ -x /usr/convex/getsysinfo ]
 then
     case `getsysinfo -f cpu_type` in
     c1*)
 	echo c1-convex-bsd
-	exit 0 ;;
+	exit ;;
     c2*)
 	if getsysinfo -f scalar_acc
 	then echo c32-convex-bsd
 	else echo c2-convex-bsd
 	fi
-	exit 0 ;;
+	exit ;;
     c34*)
 	echo c34-convex-bsd
-	exit 0 ;;
+	exit ;;
     c38*)
 	echo c38-convex-bsd
-	exit 0 ;;
+	exit ;;
     c4*)
 	echo c4-convex-bsd
-	exit 0 ;;
+	exit ;;
     esac
 fi
 
 cat >&2 <<EOF
 $0: unable to guess system type
 
 This script, last modified $timestamp, has failed to recognize
 the operating system you are using. It is advised that you
 download the most up to date version of the config scripts from
 
-    ftp://ftp.gnu.org/pub/gnu/config/
+  http://savannah.gnu.org/cgi-bin/viewcvs/*checkout*/config/config/config.guess
+and
+  http://savannah.gnu.org/cgi-bin/viewcvs/*checkout*/config/config/config.sub
 
 If the version you run ($0) is already up to date, please
 send the following data and any information you think might be
 pertinent to <config-patches@gnu.org> in order to provide the needed
 information to handle your system.
 
 config.guess timestamp = $timestamp
 
Index: mozilla/build/autoconf/config.sub
===================================================================
RCS file: /cvsroot/mozilla/build/autoconf/config.sub,v
retrieving revision 1.20
diff -u -8 -p -r1.20 config.sub
--- mozilla/build/autoconf/config.sub	18 Apr 2003 10:20:15 -0000	1.20
+++ mozilla/build/autoconf/config.sub	9 Feb 2009 04:00:53 -0000
@@ -1,14 +1,15 @@
 #! /bin/sh
 # Configuration validation subroutine script.
 #   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
-#   2000, 2001, 2002, 2003 Free Software Foundation, Inc.
+#   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
+#   Free Software Foundation, Inc.
 
-timestamp='2003-02-22'
+timestamp='2008-01-16'
 
 # This file is (in principle) common to ALL GNU software.
 # The presence of a machine in this file suggests that SOME GNU software
 # can handle that machine.  It does not imply ALL GNU software can.
 #
 # This file is free software; you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
 # the Free Software Foundation; either version 2 of the License, or
@@ -16,24 +17,25 @@ timestamp='2003-02-22'
 #
 # This program is distributed in the hope that it will be useful,
 # but WITHOUT ANY WARRANTY; without even the implied warranty of
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 # GNU General Public License for more details.
 #
 # You should have received a copy of the GNU General Public License
 # along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place - Suite 330,
-# Boston, MA 02111-1307, USA.
-
+# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
+# 02110-1301, USA.
+#
 # As a special exception to the GNU General Public License, if you
 # distribute this file as part of a program that contains a
 # configuration script generated by Autoconf, you may include it under
 # the same distribution terms that you use for the rest of that program.
 
+
 # Please send patches to <config-patches@gnu.org>.  Submit a context
 # diff and a properly formatted ChangeLog entry.
 #
 # Configuration subroutine to validate and canonicalize a configuration type.
 # Supply the specified configuration type as an argument.
 # If it is invalid, we print an error message on stderr and exit with code 1.
 # Otherwise, we print the canonical config type on stdout and succeed.
 
@@ -65,46 +67,46 @@ Operation modes:
   -t, --time-stamp   print date of last modification, then exit
   -v, --version      print version number, then exit
 
 Report bugs and patches to <config-patches@gnu.org>."
 
 version="\
 GNU config.sub ($timestamp)
 
-Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
-Free Software Foundation, Inc.
+Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
+2002, 2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
 
 This is free software; see the source for copying conditions.  There is NO
 warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
 
 help="
 Try \`$me --help' for more information."
 
 # Parse command line
 while test $# -gt 0 ; do
   case $1 in
     --time-stamp | --time* | -t )
-       echo "$timestamp" ; exit 0 ;;
+       echo "$timestamp" ; exit ;;
     --version | -v )
-       echo "$version" ; exit 0 ;;
+       echo "$version" ; exit ;;
     --help | --h* | -h )
-       echo "$usage"; exit 0 ;;
+       echo "$usage"; exit ;;
     -- )     # Stop option processing
        shift; break ;;
     - )	# Use stdin as input.
        break ;;
     -* )
        echo "$me: invalid option $1$help"
        exit 1 ;;
 
     *local*)
        # First pass through any local machine types.
        echo $1
-       exit 0;;
+       exit ;;
 
     * )
        break ;;
   esac
 done
 
 case $# in
  0) echo "$me: missing argument$help" >&2
@@ -113,17 +115,19 @@ case $# in
  *) echo "$me: too many arguments$help" >&2
     exit 1;;
 esac
 
 # Separate what the user gave into CPU-COMPANY and OS or KERNEL-OS (if any).
 # Here we must recognize all the valid KERNEL-OS combinations.
 maybe_os=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\2/'`
 case $maybe_os in
-  nto-qnx* | linux-gnu* | freebsd*-gnu* | netbsd*-gnu* | storm-chaos* | os2-emx* | rtmk-nova*)
+  nto-qnx* | linux-gnu* | linux-dietlibc | linux-newlib* | linux-uclibc* | \
+  uclinux-uclibc* | uclinux-gnu* | kfreebsd*-gnu* | knetbsd*-gnu* | netbsd*-gnu* | \
+  storm-chaos* | os2-emx* | rtmk-nova*)
     os=-$maybe_os
     basic_machine=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\1/'`
     ;;
   *)
     basic_machine=`echo $1 | sed 's/-[^-]*$//'`
     if [ $basic_machine != $1 ]
     then os=`echo $1 | sed 's/.*-/-/'`
     else os=; fi
@@ -139,17 +143,17 @@ case $os in
 		# Prevent following clause from handling this invalid input.
 		;;
 	-dec* | -mips* | -sequent* | -encore* | -pc532* | -sgi* | -sony* | \
 	-att* | -7300* | -3300* | -delta* | -motorola* | -sun[234]* | \
 	-unicom* | -ibm* | -next | -hp | -isi* | -apollo | -altos* | \
 	-convergent* | -ncr* | -news | -32* | -3600* | -3100* | -hitachi* |\
 	-c[123]* | -convex* | -sun | -crds | -omron* | -dg | -ultra | -tti* | \
 	-harris | -dolphin | -highlevel | -gould | -cbm | -ns | -masscomp | \
-	-apple | -axis)
+	-apple | -axis | -knuth | -cray)
 		os=
 		basic_machine=$1
 		;;
 	-sim | -cisco | -oki | -wec | -winbond)
 		os=
 		basic_machine=$1
 		;;
 	-scout)
@@ -164,32 +168,40 @@ case $os in
 		;;
  	-chorusrdb)
  		os=-chorusrdb
 		basic_machine=$1
  		;;
 	-hiux*)
 		os=-hiuxwe2
 		;;
+	-sco6)
+		os=-sco5v6
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
 	-sco5)
 		os=-sco3.2v5
 		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
 		;;
 	-sco4)
 		os=-sco3.2v4
 		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
 		;;
 	-sco3.2.[4-9]*)
 		os=`echo $os | sed -e 's/sco3.2./sco3.2v/'`
 		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
 		;;
 	-sco3.2v[4-9]*)
 		# Don't forget version if it is 3.2v4 or newer.
 		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
 		;;
+	-sco5v6*)
+		# Don't forget version if it is 3.2v4 or newer.
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
 	-sco*)
 		os=-sco3.2v2
 		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
 		;;
 	-udk*)
 		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
 		;;
 	-isc)
@@ -219,171 +231,196 @@ case $os in
 		os=-mint
 		;;
 esac
 
 # Decode aliases for certain CPU-COMPANY combinations.
 case $basic_machine in
 	# Recognize the basic CPU types without company name.
 	# Some are omitted here because they have special meanings below.
-#### MozillaHack 
-# mips*el
-#### End MozillaHack 
 	1750a | 580 \
 	| a29k \
 	| alpha | alphaev[4-8] | alphaev56 | alphaev6[78] | alphapca5[67] \
 	| alpha64 | alpha64ev[4-8] | alpha64ev56 | alpha64ev6[78] | alpha64pca5[67] \
-	| arc | arm | arm[bl]e | arme[lb] | armv[2345] | armv[345][lb] | avr \
-	| clipper \
+	| am33_2.0 \
+	| arc | arm | arm[bl]e | arme[lb] | armv[2345] | armv[345][lb] | avr | avr32 \
+	| bfin \
+	| c4x | clipper \
 	| d10v | d30v | dlx | dsp16xx \
-	| fr30 | frv \
+	| fido | fr30 | frv \
 	| h8300 | h8500 | hppa | hppa1.[01] | hppa2.0 | hppa2.0[nw] | hppa64 \
 	| i370 | i860 | i960 | ia64 \
-	| ip2k \
-	| m32r | m68000 | m68k | m88k | mcore \
-	| mips | mipsbe | mipseb | mips*el | mipsle \
+	| ip2k | iq2000 \
+	| m32c | m32r | m32rle | m68000 | m68k | m88k \
+	| maxq | mb | microblaze | mcore | mep \
+	| mips | mipsbe | mipseb | mipsel | mipsle \
 	| mips16 \
 	| mips64 | mips64el \
 	| mips64vr | mips64vrel \
 	| mips64orion | mips64orionel \
 	| mips64vr4100 | mips64vr4100el \
 	| mips64vr4300 | mips64vr4300el \
 	| mips64vr5000 | mips64vr5000el \
+	| mips64vr5900 | mips64vr5900el \
 	| mipsisa32 | mipsisa32el \
 	| mipsisa32r2 | mipsisa32r2el \
 	| mipsisa64 | mipsisa64el \
+	| mipsisa64r2 | mipsisa64r2el \
 	| mipsisa64sb1 | mipsisa64sb1el \
 	| mipsisa64sr71k | mipsisa64sr71kel \
 	| mipstx39 | mipstx39el \
 	| mn10200 | mn10300 \
+	| mt \
 	| msp430 \
+	| nios | nios2 \
 	| ns16k | ns32k \
-	| openrisc | or32 \
+	| or32 \
 	| pdp10 | pdp11 | pj | pjl \
 	| powerpc | powerpc64 | powerpc64le | powerpcle | ppcbe \
 	| pyramid \
-	| sh | sh[1234] | sh[23]e | sh[34]eb | shbe | shle | sh[1234]le | sh3ele \
+	| score \
+	| sh | sh[1234] | sh[24]a | sh[23]e | sh[34]eb | sheb | shbe | shle | sh[1234]le | sh3ele \
 	| sh64 | sh64le \
-	| sparc | sparc64 | sparc86x | sparclet | sparclite | sparcv9 | sparcv9b \
-	| strongarm \
-	| tahoe | thumb | tic80 | tron \
+	| sparc | sparc64 | sparc64b | sparc64v | sparc86x | sparclet | sparclite \
+	| sparcv8 | sparcv9 | sparcv9b | sparcv9v \
+	| spu | strongarm \
+	| tahoe | thumb | tic4x | tic80 | tron \
 	| v850 | v850e \
 	| we32k \
-	| x86 | xscale | xstormy16 | xtensa \
+	| x86 | xc16x | xscale | xscalee[bl] | xstormy16 | xtensa \
 	| z8k)
 		basic_machine=$basic_machine-unknown
 		;;
 	m6811 | m68hc11 | m6812 | m68hc12)
 		# Motorola 68HC11/12.
 		basic_machine=$basic_machine-unknown
 		os=-none
 		;;
 	m88110 | m680[12346]0 | m683?2 | m68360 | m5200 | v70 | w65 | z8k)
 		;;
+	ms1)
+		basic_machine=mt-unknown
+		;;
 
 	# We use `pc' rather than `unknown'
 	# because (1) that's what they normally are, and
 	# (2) the word "unknown" tends to confuse beginning users.
 	i*86 | x86_64)
 	  basic_machine=$basic_machine-pc
 	  ;;
 	# Object if more than one company name word.
 	*-*-*)
 		echo Invalid configuration \`$1\': machine \`$basic_machine\' not recognized 1>&2
 		exit 1
 		;;
 	# Recognize the basic CPU types with company name.
-#### MozillaHack 
-# mips*el
-#### End MozillaHack 
 	580-* \
 	| a29k-* \
 	| alpha-* | alphaev[4-8]-* | alphaev56-* | alphaev6[78]-* \
 	| alpha64-* | alpha64ev[4-8]-* | alpha64ev56-* | alpha64ev6[78]-* \
 	| alphapca5[67]-* | alpha64pca5[67]-* | arc-* \
 	| arm-*  | armbe-* | armle-* | armeb-* | armv*-* \
-	| avr-* \
-	| bs2000-* \
+	| avr-* | avr32-* \
+	| bfin-* | bs2000-* \
 	| c[123]* | c30-* | [cjt]90-* | c4x-* | c54x-* | c55x-* | c6x-* \
-	| clipper-* | cydra-* \
+	| clipper-* | craynv-* | cydra-* \
 	| d10v-* | d30v-* | dlx-* \
 	| elxsi-* \
-	| f30[01]-* | f700-* | fr30-* | frv-* | fx80-* \
+	| f30[01]-* | f700-* | fido-* | fr30-* | frv-* | fx80-* \
 	| h8300-* | h8500-* \
 	| hppa-* | hppa1.[01]-* | hppa2.0-* | hppa2.0[nw]-* | hppa64-* \
 	| i*86-* | i860-* | i960-* | ia64-* \
-	| ip2k-* \
-	| m32r-* \
+	| ip2k-* | iq2000-* \
+	| m32c-* | m32r-* | m32rle-* \
 	| m68000-* | m680[012346]0-* | m68360-* | m683?2-* | m68k-* \
-	| m88110-* | m88k-* | mcore-* \
-	| mips-* | mipsbe-* | mipseb-* | mips*el-* | mipsle-* \
+	| m88110-* | m88k-* | maxq-* | mcore-* \
+	| mips-* | mipsbe-* | mipseb-* | mipsel-* | mipsle-* \
 	| mips16-* \
 	| mips64-* | mips64el-* \
 	| mips64vr-* | mips64vrel-* \
 	| mips64orion-* | mips64orionel-* \
 	| mips64vr4100-* | mips64vr4100el-* \
 	| mips64vr4300-* | mips64vr4300el-* \
 	| mips64vr5000-* | mips64vr5000el-* \
+	| mips64vr5900-* | mips64vr5900el-* \
 	| mipsisa32-* | mipsisa32el-* \
 	| mipsisa32r2-* | mipsisa32r2el-* \
 	| mipsisa64-* | mipsisa64el-* \
+	| mipsisa64r2-* | mipsisa64r2el-* \
 	| mipsisa64sb1-* | mipsisa64sb1el-* \
 	| mipsisa64sr71k-* | mipsisa64sr71kel-* \
 	| mipstx39-* | mipstx39el-* \
+	| mmix-* \
+	| mt-* \
 	| msp430-* \
-	| none-* | np1-* | nv1-* | ns16k-* | ns32k-* \
+	| nios-* | nios2-* \
+	| none-* | np1-* | ns16k-* | ns32k-* \
 	| orion-* \
 	| pdp10-* | pdp11-* | pj-* | pjl-* | pn-* | power-* \
 	| powerpc-* | powerpc64-* | powerpc64le-* | powerpcle-* | ppcbe-* \
 	| pyramid-* \
 	| romp-* | rs6000-* \
-	| sh-* | sh[1234]-* | sh[23]e-* | sh[34]eb-* | shbe-* \
+	| sh-* | sh[1234]-* | sh[24]a-* | sh[23]e-* | sh[34]eb-* | sheb-* | shbe-* \
 	| shle-* | sh[1234]le-* | sh3ele-* | sh64-* | sh64le-* \
-	| sparc-* | sparc64-* | sparc86x-* | sparclet-* | sparclite-* \
-	| sparcv9-* | sparcv9b-* | strongarm-* | sv1-* | sx?-* \
+	| sparc-* | sparc64-* | sparc64b-* | sparc64v-* | sparc86x-* | sparclet-* \
+	| sparclite-* \
+	| sparcv8-* | sparcv9-* | sparcv9b-* | sparcv9v-* | strongarm-* | sv1-* | sx?-* \
 	| tahoe-* | thumb-* \
 	| tic30-* | tic4x-* | tic54x-* | tic55x-* | tic6x-* | tic80-* \
 	| tron-* \
 	| v850-* | v850e-* | vax-* \
 	| we32k-* \
-	| x86-* | x86_64-* | xps100-* | xscale-* | xstormy16-* \
-	| xtensa-* \
+	| x86-* | x86_64-* | xc16x-* | xps100-* | xscale-* | xscalee[bl]-* \
+	| xstormy16-* | xtensa*-* \
 	| ymp-* \
 	| z8k-*)
 		;;
+	# Recognize the basic CPU types without company name, with glob match.
+	xtensa*)
+		basic_machine=$basic_machine-unknown
+		;;
 	# Recognize the various machine names and aliases which stand
 	# for a CPU type and a company and sometimes even an OS.
 	386bsd)
 		basic_machine=i386-unknown
 		os=-bsd
 		;;
 	3b1 | 7300 | 7300-att | att-7300 | pc7300 | safari | unixpc)
 		basic_machine=m68000-att
 		;;
 	3b*)
 		basic_machine=we32k-att
 		;;
 	a29khif)
 		basic_machine=a29k-amd
 		os=-udi
 		;;
+    	abacus)
+		basic_machine=abacus-unknown
+		;;
 	adobe68k)
 		basic_machine=m68010-adobe
 		os=-scout
 		;;
 	alliant | fx80)
 		basic_machine=fx80-alliant
 		;;
 	altos | altos3068)
 		basic_machine=m68k-altos
 		;;
 	am29k)
 		basic_machine=a29k-none
 		os=-bsd
 		;;
+	amd64)
+		basic_machine=x86_64-pc
+		;;
+	amd64-*)
+		basic_machine=x86_64-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
 	amdahl)
 		basic_machine=580-amdahl
 		os=-sysv
 		;;
 	amiga | amiga-*)
 		basic_machine=m68k-unknown
 		;;
 	amigaos | amigados)
@@ -405,16 +442,24 @@ case $basic_machine in
 	aux)
 		basic_machine=m68k-apple
 		os=-aux
 		;;
 	balance)
 		basic_machine=ns32k-sequent
 		os=-dynix
 		;;
+	blackfin)
+		basic_machine=bfin-unknown
+		os=-linux
+		;;
+	blackfin-*)
+		basic_machine=bfin-`echo $basic_machine | sed 's/^[^-]*-//'`
+		os=-linux
+		;;
 	c90)
 		basic_machine=c90-cray
 		os=-unicos
 		;;
 	convex-c1)
 		basic_machine=c1-convex
 		os=-bsd
 		;;
@@ -433,22 +478,37 @@ case $basic_machine in
 	convex-c38)
 		basic_machine=c38-convex
 		os=-bsd
 		;;
 	cray | j90)
 		basic_machine=j90-cray
 		os=-unicos
 		;;
+	craynv)
+		basic_machine=craynv-cray
+		os=-unicosmp
+		;;
+	cr16)
+		basic_machine=cr16-unknown
+		os=-elf
+		;;
 	crds | unos)
 		basic_machine=m68k-crds
 		;;
+	crisv32 | crisv32-* | etraxfs*)
+		basic_machine=crisv32-axis
+		;;
 	cris | cris-* | etrax*)
 		basic_machine=cris-axis
 		;;
+	crx)
+		basic_machine=crx-unknown
+		os=-elf
+		;;
 	da30 | da30-*)
 		basic_machine=m68k-da30
 		;;
 	decstation | decstation-3100 | pmax | pmax-* | pmin | dec3100 | decstatn)
 		basic_machine=mips-dec
 		;;
 	decsystem10* | dec10*)
 		basic_machine=pdp10-dec
@@ -461,16 +521,20 @@ case $basic_machine in
 	delta | 3300 | motorola-3300 | motorola-delta \
 	      | 3300-motorola | delta-motorola)
 		basic_machine=m68k-motorola
 		;;
 	delta88)
 		basic_machine=m88k-motorola
 		os=-sysv3
 		;;
+	djgpp)
+		basic_machine=i586-pc
+		os=-msdosdjgpp
+		;;
 	dpx20 | dpx20-*)
 		basic_machine=rs6000-bull
 		os=-bosx
 		;;
 	dpx2* | dpx2*-bull)
 		basic_machine=m68k-bull
 		os=-sysv3
 		;;
@@ -611,66 +675,71 @@ case $basic_machine in
 			os=-irix4
 			;;
 		esac
 		;;
 	isi68 | isi)
 		basic_machine=m68k-isi
 		os=-sysv
 		;;
+	m68knommu)
+		basic_machine=m68k-unknown
+		os=-linux
+		;;
+	m68knommu-*)
+		basic_machine=m68k-`echo $basic_machine | sed 's/^[^-]*-//'`
+		os=-linux
+		;;
 	m88k-omron*)
 		basic_machine=m88k-omron
 		;;
 	magnum | m3230)
 		basic_machine=mips-mips
 		os=-sysv
 		;;
 	merlin)
 		basic_machine=ns32k-utek
 		os=-sysv
 		;;
 	mingw32)
 		basic_machine=i386-pc
 		os=-mingw32
 		;;
-#### MozillaHack 
-	i386-msvc | msvc)
-		basic_machine=i386-pc
-		os=-msvc
+	mingw32ce)
+		basic_machine=arm-unknown
+		os=-mingw32ce
 		;;
-#### End MozillaHack 
 	miniframe)
 		basic_machine=m68000-convergent
 		;;
 	*mint | -mint[0-9]* | *MiNT | *MiNT[0-9]*)
 		basic_machine=m68k-atari
 		os=-mint
 		;;
 	mips3*-*)
 		basic_machine=`echo $basic_machine | sed -e 's/mips3/mips64/'`
 		;;
 	mips3*)
 		basic_machine=`echo $basic_machine | sed -e 's/mips3/mips64/'`-unknown
 		;;
-	mmix*)
-		basic_machine=mmix-knuth
-		os=-mmixware
-		;;
 	monitor)
 		basic_machine=m68k-rom68k
 		os=-coff
 		;;
 	morphos)
 		basic_machine=powerpc-unknown
 		os=-morphos
 		;;
 	msdos)
 		basic_machine=i386-pc
 		os=-msdos
 		;;
+	ms1-*)
+		basic_machine=`echo $basic_machine | sed -e 's/ms1-/mt-/'`
+		;;
 	mvs)
 		basic_machine=i370-ibm
 		os=-mvs
 		;;
 	ncr3000)
 		basic_machine=i486-ncr
 		os=-sysv4
 		;;
@@ -729,30 +798,29 @@ case $basic_machine in
 		;;
 	nonstopux)
 		basic_machine=mips-compaq
 		os=-nonstopux
 		;;
 	np1)
 		basic_machine=np1-gould
 		;;
-	nv1)
-		basic_machine=nv1-cray
-		os=-unicosmp
-		;;
 	nsr-tandem)
 		basic_machine=nsr-tandem
 		;;
 	op50n-* | op60c-*)
 		basic_machine=hppa1.1-oki
 		os=-proelf
 		;;
-	or32 | or32-*)
+	openrisc | openrisc-*)
 		basic_machine=or32-unknown
-		os=-coff
+		;;
+	os400)
+		basic_machine=powerpc-ibm
+		os=-os400
 		;;
 	OSE68000 | ose68000)
 		basic_machine=m68000-ericsson
 		os=-ose
 		;;
 	os68k)
 		basic_machine=m68k-none
 		os=-os68k
@@ -760,43 +828,63 @@ case $basic_machine in
 	pa-hitachi)
 		basic_machine=hppa1.1-hitachi
 		os=-hiuxwe2
 		;;
 	paragon)
 		basic_machine=i860-intel
 		os=-osf
 		;;
+	parisc)
+		basic_machine=hppa-unknown
+		os=-linux
+		;;
+	parisc-*)
+		basic_machine=hppa-`echo $basic_machine | sed 's/^[^-]*-//'`
+		os=-linux
+		;;
 	pbd)
 		basic_machine=sparc-tti
 		;;
 	pbb)
 		basic_machine=m68k-tti
 		;;
 	pc532 | pc532-*)
 		basic_machine=ns32k-pc532
 		;;
+	pc98)
+		basic_machine=i386-pc
+		;;
+	pc98-*)
+		basic_machine=i386-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
 	pentium | p5 | k5 | k6 | nexgen | viac3)
 		basic_machine=i586-pc
 		;;
 	pentiumpro | p6 | 6x86 | athlon | athlon_*)
 		basic_machine=i686-pc
 		;;
-	pentiumii | pentium2)
+	pentiumii | pentium2 | pentiumiii | pentium3)
 		basic_machine=i686-pc
 		;;
+	pentium4)
+		basic_machine=i786-pc
+		;;
 	pentium-* | p5-* | k5-* | k6-* | nexgen-* | viac3-*)
 		basic_machine=i586-`echo $basic_machine | sed 's/^[^-]*-//'`
 		;;
 	pentiumpro-* | p6-* | 6x86-* | athlon-*)
 		basic_machine=i686-`echo $basic_machine | sed 's/^[^-]*-//'`
 		;;
-	pentiumii-* | pentium2-*)
+	pentiumii-* | pentium2-* | pentiumiii-* | pentium3-*)
 		basic_machine=i686-`echo $basic_machine | sed 's/^[^-]*-//'`
 		;;
+	pentium4-*)
+		basic_machine=i786-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
 	pn)
 		basic_machine=pn-gould
 		;;
 	power)	basic_machine=power-ibm
 		;;
 	ppc)	basic_machine=powerpc-unknown
 		;;
 	ppc-*)	basic_machine=powerpc-`echo $basic_machine | sed 's/^[^-]*-//'`
@@ -819,16 +907,20 @@ case $basic_machine in
 		;;
 	ps2)
 		basic_machine=i386-ibm
 		;;
 	pw32)
 		basic_machine=i586-unknown
 		os=-pw32
 		;;
+	rdos)
+		basic_machine=i386-pc
+		os=-rdos
+		;;
 	rom68k)
 		basic_machine=m68k-rom68k
 		os=-coff
 		;;
 	rm[46]00)
 		basic_machine=mips-siemens
 		;;
 	rtpc | rtpc-*)
@@ -845,23 +937,37 @@ case $basic_machine in
 		os=-udi
 		;;
 	sb1)
 		basic_machine=mipsisa64sb1-unknown
 		;;
 	sb1el)
 		basic_machine=mipsisa64sb1el-unknown
 		;;
+	sde)
+		basic_machine=mipsisa32-sde
+		os=-elf
+		;;
+	sei)
+		basic_machine=mips-sei
+		os=-seiux
+		;;
 	sequent)
 		basic_machine=i386-sequent
 		;;
 	sh)
 		basic_machine=sh-hitachi
 		os=-hms
 		;;
+	sh5el)
+		basic_machine=sh5le-unknown
+		;;
+	sh64)
+		basic_machine=sh64-unknown
+		;;
 	sparclite-wrs | simso-wrs)
 		basic_machine=sparclite-wrs
 		os=-vxworks
 		;;
 	sps7)
 		basic_machine=m68k-bull
 		os=-sysv2
 		;;
@@ -926,45 +1032,49 @@ case $basic_machine in
 	t3e)
 		basic_machine=alphaev5-cray
 		os=-unicos
 		;;
 	t90)
 		basic_machine=t90-cray
 		os=-unicos
 		;;
-        tic4x | c4x*)
-		basic_machine=tic4x-unknown
-		os=-coff
-		;;
 	tic54x | c54x*)
 		basic_machine=tic54x-unknown
 		os=-coff
 		;;
 	tic55x | c55x*)
 		basic_machine=tic55x-unknown
 		os=-coff
 		;;
 	tic6x | c6x*)
 		basic_machine=tic6x-unknown
 		os=-coff
 		;;
+	tile*)
+		basic_machine=tile-unknown
+		os=-linux-gnu
+		;;
 	tx39)
 		basic_machine=mipstx39-unknown
 		;;
 	tx39el)
 		basic_machine=mipstx39el-unknown
 		;;
 	toad1)
 		basic_machine=pdp10-xkl
 		os=-tops20
 		;;
 	tower | tower-32)
 		basic_machine=m68k-ncr
 		;;
+	tpf)
+		basic_machine=s390x-ibm
+		os=-tpf
+		;;
 	udi29k)
 		basic_machine=a29k-amd
 		os=-udi
 		;;
 	ultra3)
 		basic_machine=a29k-nyu
 		os=-sym1
 		;;
@@ -998,16 +1108,20 @@ case $basic_machine in
 	w65*)
 		basic_machine=w65-wdc
 		os=-none
 		;;
 	w89k-*)
 		basic_machine=hppa1.1-winbond
 		os=-proelf
 		;;
+	xbox)
+		basic_machine=i686-pc
+		os=-mingw32
+		;;
 	xps | xps100)
 		basic_machine=xps100-honeywell
 		;;
 	ymp)
 		basic_machine=ymp-cray
 		os=-unicos
 		;;
 	z8k-*-coff)
@@ -1028,39 +1142,39 @@ case $basic_machine in
 		basic_machine=hppa1.1-oki
 		;;
 	op60c)
 		basic_machine=hppa1.1-oki
 		;;
 	romp)
 		basic_machine=romp-ibm
 		;;
+	mmix)
+		basic_machine=mmix-knuth
+		;;
 	rs6000)
 		basic_machine=rs6000-ibm
 		;;
 	vax)
 		basic_machine=vax-dec
 		;;
 	pdp10)
 		# there are many clones, so DEC is not a safe bet
 		basic_machine=pdp10-unknown
 		;;
 	pdp11)
 		basic_machine=pdp11-dec
 		;;
 	we32k)
 		basic_machine=we32k-att
 		;;
-	sh3 | sh4 | sh[34]eb | sh[1234]le | sh[23]ele)
+	sh[1234] | sh[24]a | sh[34]eb | sh[1234]le | sh[23]ele)
 		basic_machine=sh-unknown
 		;;
-	sh64)
-		basic_machine=sh64-unknown
-		;;
-	sparc | sparcv9 | sparcv9b)
+	sparc | sparcv8 | sparcv9 | sparcv9b | sparcv9v)
 		basic_machine=sparc-sun
 		;;
 	cydra)
 		basic_machine=cydra-cydrome
 		;;
 	orion)
 		basic_machine=orion-highlevel
 		;;
@@ -1116,40 +1230,40 @@ case $os in
 		;;
 	-gnu/linux*)
 		os=`echo $os | sed -e 's|gnu/linux|linux-gnu|'`
 		;;
 	# First accept the basic system types.
 	# The portable systems comes first.
 	# Each alternative MUST END IN A *, to match a version number.
 	# -sysv* is not here because it comes later, after sysvr4.
-#### MozillaHack 
-# msvc
-#### End MozillaHack 
 	-gnu* | -bsd* | -mach* | -minix* | -genix* | -ultrix* | -irix* \
 	      | -*vms* | -sco* | -esix* | -isc* | -aix* | -sunos | -sunos[34]*\
 	      | -hpux* | -unos* | -osf* | -luna* | -dgux* | -solaris* | -sym* \
 	      | -amigaos* | -amigados* | -msdos* | -newsos* | -unicos* | -aof* \
 	      | -aos* \
 	      | -nindy* | -vxsim* | -vxworks* | -ebmon* | -hms* | -mvs* \
 	      | -clix* | -riscos* | -uniplus* | -iris* | -rtu* | -xenix* \
-	      | -hiux* | -386bsd* | -netbsd* | -openbsd* | -freebsd* | -riscix* \
-	      | -lynxos* | -bosx* | -nextstep* | -cxux* | -aout* | -elf* | -oabi* \
+	      | -hiux* | -386bsd* | -knetbsd* | -mirbsd* | -netbsd* \
+	      | -openbsd* | -solidbsd* \
+	      | -ekkobsd* | -kfreebsd* | -freebsd* | -riscix* | -lynxos* \
+	      | -bosx* | -nextstep* | -cxux* | -aout* | -elf* | -oabi* \
 	      | -ptx* | -coff* | -ecoff* | -winnt* | -domain* | -vsta* \
 	      | -udi* | -eabi* | -lites* | -ieee* | -go32* | -aux* \
 	      | -chorusos* | -chorusrdb* \
 	      | -cygwin* | -pe* | -psos* | -moss* | -proelf* | -rtems* \
-	      | -mingw32* | -linux-gnu* | -uxpv* | -beos* | -mpeix* | -udk* \
+	      | -mingw32* | -linux-gnu* | -linux-newlib* | -linux-uclibc* \
+	      | -uxpv* | -beos* | -mpeix* | -udk* \
 	      | -interix* | -uwin* | -mks* | -rhapsody* | -darwin* | -opened* \
-	      | -msvc* \
 	      | -openstep* | -oskit* | -conix* | -pw32* | -nonstopux* \
 	      | -storm-chaos* | -tops10* | -tenex* | -tops20* | -its* \
 	      | -os2* | -vos* | -palmos* | -uclinux* | -nucleus* \
 	      | -morphos* | -superux* | -rtmk* | -rtmk-nova* | -windiss* \
-	      | -powermax* | -dnix*)
+	      | -powermax* | -dnix* | -nx6 | -nx7 | -sei* | -dragonfly* \
+	      | -skyos* | -haiku* | -rdos* | -toppers* | -drops*)
 	# Remember, each alternative MUST END IN *, to match a version number.
 		;;
 	-qnx*)
 		case $basic_machine in
 		    x86-* | i*86-*)
 			;;
 		    *)
 			os=-nto$os
@@ -1157,34 +1271,40 @@ case $os in
 		esac
 		;;
 	-nto-qnx*)
 		;;
 	-nto*)
 		os=`echo $os | sed -e 's|nto|nto-qnx|'`
 		;;
 	-sim | -es1800* | -hms* | -xray | -os68k* | -none* | -v88r* \
-	      | -windows* | -osx | -abug | -netware* | -os9* | -beos* \
+	      | -windows* | -osx | -abug | -netware* | -os9* | -beos* | -haiku* \
 	      | -macos* | -mpw* | -magic* | -mmixware* | -mon960* | -lnews*)
 		;;
 	-mac*)
 		os=`echo $os | sed -e 's|mac|macos|'`
 		;;
+	-linux-dietlibc)
+		os=-linux-dietlibc
+		;;
 	-linux*)
 		os=`echo $os | sed -e 's|linux|linux-gnu|'`
 		;;
 	-sunos5*)
 		os=`echo $os | sed -e 's|sunos5|solaris2|'`
 		;;
 	-sunos6*)
 		os=`echo $os | sed -e 's|sunos6|solaris3|'`
 		;;
 	-opened*)
 		os=-openedition
 		;;
+        -os400*)
+		os=-os400
+		;;
 	-wince*)
 		os=-wince
 		;;
 	-osfrose*)
 		os=-osfrose
 		;;
 	-osf*)
 		os=-osf
@@ -1196,16 +1316,19 @@ case $os in
 		os=-bsd
 		;;
 	-acis*)
 		os=-aos
 		;;
 	-atheos*)
 		os=-atheos
 		;;
+	-syllable*)
+		os=-syllable
+		;;
 	-386bsd)
 		os=-bsd
 		;;
 	-ctix* | -uts*)
 		os=-sysv
 		;;
 	-nova*)
 		os=-rtmk-nova
@@ -1218,16 +1341,19 @@ case $os in
 		;;
 	# Preserve the version number of sinix5.
 	-sinix5.*)
 		os=`echo $os | sed -e 's|sinix|sysv|'`
 		;;
 	-sinix*)
 		os=-sysv4
 		;;
+        -tpf*)
+		os=-tpf
+		;;
 	-triton*)
 		os=-sysv3
 		;;
 	-oss*)
 		os=-sysv3
 		;;
 	-svr4)
 		os=-sysv4
@@ -1254,16 +1380,19 @@ case $os in
 		os=-mint
 		;;
 	-aros*)
 		os=-aros
 		;;
 	-kaos*)
 		os=-kaos
 		;;
+	-zvmoe)
+		os=-zvmoe
+		;;
 	-none)
 		;;
 	*)
 		# Get rid of the `-' at the beginning of $os.
 		os=`echo $os | sed 's/[^-]*-//'`
 		echo Invalid configuration \`$1\': system \`$os\' not recognized 1>&2
 		exit 1
 		;;
@@ -1276,25 +1405,34 @@ else
 
 # Note that if you're going to try to match "-MANUFACTURER" here (say,
 # "-sun"), then you have to tell the case statement up towards the top
 # that MANUFACTURER isn't an operating system.  Otherwise, code above
 # will signal an error saying that MANUFACTURER isn't an operating
 # system, and we'll never get to this point.
 
 case $basic_machine in
+        score-*)
+		os=-elf
+		;;
+        spu-*)
+		os=-elf
+		;;
 	*-acorn)
 		os=-riscix1.2
 		;;
 	arm*-rebel)
 		os=-linux
 		;;
 	arm*-semi)
 		os=-aout
 		;;
+        c4x-* | tic4x-*)
+        	os=-coff
+		;;
 	# This must come before the *-dec entry.
 	pdp10-*)
 		os=-tops20
 		;;
 	pdp11-*)
 		os=-none
 		;;
 	*-dec | vax-*)
@@ -1310,16 +1448,19 @@ case $basic_machine in
 		os=-sunos3
 		# This also exists in the configure program, but was not the
 		# default.
 		# os=-sunos4
 		;;
 	m68*-cisco)
 		os=-aout
 		;;
+        mep-*)
+		os=-elf
+		;;
 	mips*-cisco)
 		os=-elf
 		;;
 	mips*-*)
 		os=-elf
 		;;
 	or32-*)
 		os=-coff
@@ -1328,19 +1469,25 @@ case $basic_machine in
 		os=-sysv3
 		;;
 	sparc-* | *-sun)
 		os=-sunos4.1.1
 		;;
 	*-be)
 		os=-beos
 		;;
+	*-haiku)
+		os=-haiku
+		;;
 	*-ibm)
 		os=-aix
 		;;
+    	*-knuth)
+		os=-mmixware
+		;;
 	*-wec)
 		os=-proelf
 		;;
 	*-winbond)
 		os=-proelf
 		;;
 	*-oki)
 		os=-proelf
@@ -1463,19 +1610,25 @@ case $basic_machine in
 				vendor=omron
 				;;
 			-genix*)
 				vendor=ns
 				;;
 			-mvs* | -opened*)
 				vendor=ibm
 				;;
+			-os400*)
+				vendor=ibm
+				;;
 			-ptx*)
 				vendor=sequent
 				;;
+			-tpf*)
+				vendor=ibm
+				;;
 			-vxsim* | -vxworks* | -windiss*)
 				vendor=wrs
 				;;
 			-aux*)
 				vendor=apple
 				;;
 			-hms*)
 				vendor=hitachi
@@ -1490,16 +1643,16 @@ case $basic_machine in
 				vendor=stratus
 				;;
 		esac
 		basic_machine=`echo $basic_machine | sed "s/unknown/$vendor/"`
 		;;
 esac
 
 echo $basic_machine$os
-exit 0
+exit
 
 # Local variables:
 # eval: (add-hook 'write-file-hooks 'time-stamp)
 # time-stamp-start: "timestamp='"
 # time-stamp-format: "%:y-%02m-%02d"
 # time-stamp-end: "'"
 # End:
Index: mozilla/calendar/base/content/preferences/preferences.xul
===================================================================
RCS file: /cvsroot/mozilla/calendar/base/content/preferences/preferences.xul,v
retrieving revision 1.1.2.6
diff -u -8 -p -r1.1.2.6 preferences.xul
--- mozilla/calendar/base/content/preferences/preferences.xul	14 Mar 2007 09:08:19 -0000	1.1.2.6
+++ mozilla/calendar/base/content/preferences/preferences.xul	9 Feb 2009 04:00:56 -0000
@@ -66,17 +66,22 @@
 #ifdef XP_UNIX
 #ifdef XP_MACOSX
             style="&prefWindow.styleMac;">
 #else
             title="&prefWindow.titleGNOME;"
             style="&prefWindow.styleGNOME;">
 #endif
 #endif
+#ifdef XP_BEOS
+            title="&prefWindow.titleGNOME;"
+            style="&prefWindow.styleGNOME;">
 #endif
+#endif
+
 
     <prefpane id="paneGeneral"
               label="&paneGeneral.title;"
               onpaneload="gCalendarGeneralPane.init();"
               src="chrome://calendar/content/preferences/general.xul">
         <vbox id="calPreferencesBoxGeneral"/>
     </prefpane>
 
Index: mozilla/calendar/libical/src/libical/Makefile.in
===================================================================
RCS file: /cvsroot/mozilla/calendar/libical/src/libical/Makefile.in,v
retrieving revision 1.3.6.1
diff -u -8 -p -r1.3.6.1 Makefile.in
--- mozilla/calendar/libical/src/libical/Makefile.in	27 Dec 2007 10:03:57 -0000	1.3.6.1
+++ mozilla/calendar/libical/src/libical/Makefile.in	9 Feb 2009 04:00:58 -0000
@@ -84,17 +84,17 @@ CSRCS =				\
         $(NULL)
 
 ifeq (,$(filter -DHAVE_SNPRINTF=1,$(ACDEFINES)))
 CSRCS += vsnprintf.c
 endif
 
 DEFINES += -DHAVE_CONFIG_H
 
-ifneq (,$(filter BeOS Darwin OpenVMS NetBSD FreeBSD,$(OS_ARCH)))
+ifneq (,$(filter BeOS Haiku Darwin OpenVMS NetBSD FreeBSD,$(OS_ARCH)))
 DEFINES	+= -D__USE_BSD=1
 endif
 
 LOCAL_INCLUDES = -I$(srcdir)/../.. -I$(srcdir) -I.
 
 SRCS_IN_OBJDIR	= 1
 
 include $(topsrcdir)/config/rules.mk
Index: mozilla/calendar/sunbird/app/Makefile.in
===================================================================
RCS file: /cvsroot/mozilla/calendar/sunbird/app/Makefile.in,v
retrieving revision 1.21.2.23
diff -u -8 -p -r1.21.2.23 Makefile.in
--- mozilla/calendar/sunbird/app/Makefile.in	4 May 2008 01:32:07 -0000	1.21.2.23
+++ mozilla/calendar/sunbird/app/Makefile.in	9 Feb 2009 04:01:06 -0000
@@ -79,18 +79,22 @@ include $(topsrcdir)/config/rules.mk
 else
 # Build a binary bootstrapping with XRE_main
 
 MOZILLA_INTERNAL_API = 1
 
 ifeq ($(USE_SHORT_LIBNAME), 1)
 PROGRAM = sunbird$(BIN_SUFFIX)
 else
+ifeq (,$(filter-out BeOS Haiku, $(OS_ARCH)))
+PROGRAM = sunbird$(BIN_SUFFIX)
+else
 PROGRAM = sunbird-bin$(BIN_SUFFIX)
 endif
+endif
 
 REQUIRES = \
 	appshell \
 	string \
 	xpcom \
 	xulapp \
 	$(NULL)
 
@@ -189,17 +193,17 @@ endif
 ifdef BUILD_STATIC_LIBS
 RCFLAGS += -DMOZ_STATIC_BUILD
 endif
 ifdef DEBUG
 RCFLAGS += -DDEBUG
 endif
 endif
 
-ifeq ($(OS_ARCH),BeOS)
+ifeq (,$(filter-out BeOS Haiku, $(OS_ARCH)))
 ifdef BUILD_STATIC_LIBS
 OS_LIBS += -ltracker -lgame
 endif
 endif
 
 ifeq ($(OS_ARCH),OS2)
 RESFILE=splashos2.res
 RCFLAGS += -DMOZ_SUNBIRD
@@ -261,17 +265,17 @@ $(EXE_DEF_FILE):
 	@echo 	WinQueryProperty		= PMMERGE.5450 >>$(EXE_DEF_FILE)
 	@echo 	WinRemoveProperty		= PMMERGE.5451 >>$(EXE_DEF_FILE)
 	@echo 	WinSetProperty			= PMMERGE.5452 >>$(EXE_DEF_FILE)
 
 LDFLAGS += -Zlinker /NOE
 endif
 endif
 
-ifneq (,$(filter-out OS2 WINNT,$(OS_ARCH)))
+ifneq (,$(filter-out OS2 WINNT BeOS Haiku,$(OS_ARCH)))
 
 sunbird:: mozilla.in Makefile.in Makefile $(DEPTH)/config/autoconf.mk
 	cat $< | sed -e "s|%MOZAPPDIR%|$(mozappdir)|" \
                 -e "s|%MOZ_USER_DIR%|.mozilla/sunbird|" \
 		-e "s|%MREDIR%|$(mredir)|" > $@
 	chmod +x $@
 
 libs:: sunbird
Index: mozilla/config/config.mk
===================================================================
RCS file: /cvsroot/mozilla/config/config.mk,v
retrieving revision 3.337.2.12
diff -u -8 -p -r3.337.2.12 config.mk
--- mozilla/config/config.mk	23 Nov 2007 21:12:26 -0000	3.337.2.12
+++ mozilla/config/config.mk	9 Feb 2009 04:01:20 -0000
@@ -105,19 +105,16 @@ AUTOCONF_TOOLS	= $(topsrcdir)/build/auto
 
 ifeq ($(OS_ARCH),QNX)
 ifeq ($(OS_TARGET),NTO)
 LD		:= qcc -Vgcc_ntox86 -nostdlib
 else
 LD		:= $(CC)
 endif
 endif
-ifeq ($(OS_ARCH),BeOS)
-BEOS_ADDON_WORKAROUND	= 1
-endif
 
 #
 # Strip off the excessively long version numbers on these platforms,
 # but save the version to allow multiple versions of the same base
 # platform to be built in the same tree.
 #
 ifneq (,$(filter FreeBSD HP-UX IRIX Linux NetBSD OpenBSD OSF1 SunOS,$(OS_ARCH)))
 OS_RELEASE	:= $(basename $(OS_RELEASE))
Index: mozilla/config/rules.mk
===================================================================
RCS file: /cvsroot/mozilla/config/rules.mk,v
retrieving revision 3.487.2.9
diff -u -8 -p -r3.487.2.9 rules.mk
--- mozilla/config/rules.mk	18 Dec 2007 21:33:08 -0000	3.487.2.9
+++ mozilla/config/rules.mk	9 Feb 2009 04:01:24 -0000
@@ -512,17 +512,17 @@ ifeq ($(OS_ARCH),Linux)
 ifdef IS_COMPONENT
 EXTRA_DSO_LDOPTS += -Wl,-Bsymbolic
 endif
 endif 
 
 #
 # BeOS: add -Bsymbolic flag for components
 # 
-ifeq ($(OS_ARCH),BeOS)
+ifeq (,$(filter BeOS Haiku,$(OS_ARCH)))
 ifdef IS_COMPONENT
 EXTRA_DSO_LDOPTS += -Wl,-Bsymbolic
 endif
 endif 
 
 #
 # MINGW32
 #
@@ -672,19 +672,23 @@ ifdef BEOS_ADDON_WORKAROUND
 	( cd $(FINAL_TARGET)/components && $(CC) -nostart -o $(SHARED_LIBRARY).stub $(SHARED_LIBRARY) )
 endif
 else # ! IS_COMPONENT
 ifneq (,$(filter OS2 WINNT WINCE,$(OS_ARCH)))
 	$(INSTALL) $(IFLAGS2) $(IMPORT_LIBRARY) $(DIST)/lib
 else
 	$(INSTALL) $(IFLAGS2) $(SHARED_LIBRARY) $(DIST)/lib
 endif
+ifeq (,$(filter-out BeOS Haiku, $(OS_ARCH)))
+	$(INSTALL) $(IFLAGS2) $(SHARED_LIBRARY) $(FINAL_TARGET)/lib
+else
 	$(INSTALL) $(IFLAGS2) $(SHARED_LIBRARY) $(FINAL_TARGET)
+endif
 ifdef BEOS_ADDON_WORKAROUND
-	( cd $(FINAL_TARGET) && $(CC) -nostart -o $(SHARED_LIBRARY).stub $(SHARED_LIBRARY) )
+	( cd $(FINAL_TARGET)/lib && $(CC) -nostart -o $(SHARED_LIBRARY).stub $(SHARED_LIBRARY) )
 endif
 endif # IS_COMPONENT
 endif # SHARED_LIBRARY
 ifdef PROGRAM
 	$(INSTALL) $(IFLAGS2) $(PROGRAM) $(FINAL_TARGET)
 endif
 ifdef SIMPLE_PROGRAMS
 	$(INSTALL) $(IFLAGS2) $(SIMPLE_PROGRAMS) $(FINAL_TARGET)
@@ -822,17 +826,17 @@ endif # OS2
 endif # WINCE
 
 ifdef ENABLE_STRIP
 	$(STRIP) $@
 endif
 ifdef MOZ_POST_PROGRAM_COMMAND
 	$(MOZ_POST_PROGRAM_COMMAND) $@
 endif
-ifeq ($(OS_ARCH),BeOS)
+ifneq (,$(filter BeOS Haiku,$(OS_ARCH)))
 ifdef BEOS_PROGRAM_RESOURCE
 	xres -o $@ $(BEOS_PROGRAM_RESOURCE)
 	mimeset $@
 endif
 endif # BeOS
 
 $(HOST_PROGRAM): $(HOST_PROGOBJS) $(HOST_LIBS_DEPS) $(HOST_EXTRA_DEPS) Makefile Makefile.in
 ifeq ($(MOZ_OS2_TOOLS),VACPP)
Index: mozilla/directory/c-sdk/build.mk
===================================================================
RCS file: /cvsroot/mozilla/directory/c-sdk/build.mk,v
retrieving revision 5.0.2.15.4.1
diff -u -8 -p -r5.0.2.15.4.1 build.mk
--- mozilla/directory/c-sdk/build.mk	3 Feb 2006 14:44:29 -0000	5.0.2.15.4.1
+++ mozilla/directory/c-sdk/build.mk	9 Feb 2009 04:01:33 -0000
@@ -437,17 +437,17 @@ endif #!os2
 
 ifeq ($(OS_ARCH), OSF1)
 # The linker on OSF/1 gets confused if it finds an so_locations file
 # that doesn't meet its expectations, so we arrange to remove it before
 # linking.
 SO_FILES_TO_REMOVE=so_locations
 endif
 
-ifneq (,$(filter BeOS Darwin NetBSD,$(OS_ARCH)))
+ifneq (,$(filter BeOS Haiku Darwin NetBSD,$(OS_ARCH)))
 LINK_DLL	= $(MKSHLIB) $(OBJS)
 endif
 
 ifeq ($(OS_ARCH), HP-UX)
 # On HPUX, we need a couple of changes:
 # 1) Use the C++ compiler for linking, which will pass the +eh flag on down to the
 #    linker so the correct exception-handling-aware libC gets used (libnshttpd.sl
 #    needs this).
Index: mozilla/directory/c-sdk/configure.in
===================================================================
RCS file: /cvsroot/mozilla/directory/c-sdk/configure.in,v
retrieving revision 5.0.2.34.4.3
diff -u -8 -p -r5.0.2.34.4.3 configure.in
--- mozilla/directory/c-sdk/configure.in	11 Jul 2007 20:43:19 -0000	5.0.2.34.4.3
+++ mozilla/directory/c-sdk/configure.in	9 Feb 2009 04:01:39 -0000
@@ -355,17 +355,17 @@ fi
 if test -z "$SKIP_PATH_CHECKS"; then
     AC_PATH_PROG(WHOAMI, $WHOAMI whoami, echo not_whoami)
 fi
 
 if test -n "$MOZ_DEBUG"; then
     AC_DEFINE(DEBUG)
     DEFINES="$DEFINES -UNDEBUG"
     case "${target_os}" in
-    beos*)
+    beos*|haiku*)
         DEFINES="$DEFINES -DDEBUG_${USER}"
         ;;
     msvc*|mks*|cygwin*|mingw*|os2*)
         DEFINES="$DEFINES -DDEBUG_`echo ${USERNAME} | sed -e 's| |_|g'`"
         ;;
     *) 
         DEFINES="$MOZ_DEBUG_ENABLE_DEFS -DDEBUG_`$WHOAMI`"
         ;;
@@ -728,17 +728,17 @@ case "$host" in
 *-cygwin*|*-msvc*|*-mks*)
     CYGWIN_WRAPPER='sh $(topsrcdir)/config/cygwin-wrapper'
     NSINSTALL='$(CYGWIN_WRAPPER) nsinstall'
     if test "`${PERL} -v | grep -c cygwin  2>/dev/null`" = 0; then
         PERL='$(CYGWIN_WRAPPER) perl'
     fi
     WIN_TOP_SRC=`cygpath -a -w $srcdir | sed -e 's|\\\\|/|g'`
     ;;
-*-beos*)
+*-beos*|*-haiku*)
     HOST_CFLAGS="$HOST_CFLAGS -DXP_BEOS -DBeOS -DBEOS -D_POSIX_SOURCE"
     ;;
 *os2*)
     ;;
 *)
     HOST_CFLAGS="$HOST_CFLAGS -DXP_UNIX"
     ;;
 esac
@@ -807,34 +807,52 @@ case "$target" in
         else
             MDCPUCFG_H=_aix32.cfg
         fi
     fi
     PR_MD_CSRCS=aix.c
     RESOLVE_LINK_SYMBOLS=1
     ;;
         
-*-beos*)
+*-beos*|*-haiku*)
     AC_DEFINE(XP_BEOS)
     AC_DEFINE(BeOS)
     AC_DEFINE(BEOS)
     AC_DEFINE(_POSIX_SOURCE)
+    DSO_CFLAGS=-fPIC
     DSO_LDOPTS=-nostart
+    
     MDCPUCFG_H=_beos.cfg
     USE_BTHREADS=1
     PR_MD_ARCH_DIR=beos
     RESOLVE_LINK_SYMBOLS=1
+	
+	_HAIKU_BUILD=0
+	AC_CHECK_LIB(network,main,_HAIKU_BUILD=1)
+	if test "$_HAIKU_BUILD" = 1; then
+      OS_LIBS="$OS_LIBS -lnetwork"
+      AC_DEFINE(XP_HAIKU)
+      AC_DEFINE(BONE_VERSION)
+    else
+      AC_CHECK_LIB(bind, gethostbyaddr, [OS_LIBS="$OS_LIBS -lbind -lsocket"])
+    fi 
+    
+    
+    
     case "${target_cpu}" in
     i*86)
-        _OPTIMIZE_FLAGS=-O2
-        _DEBUG_FLAGS='-gdwarf-2 -O0'
+        AC_DEFINE(i586)
+        CPU_ARCH=i586
+        _OPTIMIZE_FLAGS=-O3
+        _DEBUG_FLAGS='-gdwarf-2 -O0 -fno-inline'
         MKSHLIB='$(CCC) $(DSO_LDOPTS) -o $@'
-        AC_CHECK_LIB(bind, gethostbyaddr, [OS_LIBS="$OS_LIBS -lbind -lsocket"])
         ;;
     powerpc)
+        AC_DEFINE(ppc)
+        CPU_ARCH=ppc
         CC=mwcc
         CCC=mwcc
         LD=mwld
         DSO_LDOPTS='-xms -export pragma -init _init_routine_ -term _term_routine_ -lroot -lnet /boot/develop/lib/ppc/glue-noinit.a /boot/develop/lib/ppc/init_term_dyn.o /boot/develop/lib/ppc/start_dyn.o'
         _OPTIMIZE_FLAGS=-O2    
         _DEBUG_FLAGS='-g -O0'
         ;;
     esac
@@ -2090,17 +2108,17 @@ AC_ARG_ENABLE(nspr-threads,
     [  --enable-nspr-threads   Build using classic nspr threads],
     [ if test "$enableval" = "yes"; then
 	    USE_PTHREADS=
 	    USE_USER_PTHREADS=
 	    USE_NSPR_THREADS=1
 	  fi])
 
 case "$target" in
-*-beos*)
+*-beos*|*-haiku*)
     AC_ARG_WITH(bthreads,
     [  --with-bthreads         Use system bthreads library as thread subsystem (BeOS only)],
     [	if test "$withval" = "yes"; then
     	    USE_BTHREADS=1
 	        USE_USER_PTHREADS=
 	        USE_PTHREADS=
 	    fi])
     ;;
Index: mozilla/directory/c-sdk/config/autoconf/config.guess
===================================================================
RCS file: /cvsroot/mozilla/directory/c-sdk/config/autoconf/config.guess,v
retrieving revision 5.0.2.2
diff -u -8 -p -r5.0.2.2 config.guess
--- mozilla/directory/c-sdk/config/autoconf/config.guess	18 Apr 2003 10:20:22 -0000	5.0.2.2
+++ mozilla/directory/c-sdk/config/autoconf/config.guess	9 Feb 2009 04:01:43 -0000
@@ -1,34 +1,37 @@
 #! /bin/sh
 # Attempt to guess a canonical system name.
 #   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
-#   2000, 2001, 2002, 2003 Free Software Foundation, Inc.
+#   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
+#   Free Software Foundation, Inc.
 
-timestamp='2003-02-22'
+timestamp='2008-01-08'
 
 # This file is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by
 # the Free Software Foundation; either version 2 of the License, or
 # (at your option) any later version.
 #
 # This program is distributed in the hope that it will be useful, but
 # WITHOUT ANY WARRANTY; without even the implied warranty of
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 # General Public License for more details.
 #
 # You should have received a copy of the GNU General Public License
 # along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
+# 02110-1301, USA.
 #
 # As a special exception to the GNU General Public License, if you
 # distribute this file as part of a program that contains a
 # configuration script generated by Autoconf, you may include it under
 # the same distribution terms that you use for the rest of that program.
 
+
 # Originally written by Per Bothner <per@bothner.com>.
 # Please send patches to <config-patches@gnu.org>.  Submit a context
 # diff and a properly formatted ChangeLog entry.
 #
 # This script attempts to guess a canonical system name similar to
 # config.sub.  If it succeeds, it prints the system name on stdout, and
 # exits with 0.  Otherwise, it exits with 1.
 #
@@ -48,34 +51,34 @@ Operation modes:
   -v, --version      print version number, then exit
 
 Report bugs and patches to <config-patches@gnu.org>."
 
 version="\
 GNU config.guess ($timestamp)
 
 Originally written by Per Bothner.
-Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
-Free Software Foundation, Inc.
+Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
+2002, 2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
 
 This is free software; see the source for copying conditions.  There is NO
 warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
 
 help="
 Try \`$me --help' for more information."
 
 # Parse command line
 while test $# -gt 0 ; do
   case $1 in
     --time-stamp | --time* | -t )
-       echo "$timestamp" ; exit 0 ;;
+       echo "$timestamp" ; exit ;;
     --version | -v )
-       echo "$version" ; exit 0 ;;
+       echo "$version" ; exit ;;
     --help | --h* | -h )
-       echo "$usage"; exit 0 ;;
+       echo "$usage"; exit ;;
     -- )     # Stop option processing
        shift; break ;;
     - )	# Use stdin as input.
        break ;;
     -* )
        echo "$me: invalid option $1$help" >&2
        exit 1 ;;
     * )
@@ -99,35 +102,36 @@ trap 'exit 1' 1 2 15
 # use `HOST_CC' if defined, but it is deprecated.
 
 # Portable tmp directory creation inspired by the Autoconf team.
 
 set_cc_for_build='
 trap "exitcode=\$?; (rm -f \$tmpfiles 2>/dev/null; rmdir \$tmp 2>/dev/null) && exit \$exitcode" 0 ;
 trap "rm -f \$tmpfiles 2>/dev/null; rmdir \$tmp 2>/dev/null; exit 1" 1 2 13 15 ;
 : ${TMPDIR=/tmp} ;
- { tmp=`(umask 077 && mktemp -d -q "$TMPDIR/cgXXXXXX") 2>/dev/null` && test -n "$tmp" && test -d "$tmp" ; } ||
+ { tmp=`(umask 077 && mktemp -d "$TMPDIR/cgXXXXXX") 2>/dev/null` && test -n "$tmp" && test -d "$tmp" ; } ||
  { test -n "$RANDOM" && tmp=$TMPDIR/cg$$-$RANDOM && (umask 077 && mkdir $tmp) ; } ||
+ { tmp=$TMPDIR/cg-$$ && (umask 077 && mkdir $tmp) && echo "Warning: creating insecure temp directory" >&2 ; } ||
  { echo "$me: cannot create a temporary directory in $TMPDIR" >&2 ; exit 1 ; } ;
 dummy=$tmp/dummy ;
 tmpfiles="$dummy.c $dummy.o $dummy.rel $dummy" ;
 case $CC_FOR_BUILD,$HOST_CC,$CC in
  ,,)    echo "int x;" > $dummy.c ;
 	for c in cc gcc c89 c99 ; do
 	  if ($c -c -o $dummy.o $dummy.c) >/dev/null 2>&1 ; then
 	     CC_FOR_BUILD="$c"; break ;
 	  fi ;
 	done ;
 	if test x"$CC_FOR_BUILD" = x ; then
 	  CC_FOR_BUILD=no_compiler_found ;
 	fi
 	;;
  ,,*)   CC_FOR_BUILD=$CC ;;
  ,*,*)  CC_FOR_BUILD=$HOST_CC ;;
-esac ;'
+esac ; set_cc_for_build= ;'
 
 # This is needed to find uname on a Pyramid OSx when run in the BSD universe.
 # (ghazi@noc.rutgers.edu 1994-08-24)
 if (test -f /.attbin/uname) >/dev/null 2>&1 ; then
 	PATH=$PATH:/.attbin ; export PATH
 fi
 
 UNAME_MACHINE=`(uname -m) 2>/dev/null` || UNAME_MACHINE=unknown
@@ -152,16 +156,17 @@ case "${UNAME_MACHINE}:${UNAME_SYSTEM}:$
 	sysctl="sysctl -n hw.machine_arch"
 	UNAME_MACHINE_ARCH=`(/sbin/$sysctl 2>/dev/null || \
 	    /usr/sbin/$sysctl 2>/dev/null || echo unknown)`
 	case "${UNAME_MACHINE_ARCH}" in
 	    armeb) machine=armeb-unknown ;;
 	    arm*) machine=arm-unknown ;;
 	    sh3el) machine=shl-unknown ;;
 	    sh3eb) machine=sh-unknown ;;
+	    sh5el) machine=sh5le-unknown ;;
 	    *) machine=${UNAME_MACHINE_ARCH}-unknown ;;
 	esac
 	# The Operating System including object format, if it has switched
 	# to ELF recently, or will in the future.
 	case "${UNAME_MACHINE_ARCH}" in
 	    arm*|i386|m68k|ns32k|sh3*|sparc|vax)
 		eval $set_cc_for_build
 		if echo __ELF__ | $CC_FOR_BUILD -E - 2>/dev/null \
@@ -190,60 +195,42 @@ case "${UNAME_MACHINE}:${UNAME_SYSTEM}:$
 	    *)
 		release=`echo ${UNAME_RELEASE}|sed -e 's/[-_].*/\./'`
 		;;
 	esac
 	# Since CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM:
 	# contains redundant information, the shorter form:
 	# CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM is used.
 	echo "${machine}-${os}${release}"
-	exit 0 ;;
-    amiga:OpenBSD:*:*)
-	echo m68k-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    arc:OpenBSD:*:*)
-	echo mipsel-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    hp300:OpenBSD:*:*)
-	echo m68k-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    mac68k:OpenBSD:*:*)
-	echo m68k-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    macppc:OpenBSD:*:*)
-	echo powerpc-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    mvme68k:OpenBSD:*:*)
-	echo m68k-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    mvme88k:OpenBSD:*:*)
-	echo m88k-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    mvmeppc:OpenBSD:*:*)
-	echo powerpc-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    pmax:OpenBSD:*:*)
-	echo mipsel-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    sgi:OpenBSD:*:*)
-	echo mipseb-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    sun3:OpenBSD:*:*)
-	echo m68k-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    wgrisc:OpenBSD:*:*)
-	echo mipsel-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     *:OpenBSD:*:*)
-	echo ${UNAME_MACHINE}-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
+	UNAME_MACHINE_ARCH=`arch | sed 's/OpenBSD.//'`
+	echo ${UNAME_MACHINE_ARCH}-unknown-openbsd${UNAME_RELEASE}
+	exit ;;
+    *:ekkoBSD:*:*)
+	echo ${UNAME_MACHINE}-unknown-ekkobsd${UNAME_RELEASE}
+	exit ;;
+    *:SolidBSD:*:*)
+	echo ${UNAME_MACHINE}-unknown-solidbsd${UNAME_RELEASE}
+	exit ;;
+    macppc:MirBSD:*:*)
+	echo powerpc-unknown-mirbsd${UNAME_RELEASE}
+	exit ;;
+    *:MirBSD:*:*)
+	echo ${UNAME_MACHINE}-unknown-mirbsd${UNAME_RELEASE}
+	exit ;;
     alpha:OSF1:*:*)
-	if test $UNAME_RELEASE = "V4.0"; then
+	case $UNAME_RELEASE in
+	*4.0)
 		UNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $3}'`
-	fi
+		;;
+	*5.*)
+	        UNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $4}'`
+		;;
+	esac
 	# According to Compaq, /usr/sbin/psrinfo has been available on
 	# OSF/1 and Tru64 systems produced since 1995.  I hope that
 	# covers most systems running today.  This code pipes the CPU
 	# types through head -n 1, so we only detect the type of CPU 0.
 	ALPHA_CPU_TYPE=`/usr/sbin/psrinfo -v | sed -n -e 's/^  The alpha \(.*\) processor.*$/\1/p' | head -n 1`
 	case "$ALPHA_CPU_TYPE" in
 	    "EV4 (21064)")
 		UNAME_MACHINE="alpha" ;;
@@ -271,147 +258,163 @@ case "${UNAME_MACHINE}:${UNAME_SYSTEM}:$
 		UNAME_MACHINE="alphaev68" ;;
 	    "EV6.9A (21264/EV69A)")
 		UNAME_MACHINE="alphaev69" ;;
 	    "EV7 (21364)")
 		UNAME_MACHINE="alphaev7" ;;
 	    "EV7.9 (21364A)")
 		UNAME_MACHINE="alphaev79" ;;
 	esac
+	# A Pn.n version is a patched version.
 	# A Vn.n version is a released version.
 	# A Tn.n version is a released field test version.
 	# A Xn.n version is an unreleased experimental baselevel.
 	# 1.2 uses "1.2" for uname -r.
-	echo ${UNAME_MACHINE}-dec-osf`echo ${UNAME_RELEASE} | sed -e 's/^[VTX]//' | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`
-	exit 0 ;;
+	echo ${UNAME_MACHINE}-dec-osf`echo ${UNAME_RELEASE} | sed -e 's/^[PVTX]//' | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`
+	exit ;;
     Alpha\ *:Windows_NT*:*)
 	# How do we know it's Interix rather than the generic POSIX subsystem?
 	# Should we change UNAME_MACHINE based on the output of uname instead
 	# of the specific Alpha model?
 	echo alpha-pc-interix
-	exit 0 ;;
+	exit ;;
     21064:Windows_NT:50:3)
 	echo alpha-dec-winnt3.5
-	exit 0 ;;
+	exit ;;
     Amiga*:UNIX_System_V:4.0:*)
 	echo m68k-unknown-sysv4
-	exit 0;;
+	exit ;;
     *:[Aa]miga[Oo][Ss]:*:*)
 	echo ${UNAME_MACHINE}-unknown-amigaos
-	exit 0 ;;
+	exit ;;
     *:[Mm]orph[Oo][Ss]:*:*)
 	echo ${UNAME_MACHINE}-unknown-morphos
-	exit 0 ;;
+	exit ;;
     *:OS/390:*:*)
 	echo i370-ibm-openedition
-	exit 0 ;;
+	exit ;;
+    *:z/VM:*:*)
+	echo s390-ibm-zvmoe
+	exit ;;
+    *:OS400:*:*)
+        echo powerpc-ibm-os400
+	exit ;;
     arm:RISC*:1.[012]*:*|arm:riscix:1.[012]*:*)
 	echo arm-acorn-riscix${UNAME_RELEASE}
-	exit 0;;
+	exit ;;
+    arm:riscos:*:*|arm:RISCOS:*:*)
+	echo arm-unknown-riscos
+	exit ;;
     SR2?01:HI-UX/MPP:*:* | SR8000:HI-UX/MPP:*:*)
 	echo hppa1.1-hitachi-hiuxmpp
-	exit 0;;
+	exit ;;
     Pyramid*:OSx*:*:* | MIS*:OSx*:*:* | MIS*:SMP_DC-OSx*:*:*)
 	# akee@wpdis03.wpafb.af.mil (Earle F. Ake) contributed MIS and NILE.
 	if test "`(/bin/universe) 2>/dev/null`" = att ; then
 		echo pyramid-pyramid-sysv3
 	else
 		echo pyramid-pyramid-bsd
 	fi
-	exit 0 ;;
+	exit ;;
     NILE*:*:*:dcosx)
 	echo pyramid-pyramid-svr4
-	exit 0 ;;
-    DRS?6000:UNIX_SV:4.2*:7*)
+	exit ;;
+    DRS?6000:unix:4.0:6*)
+	echo sparc-icl-nx6
+	exit ;;
+    DRS?6000:UNIX_SV:4.2*:7* | DRS?6000:isis:4.2*:7*)
 	case `/usr/bin/uname -p` in
-	    sparc) echo sparc-icl-nx7 && exit 0 ;;
+	    sparc) echo sparc-icl-nx7; exit ;;
 	esac ;;
     sun4H:SunOS:5.*:*)
 	echo sparc-hal-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
-	exit 0 ;;
+	exit ;;
     sun4*:SunOS:5.*:* | tadpole*:SunOS:5.*:*)
 	echo sparc-sun-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
-	exit 0 ;;
-    i86pc:SunOS:5.*:*)
+	exit ;;
+    i86pc:SunOS:5.*:* | i86xen:SunOS:5.*:*)
 	echo i386-pc-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
-	exit 0 ;;
+	exit ;;
     sun4*:SunOS:6*:*)
 	# According to config.sub, this is the proper way to canonicalize
 	# SunOS6.  Hard to guess exactly what SunOS6 will be like, but
 	# it's likely to be more like Solaris than SunOS4.
 	echo sparc-sun-solaris3`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
-	exit 0 ;;
+	exit ;;
     sun4*:SunOS:*:*)
 	case "`/usr/bin/arch -k`" in
 	    Series*|S4*)
 		UNAME_RELEASE=`uname -v`
 		;;
 	esac
 	# Japanese Language versions have a version number like `4.1.3-JL'.
 	echo sparc-sun-sunos`echo ${UNAME_RELEASE}|sed -e 's/-/_/'`
-	exit 0 ;;
+	exit ;;
     sun3*:SunOS:*:*)
 	echo m68k-sun-sunos${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     sun*:*:4.2BSD:*)
 	UNAME_RELEASE=`(sed 1q /etc/motd | awk '{print substr($5,1,3)}') 2>/dev/null`
 	test "x${UNAME_RELEASE}" = "x" && UNAME_RELEASE=3
 	case "`/bin/arch`" in
 	    sun3)
 		echo m68k-sun-sunos${UNAME_RELEASE}
 		;;
 	    sun4)
 		echo sparc-sun-sunos${UNAME_RELEASE}
 		;;
 	esac
-	exit 0 ;;
+	exit ;;
     aushp:SunOS:*:*)
 	echo sparc-auspex-sunos${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     # The situation for MiNT is a little confusing.  The machine name
     # can be virtually everything (everything which is not
     # "atarist" or "atariste" at least should have a processor
     # > m68000).  The system name ranges from "MiNT" over "FreeMiNT"
     # to the lowercase version "mint" (or "freemint").  Finally
     # the system name "TOS" denotes a system which is actually not
     # MiNT.  But MiNT is downward compatible to TOS, so this should
     # be no problem.
     atarist[e]:*MiNT:*:* | atarist[e]:*mint:*:* | atarist[e]:*TOS:*:*)
         echo m68k-atari-mint${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     atari*:*MiNT:*:* | atari*:*mint:*:* | atarist[e]:*TOS:*:*)
 	echo m68k-atari-mint${UNAME_RELEASE}
-        exit 0 ;;
+        exit ;;
     *falcon*:*MiNT:*:* | *falcon*:*mint:*:* | *falcon*:*TOS:*:*)
         echo m68k-atari-mint${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     milan*:*MiNT:*:* | milan*:*mint:*:* | *milan*:*TOS:*:*)
         echo m68k-milan-mint${UNAME_RELEASE}
-        exit 0 ;;
+        exit ;;
     hades*:*MiNT:*:* | hades*:*mint:*:* | *hades*:*TOS:*:*)
         echo m68k-hades-mint${UNAME_RELEASE}
-        exit 0 ;;
+        exit ;;
     *:*MiNT:*:* | *:*mint:*:* | *:*TOS:*:*)
         echo m68k-unknown-mint${UNAME_RELEASE}
-        exit 0 ;;
+        exit ;;
+    m68k:machten:*:*)
+	echo m68k-apple-machten${UNAME_RELEASE}
+	exit ;;
     powerpc:machten:*:*)
 	echo powerpc-apple-machten${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     RISC*:Mach:*:*)
 	echo mips-dec-mach_bsd4.3
-	exit 0 ;;
+	exit ;;
     RISC*:ULTRIX:*:*)
 	echo mips-dec-ultrix${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     VAX*:ULTRIX*:*:*)
 	echo vax-dec-ultrix${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     2020:CLIX:*:* | 2430:CLIX:*:*)
 	echo clipper-intergraph-clix${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     mips:*:*:UMIPS | mips:*:*:RISCos)
 	eval $set_cc_for_build
 	sed 's/^	//' << EOF >$dummy.c
 #ifdef __cplusplus
 #include <stdio.h>  /* for printf() prototype */
 	int main (int argc, char *argv[]) {
 #else
 	int main (argc, argv) int argc; char *argv[]; {
@@ -425,145 +428,150 @@ case "${UNAME_MACHINE}:${UNAME_SYSTEM}:$
 	#endif
 	#if defined (SYSTYPE_BSD43) || defined(SYSTYPE_BSD)
 	  printf ("mips-mips-riscos%sbsd\n", argv[1]); exit (0);
 	#endif
 	#endif
 	  exit (-1);
 	}
 EOF
-	$CC_FOR_BUILD -o $dummy $dummy.c \
-	  && $dummy `echo "${UNAME_RELEASE}" | sed -n 's/\([0-9]*\).*/\1/p'` \
-	  && exit 0
+	$CC_FOR_BUILD -o $dummy $dummy.c &&
+	  dummyarg=`echo "${UNAME_RELEASE}" | sed -n 's/\([0-9]*\).*/\1/p'` &&
+	  SYSTEM_NAME=`$dummy $dummyarg` &&
+	    { echo "$SYSTEM_NAME"; exit; }
 	echo mips-mips-riscos${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     Motorola:PowerMAX_OS:*:*)
 	echo powerpc-motorola-powermax
-	exit 0 ;;
+	exit ;;
     Motorola:*:4.3:PL8-*)
 	echo powerpc-harris-powermax
-	exit 0 ;;
+	exit ;;
     Night_Hawk:*:*:PowerMAX_OS | Synergy:PowerMAX_OS:*:*)
 	echo powerpc-harris-powermax
-	exit 0 ;;
+	exit ;;
     Night_Hawk:Power_UNIX:*:*)
 	echo powerpc-harris-powerunix
-	exit 0 ;;
+	exit ;;
     m88k:CX/UX:7*:*)
 	echo m88k-harris-cxux7
-	exit 0 ;;
+	exit ;;
     m88k:*:4*:R4*)
 	echo m88k-motorola-sysv4
-	exit 0 ;;
+	exit ;;
     m88k:*:3*:R3*)
 	echo m88k-motorola-sysv3
-	exit 0 ;;
+	exit ;;
     AViiON:dgux:*:*)
         # DG/UX returns AViiON for all architectures
         UNAME_PROCESSOR=`/usr/bin/uname -p`
 	if [ $UNAME_PROCESSOR = mc88100 ] || [ $UNAME_PROCESSOR = mc88110 ]
 	then
 	    if [ ${TARGET_BINARY_INTERFACE}x = m88kdguxelfx ] || \
 	       [ ${TARGET_BINARY_INTERFACE}x = x ]
 	    then
 		echo m88k-dg-dgux${UNAME_RELEASE}
 	    else
 		echo m88k-dg-dguxbcs${UNAME_RELEASE}
 	    fi
 	else
 	    echo i586-dg-dgux${UNAME_RELEASE}
 	fi
- 	exit 0 ;;
+ 	exit ;;
     M88*:DolphinOS:*:*)	# DolphinOS (SVR3)
 	echo m88k-dolphin-sysv3
-	exit 0 ;;
+	exit ;;
     M88*:*:R3*:*)
 	# Delta 88k system running SVR3
 	echo m88k-motorola-sysv3
-	exit 0 ;;
+	exit ;;
     XD88*:*:*:*) # Tektronix XD88 system running UTekV (SVR3)
 	echo m88k-tektronix-sysv3
-	exit 0 ;;
+	exit ;;
     Tek43[0-9][0-9]:UTek:*:*) # Tektronix 4300 system running UTek (BSD)
 	echo m68k-tektronix-bsd
-	exit 0 ;;
+	exit ;;
     *:IRIX*:*:*)
 	echo mips-sgi-irix`echo ${UNAME_RELEASE}|sed -e 's/-/_/g'`
-	exit 0 ;;
+	exit ;;
     ????????:AIX?:[12].1:2)   # AIX 2.2.1 or AIX 2.1.1 is RT/PC AIX.
-	echo romp-ibm-aix      # uname -m gives an 8 hex-code CPU id
-	exit 0 ;;              # Note that: echo "'`uname -s`'" gives 'AIX '
+	echo romp-ibm-aix     # uname -m gives an 8 hex-code CPU id
+	exit ;;               # Note that: echo "'`uname -s`'" gives 'AIX '
     i*86:AIX:*:*)
 	echo i386-ibm-aix
-	exit 0 ;;
+	exit ;;
     ia64:AIX:*:*)
 	if [ -x /usr/bin/oslevel ] ; then
 		IBM_REV=`/usr/bin/oslevel`
 	else
 		IBM_REV=${UNAME_VERSION}.${UNAME_RELEASE}
 	fi
 	echo ${UNAME_MACHINE}-ibm-aix${IBM_REV}
-	exit 0 ;;
+	exit ;;
     *:AIX:2:3)
 	if grep bos325 /usr/include/stdio.h >/dev/null 2>&1; then
 		eval $set_cc_for_build
 		sed 's/^		//' << EOF >$dummy.c
 		#include <sys/systemcfg.h>
 
 		main()
 			{
 			if (!__power_pc())
 				exit(1);
 			puts("powerpc-ibm-aix3.2.5");
 			exit(0);
 			}
 EOF
-		$CC_FOR_BUILD -o $dummy $dummy.c && $dummy && exit 0
-		echo rs6000-ibm-aix3.2.5
+		if $CC_FOR_BUILD -o $dummy $dummy.c && SYSTEM_NAME=`$dummy`
+		then
+			echo "$SYSTEM_NAME"
+		else
+			echo rs6000-ibm-aix3.2.5
+		fi
 	elif grep bos324 /usr/include/stdio.h >/dev/null 2>&1; then
 		echo rs6000-ibm-aix3.2.4
 	else
 		echo rs6000-ibm-aix3.2
 	fi
-	exit 0 ;;
-    *:AIX:*:[45])
+	exit ;;
+    *:AIX:*:[456])
 	IBM_CPU_ID=`/usr/sbin/lsdev -C -c processor -S available | sed 1q | awk '{ print $1 }'`
 	if /usr/sbin/lsattr -El ${IBM_CPU_ID} | grep ' POWER' >/dev/null 2>&1; then
 		IBM_ARCH=rs6000
 	else
 		IBM_ARCH=powerpc
 	fi
 	if [ -x /usr/bin/oslevel ] ; then
 		IBM_REV=`/usr/bin/oslevel`
 	else
 		IBM_REV=${UNAME_VERSION}.${UNAME_RELEASE}
 	fi
 	echo ${IBM_ARCH}-ibm-aix${IBM_REV}
-	exit 0 ;;
+	exit ;;
     *:AIX:*:*)
 	echo rs6000-ibm-aix
-	exit 0 ;;
+	exit ;;
     ibmrt:4.4BSD:*|romp-ibm:BSD:*)
 	echo romp-ibm-bsd4.4
-	exit 0 ;;
+	exit ;;
     ibmrt:*BSD:*|romp-ibm:BSD:*)            # covers RT/PC BSD and
 	echo romp-ibm-bsd${UNAME_RELEASE}   # 4.3 with uname added to
-	exit 0 ;;                           # report: romp-ibm BSD 4.3
+	exit ;;                             # report: romp-ibm BSD 4.3
     *:BOSX:*:*)
 	echo rs6000-bull-bosx
-	exit 0 ;;
+	exit ;;
     DPX/2?00:B.O.S.:*:*)
 	echo m68k-bull-sysv3
-	exit 0 ;;
+	exit ;;
     9000/[34]??:4.3bsd:1.*:*)
 	echo m68k-hp-bsd
-	exit 0 ;;
+	exit ;;
     hp300:4.4BSD:*:* | 9000/[34]??:4.3bsd:2.*:*)
 	echo m68k-hp-bsd4.4
-	exit 0 ;;
+	exit ;;
     9000/[34678]??:HP-UX:*:*)
 	HPUX_REV=`echo ${UNAME_RELEASE}|sed -e 's/[^.]*.[0B]*//'`
 	case "${UNAME_MACHINE}" in
 	    9000/31? )            HP_ARCH=m68000 ;;
 	    9000/[34]?? )         HP_ARCH=m68k ;;
 	    9000/[678][0-9][0-9])
 		if [ -x /usr/bin/getconf ]; then
 		    sc_cpu_version=`/usr/bin/getconf SC_CPU_VERSION 2>/dev/null`
@@ -615,31 +623,41 @@ EOF
               }
 EOF
 		    (CCOPTS= $CC_FOR_BUILD -o $dummy $dummy.c 2>/dev/null) && HP_ARCH=`$dummy`
 		    test -z "$HP_ARCH" && HP_ARCH=hppa
 		fi ;;
 	esac
 	if [ ${HP_ARCH} = "hppa2.0w" ]
 	then
-	    # avoid double evaluation of $set_cc_for_build
-	    test -n "$CC_FOR_BUILD" || eval $set_cc_for_build
-	    if echo __LP64__ | (CCOPTS= $CC_FOR_BUILD -E -) | grep __LP64__ >/dev/null
+	    eval $set_cc_for_build
+
+	    # hppa2.0w-hp-hpux* has a 64-bit kernel and a compiler generating
+	    # 32-bit code.  hppa64-hp-hpux* has the same kernel and a compiler
+	    # generating 64-bit code.  GNU and HP use different nomenclature:
+	    #
+	    # $ CC_FOR_BUILD=cc ./config.guess
+	    # => hppa2.0w-hp-hpux11.23
+	    # $ CC_FOR_BUILD="cc +DA2.0w" ./config.guess
+	    # => hppa64-hp-hpux11.23
+
+	    if echo __LP64__ | (CCOPTS= $CC_FOR_BUILD -E - 2>/dev/null) |
+		grep __LP64__ >/dev/null
 	    then
 		HP_ARCH="hppa2.0w"
 	    else
 		HP_ARCH="hppa64"
 	    fi
 	fi
 	echo ${HP_ARCH}-hp-hpux${HPUX_REV}
-	exit 0 ;;
+	exit ;;
     ia64:HP-UX:*:*)
 	HPUX_REV=`echo ${UNAME_RELEASE}|sed -e 's/[^.]*.[0B]*//'`
 	echo ia64-hp-hpux${HPUX_REV}
-	exit 0 ;;
+	exit ;;
     3050*:HI-UX:*:*)
 	eval $set_cc_for_build
 	sed 's/^	//' << EOF >$dummy.c
 	#include <unistd.h>
 	int
 	main ()
 	{
 	  long cpu = sysconf (_SC_CPU_VERSION);
@@ -657,181 +675,224 @@ EOF
 		}
 	    }
 	  else if (CPU_IS_HP_MC68K (cpu))
 	    puts ("m68k-hitachi-hiuxwe2");
 	  else puts ("unknown-hitachi-hiuxwe2");
 	  exit (0);
 	}
 EOF
-	$CC_FOR_BUILD -o $dummy $dummy.c && $dummy && exit 0
+	$CC_FOR_BUILD -o $dummy $dummy.c && SYSTEM_NAME=`$dummy` &&
+		{ echo "$SYSTEM_NAME"; exit; }
 	echo unknown-hitachi-hiuxwe2
-	exit 0 ;;
+	exit ;;
     9000/7??:4.3bsd:*:* | 9000/8?[79]:4.3bsd:*:* )
 	echo hppa1.1-hp-bsd
-	exit 0 ;;
+	exit ;;
     9000/8??:4.3bsd:*:*)
 	echo hppa1.0-hp-bsd
-	exit 0 ;;
+	exit ;;
     *9??*:MPE/iX:*:* | *3000*:MPE/iX:*:*)
 	echo hppa1.0-hp-mpeix
-	exit 0 ;;
+	exit ;;
     hp7??:OSF1:*:* | hp8?[79]:OSF1:*:* )
 	echo hppa1.1-hp-osf
-	exit 0 ;;
+	exit ;;
     hp8??:OSF1:*:*)
 	echo hppa1.0-hp-osf
-	exit 0 ;;
+	exit ;;
     i*86:OSF1:*:*)
 	if [ -x /usr/sbin/sysversion ] ; then
 	    echo ${UNAME_MACHINE}-unknown-osf1mk
 	else
 	    echo ${UNAME_MACHINE}-unknown-osf1
 	fi
-	exit 0 ;;
+	exit ;;
     parisc*:Lites*:*:*)
 	echo hppa1.1-hp-lites
-	exit 0 ;;
+	exit ;;
     C1*:ConvexOS:*:* | convex:ConvexOS:C1*:*)
 	echo c1-convex-bsd
-        exit 0 ;;
+        exit ;;
     C2*:ConvexOS:*:* | convex:ConvexOS:C2*:*)
 	if getsysinfo -f scalar_acc
 	then echo c32-convex-bsd
 	else echo c2-convex-bsd
 	fi
-        exit 0 ;;
+        exit ;;
     C34*:ConvexOS:*:* | convex:ConvexOS:C34*:*)
 	echo c34-convex-bsd
-        exit 0 ;;
+        exit ;;
     C38*:ConvexOS:*:* | convex:ConvexOS:C38*:*)
 	echo c38-convex-bsd
-        exit 0 ;;
+        exit ;;
     C4*:ConvexOS:*:* | convex:ConvexOS:C4*:*)
 	echo c4-convex-bsd
-        exit 0 ;;
+        exit ;;
     CRAY*Y-MP:*:*:*)
 	echo ymp-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
-	exit 0 ;;
+	exit ;;
     CRAY*[A-Z]90:*:*:*)
 	echo ${UNAME_MACHINE}-cray-unicos${UNAME_RELEASE} \
 	| sed -e 's/CRAY.*\([A-Z]90\)/\1/' \
 	      -e y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/ \
 	      -e 's/\.[^.]*$/.X/'
-	exit 0 ;;
+	exit ;;
     CRAY*TS:*:*:*)
 	echo t90-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
-	exit 0 ;;
+	exit ;;
     CRAY*T3E:*:*:*)
 	echo alphaev5-cray-unicosmk${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
-	exit 0 ;;
+	exit ;;
     CRAY*SV1:*:*:*)
 	echo sv1-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
-	exit 0 ;;
+	exit ;;
     *:UNICOS/mp:*:*)
-	echo nv1-cray-unicosmp${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/' 
-	exit 0 ;;
+	echo craynv-cray-unicosmp${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
+	exit ;;
     F30[01]:UNIX_System_V:*:* | F700:UNIX_System_V:*:*)
 	FUJITSU_PROC=`uname -m | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`
         FUJITSU_SYS=`uname -p | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/\///'`
         FUJITSU_REL=`echo ${UNAME_RELEASE} | sed -e 's/ /_/'`
         echo "${FUJITSU_PROC}-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
-        exit 0 ;;
+        exit ;;
+    5000:UNIX_System_V:4.*:*)
+        FUJITSU_SYS=`uname -p | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/\///'`
+        FUJITSU_REL=`echo ${UNAME_RELEASE} | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/ /_/'`
+        echo "sparc-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
+	exit ;;
     i*86:BSD/386:*:* | i*86:BSD/OS:*:* | *:Ascend\ Embedded/OS:*:*)
 	echo ${UNAME_MACHINE}-pc-bsdi${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     sparc*:BSD/OS:*:*)
 	echo sparc-unknown-bsdi${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     *:BSD/OS:*:*)
 	echo ${UNAME_MACHINE}-unknown-bsdi${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     *:FreeBSD:*:*)
-	# Determine whether the default compiler uses glibc.
-	eval $set_cc_for_build
-	sed 's/^	//' << EOF >$dummy.c
-	#include <features.h>
-	#if __GLIBC__ >= 2
-	LIBC=gnu
-	#else
-	LIBC=
-	#endif
-EOF
-	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep ^LIBC=`
-	echo ${UNAME_MACHINE}-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`${LIBC:+-$LIBC}
-	exit 0 ;;
+	case ${UNAME_MACHINE} in
+	    pc98)
+		echo i386-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'` ;;
+	    amd64)
+		echo x86_64-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'` ;;
+	    *)
+		echo ${UNAME_MACHINE}-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'` ;;
+	esac
+	exit ;;
     i*:CYGWIN*:*)
 	echo ${UNAME_MACHINE}-pc-cygwin
-	exit 0 ;;
-    i*:MINGW*:*)
+	exit ;;
+    *:MINGW*:*)
 	echo ${UNAME_MACHINE}-pc-mingw32
-	exit 0 ;;
-#### MozillaHack 
-# Netscape's hacked uname
-    xx:WINNT:* | xx:WIN95:*)
-	echo i586-pc-msvc
-	exit 0 ;;
-###  End MozillaHack
+	exit ;;
+    i*:windows32*:*)
+    	# uname -m includes "-pc" on this system.
+    	echo ${UNAME_MACHINE}-mingw32
+	exit ;;
     i*:PW*:*)
 	echo ${UNAME_MACHINE}-pc-pw32
-	exit 0 ;;
-    x86:Interix*:3*)
-	echo i586-pc-interix3
-	exit 0 ;;
+	exit ;;
+    *:Interix*:[3456]*)
+    	case ${UNAME_MACHINE} in
+	    x86)
+		echo i586-pc-interix${UNAME_RELEASE}
+		exit ;;
+	    EM64T | authenticamd)
+		echo x86_64-unknown-interix${UNAME_RELEASE}
+		exit ;;
+	    IA64)
+		echo ia64-unknown-interix${UNAME_RELEASE}
+		exit ;;
+	esac ;;
     [345]86:Windows_95:* | [345]86:Windows_98:* | [345]86:Windows_NT:*)
 	echo i${UNAME_MACHINE}-pc-mks
-	exit 0 ;;
+	exit ;;
     i*:Windows_NT*:* | Pentium*:Windows_NT*:*)
 	# How do we know it's Interix rather than the generic POSIX subsystem?
 	# It also conflicts with pre-2.0 versions of AT&T UWIN. Should we
 	# UNAME_MACHINE based on the output of uname instead of i386?
 	echo i586-pc-interix
-	exit 0 ;;
+	exit ;;
     i*:UWIN*:*)
 	echo ${UNAME_MACHINE}-pc-uwin
-	exit 0 ;;
+	exit ;;
+    amd64:CYGWIN*:*:* | x86_64:CYGWIN*:*:*)
+	echo x86_64-unknown-cygwin
+	exit ;;
     p*:CYGWIN*:*)
 	echo powerpcle-unknown-cygwin
-	exit 0 ;;
+	exit ;;
     prep*:SunOS:5.*:*)
 	echo powerpcle-unknown-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
-	exit 0 ;;
+	exit ;;
     *:GNU:*:*)
+	# the GNU system
 	echo `echo ${UNAME_MACHINE}|sed -e 's,[-/].*$,,'`-unknown-gnu`echo ${UNAME_RELEASE}|sed -e 's,/.*$,,'`
-	exit 0 ;;
+	exit ;;
+    *:GNU/*:*:*)
+	# other systems with GNU libc and userland
+	echo ${UNAME_MACHINE}-unknown-`echo ${UNAME_SYSTEM} | sed 's,^[^/]*/,,' | tr '[A-Z]' '[a-z]'``echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`-gnu
+	exit ;;
     i*86:Minix:*:*)
 	echo ${UNAME_MACHINE}-pc-minix
-	exit 0 ;;
+	exit ;;
     arm*:Linux:*:*)
+	eval $set_cc_for_build
+	if echo __ARM_EABI__ | $CC_FOR_BUILD -E - 2>/dev/null \
+	    | grep -q __ARM_EABI__
+	then
+	    echo ${UNAME_MACHINE}-unknown-linux-gnu
+	else
+	    echo ${UNAME_MACHINE}-unknown-linux-gnueabi
+	fi
+	exit ;;
+    avr32*:Linux:*:*)
 	echo ${UNAME_MACHINE}-unknown-linux-gnu
-	exit 0 ;;
+	exit ;;
+    cris:Linux:*:*)
+	echo cris-axis-linux-gnu
+	exit ;;
+    crisv32:Linux:*:*)
+	echo crisv32-axis-linux-gnu
+	exit ;;
+    frv:Linux:*:*)
+    	echo frv-unknown-linux-gnu
+	exit ;;
     ia64:Linux:*:*)
 	echo ${UNAME_MACHINE}-unknown-linux-gnu
-	exit 0 ;;
+	exit ;;
+    m32r*:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	exit ;;
     m68*:Linux:*:*)
 	echo ${UNAME_MACHINE}-unknown-linux-gnu
-	exit 0 ;;
+	exit ;;
     mips:Linux:*:*)
 	eval $set_cc_for_build
 	sed 's/^	//' << EOF >$dummy.c
 	#undef CPU
 	#undef mips
 	#undef mipsel
 	#if defined(__MIPSEL__) || defined(__MIPSEL) || defined(_MIPSEL) || defined(MIPSEL)
 	CPU=mipsel
 	#else
 	#if defined(__MIPSEB__) || defined(__MIPSEB) || defined(_MIPSEB) || defined(MIPSEB)
 	CPU=mips
 	#else
 	CPU=
 	#endif
 	#endif
 EOF
-	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep ^CPU=`
-	test x"${CPU}" != x && echo "${CPU}-unknown-linux-gnu" && exit 0
+	eval "`$CC_FOR_BUILD -E $dummy.c 2>/dev/null | sed -n '
+	    /^CPU/{
+		s: ::g
+		p
+	    }'`"
+	test x"${CPU}" != x && { echo "${CPU}-unknown-linux-gnu"; exit; }
 	;;
     mips64:Linux:*:*)
 	eval $set_cc_for_build
 	sed 's/^	//' << EOF >$dummy.c
 	#undef CPU
 	#undef mips64
 	#undef mips64el
 	#if defined(__MIPSEL__) || defined(__MIPSEL) || defined(_MIPSEL) || defined(MIPSEL)
@@ -839,62 +900,78 @@ EOF
 	#else
 	#if defined(__MIPSEB__) || defined(__MIPSEB) || defined(_MIPSEB) || defined(MIPSEB)
 	CPU=mips64
 	#else
 	CPU=
 	#endif
 	#endif
 EOF
-	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep ^CPU=`
-	test x"${CPU}" != x && echo "${CPU}-unknown-linux-gnu" && exit 0
+	eval "`$CC_FOR_BUILD -E $dummy.c 2>/dev/null | sed -n '
+	    /^CPU/{
+		s: ::g
+		p
+	    }'`"
+	test x"${CPU}" != x && { echo "${CPU}-unknown-linux-gnu"; exit; }
 	;;
+    or32:Linux:*:*)
+	echo or32-unknown-linux-gnu
+	exit ;;
     ppc:Linux:*:*)
 	echo powerpc-unknown-linux-gnu
-	exit 0 ;;
+	exit ;;
     ppc64:Linux:*:*)
 	echo powerpc64-unknown-linux-gnu
-	exit 0 ;;
+	exit ;;
     alpha:Linux:*:*)
 	case `sed -n '/^cpu model/s/^.*: \(.*\)/\1/p' < /proc/cpuinfo` in
 	  EV5)   UNAME_MACHINE=alphaev5 ;;
 	  EV56)  UNAME_MACHINE=alphaev56 ;;
 	  PCA56) UNAME_MACHINE=alphapca56 ;;
 	  PCA57) UNAME_MACHINE=alphapca56 ;;
 	  EV6)   UNAME_MACHINE=alphaev6 ;;
 	  EV67)  UNAME_MACHINE=alphaev67 ;;
 	  EV68*) UNAME_MACHINE=alphaev68 ;;
         esac
 	objdump --private-headers /bin/sh | grep ld.so.1 >/dev/null
 	if test "$?" = 0 ; then LIBC="libc1" ; else LIBC="" ; fi
 	echo ${UNAME_MACHINE}-unknown-linux-gnu${LIBC}
-	exit 0 ;;
+	exit ;;
     parisc:Linux:*:* | hppa:Linux:*:*)
 	# Look for CPU level
 	case `grep '^cpu[^a-z]*:' /proc/cpuinfo 2>/dev/null | cut -d' ' -f2` in
 	  PA7*) echo hppa1.1-unknown-linux-gnu ;;
 	  PA8*) echo hppa2.0-unknown-linux-gnu ;;
 	  *)    echo hppa-unknown-linux-gnu ;;
 	esac
-	exit 0 ;;
+	exit ;;
     parisc64:Linux:*:* | hppa64:Linux:*:*)
 	echo hppa64-unknown-linux-gnu
-	exit 0 ;;
+	exit ;;
     s390:Linux:*:* | s390x:Linux:*:*)
 	echo ${UNAME_MACHINE}-ibm-linux
-	exit 0 ;;
+	exit ;;
+    sh64*:Linux:*:*)
+    	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	exit ;;
     sh*:Linux:*:*)
 	echo ${UNAME_MACHINE}-unknown-linux-gnu
-	exit 0 ;;
+	exit ;;
     sparc:Linux:*:* | sparc64:Linux:*:*)
 	echo ${UNAME_MACHINE}-unknown-linux-gnu
-	exit 0 ;;
+	exit ;;
+    vax:Linux:*:*)
+	echo ${UNAME_MACHINE}-dec-linux-gnu
+	exit ;;
     x86_64:Linux:*:*)
 	echo x86_64-unknown-linux-gnu
-	exit 0 ;;
+	exit ;;
+    xtensa*:Linux:*:*)
+    	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	exit ;;
     i*86:Linux:*:*)
 	# The BFD linker knows what the default object file format is, so
 	# first see if it will tell us. cd to the root directory to prevent
 	# problems with other programs or directories called `ld' in the path.
 	# Set LC_ALL=C to ensure ld outputs messages in English.
 	ld_supported_targets=`cd /; LC_ALL=C ld --help 2>&1 \
 			 | sed -ne '/supported targets:/!d
 				    s/[ 	][ 	]*/ /g
@@ -902,99 +979,113 @@ EOF
 				    s/ .*//
 				    p'`
         case "$ld_supported_targets" in
 	  elf32-i386)
 		TENTATIVE="${UNAME_MACHINE}-pc-linux-gnu"
 		;;
 	  a.out-i386-linux)
 		echo "${UNAME_MACHINE}-pc-linux-gnuaout"
-		exit 0 ;;
+		exit ;;
 	  coff-i386)
 		echo "${UNAME_MACHINE}-pc-linux-gnucoff"
-		exit 0 ;;
+		exit ;;
 	  "")
 		# Either a pre-BFD a.out linker (linux-gnuoldld) or
 		# one that does not give us useful --help.
 		echo "${UNAME_MACHINE}-pc-linux-gnuoldld"
-		exit 0 ;;
+		exit ;;
 	esac
 	# Determine whether the default compiler is a.out or elf
 	eval $set_cc_for_build
 	sed 's/^	//' << EOF >$dummy.c
 	#include <features.h>
 	#ifdef __ELF__
 	# ifdef __GLIBC__
 	#  if __GLIBC__ >= 2
 	LIBC=gnu
 	#  else
 	LIBC=gnulibc1
 	#  endif
 	# else
 	LIBC=gnulibc1
 	# endif
 	#else
-	#ifdef __INTEL_COMPILER
+	#if defined(__INTEL_COMPILER) || defined(__PGI) || defined(__SUNPRO_C) || defined(__SUNPRO_CC)
 	LIBC=gnu
 	#else
 	LIBC=gnuaout
 	#endif
 	#endif
+	#ifdef __dietlibc__
+	LIBC=dietlibc
+	#endif
 EOF
-	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep ^LIBC=`
-	test x"${LIBC}" != x && echo "${UNAME_MACHINE}-pc-linux-${LIBC}" && exit 0
-	test x"${TENTATIVE}" != x && echo "${TENTATIVE}" && exit 0
+	eval "`$CC_FOR_BUILD -E $dummy.c 2>/dev/null | sed -n '
+	    /^LIBC/{
+		s: ::g
+		p
+	    }'`"
+	test x"${LIBC}" != x && {
+		echo "${UNAME_MACHINE}-pc-linux-${LIBC}"
+		exit
+	}
+	test x"${TENTATIVE}" != x && { echo "${TENTATIVE}"; exit; }
 	;;
     i*86:DYNIX/ptx:4*:*)
 	# ptx 4.0 does uname -s correctly, with DYNIX/ptx in there.
 	# earlier versions are messed up and put the nodename in both
 	# sysname and nodename.
 	echo i386-sequent-sysv4
-	exit 0 ;;
+	exit ;;
     i*86:UNIX_SV:4.2MP:2.*)
         # Unixware is an offshoot of SVR4, but it has its own version
         # number series starting with 2...
         # I am not positive that other SVR4 systems won't match this,
 	# I just have to hope.  -- rms.
         # Use sysv4.2uw... so that sysv4* matches it.
 	echo ${UNAME_MACHINE}-pc-sysv4.2uw${UNAME_VERSION}
-	exit 0 ;;
+	exit ;;
     i*86:OS/2:*:*)
 	# If we were able to find `uname', then EMX Unix compatibility
 	# is probably installed.
 	echo ${UNAME_MACHINE}-pc-os2-emx
-	exit 0 ;;
+	exit ;;
     i*86:XTS-300:*:STOP)
 	echo ${UNAME_MACHINE}-unknown-stop
-	exit 0 ;;
+	exit ;;
     i*86:atheos:*:*)
 	echo ${UNAME_MACHINE}-unknown-atheos
-	exit 0 ;;
+	exit ;;
+    i*86:syllable:*:*)
+	echo ${UNAME_MACHINE}-pc-syllable
+	exit ;;
     i*86:LynxOS:2.*:* | i*86:LynxOS:3.[01]*:* | i*86:LynxOS:4.0*:*)
 	echo i386-unknown-lynxos${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     i*86:*DOS:*:*)
 	echo ${UNAME_MACHINE}-pc-msdosdjgpp
-	exit 0 ;;
+	exit ;;
     i*86:*:4.*:* | i*86:SYSTEM_V:4.*:*)
 	UNAME_REL=`echo ${UNAME_RELEASE} | sed 's/\/MP$//'`
 	if grep Novell /usr/include/link.h >/dev/null 2>/dev/null; then
 		echo ${UNAME_MACHINE}-univel-sysv${UNAME_REL}
 	else
 		echo ${UNAME_MACHINE}-pc-sysv${UNAME_REL}
 	fi
-	exit 0 ;;
-    i*86:*:5:[78]*)
+	exit ;;
+    i*86:*:5:[678]*)
+    	# UnixWare 7.x, OpenUNIX and OpenServer 6.
 	case `/bin/uname -X | grep "^Machine"` in
 	    *486*)	     UNAME_MACHINE=i486 ;;
 	    *Pentium)	     UNAME_MACHINE=i586 ;;
 	    *Pent*|*Celeron) UNAME_MACHINE=i686 ;;
 	esac
 	echo ${UNAME_MACHINE}-unknown-sysv${UNAME_RELEASE}${UNAME_SYSTEM}${UNAME_VERSION}
-	exit 0 ;;
+	exit ;;
     i*86:*:3.2:*)
 	if test -f /usr/options/cb.name; then
 		UNAME_REL=`sed -n 's/.*Version //p' </usr/options/cb.name`
 		echo ${UNAME_MACHINE}-pc-isc$UNAME_REL
 	elif /bin/uname -X 2>/dev/null >/dev/null ; then
 		UNAME_REL=`(/bin/uname -X|grep Release|sed -e 's/.*= //')`
 		(/bin/uname -X|grep i80486 >/dev/null) && UNAME_MACHINE=i486
 		(/bin/uname -X|grep '^Machine.*Pentium' >/dev/null) \
@@ -1002,214 +1093,248 @@ EOF
 		(/bin/uname -X|grep '^Machine.*Pent *II' >/dev/null) \
 			&& UNAME_MACHINE=i686
 		(/bin/uname -X|grep '^Machine.*Pentium Pro' >/dev/null) \
 			&& UNAME_MACHINE=i686
 		echo ${UNAME_MACHINE}-pc-sco$UNAME_REL
 	else
 		echo ${UNAME_MACHINE}-pc-sysv32
 	fi
-	exit 0 ;;
+	exit ;;
     pc:*:*:*)
 	# Left here for compatibility:
         # uname -m prints for DJGPP always 'pc', but it prints nothing about
         # the processor, so we play safe by assuming i386.
 	echo i386-pc-msdosdjgpp
-        exit 0 ;;
+        exit ;;
     Intel:Mach:3*:*)
 	echo i386-pc-mach3
-	exit 0 ;;
+	exit ;;
     paragon:*:*:*)
 	echo i860-intel-osf1
-	exit 0 ;;
+	exit ;;
     i860:*:4.*:*) # i860-SVR4
 	if grep Stardent /usr/include/sys/uadmin.h >/dev/null 2>&1 ; then
 	  echo i860-stardent-sysv${UNAME_RELEASE} # Stardent Vistra i860-SVR4
 	else # Add other i860-SVR4 vendors below as they are discovered.
 	  echo i860-unknown-sysv${UNAME_RELEASE}  # Unknown i860-SVR4
 	fi
-	exit 0 ;;
+	exit ;;
     mini*:CTIX:SYS*5:*)
 	# "miniframe"
 	echo m68010-convergent-sysv
-	exit 0 ;;
+	exit ;;
     mc68k:UNIX:SYSTEM5:3.51m)
 	echo m68k-convergent-sysv
-	exit 0 ;;
+	exit ;;
     M680?0:D-NIX:5.3:*)
 	echo m68k-diab-dnix
-	exit 0 ;;
-    M68*:*:R3V[567]*:*)
-	test -r /sysV68 && echo 'm68k-motorola-sysv' && exit 0 ;;
-    3[34]??:*:4.0:3.0 | 3[34]??A:*:4.0:3.0 | 3[34]??,*:*:4.0:3.0 | 3[34]??/*:*:4.0:3.0 | 4400:*:4.0:3.0 | 4850:*:4.0:3.0 | SKA40:*:4.0:3.0 | SDS2:*:4.0:3.0)
+	exit ;;
+    M68*:*:R3V[5678]*:*)
+	test -r /sysV68 && { echo 'm68k-motorola-sysv'; exit; } ;;
+    3[345]??:*:4.0:3.0 | 3[34]??A:*:4.0:3.0 | 3[34]??,*:*:4.0:3.0 | 3[34]??/*:*:4.0:3.0 | 4400:*:4.0:3.0 | 4850:*:4.0:3.0 | SKA40:*:4.0:3.0 | SDS2:*:4.0:3.0 | SHG2:*:4.0:3.0 | S7501*:*:4.0:3.0)
 	OS_REL=''
 	test -r /etc/.relid \
 	&& OS_REL=.`sed -n 's/[^ ]* [^ ]* \([0-9][0-9]\).*/\1/p' < /etc/.relid`
 	/bin/uname -p 2>/dev/null | grep 86 >/dev/null \
-	  && echo i486-ncr-sysv4.3${OS_REL} && exit 0
+	  && { echo i486-ncr-sysv4.3${OS_REL}; exit; }
 	/bin/uname -p 2>/dev/null | /bin/grep entium >/dev/null \
-	  && echo i586-ncr-sysv4.3${OS_REL} && exit 0 ;;
+	  && { echo i586-ncr-sysv4.3${OS_REL}; exit; } ;;
     3[34]??:*:4.0:* | 3[34]??,*:*:4.0:*)
         /bin/uname -p 2>/dev/null | grep 86 >/dev/null \
-          && echo i486-ncr-sysv4 && exit 0 ;;
+          && { echo i486-ncr-sysv4; exit; } ;;
     m68*:LynxOS:2.*:* | m68*:LynxOS:3.0*:*)
 	echo m68k-unknown-lynxos${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     mc68030:UNIX_System_V:4.*:*)
 	echo m68k-atari-sysv4
-	exit 0 ;;
+	exit ;;
     TSUNAMI:LynxOS:2.*:*)
 	echo sparc-unknown-lynxos${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     rs6000:LynxOS:2.*:*)
 	echo rs6000-unknown-lynxos${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     PowerPC:LynxOS:2.*:* | PowerPC:LynxOS:3.[01]*:* | PowerPC:LynxOS:4.0*:*)
 	echo powerpc-unknown-lynxos${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     SM[BE]S:UNIX_SV:*:*)
 	echo mips-dde-sysv${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     RM*:ReliantUNIX-*:*:*)
 	echo mips-sni-sysv4
-	exit 0 ;;
+	exit ;;
     RM*:SINIX-*:*:*)
 	echo mips-sni-sysv4
-	exit 0 ;;
+	exit ;;
     *:SINIX-*:*:*)
 	if uname -p 2>/dev/null >/dev/null ; then
 		UNAME_MACHINE=`(uname -p) 2>/dev/null`
 		echo ${UNAME_MACHINE}-sni-sysv4
 	else
 		echo ns32k-sni-sysv
 	fi
-	exit 0 ;;
+	exit ;;
     PENTIUM:*:4.0*:*) # Unisys `ClearPath HMP IX 4000' SVR4/MP effort
                       # says <Richard.M.Bartel@ccMail.Census.GOV>
         echo i586-unisys-sysv4
-        exit 0 ;;
-#### MozillaHack 
-    *:*OpenVMS*:*:*)
-        case "${UNAME_SYSTEM}" in
-            POSIX_for_OpenVMS_AXP) echo alpha-dec-openvmsposix ;;
-            POSIX_for_OpenVMS_VAX) echo vax-dec-openvmsposix ;;
-            OpenVMS) echo alpha-dec-openvms ;;
-            *) echo unknown-dec-openvms ;;
-        esac
-        exit 0 ;;
-#### End MozillaHack 
+        exit ;;
     *:UNIX_System_V:4*:FTX*)
 	# From Gerald Hewes <hewes@openmarket.com>.
 	# How about differentiating between stratus architectures? -djm
 	echo hppa1.1-stratus-sysv4
-	exit 0 ;;
+	exit ;;
     *:*:*:FTX*)
 	# From seanf@swdc.stratus.com.
 	echo i860-stratus-sysv4
-	exit 0 ;;
+	exit ;;
+    i*86:VOS:*:*)
+	# From Paul.Green@stratus.com.
+	echo ${UNAME_MACHINE}-stratus-vos
+	exit ;;
     *:VOS:*:*)
 	# From Paul.Green@stratus.com.
 	echo hppa1.1-stratus-vos
-	exit 0 ;;
+	exit ;;
     mc68*:A/UX:*:*)
 	echo m68k-apple-aux${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     news*:NEWS-OS:6*:*)
 	echo mips-sony-newsos6
-	exit 0 ;;
+	exit ;;
     R[34]000:*System_V*:*:* | R4000:UNIX_SYSV:*:* | R*000:UNIX_SV:*:*)
 	if [ -d /usr/nec ]; then
 	        echo mips-nec-sysv${UNAME_RELEASE}
 	else
 	        echo mips-unknown-sysv${UNAME_RELEASE}
 	fi
-        exit 0 ;;
+        exit ;;
     BeBox:BeOS:*:*)	# BeOS running on hardware made by Be, PPC only.
 	echo powerpc-be-beos
-	exit 0 ;;
+	exit ;;
     BeMac:BeOS:*:*)	# BeOS running on Mac or Mac clone, PPC only.
 	echo powerpc-apple-beos
-	exit 0 ;;
+	exit ;;
     BePC:BeOS:*:*)	# BeOS running on Intel PC compatible.
 	echo i586-pc-beos
-	exit 0 ;;
+	exit ;;
+    BeMac:Haiku:*:*)
+	echo powerpc-apple-haiku
+	exit ;;
+    BePC:Haiku:*:*)
+	echo i586-pc-haiku
+	exit ;;
     SX-4:SUPER-UX:*:*)
 	echo sx4-nec-superux${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     SX-5:SUPER-UX:*:*)
 	echo sx5-nec-superux${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     SX-6:SUPER-UX:*:*)
 	echo sx6-nec-superux${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
+    SX-7:SUPER-UX:*:*)
+	echo sx7-nec-superux${UNAME_RELEASE}
+	exit ;;
+    SX-8:SUPER-UX:*:*)
+	echo sx8-nec-superux${UNAME_RELEASE}
+	exit ;;
+    SX-8R:SUPER-UX:*:*)
+	echo sx8r-nec-superux${UNAME_RELEASE}
+	exit ;;
     Power*:Rhapsody:*:*)
 	echo powerpc-apple-rhapsody${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     *:Rhapsody:*:*)
 	echo ${UNAME_MACHINE}-apple-rhapsody${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     *:Darwin:*:*)
-	case `uname -p` in
-	    *86) UNAME_PROCESSOR=i686 ;;
-	    powerpc) UNAME_PROCESSOR=powerpc ;;
+	UNAME_PROCESSOR=`uname -p` || UNAME_PROCESSOR=unknown
+	case $UNAME_PROCESSOR in
+	    unknown) UNAME_PROCESSOR=powerpc ;;
 	esac
 	echo ${UNAME_PROCESSOR}-apple-darwin${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     *:procnto*:*:* | *:QNX:[0123456789]*:*)
 	UNAME_PROCESSOR=`uname -p`
 	if test "$UNAME_PROCESSOR" = "x86"; then
 		UNAME_PROCESSOR=i386
 		UNAME_MACHINE=pc
 	fi
 	echo ${UNAME_PROCESSOR}-${UNAME_MACHINE}-nto-qnx${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     *:QNX:*:4*)
 	echo i386-pc-qnx
-	exit 0 ;;
-    NSR-[DGKLNPTVW]:NONSTOP_KERNEL:*:*)
+	exit ;;
+    NSE-?:NONSTOP_KERNEL:*:*)
+	echo nse-tandem-nsk${UNAME_RELEASE}
+	exit ;;
+    NSR-?:NONSTOP_KERNEL:*:*)
 	echo nsr-tandem-nsk${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     *:NonStop-UX:*:*)
 	echo mips-compaq-nonstopux
-	exit 0 ;;
+	exit ;;
     BS2000:POSIX*:*:*)
 	echo bs2000-siemens-sysv
-	exit 0 ;;
+	exit ;;
     DS/*:UNIX_System_V:*:*)
 	echo ${UNAME_MACHINE}-${UNAME_SYSTEM}-${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     *:Plan9:*:*)
 	# "uname -m" is not consistent, so use $cputype instead. 386
 	# is converted to i386 for consistency with other x86
 	# operating systems.
 	if test "$cputype" = "386"; then
 	    UNAME_MACHINE=i386
 	else
 	    UNAME_MACHINE="$cputype"
 	fi
 	echo ${UNAME_MACHINE}-unknown-plan9
-	exit 0 ;;
+	exit ;;
     *:TOPS-10:*:*)
 	echo pdp10-unknown-tops10
-	exit 0 ;;
+	exit ;;
     *:TENEX:*:*)
 	echo pdp10-unknown-tenex
-	exit 0 ;;
+	exit ;;
     KS10:TOPS-20:*:* | KL10:TOPS-20:*:* | TYPE4:TOPS-20:*:*)
 	echo pdp10-dec-tops20
-	exit 0 ;;
+	exit ;;
     XKL-1:TOPS-20:*:* | TYPE5:TOPS-20:*:*)
 	echo pdp10-xkl-tops20
-	exit 0 ;;
+	exit ;;
     *:TOPS-20:*:*)
 	echo pdp10-unknown-tops20
-	exit 0 ;;
+	exit ;;
     *:ITS:*:*)
 	echo pdp10-unknown-its
-	exit 0 ;;
+	exit ;;
+    SEI:*:*:SEIUX)
+        echo mips-sei-seiux${UNAME_RELEASE}
+	exit ;;
+    *:DragonFly:*:*)
+	echo ${UNAME_MACHINE}-unknown-dragonfly`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`
+	exit ;;
+    *:*VMS:*:*)
+    	UNAME_MACHINE=`(uname -p) 2>/dev/null`
+	case "${UNAME_MACHINE}" in
+	    A*) echo alpha-dec-vms ; exit ;;
+	    I*) echo ia64-dec-vms ; exit ;;
+	    V*) echo vax-dec-vms ; exit ;;
+	esac ;;
+    *:XENIX:*:SysV)
+	echo i386-pc-xenix
+	exit ;;
+    i*86:skyos:*:*)
+	echo ${UNAME_MACHINE}-pc-skyos`echo ${UNAME_RELEASE}` | sed -e 's/ .*$//'
+	exit ;;
+    i*86:rdos:*:*)
+	echo ${UNAME_MACHINE}-pc-rdos
+	exit ;;
 esac
 
 #echo '(No uname command or uname output not recognized.)' 1>&2
 #echo "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" 1>&2
 
 eval $set_cc_for_build
 cat >$dummy.c <<EOF
 #ifdef _SEQUENT_
@@ -1231,17 +1356,17 @@ main ()
 #else
 	  ""
 #endif
          ); exit (0);
 #endif
 #endif
 
 #if defined (__arm) && defined (__acorn) && defined (__unix)
-  printf ("arm-acorn-riscix"); exit (0);
+  printf ("arm-acorn-riscix\n"); exit (0);
 #endif
 
 #if defined (hp300) && !defined (hpux)
   printf ("m68k-hp-bsd\n"); exit (0);
 #endif
 
 #if defined (NeXT)
 #if !defined (__ARCHITECTURE__)
@@ -1320,56 +1445,59 @@ main ()
 #if defined (alliant) && defined (i860)
   printf ("i860-alliant-bsd\n"); exit (0);
 #endif
 
   exit (1);
 }
 EOF
 
-$CC_FOR_BUILD -o $dummy $dummy.c 2>/dev/null && $dummy && exit 0
+$CC_FOR_BUILD -o $dummy $dummy.c 2>/dev/null && SYSTEM_NAME=`$dummy` &&
+	{ echo "$SYSTEM_NAME"; exit; }
 
 # Apollos put the system type in the environment.
 
-test -d /usr/apollo && { echo ${ISP}-apollo-${SYSTYPE}; exit 0; }
+test -d /usr/apollo && { echo ${ISP}-apollo-${SYSTYPE}; exit; }
 
 # Convex versions that predate uname can use getsysinfo(1)
 
 if [ -x /usr/convex/getsysinfo ]
 then
     case `getsysinfo -f cpu_type` in
     c1*)
 	echo c1-convex-bsd
-	exit 0 ;;
+	exit ;;
     c2*)
 	if getsysinfo -f scalar_acc
 	then echo c32-convex-bsd
 	else echo c2-convex-bsd
 	fi
-	exit 0 ;;
+	exit ;;
     c34*)
 	echo c34-convex-bsd
-	exit 0 ;;
+	exit ;;
     c38*)
 	echo c38-convex-bsd
-	exit 0 ;;
+	exit ;;
     c4*)
 	echo c4-convex-bsd
-	exit 0 ;;
+	exit ;;
     esac
 fi
 
 cat >&2 <<EOF
 $0: unable to guess system type
 
 This script, last modified $timestamp, has failed to recognize
 the operating system you are using. It is advised that you
 download the most up to date version of the config scripts from
 
-    ftp://ftp.gnu.org/pub/gnu/config/
+  http://savannah.gnu.org/cgi-bin/viewcvs/*checkout*/config/config/config.guess
+and
+  http://savannah.gnu.org/cgi-bin/viewcvs/*checkout*/config/config/config.sub
 
 If the version you run ($0) is already up to date, please
 send the following data and any information you think might be
 pertinent to <config-patches@gnu.org> in order to provide the needed
 information to handle your system.
 
 config.guess timestamp = $timestamp
 
Index: mozilla/directory/c-sdk/config/autoconf/config.sub
===================================================================
RCS file: /cvsroot/mozilla/directory/c-sdk/config/autoconf/config.sub,v
retrieving revision 5.0.2.3
diff -u -8 -p -r5.0.2.3 config.sub
--- mozilla/directory/c-sdk/config/autoconf/config.sub	18 Apr 2003 10:20:22 -0000	5.0.2.3
+++ mozilla/directory/c-sdk/config/autoconf/config.sub	9 Feb 2009 04:01:46 -0000
@@ -1,14 +1,15 @@
 #! /bin/sh
 # Configuration validation subroutine script.
 #   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
-#   2000, 2001, 2002, 2003 Free Software Foundation, Inc.
+#   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
+#   Free Software Foundation, Inc.
 
-timestamp='2003-02-22'
+timestamp='2008-01-16'
 
 # This file is (in principle) common to ALL GNU software.
 # The presence of a machine in this file suggests that SOME GNU software
 # can handle that machine.  It does not imply ALL GNU software can.
 #
 # This file is free software; you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
 # the Free Software Foundation; either version 2 of the License, or
@@ -16,24 +17,25 @@ timestamp='2003-02-22'
 #
 # This program is distributed in the hope that it will be useful,
 # but WITHOUT ANY WARRANTY; without even the implied warranty of
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 # GNU General Public License for more details.
 #
 # You should have received a copy of the GNU General Public License
 # along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place - Suite 330,
-# Boston, MA 02111-1307, USA.
-
+# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
+# 02110-1301, USA.
+#
 # As a special exception to the GNU General Public License, if you
 # distribute this file as part of a program that contains a
 # configuration script generated by Autoconf, you may include it under
 # the same distribution terms that you use for the rest of that program.
 
+
 # Please send patches to <config-patches@gnu.org>.  Submit a context
 # diff and a properly formatted ChangeLog entry.
 #
 # Configuration subroutine to validate and canonicalize a configuration type.
 # Supply the specified configuration type as an argument.
 # If it is invalid, we print an error message on stderr and exit with code 1.
 # Otherwise, we print the canonical config type on stdout and succeed.
 
@@ -65,46 +67,46 @@ Operation modes:
   -t, --time-stamp   print date of last modification, then exit
   -v, --version      print version number, then exit
 
 Report bugs and patches to <config-patches@gnu.org>."
 
 version="\
 GNU config.sub ($timestamp)
 
-Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
-Free Software Foundation, Inc.
+Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
+2002, 2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
 
 This is free software; see the source for copying conditions.  There is NO
 warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
 
 help="
 Try \`$me --help' for more information."
 
 # Parse command line
 while test $# -gt 0 ; do
   case $1 in
     --time-stamp | --time* | -t )
-       echo "$timestamp" ; exit 0 ;;
+       echo "$timestamp" ; exit ;;
     --version | -v )
-       echo "$version" ; exit 0 ;;
+       echo "$version" ; exit ;;
     --help | --h* | -h )
-       echo "$usage"; exit 0 ;;
+       echo "$usage"; exit ;;
     -- )     # Stop option processing
        shift; break ;;
     - )	# Use stdin as input.
        break ;;
     -* )
        echo "$me: invalid option $1$help"
        exit 1 ;;
 
     *local*)
        # First pass through any local machine types.
        echo $1
-       exit 0;;
+       exit ;;
 
     * )
        break ;;
   esac
 done
 
 case $# in
  0) echo "$me: missing argument$help" >&2
@@ -113,17 +115,19 @@ case $# in
  *) echo "$me: too many arguments$help" >&2
     exit 1;;
 esac
 
 # Separate what the user gave into CPU-COMPANY and OS or KERNEL-OS (if any).
 # Here we must recognize all the valid KERNEL-OS combinations.
 maybe_os=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\2/'`
 case $maybe_os in
-  nto-qnx* | linux-gnu* | freebsd*-gnu* | netbsd*-gnu* | storm-chaos* | os2-emx* | rtmk-nova*)
+  nto-qnx* | linux-gnu* | linux-dietlibc | linux-newlib* | linux-uclibc* | \
+  uclinux-uclibc* | uclinux-gnu* | kfreebsd*-gnu* | knetbsd*-gnu* | netbsd*-gnu* | \
+  storm-chaos* | os2-emx* | rtmk-nova*)
     os=-$maybe_os
     basic_machine=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\1/'`
     ;;
   *)
     basic_machine=`echo $1 | sed 's/-[^-]*$//'`
     if [ $basic_machine != $1 ]
     then os=`echo $1 | sed 's/.*-/-/'`
     else os=; fi
@@ -139,17 +143,17 @@ case $os in
 		# Prevent following clause from handling this invalid input.
 		;;
 	-dec* | -mips* | -sequent* | -encore* | -pc532* | -sgi* | -sony* | \
 	-att* | -7300* | -3300* | -delta* | -motorola* | -sun[234]* | \
 	-unicom* | -ibm* | -next | -hp | -isi* | -apollo | -altos* | \
 	-convergent* | -ncr* | -news | -32* | -3600* | -3100* | -hitachi* |\
 	-c[123]* | -convex* | -sun | -crds | -omron* | -dg | -ultra | -tti* | \
 	-harris | -dolphin | -highlevel | -gould | -cbm | -ns | -masscomp | \
-	-apple | -axis)
+	-apple | -axis | -knuth | -cray)
 		os=
 		basic_machine=$1
 		;;
 	-sim | -cisco | -oki | -wec | -winbond)
 		os=
 		basic_machine=$1
 		;;
 	-scout)
@@ -164,32 +168,40 @@ case $os in
 		;;
  	-chorusrdb)
  		os=-chorusrdb
 		basic_machine=$1
  		;;
 	-hiux*)
 		os=-hiuxwe2
 		;;
+	-sco6)
+		os=-sco5v6
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
 	-sco5)
 		os=-sco3.2v5
 		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
 		;;
 	-sco4)
 		os=-sco3.2v4
 		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
 		;;
 	-sco3.2.[4-9]*)
 		os=`echo $os | sed -e 's/sco3.2./sco3.2v/'`
 		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
 		;;
 	-sco3.2v[4-9]*)
 		# Don't forget version if it is 3.2v4 or newer.
 		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
 		;;
+	-sco5v6*)
+		# Don't forget version if it is 3.2v4 or newer.
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
 	-sco*)
 		os=-sco3.2v2
 		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
 		;;
 	-udk*)
 		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
 		;;
 	-isc)
@@ -219,171 +231,196 @@ case $os in
 		os=-mint
 		;;
 esac
 
 # Decode aliases for certain CPU-COMPANY combinations.
 case $basic_machine in
 	# Recognize the basic CPU types without company name.
 	# Some are omitted here because they have special meanings below.
-#### MozillaHack 
-# mips*el
-#### End MozillaHack 
 	1750a | 580 \
 	| a29k \
 	| alpha | alphaev[4-8] | alphaev56 | alphaev6[78] | alphapca5[67] \
 	| alpha64 | alpha64ev[4-8] | alpha64ev56 | alpha64ev6[78] | alpha64pca5[67] \
-	| arc | arm | arm[bl]e | arme[lb] | armv[2345] | armv[345][lb] | avr \
-	| clipper \
+	| am33_2.0 \
+	| arc | arm | arm[bl]e | arme[lb] | armv[2345] | armv[345][lb] | avr | avr32 \
+	| bfin \
+	| c4x | clipper \
 	| d10v | d30v | dlx | dsp16xx \
-	| fr30 | frv \
+	| fido | fr30 | frv \
 	| h8300 | h8500 | hppa | hppa1.[01] | hppa2.0 | hppa2.0[nw] | hppa64 \
 	| i370 | i860 | i960 | ia64 \
-	| ip2k \
-	| m32r | m68000 | m68k | m88k | mcore \
-	| mips | mipsbe | mipseb | mips*el | mipsle \
+	| ip2k | iq2000 \
+	| m32c | m32r | m32rle | m68000 | m68k | m88k \
+	| maxq | mb | microblaze | mcore | mep \
+	| mips | mipsbe | mipseb | mipsel | mipsle \
 	| mips16 \
 	| mips64 | mips64el \
 	| mips64vr | mips64vrel \
 	| mips64orion | mips64orionel \
 	| mips64vr4100 | mips64vr4100el \
 	| mips64vr4300 | mips64vr4300el \
 	| mips64vr5000 | mips64vr5000el \
+	| mips64vr5900 | mips64vr5900el \
 	| mipsisa32 | mipsisa32el \
 	| mipsisa32r2 | mipsisa32r2el \
 	| mipsisa64 | mipsisa64el \
+	| mipsisa64r2 | mipsisa64r2el \
 	| mipsisa64sb1 | mipsisa64sb1el \
 	| mipsisa64sr71k | mipsisa64sr71kel \
 	| mipstx39 | mipstx39el \
 	| mn10200 | mn10300 \
+	| mt \
 	| msp430 \
+	| nios | nios2 \
 	| ns16k | ns32k \
-	| openrisc | or32 \
+	| or32 \
 	| pdp10 | pdp11 | pj | pjl \
 	| powerpc | powerpc64 | powerpc64le | powerpcle | ppcbe \
 	| pyramid \
-	| sh | sh[1234] | sh[23]e | sh[34]eb | shbe | shle | sh[1234]le | sh3ele \
+	| score \
+	| sh | sh[1234] | sh[24]a | sh[23]e | sh[34]eb | sheb | shbe | shle | sh[1234]le | sh3ele \
 	| sh64 | sh64le \
-	| sparc | sparc64 | sparc86x | sparclet | sparclite | sparcv9 | sparcv9b \
-	| strongarm \
-	| tahoe | thumb | tic80 | tron \
+	| sparc | sparc64 | sparc64b | sparc64v | sparc86x | sparclet | sparclite \
+	| sparcv8 | sparcv9 | sparcv9b | sparcv9v \
+	| spu | strongarm \
+	| tahoe | thumb | tic4x | tic80 | tron \
 	| v850 | v850e \
 	| we32k \
-	| x86 | xscale | xstormy16 | xtensa \
+	| x86 | xc16x | xscale | xscalee[bl] | xstormy16 | xtensa \
 	| z8k)
 		basic_machine=$basic_machine-unknown
 		;;
 	m6811 | m68hc11 | m6812 | m68hc12)
 		# Motorola 68HC11/12.
 		basic_machine=$basic_machine-unknown
 		os=-none
 		;;
 	m88110 | m680[12346]0 | m683?2 | m68360 | m5200 | v70 | w65 | z8k)
 		;;
+	ms1)
+		basic_machine=mt-unknown
+		;;
 
 	# We use `pc' rather than `unknown'
 	# because (1) that's what they normally are, and
 	# (2) the word "unknown" tends to confuse beginning users.
 	i*86 | x86_64)
 	  basic_machine=$basic_machine-pc
 	  ;;
 	# Object if more than one company name word.
 	*-*-*)
 		echo Invalid configuration \`$1\': machine \`$basic_machine\' not recognized 1>&2
 		exit 1
 		;;
 	# Recognize the basic CPU types with company name.
-#### MozillaHack 
-# mips*el
-#### End MozillaHack 
 	580-* \
 	| a29k-* \
 	| alpha-* | alphaev[4-8]-* | alphaev56-* | alphaev6[78]-* \
 	| alpha64-* | alpha64ev[4-8]-* | alpha64ev56-* | alpha64ev6[78]-* \
 	| alphapca5[67]-* | alpha64pca5[67]-* | arc-* \
 	| arm-*  | armbe-* | armle-* | armeb-* | armv*-* \
-	| avr-* \
-	| bs2000-* \
+	| avr-* | avr32-* \
+	| bfin-* | bs2000-* \
 	| c[123]* | c30-* | [cjt]90-* | c4x-* | c54x-* | c55x-* | c6x-* \
-	| clipper-* | cydra-* \
+	| clipper-* | craynv-* | cydra-* \
 	| d10v-* | d30v-* | dlx-* \
 	| elxsi-* \
-	| f30[01]-* | f700-* | fr30-* | frv-* | fx80-* \
+	| f30[01]-* | f700-* | fido-* | fr30-* | frv-* | fx80-* \
 	| h8300-* | h8500-* \
 	| hppa-* | hppa1.[01]-* | hppa2.0-* | hppa2.0[nw]-* | hppa64-* \
 	| i*86-* | i860-* | i960-* | ia64-* \
-	| ip2k-* \
-	| m32r-* \
+	| ip2k-* | iq2000-* \
+	| m32c-* | m32r-* | m32rle-* \
 	| m68000-* | m680[012346]0-* | m68360-* | m683?2-* | m68k-* \
-	| m88110-* | m88k-* | mcore-* \
-	| mips-* | mipsbe-* | mipseb-* | mips*el-* | mipsle-* \
+	| m88110-* | m88k-* | maxq-* | mcore-* \
+	| mips-* | mipsbe-* | mipseb-* | mipsel-* | mipsle-* \
 	| mips16-* \
 	| mips64-* | mips64el-* \
 	| mips64vr-* | mips64vrel-* \
 	| mips64orion-* | mips64orionel-* \
 	| mips64vr4100-* | mips64vr4100el-* \
 	| mips64vr4300-* | mips64vr4300el-* \
 	| mips64vr5000-* | mips64vr5000el-* \
+	| mips64vr5900-* | mips64vr5900el-* \
 	| mipsisa32-* | mipsisa32el-* \
 	| mipsisa32r2-* | mipsisa32r2el-* \
 	| mipsisa64-* | mipsisa64el-* \
+	| mipsisa64r2-* | mipsisa64r2el-* \
 	| mipsisa64sb1-* | mipsisa64sb1el-* \
 	| mipsisa64sr71k-* | mipsisa64sr71kel-* \
 	| mipstx39-* | mipstx39el-* \
+	| mmix-* \
+	| mt-* \
 	| msp430-* \
-	| none-* | np1-* | nv1-* | ns16k-* | ns32k-* \
+	| nios-* | nios2-* \
+	| none-* | np1-* | ns16k-* | ns32k-* \
 	| orion-* \
 	| pdp10-* | pdp11-* | pj-* | pjl-* | pn-* | power-* \
 	| powerpc-* | powerpc64-* | powerpc64le-* | powerpcle-* | ppcbe-* \
 	| pyramid-* \
 	| romp-* | rs6000-* \
-	| sh-* | sh[1234]-* | sh[23]e-* | sh[34]eb-* | shbe-* \
+	| sh-* | sh[1234]-* | sh[24]a-* | sh[23]e-* | sh[34]eb-* | sheb-* | shbe-* \
 	| shle-* | sh[1234]le-* | sh3ele-* | sh64-* | sh64le-* \
-	| sparc-* | sparc64-* | sparc86x-* | sparclet-* | sparclite-* \
-	| sparcv9-* | sparcv9b-* | strongarm-* | sv1-* | sx?-* \
+	| sparc-* | sparc64-* | sparc64b-* | sparc64v-* | sparc86x-* | sparclet-* \
+	| sparclite-* \
+	| sparcv8-* | sparcv9-* | sparcv9b-* | sparcv9v-* | strongarm-* | sv1-* | sx?-* \
 	| tahoe-* | thumb-* \
 	| tic30-* | tic4x-* | tic54x-* | tic55x-* | tic6x-* | tic80-* \
 	| tron-* \
 	| v850-* | v850e-* | vax-* \
 	| we32k-* \
-	| x86-* | x86_64-* | xps100-* | xscale-* | xstormy16-* \
-	| xtensa-* \
+	| x86-* | x86_64-* | xc16x-* | xps100-* | xscale-* | xscalee[bl]-* \
+	| xstormy16-* | xtensa*-* \
 	| ymp-* \
 	| z8k-*)
 		;;
+	# Recognize the basic CPU types without company name, with glob match.
+	xtensa*)
+		basic_machine=$basic_machine-unknown
+		;;
 	# Recognize the various machine names and aliases which stand
 	# for a CPU type and a company and sometimes even an OS.
 	386bsd)
 		basic_machine=i386-unknown
 		os=-bsd
 		;;
 	3b1 | 7300 | 7300-att | att-7300 | pc7300 | safari | unixpc)
 		basic_machine=m68000-att
 		;;
 	3b*)
 		basic_machine=we32k-att
 		;;
 	a29khif)
 		basic_machine=a29k-amd
 		os=-udi
 		;;
+    	abacus)
+		basic_machine=abacus-unknown
+		;;
 	adobe68k)
 		basic_machine=m68010-adobe
 		os=-scout
 		;;
 	alliant | fx80)
 		basic_machine=fx80-alliant
 		;;
 	altos | altos3068)
 		basic_machine=m68k-altos
 		;;
 	am29k)
 		basic_machine=a29k-none
 		os=-bsd
 		;;
+	amd64)
+		basic_machine=x86_64-pc
+		;;
+	amd64-*)
+		basic_machine=x86_64-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
 	amdahl)
 		basic_machine=580-amdahl
 		os=-sysv
 		;;
 	amiga | amiga-*)
 		basic_machine=m68k-unknown
 		;;
 	amigaos | amigados)
@@ -405,16 +442,24 @@ case $basic_machine in
 	aux)
 		basic_machine=m68k-apple
 		os=-aux
 		;;
 	balance)
 		basic_machine=ns32k-sequent
 		os=-dynix
 		;;
+	blackfin)
+		basic_machine=bfin-unknown
+		os=-linux
+		;;
+	blackfin-*)
+		basic_machine=bfin-`echo $basic_machine | sed 's/^[^-]*-//'`
+		os=-linux
+		;;
 	c90)
 		basic_machine=c90-cray
 		os=-unicos
 		;;
 	convex-c1)
 		basic_machine=c1-convex
 		os=-bsd
 		;;
@@ -433,22 +478,37 @@ case $basic_machine in
 	convex-c38)
 		basic_machine=c38-convex
 		os=-bsd
 		;;
 	cray | j90)
 		basic_machine=j90-cray
 		os=-unicos
 		;;
+	craynv)
+		basic_machine=craynv-cray
+		os=-unicosmp
+		;;
+	cr16)
+		basic_machine=cr16-unknown
+		os=-elf
+		;;
 	crds | unos)
 		basic_machine=m68k-crds
 		;;
+	crisv32 | crisv32-* | etraxfs*)
+		basic_machine=crisv32-axis
+		;;
 	cris | cris-* | etrax*)
 		basic_machine=cris-axis
 		;;
+	crx)
+		basic_machine=crx-unknown
+		os=-elf
+		;;
 	da30 | da30-*)
 		basic_machine=m68k-da30
 		;;
 	decstation | decstation-3100 | pmax | pmax-* | pmin | dec3100 | decstatn)
 		basic_machine=mips-dec
 		;;
 	decsystem10* | dec10*)
 		basic_machine=pdp10-dec
@@ -461,16 +521,20 @@ case $basic_machine in
 	delta | 3300 | motorola-3300 | motorola-delta \
 	      | 3300-motorola | delta-motorola)
 		basic_machine=m68k-motorola
 		;;
 	delta88)
 		basic_machine=m88k-motorola
 		os=-sysv3
 		;;
+	djgpp)
+		basic_machine=i586-pc
+		os=-msdosdjgpp
+		;;
 	dpx20 | dpx20-*)
 		basic_machine=rs6000-bull
 		os=-bosx
 		;;
 	dpx2* | dpx2*-bull)
 		basic_machine=m68k-bull
 		os=-sysv3
 		;;
@@ -611,66 +675,71 @@ case $basic_machine in
 			os=-irix4
 			;;
 		esac
 		;;
 	isi68 | isi)
 		basic_machine=m68k-isi
 		os=-sysv
 		;;
+	m68knommu)
+		basic_machine=m68k-unknown
+		os=-linux
+		;;
+	m68knommu-*)
+		basic_machine=m68k-`echo $basic_machine | sed 's/^[^-]*-//'`
+		os=-linux
+		;;
 	m88k-omron*)
 		basic_machine=m88k-omron
 		;;
 	magnum | m3230)
 		basic_machine=mips-mips
 		os=-sysv
 		;;
 	merlin)
 		basic_machine=ns32k-utek
 		os=-sysv
 		;;
 	mingw32)
 		basic_machine=i386-pc
 		os=-mingw32
 		;;
-#### MozillaHack 
-	i386-msvc | msvc)
-		basic_machine=i386-pc
-		os=-msvc
+	mingw32ce)
+		basic_machine=arm-unknown
+		os=-mingw32ce
 		;;
-#### End MozillaHack 
 	miniframe)
 		basic_machine=m68000-convergent
 		;;
 	*mint | -mint[0-9]* | *MiNT | *MiNT[0-9]*)
 		basic_machine=m68k-atari
 		os=-mint
 		;;
 	mips3*-*)
 		basic_machine=`echo $basic_machine | sed -e 's/mips3/mips64/'`
 		;;
 	mips3*)
 		basic_machine=`echo $basic_machine | sed -e 's/mips3/mips64/'`-unknown
 		;;
-	mmix*)
-		basic_machine=mmix-knuth
-		os=-mmixware
-		;;
 	monitor)
 		basic_machine=m68k-rom68k
 		os=-coff
 		;;
 	morphos)
 		basic_machine=powerpc-unknown
 		os=-morphos
 		;;
 	msdos)
 		basic_machine=i386-pc
 		os=-msdos
 		;;
+	ms1-*)
+		basic_machine=`echo $basic_machine | sed -e 's/ms1-/mt-/'`
+		;;
 	mvs)
 		basic_machine=i370-ibm
 		os=-mvs
 		;;
 	ncr3000)
 		basic_machine=i486-ncr
 		os=-sysv4
 		;;
@@ -729,30 +798,29 @@ case $basic_machine in
 		;;
 	nonstopux)
 		basic_machine=mips-compaq
 		os=-nonstopux
 		;;
 	np1)
 		basic_machine=np1-gould
 		;;
-	nv1)
-		basic_machine=nv1-cray
-		os=-unicosmp
-		;;
 	nsr-tandem)
 		basic_machine=nsr-tandem
 		;;
 	op50n-* | op60c-*)
 		basic_machine=hppa1.1-oki
 		os=-proelf
 		;;
-	or32 | or32-*)
+	openrisc | openrisc-*)
 		basic_machine=or32-unknown
-		os=-coff
+		;;
+	os400)
+		basic_machine=powerpc-ibm
+		os=-os400
 		;;
 	OSE68000 | ose68000)
 		basic_machine=m68000-ericsson
 		os=-ose
 		;;
 	os68k)
 		basic_machine=m68k-none
 		os=-os68k
@@ -760,43 +828,63 @@ case $basic_machine in
 	pa-hitachi)
 		basic_machine=hppa1.1-hitachi
 		os=-hiuxwe2
 		;;
 	paragon)
 		basic_machine=i860-intel
 		os=-osf
 		;;
+	parisc)
+		basic_machine=hppa-unknown
+		os=-linux
+		;;
+	parisc-*)
+		basic_machine=hppa-`echo $basic_machine | sed 's/^[^-]*-//'`
+		os=-linux
+		;;
 	pbd)
 		basic_machine=sparc-tti
 		;;
 	pbb)
 		basic_machine=m68k-tti
 		;;
 	pc532 | pc532-*)
 		basic_machine=ns32k-pc532
 		;;
+	pc98)
+		basic_machine=i386-pc
+		;;
+	pc98-*)
+		basic_machine=i386-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
 	pentium | p5 | k5 | k6 | nexgen | viac3)
 		basic_machine=i586-pc
 		;;
 	pentiumpro | p6 | 6x86 | athlon | athlon_*)
 		basic_machine=i686-pc
 		;;
-	pentiumii | pentium2)
+	pentiumii | pentium2 | pentiumiii | pentium3)
 		basic_machine=i686-pc
 		;;
+	pentium4)
+		basic_machine=i786-pc
+		;;
 	pentium-* | p5-* | k5-* | k6-* | nexgen-* | viac3-*)
 		basic_machine=i586-`echo $basic_machine | sed 's/^[^-]*-//'`
 		;;
 	pentiumpro-* | p6-* | 6x86-* | athlon-*)
 		basic_machine=i686-`echo $basic_machine | sed 's/^[^-]*-//'`
 		;;
-	pentiumii-* | pentium2-*)
+	pentiumii-* | pentium2-* | pentiumiii-* | pentium3-*)
 		basic_machine=i686-`echo $basic_machine | sed 's/^[^-]*-//'`
 		;;
+	pentium4-*)
+		basic_machine=i786-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
 	pn)
 		basic_machine=pn-gould
 		;;
 	power)	basic_machine=power-ibm
 		;;
 	ppc)	basic_machine=powerpc-unknown
 		;;
 	ppc-*)	basic_machine=powerpc-`echo $basic_machine | sed 's/^[^-]*-//'`
@@ -819,16 +907,20 @@ case $basic_machine in
 		;;
 	ps2)
 		basic_machine=i386-ibm
 		;;
 	pw32)
 		basic_machine=i586-unknown
 		os=-pw32
 		;;
+	rdos)
+		basic_machine=i386-pc
+		os=-rdos
+		;;
 	rom68k)
 		basic_machine=m68k-rom68k
 		os=-coff
 		;;
 	rm[46]00)
 		basic_machine=mips-siemens
 		;;
 	rtpc | rtpc-*)
@@ -845,23 +937,37 @@ case $basic_machine in
 		os=-udi
 		;;
 	sb1)
 		basic_machine=mipsisa64sb1-unknown
 		;;
 	sb1el)
 		basic_machine=mipsisa64sb1el-unknown
 		;;
+	sde)
+		basic_machine=mipsisa32-sde
+		os=-elf
+		;;
+	sei)
+		basic_machine=mips-sei
+		os=-seiux
+		;;
 	sequent)
 		basic_machine=i386-sequent
 		;;
 	sh)
 		basic_machine=sh-hitachi
 		os=-hms
 		;;
+	sh5el)
+		basic_machine=sh5le-unknown
+		;;
+	sh64)
+		basic_machine=sh64-unknown
+		;;
 	sparclite-wrs | simso-wrs)
 		basic_machine=sparclite-wrs
 		os=-vxworks
 		;;
 	sps7)
 		basic_machine=m68k-bull
 		os=-sysv2
 		;;
@@ -926,45 +1032,49 @@ case $basic_machine in
 	t3e)
 		basic_machine=alphaev5-cray
 		os=-unicos
 		;;
 	t90)
 		basic_machine=t90-cray
 		os=-unicos
 		;;
-        tic4x | c4x*)
-		basic_machine=tic4x-unknown
-		os=-coff
-		;;
 	tic54x | c54x*)
 		basic_machine=tic54x-unknown
 		os=-coff
 		;;
 	tic55x | c55x*)
 		basic_machine=tic55x-unknown
 		os=-coff
 		;;
 	tic6x | c6x*)
 		basic_machine=tic6x-unknown
 		os=-coff
 		;;
+	tile*)
+		basic_machine=tile-unknown
+		os=-linux-gnu
+		;;
 	tx39)
 		basic_machine=mipstx39-unknown
 		;;
 	tx39el)
 		basic_machine=mipstx39el-unknown
 		;;
 	toad1)
 		basic_machine=pdp10-xkl
 		os=-tops20
 		;;
 	tower | tower-32)
 		basic_machine=m68k-ncr
 		;;
+	tpf)
+		basic_machine=s390x-ibm
+		os=-tpf
+		;;
 	udi29k)
 		basic_machine=a29k-amd
 		os=-udi
 		;;
 	ultra3)
 		basic_machine=a29k-nyu
 		os=-sym1
 		;;
@@ -998,16 +1108,20 @@ case $basic_machine in
 	w65*)
 		basic_machine=w65-wdc
 		os=-none
 		;;
 	w89k-*)
 		basic_machine=hppa1.1-winbond
 		os=-proelf
 		;;
+	xbox)
+		basic_machine=i686-pc
+		os=-mingw32
+		;;
 	xps | xps100)
 		basic_machine=xps100-honeywell
 		;;
 	ymp)
 		basic_machine=ymp-cray
 		os=-unicos
 		;;
 	z8k-*-coff)
@@ -1028,39 +1142,39 @@ case $basic_machine in
 		basic_machine=hppa1.1-oki
 		;;
 	op60c)
 		basic_machine=hppa1.1-oki
 		;;
 	romp)
 		basic_machine=romp-ibm
 		;;
+	mmix)
+		basic_machine=mmix-knuth
+		;;
 	rs6000)
 		basic_machine=rs6000-ibm
 		;;
 	vax)
 		basic_machine=vax-dec
 		;;
 	pdp10)
 		# there are many clones, so DEC is not a safe bet
 		basic_machine=pdp10-unknown
 		;;
 	pdp11)
 		basic_machine=pdp11-dec
 		;;
 	we32k)
 		basic_machine=we32k-att
 		;;
-	sh3 | sh4 | sh[34]eb | sh[1234]le | sh[23]ele)
+	sh[1234] | sh[24]a | sh[34]eb | sh[1234]le | sh[23]ele)
 		basic_machine=sh-unknown
 		;;
-	sh64)
-		basic_machine=sh64-unknown
-		;;
-	sparc | sparcv9 | sparcv9b)
+	sparc | sparcv8 | sparcv9 | sparcv9b | sparcv9v)
 		basic_machine=sparc-sun
 		;;
 	cydra)
 		basic_machine=cydra-cydrome
 		;;
 	orion)
 		basic_machine=orion-highlevel
 		;;
@@ -1116,40 +1230,40 @@ case $os in
 		;;
 	-gnu/linux*)
 		os=`echo $os | sed -e 's|gnu/linux|linux-gnu|'`
 		;;
 	# First accept the basic system types.
 	# The portable systems comes first.
 	# Each alternative MUST END IN A *, to match a version number.
 	# -sysv* is not here because it comes later, after sysvr4.
-#### MozillaHack 
-# msvc
-#### End MozillaHack 
 	-gnu* | -bsd* | -mach* | -minix* | -genix* | -ultrix* | -irix* \
 	      | -*vms* | -sco* | -esix* | -isc* | -aix* | -sunos | -sunos[34]*\
 	      | -hpux* | -unos* | -osf* | -luna* | -dgux* | -solaris* | -sym* \
 	      | -amigaos* | -amigados* | -msdos* | -newsos* | -unicos* | -aof* \
 	      | -aos* \
 	      | -nindy* | -vxsim* | -vxworks* | -ebmon* | -hms* | -mvs* \
 	      | -clix* | -riscos* | -uniplus* | -iris* | -rtu* | -xenix* \
-	      | -hiux* | -386bsd* | -netbsd* | -openbsd* | -freebsd* | -riscix* \
-	      | -lynxos* | -bosx* | -nextstep* | -cxux* | -aout* | -elf* | -oabi* \
+	      | -hiux* | -386bsd* | -knetbsd* | -mirbsd* | -netbsd* \
+	      | -openbsd* | -solidbsd* \
+	      | -ekkobsd* | -kfreebsd* | -freebsd* | -riscix* | -lynxos* \
+	      | -bosx* | -nextstep* | -cxux* | -aout* | -elf* | -oabi* \
 	      | -ptx* | -coff* | -ecoff* | -winnt* | -domain* | -vsta* \
 	      | -udi* | -eabi* | -lites* | -ieee* | -go32* | -aux* \
 	      | -chorusos* | -chorusrdb* \
 	      | -cygwin* | -pe* | -psos* | -moss* | -proelf* | -rtems* \
-	      | -mingw32* | -linux-gnu* | -uxpv* | -beos* | -mpeix* | -udk* \
+	      | -mingw32* | -linux-gnu* | -linux-newlib* | -linux-uclibc* \
+	      | -uxpv* | -beos* | -mpeix* | -udk* \
 	      | -interix* | -uwin* | -mks* | -rhapsody* | -darwin* | -opened* \
-	      | -msvc* \
 	      | -openstep* | -oskit* | -conix* | -pw32* | -nonstopux* \
 	      | -storm-chaos* | -tops10* | -tenex* | -tops20* | -its* \
 	      | -os2* | -vos* | -palmos* | -uclinux* | -nucleus* \
 	      | -morphos* | -superux* | -rtmk* | -rtmk-nova* | -windiss* \
-	      | -powermax* | -dnix*)
+	      | -powermax* | -dnix* | -nx6 | -nx7 | -sei* | -dragonfly* \
+	      | -skyos* | -haiku* | -rdos* | -toppers* | -drops*)
 	# Remember, each alternative MUST END IN *, to match a version number.
 		;;
 	-qnx*)
 		case $basic_machine in
 		    x86-* | i*86-*)
 			;;
 		    *)
 			os=-nto$os
@@ -1157,34 +1271,40 @@ case $os in
 		esac
 		;;
 	-nto-qnx*)
 		;;
 	-nto*)
 		os=`echo $os | sed -e 's|nto|nto-qnx|'`
 		;;
 	-sim | -es1800* | -hms* | -xray | -os68k* | -none* | -v88r* \
-	      | -windows* | -osx | -abug | -netware* | -os9* | -beos* \
+	      | -windows* | -osx | -abug | -netware* | -os9* | -beos* | -haiku* \
 	      | -macos* | -mpw* | -magic* | -mmixware* | -mon960* | -lnews*)
 		;;
 	-mac*)
 		os=`echo $os | sed -e 's|mac|macos|'`
 		;;
+	-linux-dietlibc)
+		os=-linux-dietlibc
+		;;
 	-linux*)
 		os=`echo $os | sed -e 's|linux|linux-gnu|'`
 		;;
 	-sunos5*)
 		os=`echo $os | sed -e 's|sunos5|solaris2|'`
 		;;
 	-sunos6*)
 		os=`echo $os | sed -e 's|sunos6|solaris3|'`
 		;;
 	-opened*)
 		os=-openedition
 		;;
+        -os400*)
+		os=-os400
+		;;
 	-wince*)
 		os=-wince
 		;;
 	-osfrose*)
 		os=-osfrose
 		;;
 	-osf*)
 		os=-osf
@@ -1196,16 +1316,19 @@ case $os in
 		os=-bsd
 		;;
 	-acis*)
 		os=-aos
 		;;
 	-atheos*)
 		os=-atheos
 		;;
+	-syllable*)
+		os=-syllable
+		;;
 	-386bsd)
 		os=-bsd
 		;;
 	-ctix* | -uts*)
 		os=-sysv
 		;;
 	-nova*)
 		os=-rtmk-nova
@@ -1218,16 +1341,19 @@ case $os in
 		;;
 	# Preserve the version number of sinix5.
 	-sinix5.*)
 		os=`echo $os | sed -e 's|sinix|sysv|'`
 		;;
 	-sinix*)
 		os=-sysv4
 		;;
+        -tpf*)
+		os=-tpf
+		;;
 	-triton*)
 		os=-sysv3
 		;;
 	-oss*)
 		os=-sysv3
 		;;
 	-svr4)
 		os=-sysv4
@@ -1254,16 +1380,19 @@ case $os in
 		os=-mint
 		;;
 	-aros*)
 		os=-aros
 		;;
 	-kaos*)
 		os=-kaos
 		;;
+	-zvmoe)
+		os=-zvmoe
+		;;
 	-none)
 		;;
 	*)
 		# Get rid of the `-' at the beginning of $os.
 		os=`echo $os | sed 's/[^-]*-//'`
 		echo Invalid configuration \`$1\': system \`$os\' not recognized 1>&2
 		exit 1
 		;;
@@ -1276,25 +1405,34 @@ else
 
 # Note that if you're going to try to match "-MANUFACTURER" here (say,
 # "-sun"), then you have to tell the case statement up towards the top
 # that MANUFACTURER isn't an operating system.  Otherwise, code above
 # will signal an error saying that MANUFACTURER isn't an operating
 # system, and we'll never get to this point.
 
 case $basic_machine in
+        score-*)
+		os=-elf
+		;;
+        spu-*)
+		os=-elf
+		;;
 	*-acorn)
 		os=-riscix1.2
 		;;
 	arm*-rebel)
 		os=-linux
 		;;
 	arm*-semi)
 		os=-aout
 		;;
+        c4x-* | tic4x-*)
+        	os=-coff
+		;;
 	# This must come before the *-dec entry.
 	pdp10-*)
 		os=-tops20
 		;;
 	pdp11-*)
 		os=-none
 		;;
 	*-dec | vax-*)
@@ -1310,16 +1448,19 @@ case $basic_machine in
 		os=-sunos3
 		# This also exists in the configure program, but was not the
 		# default.
 		# os=-sunos4
 		;;
 	m68*-cisco)
 		os=-aout
 		;;
+        mep-*)
+		os=-elf
+		;;
 	mips*-cisco)
 		os=-elf
 		;;
 	mips*-*)
 		os=-elf
 		;;
 	or32-*)
 		os=-coff
@@ -1328,19 +1469,25 @@ case $basic_machine in
 		os=-sysv3
 		;;
 	sparc-* | *-sun)
 		os=-sunos4.1.1
 		;;
 	*-be)
 		os=-beos
 		;;
+	*-haiku)
+		os=-haiku
+		;;
 	*-ibm)
 		os=-aix
 		;;
+    	*-knuth)
+		os=-mmixware
+		;;
 	*-wec)
 		os=-proelf
 		;;
 	*-winbond)
 		os=-proelf
 		;;
 	*-oki)
 		os=-proelf
@@ -1463,19 +1610,25 @@ case $basic_machine in
 				vendor=omron
 				;;
 			-genix*)
 				vendor=ns
 				;;
 			-mvs* | -opened*)
 				vendor=ibm
 				;;
+			-os400*)
+				vendor=ibm
+				;;
 			-ptx*)
 				vendor=sequent
 				;;
+			-tpf*)
+				vendor=ibm
+				;;
 			-vxsim* | -vxworks* | -windiss*)
 				vendor=wrs
 				;;
 			-aux*)
 				vendor=apple
 				;;
 			-hms*)
 				vendor=hitachi
@@ -1490,16 +1643,16 @@ case $basic_machine in
 				vendor=stratus
 				;;
 		esac
 		basic_machine=`echo $basic_machine | sed "s/unknown/$vendor/"`
 		;;
 esac
 
 echo $basic_machine$os
-exit 0
+exit
 
 # Local variables:
 # eval: (add-hook 'write-file-hooks 'time-stamp)
 # time-stamp-start: "timestamp='"
 # time-stamp-format: "%:y-%02m-%02d"
 # time-stamp-end: "'"
 # End:
Index: mozilla/directory/c-sdk/ldap/libraries/libldap/Makefile.in
===================================================================
RCS file: /cvsroot/mozilla/directory/c-sdk/ldap/libraries/libldap/Makefile.in,v
retrieving revision 5.0.2.21.4.1
diff -u -8 -p -r5.0.2.21.4.1 Makefile.in
--- mozilla/directory/c-sdk/ldap/libraries/libldap/Makefile.in	3 Feb 2006 14:44:42 -0000	5.0.2.21.4.1
+++ mozilla/directory/c-sdk/ldap/libraries/libldap/Makefile.in	9 Feb 2009 04:01:47 -0000
@@ -232,17 +232,17 @@ ifeq ($(OS_ARCH), Darwin)
 EXTRA_LIBS = -L$(dist_libdir) -l$(LBER_LIBNAME)
 endif
 
 ifeq ($(OS_ARCH), OpenVMS)
 EXTRA_LIBS = -L$(dist_libdir) -l$(LBER_LIBNAME) $(OS_LIBS)
 SHARED_LIBRARY_LIBS = $(dist_libdir)/lib$(LBER_LIBNAME).a
 endif
 
-ifeq ($(OS_ARCH), BeOS)
+ifeq (,$(filter-out BeOS Haiku, $(OS_ARCH)))
 EXTRA_LIBS = -L$(dist_libdir) -l$(LBER_LIBNAME) -lbe
 endif
 
 ifeq ($(OS_ARCH), NetBSD)
 EXTRA_LIBS = -L$(dist_libdir) -l$(LBER_LIBNAME)
 endif
 
 ifeq ($(OS_ARCH), OpenBSD)
@@ -297,17 +297,17 @@ ltest::	$(LIBLDAP) test.o
 $(LIBDIR):
 	$(MKDIR) $(LIBDIR)
 
 $(LIBLDAP): $(OBJS) $(LIBDIR) $(LDAP_EXPORT_DEFS)
 	@echo ======= making $(LIBLDAP)
 ifdef SO_FILES_TO_REMOVE
 	-$(RM) $(SO_FILES_TO_REMOVE)
 endif
-ifneq (,$(filter AIX Linux HP-UX Darwin BeOS QNX NetBSD OSF1 OpenBSD, $(OS_ARCH)))
+ifneq (,$(filter AIX Linux HP-UX Darwin BeOS Haiku QNX NetBSD OSF1 OpenBSD, $(OS_ARCH)))
 	$(LINK_LIB) ../liblber/$(OBJDIR_NAME)/*.a
 else
 ifeq ($(OS_ARCH),OS2)
 # create import library for OS/2
 	rm -f $@
 	$(IMPLIB) $@ $(LDAP_EXPORT_DEFS)
 else
 	$(LINK_LIB) $(EXTRA_LIBS)
@@ -336,15 +336,19 @@ ifeq ($(LD),link)
 EXPDEPS2 = $(DLLLDAP)
 endif
 endif
 
 export::	$(EXPDEPS2)
 ifdef MKSHLIB
 	$(INSTALL) -m 444 $(LIBLDAP) $(dist_libdir)
 	$(INSTALL) -m 444 $(DLLLDAP) $(dist_libdir)
+ifeq (,$(filter-out BeOS Haiku, $(OS_ARCH)))
+	$(INSTALL) -m 444 $(DLLLDAP) $(dist_bindir)/lib
+else	
 	$(INSTALL) -m 444 $(DLLLDAP) $(dist_bindir)
 endif
+endif
 ifeq ($(OS_ARCH), WINNT)
 	$(INSTALL) -m 444 $(LIBLDAP) $(dist_libdir)
 	$(INSTALL) -m 444 $(DLLLDAP) $(dist_libdir)
 endif
 	$(INSTALL) -m 444 $(ETCFILES) $(ETCDIR)
Index: mozilla/directory/c-sdk/ldap/libraries/libprldap/Makefile.in
===================================================================
RCS file: /cvsroot/mozilla/directory/c-sdk/ldap/libraries/libprldap/Makefile.in,v
retrieving revision 5.0.2.18.4.1
diff -u -8 -p -r5.0.2.18.4.1 Makefile.in
--- mozilla/directory/c-sdk/ldap/libraries/libprldap/Makefile.in	3 Feb 2006 14:44:49 -0000	5.0.2.18.4.1
+++ mozilla/directory/c-sdk/ldap/libraries/libprldap/Makefile.in	9 Feb 2009 04:01:49 -0000
@@ -160,17 +160,18 @@ EXTRA_LIBS = -L$(dist_libdir) -l$(LDAP_L
 EXTRA_LIBS += -L$(dist_libdir) $(DYNAMICNSPR)
 endif
 
 ifeq ($(OS_ARCH), OpenVMS)
 EXTRA_LIBS = -L$(dist_libdir) -l$(LDAP_LIBNAME)
 EXTRA_LIBS += -L$(dist_libdir) $(DYNAMICNSPR)
 endif
 
-ifeq ($(OS_ARCH), BeOS)
+
+ifeq (,$(filter-out BeOS Haiku, $(OS_ARCH)))
 EXTRA_LIBS = -L$(dist_libdir) -l$(LDAP_LIBNAME)
 EXTRA_LIBS += -L$(dist_libdir) $(DYNAMICNSPR)
 endif
 
 OBJDEST = $(OBJDIR_NAME)
 
 ###########################################################################
 
@@ -250,10 +251,14 @@ ifeq ($(OS_ARCH), WINNT)
 	$(INSTALL) -m 555 $(LIBPRLDAP) $(dist_libdir)
 	$(INSTALL) -m 555 $(DLLPRLDAP) $(dist_libdir)
 endif
 ifeq ($(OS_ARCH),OS2)
 	$(INSTALL) -m 444 $(LIBPRLDAP) $(dist_libdir)
 endif
 ifdef MKSHLIB
 	$(INSTALL) -m 555 $(DLLPRLDAP) $(dist_libdir)
+ifeq (,$(filter-out BeOS Haiku, $(OS_ARCH)))
+	$(INSTALL) -m 444 $(DLLPRLDAP) $(dist_bindir)/lib
+else	
 	$(INSTALL) -m 444 $(DLLPRLDAP) $(dist_bindir)
 endif
+endif
Index: mozilla/directory/c-sdk/ldap/libraries/libssldap/Makefile
===================================================================
RCS file: /cvsroot/mozilla/directory/c-sdk/ldap/libraries/libssldap/Attic/Makefile,v
retrieving revision 5.0.2.8
diff -u -8 -p -r5.0.2.8 Makefile
--- mozilla/directory/c-sdk/ldap/libraries/libssldap/Makefile	25 Aug 2004 23:02:30 -0000	5.0.2.8
+++ mozilla/directory/c-sdk/ldap/libraries/libssldap/Makefile	9 Feb 2009 04:01:49 -0000
@@ -162,17 +162,17 @@ EXTRA_LIBS = -L$(dist_libdir) -l$(LDAP_L
 ifeq ($(NSS_DYNAMIC_SOFTOKN),1)
 EXTRA_LIBS += -l$(SOFTOKN_LIBNAME)
 endif
 EXTRA_LIBS += -l$(SSL_LIBNAME) -l$(NSS_LIBNAME)
 EXTRA_LIBS += $(DYNAMICNSPR) 
 EXTRA_LIBS += $(OS_LIBS)
 endif
 
-ifeq ($(OS_ARCH), BeOS)
+ifeq (,$(filter-out BeOS Haiku, $(OS_ARCH)))
 EXTRA_LIBS = -L$(dist_libdir) -l$(LDAP_LIBNAME) -l$(PRLDAP_LIBNAME)
 ifeq ($(NSS_DYNAMIC_SOFTOKN),1)
 EXTRA_LIBS += -l$(SOFTOKN_LIBNAME)
 endif
 EXTRA_LIBS += -l$(SSL_LIBNAME) -l$(NSS_LIBNAME)
 EXTRA_LIBS += $(DYNAMICNSPR) 
 EXTRA_LIBS += $(OS_LIBS)
 endif
Index: mozilla/directory/c-sdk/ldap/libraries/libssldap/Makefile.in
===================================================================
RCS file: /cvsroot/mozilla/directory/c-sdk/ldap/libraries/libssldap/Makefile.in,v
retrieving revision 5.0.2.9.4.1
diff -u -8 -p -r5.0.2.9.4.1 Makefile.in
--- mozilla/directory/c-sdk/ldap/libraries/libssldap/Makefile.in	3 Feb 2006 14:44:49 -0000	5.0.2.9.4.1
+++ mozilla/directory/c-sdk/ldap/libraries/libssldap/Makefile.in	9 Feb 2009 04:01:50 -0000
@@ -177,17 +177,17 @@ EXTRA_LIBS = -L$(dist_libdir) -l$(LDAP_L
 ifeq ($(NSS_DYNAMIC_SOFTOKN),1)
 EXTRA_LIBS += -l$(SOFTOKN_LIBNAME)
 endif
 EXTRA_LIBS += -l$(SSL_LIBNAME) -l$(NSS_LIBNAME)
 EXTRA_LIBS += $(DYNAMICNSPR) 
 EXTRA_LIBS += $(OS_LIBS)
 endif
 
-ifeq ($(OS_ARCH), BeOS)
+ifeq (,$(filter-out BeOS Haiku, $(OS_ARCH)))
 EXTRA_LIBS = -L$(dist_libdir) -l$(LDAP_LIBNAME) -l$(PRLDAP_LIBNAME)
 ifeq ($(NSS_DYNAMIC_SOFTOKN),1)
 EXTRA_LIBS += -l$(SOFTOKN_LIBNAME)
 endif
 EXTRA_LIBS += -l$(SSL_LIBNAME) -l$(NSS_LIBNAME)
 EXTRA_LIBS += $(DYNAMICNSPR) 
 EXTRA_LIBS += $(OS_LIBS)
 endif
Index: mozilla/embedding/componentlib/Makefile.in
===================================================================
RCS file: /cvsroot/mozilla/embedding/componentlib/Makefile.in,v
retrieving revision 1.3
diff -u -8 -p -r1.3 Makefile.in
--- mozilla/embedding/componentlib/Makefile.in	18 Apr 2004 22:00:41 -0000	1.3
+++ mozilla/embedding/componentlib/Makefile.in	9 Feb 2009 04:02:04 -0000
@@ -147,17 +147,17 @@ OS_LIBS := -lstdc++ $(OS_LIBS)
 SHLIB_LDENDFILE = -lgcc
 
 endif  # darwin
 
 ifeq ($(OS_ARCH),WINNT)
 OS_LIBS	+= ole32.lib shell32.lib
 endif
 
-ifeq ($(OS_ARCH),BeOS)
+ifeq (,$(filter-out BeOS Haiku, $(OS_ARCH)))
 OS_LIBS += -ltracker
 endif
 
 GARBAGE += $(CPPSRCS)
 
 ifdef _NO_AUTO_VARS
 _TARGET = $(srcdir)/$(@F)
 GARBAGE	+= $(addprefix $(srcdir)/,$(CPPSRCS))
Index: mozilla/gfx/src/beos/nsFontMetricsBeOS.cpp
===================================================================
RCS file: /cvsroot/mozilla/gfx/src/beos/nsFontMetricsBeOS.cpp,v
retrieving revision 1.40.12.5
diff -u -8 -p -r1.40.12.5 nsFontMetricsBeOS.cpp
--- mozilla/gfx/src/beos/nsFontMetricsBeOS.cpp	27 Sep 2007 21:36:00 -0000	1.40.12.5
+++ mozilla/gfx/src/beos/nsFontMetricsBeOS.cpp	9 Feb 2009 04:02:35 -0000
@@ -123,22 +123,22 @@ NS_IMETHODIMP nsFontMetricsBeOS::Init(co
     nsString *fam = param.family.StringAt(i);
     PRBool isgeneric = ( param.isgeneric[i] ) ? PR_TRUE: PR_FALSE;
     NS_ConvertUTF16toUTF8 family(*fam);
     // Fallback
     isfixed = family.Equals("monospace") || family.Equals("fixed");
     if (!isgeneric) 
     {
       // non-generic font
-      if (count_font_styles((font_family)family.get()) <= 0) 
+      if (count_font_styles((char *) family.get()) <= 0) 
       {
         // the specified font does not exist on this computer.
         continue;
       }
-      mFontHandle.SetFamilyAndStyle( (font_family)family.get(), NULL );
+      mFontHandle.SetFamilyAndStyle( (char *)family.get(), NULL );
       fontfound = PR_TRUE;
       break;
     } 
     else 
     {
       // family is generic string like 
       // "serif" "sans-serif" "cursive" "fantasy" "monospace" "-moz-fixed"
       // so look up preferences and get real family name
@@ -153,19 +153,19 @@ NS_IMETHODIMP nsFontMetricsBeOS::Init(co
       //NS_WITH_SERVICE( nsIPref, prefs, kPrefCID, &res );
       nsCOMPtr<nsIPrefService> prefs = do_GetService( NS_PREFSERVICE_CONTRACTID, &res );
       if (NS_SUCCEEDED(res)) 
       {
         nsCOMPtr<nsIPrefBranch> branch;
         prefs->GetBranch("font.name.", getter_AddRefs(branch));
         branch->GetCharPref(prop, getter_Copies(real_family));
 
-        if (!real_family.IsEmpty() && real_family.Length() <= B_FONT_FAMILY_LENGTH  && count_font_styles((font_family)real_family.get()) > 0) 
+        if (!real_family.IsEmpty() && real_family.Length() <= B_FONT_FAMILY_LENGTH  && count_font_styles((char *)real_family.get()) > 0) 
         {
-          mFontHandle.SetFamilyAndStyle( (font_family)real_family.get(), NULL );
+          mFontHandle.SetFamilyAndStyle( (char *)real_family.get(), NULL );
           fontfound = PR_TRUE;
           break;        
         }
       } 
       // not successful. use system font.
       if (isfixed)
         mFontHandle = BFont(be_fixed_font);
       else
@@ -409,18 +409,18 @@ NS_IMETHODIMP  nsFontMetricsBeOS::GetFon
   aHandle = (nsFontHandle)&mFontHandle;
   return NS_OK;
 } 
  
 nsresult 
 nsFontMetricsBeOS::FamilyExists(const nsString& aName) 
 { 
   NS_ConvertUTF16toUTF8 family(aName);
-  printf("exists? %s", (font_family)family.get()); 
-  return  (count_font_styles((font_family)family.get()) > 0) ? NS_OK : NS_ERROR_FAILURE;
+  printf("exists? %s", (char *)family.get()); 
+  return  (count_font_styles((char *)family.get()) > 0) ? NS_OK : NS_ERROR_FAILURE;
 } 
 
 // useful UTF-8 utility
 inline uint32 utf8_char_len(uchar byte) 
 {
 	return (((0xE5000000 >> ((byte >> 3) & 0x1E)) & 3) + 1);
 }
 
Index: mozilla/gfx/src/beos/nsRenderingContextBeOS.cpp
===================================================================
RCS file: /cvsroot/mozilla/gfx/src/beos/nsRenderingContextBeOS.cpp,v
retrieving revision 1.51.12.8
diff -u -8 -p -r1.51.12.8 nsRenderingContextBeOS.cpp
--- mozilla/gfx/src/beos/nsRenderingContextBeOS.cpp	18 Dec 2007 07:17:21 -0000	1.51.12.8
+++ mozilla/gfx/src/beos/nsRenderingContextBeOS.cpp	9 Feb 2009 04:02:39 -0000
@@ -345,19 +345,22 @@ bool nsRenderingContextBeOS::LockAndUpda
 		return rv; 
 
 	// Intelligent lock
 	if (mSurface->LockDrawable()) 
 	{
 		// if BFont wasn't set already
 		if (mCurrentBFont == nsnull)
 		{ 
-			if (mFontMetrics)
-				mFontMetrics->GetFontHandle((nsFontHandle)mCurrentBFont);
-
+			if (mFontMetrics) 
+			{
+				nsFontHandle fontHandle;
+				mFontMetrics->GetFontHandle(fontHandle);
+				mCurrentBFont = (BFont *) fontHandle;
+			}
 			if (mCurrentBFont)
 				mView->SetFont(mCurrentBFont);
 			else
 				mView->SetFont(be_plain_font); // fallback - only for single call
 		}
 
 		if (mClipRegion) 
 		{
@@ -1122,17 +1125,17 @@ NS_IMETHODIMP nsRenderingContextBeOS::Ge
 // and call (UTF-8) char* version of the method.
 // It works well with current nsFontMetricsBeOS which is, again, simpler in comparison with
 // other platforms, partly due to UTF-8 nature of BeOS, partly due unimplemented font fallbacks
 // and other tricks.
 
 NS_IMETHODIMP nsRenderingContextBeOS::GetTextDimensions(const PRUnichar* aString,
 	PRInt32 aLength, PRInt32 aAvailWidth, PRInt32* aBreaks, PRInt32 aNumBreaks,
 	nsTextDimensions& aDimensions, PRInt32& aNumCharsFit, nsTextDimensions& aLastWordDimensions,
-	PRInt32* aFontID = nsnull)
+	PRInt32* aFontID)
 {
 	nsresult ret_code = NS_ERROR_FAILURE;	
 	uint8 utf8buf[1024];
 	uint8* utf8str = nsnull;
 	// max UTF-8 string length
 	PRUint32 slength = aLength * 4 + 1;
 	// Allocating char* array rather from stack than from heap for speed.
 	//  1024 char array forms  e.g.  256 == 32*8 frame for CJK glyphs, which may be
@@ -1155,17 +1158,17 @@ NS_IMETHODIMP nsRenderingContextBeOS::Ge
 	// deallocating if got from heap
 	if (utf8str != utf8buf)
 			delete [] utf8str;
 	return ret_code;
 }
 
 NS_IMETHODIMP nsRenderingContextBeOS::GetTextDimensions(const char* aString, PRInt32 aLength,
 	PRInt32 aAvailWidth,PRInt32* aBreaks, PRInt32 aNumBreaks, nsTextDimensions& aDimensions,
-	PRInt32& aNumCharsFit, nsTextDimensions& aLastWordDimensions, PRInt32* aFontID = nsnull)
+	PRInt32& aNumCharsFit, nsTextDimensions& aLastWordDimensions, PRInt32* aFontID)
 {
 	// Code is borrowed from win32 implementation including comments.
 	// Minor changes are introduced due multibyte/utf-8 nature of char* strings handling in BeOS.
 	char * utf8ptr = (char *)aString;
 	PRInt32 *utf8pos =0;	
 	PRInt32 num_of_glyphs = 0; // Number of glyphs isn't equal to number of bytes in case of UTF-8
 	PRInt32 utf8posbuf[1025];
 	if (aLength < 1025) 
Index: mozilla/intl/uconv/src/Makefile.in
===================================================================
RCS file: /cvsroot/mozilla/intl/uconv/src/Makefile.in,v
retrieving revision 1.82.4.2
diff -u -8 -p -r1.82.4.2 Makefile.in
--- mozilla/intl/uconv/src/Makefile.in	29 Jan 2006 16:51:01 -0000	1.82.4.2
+++ mozilla/intl/uconv/src/Makefile.in	9 Feb 2009 04:02:45 -0000
@@ -114,17 +114,17 @@ else
 ifeq ($(MOZ_WIDGET_TOOLKIT),windows)
 CPPSRCS			+= nsWinCharset.cpp
 EXPORT_RESOURCE		+= wincharset.properties
 else
 ifneq (,$(filter cocoa mac, $(MOZ_WIDGET_TOOLKIT)))
 CPPSRCS			+= nsMacCharset.cpp
 EXPORT_RESOURCE		+= maccharset.properties
 else
-ifeq ($(OS_ARCH),BeOS)
+ifeq (,$(filter-out BeOS Haiku, $(OS_ARCH)))
 CPPSRCS			+= nsBeOSCharset.cpp
 else
 CPPSRCS			+= nsUNIXCharset.cpp
 EXPORT_RESOURCE		+= unixcharset.properties
 # add platform charset remapping properties files here if necessary
 # (see unixcharset.sample.properties for an example file)
 # eg: if we needed a charset remap for OSARCH=Linux then add the following line:
 #EXPORT_RESOURCE		+= unixcharset.Linux.properties
Index: mozilla/ipc/ipcd/client/src/Makefile.in
===================================================================
RCS file: /cvsroot/mozilla/ipc/ipcd/client/src/Makefile.in,v
retrieving revision 1.7
diff -u -8 -p -r1.7 Makefile.in
--- mozilla/ipc/ipcd/client/src/Makefile.in	9 Dec 2004 19:28:19 -0000	1.7
+++ mozilla/ipc/ipcd/client/src/Makefile.in	9 Feb 2009 04:02:51 -0000
@@ -59,17 +59,18 @@ CPPSRCS		= \
             ipcdclient.cpp \
             ipcService.cpp \
             ipcModuleFactory.cpp \
             $(NULL)
 
 ifeq ($(OS_ARCH),WINNT)
 CPPSRCS +=  ipcConnectionWin.cpp
 else
-ifeq ($(OS_ARCH),BeOS)
+
+ifeq (,$(filter-out BeOS Haiku, $(OS_ARCH)))
 CPPSRCS +=  ipcConnectionStub.cpp
 else
 CPPSRCS +=  ipcConnectionUnix.cpp
 endif
 endif
 
 LOCAL_INCLUDES = \
             -I$(srcdir)/../../shared/src \
Index: mozilla/ipc/ipcd/daemon/src/Makefile.in
===================================================================
RCS file: /cvsroot/mozilla/ipc/ipcd/daemon/src/Makefile.in,v
retrieving revision 1.3
diff -u -8 -p -r1.3 Makefile.in
--- mozilla/ipc/ipcd/daemon/src/Makefile.in	28 Jan 2004 21:31:46 -0000	1.3
+++ mozilla/ipc/ipcd/daemon/src/Makefile.in	9 Feb 2009 04:02:52 -0000
@@ -54,17 +54,18 @@ CPPSRCS		= \
             ipcd.cpp \
             ipcClient.cpp \
             ipcModuleReg.cpp \
             ipcCommandModule.cpp
 
 ifeq ($(OS_ARCH),WINNT)
 CPPSRCS +=  ipcdWin.cpp
 else
-ifeq ($(OS_ARCH),BeOS)
+
+ifeq (,$(filter-out BeOS Haiku, $(OS_ARCH)))
 CPPSRCS +=  ipcdStub.cpp
 else
 CPPSRCS +=  ipcdUnix.cpp
 endif
 endif
 
 PROGRAM =   mozilla-ipcd$(BIN_SUFFIX)
 
Index: mozilla/js/src/Makefile.in
===================================================================
RCS file: /cvsroot/mozilla/js/src/Makefile.in,v
retrieving revision 3.95.4.5
diff -u -8 -p -r3.95.4.5 Makefile.in
--- mozilla/js/src/Makefile.in	27 Jul 2006 22:56:20 -0000	3.95.4.5
+++ mozilla/js/src/Makefile.in	9 Feb 2009 04:02:54 -0000
@@ -241,17 +241,17 @@ ifneq ($(findstring -L,$(NSPR_LIBS)),)
 NSPR_STATIC_PATH = $(subst -L,,$(findstring -L,$(NSPR_LIBS)))
 else
 NSPR_STATIC_PATH = $(DIST)/lib
 endif
 
 LDFLAGS		+= $(pathsubst -l%,$(NSPR_STATIC_PATH)/%.a,$(NSPR_LIBS))
 
 # BeOS and HP-UX do not require the extra linking of "-lm"
-ifeq (,$(filter BeOS HP-UX WINNT WINCE OpenVMS,$(OS_ARCH)))
+ifeq (,$(filter BeOS Haiku HP-UX WINNT WINCE OpenVMS,$(OS_ARCH)))
 LDFLAGS		+= -lm
 endif
 
 # Prevent floating point errors caused by VC++ optimizations
 ifeq ($(OS_ARCH)_$(GNU_CC),WINNT_)
 ifeq (,$(filter-out 1200 1300 1310,$(_MSC_VER)))
 CFLAGS += -Op
 else
Index: mozilla/mail/app/Makefile.in
===================================================================
RCS file: /cvsroot/mozilla/mail/app/Makefile.in,v
retrieving revision 1.46.2.10
diff -u -8 -p -r1.46.2.10 Makefile.in
--- mozilla/mail/app/Makefile.in	22 Oct 2008 21:04:53 -0000	1.46.2.10
+++ mozilla/mail/app/Makefile.in	9 Feb 2009 04:03:21 -0000
@@ -57,18 +57,22 @@ PREF_JS_EXPORTS = \
 
 ifndef MOZ_BRANDING_DIRECTORY
 PREF_JS_EXPORTS += $(srcdir)/thunderbird-branding.js
 endif
 
 ifeq ($(USE_SHORT_LIBNAME), 1)
 PROGRAM = thunderbird$(BIN_SUFFIX)
 else
+ifeq (,$(filter-out BeOS Haiku, $(OS_ARCH)))
+PROGRAM = thunderbird$(BIN_SUFFIX)
+else
 PROGRAM = thunderbird-bin$(BIN_SUFFIX)
 endif
+endif
 
 REQUIRES = \
 	xpcom \
 	$(NULL)
 
 LOCAL_INCLUDES = -I$(topsrcdir)/toolkit/xre
 
 CPPSRCS = nsMailApp.cpp
@@ -142,17 +146,17 @@ RCFLAGS += -DMOZ_THUNDERBIRD -I$(srcdir)
 else
 RCFLAGS += -DMOZ_THUNDERBIRD --include-dir $(srcdir)
 endif
 ifdef BUILD_STATIC_LIBS
 RCFLAGS += -DMOZ_STATIC_BUILD
 endif
 endif
 
-ifeq ($(OS_ARCH),BeOS)
+ifeq (,$(filter-out BeOS Haiku, $(OS_ARCH)))
 BEOS_PROGRAM_RESOURCE = $(srcdir)/apprunner-beos.rsrc
 ifdef BUILD_STATIC_LIBS
 OS_LIBS += -ltracker -lgame
 endif
 endif
 
 ifeq ($(OS_ARCH),OS2)
 RESFILE=splashos2.res
@@ -257,17 +261,17 @@ ifneq (,$(filter gtk gtk2,$(MOZ_WIDGET_T
 	cp $(srcdir)/mozicon16.xpm $(DIST)/branding/mozicon16.xpm
 	cp $(srcdir)/mozicon50.xpm $(DIST)/branding/mozicon50.xpm
 endif
 ifeq ($(MOZ_WIDGET_TOOLKIT),gtk2)
 	cp $(srcdir)/default.xpm   $(DIST)/branding/default.xpm	
 endif
 endif
 
-ifneq (,$(filter-out OS2 WINNT Darwin,$(OS_ARCH)))
+ifneq (,$(filter-out OS2 WINNT Darwin BeOS Haiku,$(OS_ARCH)))
 thunderbird:: mozilla.in Makefile.in Makefile $(DEPTH)/config/autoconf.mk
 	cat $< | sed -e "s|%MOZAPPDIR%|$(mozappdir)|" \
                 -e "s|%MOZ_USER_DIR%|.thunderbird|" \
 		-e "s|%MREDIR%|$(mredir)|" \
  		-e "s|%MOZ_APP_DISPLAYNAME%|$(MOZ_APP_DISPLAYNAME)|" > $@
 	chmod +x $@
 
 libs:: thunderbird
Index: mozilla/modules/libpr0n/decoders/Makefile.in
===================================================================
RCS file: /cvsroot/mozilla/modules/libpr0n/decoders/Makefile.in,v
retrieving revision 1.13.18.2
diff -u -8 -p -r1.13.18.2 Makefile.in
--- mozilla/modules/libpr0n/decoders/Makefile.in	17 Feb 2006 19:03:47 -0000	1.13.18.2
+++ mozilla/modules/libpr0n/decoders/Makefile.in	9 Feb 2009 04:03:46 -0000
@@ -47,17 +47,17 @@ ifdef MOZ_ENABLE_GNOMEUI
 TOOL_DIRS = icon/gtk icon
 endif
 ifneq (,$(filter WINCE WINNT,$(OS_ARCH)))
 DIRS = icon/win icon
 endif
 ifeq ($(OS_ARCH),OS2)
 DIRS = icon/os2 icon
 endif
-ifeq ($(OS_ARCH),BeOS)
+ifeq (,$(filter-out BeOS Haiku, $(OS_ARCH)))
 DIRS = icon/beos icon
 endif
 ifneq (,$(filter mac cocoa,$(MOZ_WIDGET_TOOLKIT)))
 DIRS = icon/mac icon
 endif
 endif # icon
 
 DIRS += $(filter-out icon,$(MOZ_IMG_DECODERS))
Index: mozilla/modules/libpr0n/decoders/icon/Makefile.in
===================================================================
RCS file: /cvsroot/mozilla/modules/libpr0n/decoders/icon/Makefile.in,v
retrieving revision 1.17.8.6
diff -u -8 -p -r1.17.8.6 Makefile.in
--- mozilla/modules/libpr0n/decoders/icon/Makefile.in	30 May 2006 15:46:21 -0000	1.17.8.6
+++ mozilla/modules/libpr0n/decoders/icon/Makefile.in	9 Feb 2009 04:03:46 -0000
@@ -77,17 +77,17 @@ endif
 ifeq ($(OS_ARCH),OS2)
 PLATFORM = os2
 endif
 
 ifeq ($(OS_ARCH),Darwin)
 PLATFORM = mac
 endif
 
-ifeq ($(OS_ARCH),BeOS)
+ifeq (,$(filter-out BeOS Haiku, $(OS_ARCH)))
 PLATFORM = beos
 endif
 
 REQUIRES	= xpcom \
 		  string \
 		  gfx \
 		  imglib2 \
 		  necko \
@@ -97,17 +97,17 @@ CPPSRCS		= \
 		nsIconURI.cpp \
 		nsIconModule.cpp \
 		nsIconProtocolHandler.cpp \
 		$(NULL)
 
 ifdef MOZ_ENABLE_GNOMEUI
 USE_ICON_DECODER = 1
 endif
-ifeq (,$(filter-out Darwin OS2 BeOS,$(OS_ARCH)))
+ifeq (,$(filter-out Darwin OS2 BeOS Haiku,$(OS_ARCH)))
 USE_ICON_DECODER = 1
 endif
 
 ifdef USE_ICON_DECODER
 CPPSRCS		+= nsIconDecoder.cpp
 DEFINES		+= -DUSE_ICON_DECODER
 endif
 
Index: mozilla/modules/libreg/src/Makefile.in
===================================================================
RCS file: /cvsroot/mozilla/modules/libreg/src/Makefile.in,v
retrieving revision 1.39
diff -u -8 -p -r1.39 Makefile.in
--- mozilla/modules/libreg/src/Makefile.in	18 Apr 2004 22:00:45 -0000	1.39
+++ mozilla/modules/libreg/src/Makefile.in	9 Feb 2009 04:03:47 -0000
@@ -61,17 +61,17 @@ FORCE_STATIC_LIB = 1
 
 # Force use of PIC
 FORCE_USE_PIC	= 1
 
 include $(topsrcdir)/config/config.mk
 
 DEFINES         += -DUSE_BUFFERED_REGISTRY_IO	
 # Memory mapped files are not supported under QNX, Neutrino, HP-UX and BeOS
-#ifeq (,$(filter BeOS HP-UX QNX,$(OS_ARCH)))
+#ifeq (,$(filter BeOS Haiku HP-UX QNX,$(OS_ARCH)))
 #CSRCS		+= mmapio.c
 #DEFINES		+= -DUSE_MMAP_REGISTRY_IO
 #endif
 
 include $(topsrcdir)/config/rules.mk
 
 R_%.o: %.c
 	$(CC) $(OUTOPTION)$@ -c $(COMPILE_CFLAGS) -DSTANDALONE_REGISTRY $<
Index: mozilla/modules/plugin/base/src/Makefile.in
===================================================================
RCS file: /cvsroot/mozilla/modules/plugin/base/src/Makefile.in,v
retrieving revision 1.104
diff -u -8 -p -r1.104 Makefile.in
--- mozilla/modules/plugin/base/src/Makefile.in	8 Jun 2005 16:48:43 -0000	1.104
+++ mozilla/modules/plugin/base/src/Makefile.in	9 Feb 2009 04:03:55 -0000
@@ -91,17 +91,17 @@ CPPSRCS		= \
 		ns4xPluginInstance.cpp \
 		nsPluginHostImpl.cpp \
 		nsPluginModule.cpp \
 		nsPluginInstancePeer.cpp \
 		nsPluginDirServiceProvider.cpp \
 		nsJSNPRuntime.cpp \
 		$(NULL)
 
-ifeq ($(OS_ARCH), BeOS)
+ifeq (,$(filter-out BeOS Haiku, $(OS_ARCH)))
 	CPPSRCS += nsPluginsDirBeOS.cpp
 	CPPSRCS += nsPluginNativeWindow.cpp
 else
 ifneq (,$(filter WINNT WINCE,$(OS_ARCH)))
 	CPPSRCS += nsPluginsDirWin.cpp
 	CPPSRCS += nsPluginNativeWindowWin.cpp
 else
 ifeq ($(MOZ_WIDGET_TOOLKIT),os2)
Index: mozilla/nsprpub/configure.in
===================================================================
RCS file: /cvsroot/mozilla/nsprpub/configure.in,v
retrieving revision 1.199.2.17
diff -u -8 -p -r1.199.2.17 configure.in
--- mozilla/nsprpub/configure.in	31 Oct 2007 18:07:38 -0000	1.199.2.17
+++ mozilla/nsprpub/configure.in	9 Feb 2009 04:04:09 -0000
@@ -358,17 +358,17 @@ if test -z "$SKIP_PATH_CHECKS"; then
     AC_PATH_PROG(WHOAMI, $WHOAMI whoami, echo not_whoami)
 fi
 
 if test -n "$MOZ_DEBUG"; then
     AC_DEFINE(DEBUG)
     DEFINES="$DEFINES -UNDEBUG"
 
     case "${target_os}" in
-    beos*)
+    beos*|haiku*)
         DEFINES="$DEFINES -DDEBUG_${USER}"
         ;;
     msvc*|mks*|cygwin*|mingw*|os2*)
         DEFINES="$DEFINES -DDEBUG_`echo ${USERNAME} | sed -e 's| |_|g'`"
         ;;
     *) 
         DEFINES="$DEFINES -DDEBUG_`$WHOAMI`"
         ;;
@@ -787,17 +787,17 @@ case "$host" in
     NSINSTALL=nsinstall
     ;;
 *-cygwin*|*-msvc*|*-mks*)
     NSINSTALL='$(CYGWIN_WRAPPER) nsinstall'
     if test `echo "${PATH}" | grep -c \;` = 0; then
         CYGWIN_WRAPPER='sh $(topsrcdir)/build/cygwin-wrapper'
     fi
     ;;
-*-beos*)
+*-beos*|*-haiku*)
     HOST_CFLAGS="$HOST_CFLAGS -DXP_BEOS -DBeOS -DBEOS -D_POSIX_SOURCE"
     ;;
 *os2*)
     ;;
 *)
     HOST_CFLAGS="$HOST_CFLAGS -DXP_UNIX"
     ;;
 esac
@@ -862,34 +862,50 @@ case "$target" in
         OBJECT_MODE=64
     else
         MDCPUCFG_H=_aix32.cfg
     fi
     PR_MD_CSRCS=aix.c
     RESOLVE_LINK_SYMBOLS=1
     ;;
         
-*-beos*)
+*-beos*|*-haiku*)
     AC_DEFINE(XP_BEOS)
     AC_DEFINE(BeOS)
     AC_DEFINE(BEOS)
     AC_DEFINE(_POSIX_SOURCE)
-    DSO_LDOPTS=-nostart
+    DSO_CFLAGS=-fPIC
+    DSO_LDOPTS='-nostart'
+
     MDCPUCFG_H=_beos.cfg
     USE_BTHREADS=1
     PR_MD_ARCH_DIR=beos
     RESOLVE_LINK_SYMBOLS=1
+	
+	_HAIKU_BUILD=0
+	AC_CHECK_LIB(network,main,_HAIKU_BUILD=1)
+	if test "$_HAIKU_BUILD" = 1; then
+      OS_LIBS="$OS_LIBS -lnetwork"
+      AC_DEFINE(XP_HAIKU)
+      AC_DEFINE(BONE_VERSION)
+    else
+      AC_CHECK_LIB(bind, gethostbyaddr, [OS_LIBS="$OS_LIBS -lbind -lsocket"])
+    fi
+	
     case "${target_cpu}" in
     i*86)
-        _OPTIMIZE_FLAGS=-O2
-        _DEBUG_FLAGS='-gdwarf-2 -O0'
+        AC_DEFINE(i586)
+        CPU_ARCH=i586
+        _OPTIMIZE_FLAGS=-O3
+        _DEBUG_FLAGS='-gdwarf-2 -O0 -fno-inline'
         MKSHLIB='$(CCC) $(DSO_LDOPTS) -o $@'
-        AC_CHECK_LIB(bind, gethostbyaddr, [OS_LIBS="$OS_LIBS -lbind -lsocket"])
         ;;
     powerpc)
+        AC_DEFINE(ppc)
+        CPU_ARCH=ppc
         CC=mwcc
         CCC=mwcc
         LD=mwld
         DSO_LDOPTS='-xms -export pragma -init _init_routine_ -term _term_routine_ -lroot -lnet /boot/develop/lib/ppc/glue-noinit.a /boot/develop/lib/ppc/init_term_dyn.o /boot/develop/lib/ppc/start_dyn.o'
         _OPTIMIZE_FLAGS=-O2    
         _DEBUG_FLAGS='-g -O0'
         ;;
     esac
@@ -2164,16 +2180,18 @@ dnl AC_CHECK_LIB(vms_jackets, main)
 
 
 dnl We don't want anything to link with libdl even if it's present on OS X, 
 dnl since it's not used and not part of the default installation.
 
 case $target in
 *-darwin*)
     ;;
+*-beos*|*-haiku*)
+    ;;
 *)
     AC_CHECK_LIB(dl, dlopen,
         AC_CHECK_HEADER(dlfcn.h,
             OS_LIBS="-ldl $OS_LIBS"))
     ;;
 esac
 
 
@@ -2352,17 +2370,17 @@ AC_ARG_ENABLE(nspr-threads,
     [  --enable-nspr-threads   Build using classic nspr threads],
     [ if test "$enableval" = "yes"; then
 	    USE_PTHREADS=
 	    USE_USER_PTHREADS=
 	    USE_NSPR_THREADS=1
 	  fi])
 
 case "$target" in
-*-beos*)
+*-beos*|*-haiku*)
     AC_ARG_WITH(bthreads,
     [  --with-bthreads         Use system bthreads library as thread subsystem
                           (BeOS only)],
     [	if test "$withval" = "yes"; then
     	    USE_BTHREADS=1
 	        USE_USER_PTHREADS=
 	        USE_PTHREADS=
 	    fi])
Index: mozilla/nsprpub/build/autoconf/config.guess
===================================================================
RCS file: /cvsroot/mozilla/nsprpub/build/autoconf/config.guess,v
retrieving revision 1.15
diff -u -8 -p -r1.15 config.guess
--- mozilla/nsprpub/build/autoconf/config.guess	18 Apr 2003 19:20:18 -0000	1.15
+++ mozilla/nsprpub/build/autoconf/config.guess	9 Feb 2009 04:04:13 -0000
@@ -1,34 +1,37 @@
 #! /bin/sh
 # Attempt to guess a canonical system name.
 #   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
-#   2000, 2001, 2002, 2003 Free Software Foundation, Inc.
+#   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
+#   Free Software Foundation, Inc.
 
-timestamp='2003-02-22'
+timestamp='2008-01-08'
 
 # This file is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by
 # the Free Software Foundation; either version 2 of the License, or
 # (at your option) any later version.
 #
 # This program is distributed in the hope that it will be useful, but
 # WITHOUT ANY WARRANTY; without even the implied warranty of
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 # General Public License for more details.
 #
 # You should have received a copy of the GNU General Public License
 # along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
+# 02110-1301, USA.
 #
 # As a special exception to the GNU General Public License, if you
 # distribute this file as part of a program that contains a
 # configuration script generated by Autoconf, you may include it under
 # the same distribution terms that you use for the rest of that program.
 
+
 # Originally written by Per Bothner <per@bothner.com>.
 # Please send patches to <config-patches@gnu.org>.  Submit a context
 # diff and a properly formatted ChangeLog entry.
 #
 # This script attempts to guess a canonical system name similar to
 # config.sub.  If it succeeds, it prints the system name on stdout, and
 # exits with 0.  Otherwise, it exits with 1.
 #
@@ -48,34 +51,34 @@ Operation modes:
   -v, --version      print version number, then exit
 
 Report bugs and patches to <config-patches@gnu.org>."
 
 version="\
 GNU config.guess ($timestamp)
 
 Originally written by Per Bothner.
-Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
-Free Software Foundation, Inc.
+Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
+2002, 2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
 
 This is free software; see the source for copying conditions.  There is NO
 warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
 
 help="
 Try \`$me --help' for more information."
 
 # Parse command line
 while test $# -gt 0 ; do
   case $1 in
     --time-stamp | --time* | -t )
-       echo "$timestamp" ; exit 0 ;;
+       echo "$timestamp" ; exit ;;
     --version | -v )
-       echo "$version" ; exit 0 ;;
+       echo "$version" ; exit ;;
     --help | --h* | -h )
-       echo "$usage"; exit 0 ;;
+       echo "$usage"; exit ;;
     -- )     # Stop option processing
        shift; break ;;
     - )	# Use stdin as input.
        break ;;
     -* )
        echo "$me: invalid option $1$help" >&2
        exit 1 ;;
     * )
@@ -99,35 +102,36 @@ trap 'exit 1' 1 2 15
 # use `HOST_CC' if defined, but it is deprecated.
 
 # Portable tmp directory creation inspired by the Autoconf team.
 
 set_cc_for_build='
 trap "exitcode=\$?; (rm -f \$tmpfiles 2>/dev/null; rmdir \$tmp 2>/dev/null) && exit \$exitcode" 0 ;
 trap "rm -f \$tmpfiles 2>/dev/null; rmdir \$tmp 2>/dev/null; exit 1" 1 2 13 15 ;
 : ${TMPDIR=/tmp} ;
- { tmp=`(umask 077 && mktemp -d -q "$TMPDIR/cgXXXXXX") 2>/dev/null` && test -n "$tmp" && test -d "$tmp" ; } ||
+ { tmp=`(umask 077 && mktemp -d "$TMPDIR/cgXXXXXX") 2>/dev/null` && test -n "$tmp" && test -d "$tmp" ; } ||
  { test -n "$RANDOM" && tmp=$TMPDIR/cg$$-$RANDOM && (umask 077 && mkdir $tmp) ; } ||
+ { tmp=$TMPDIR/cg-$$ && (umask 077 && mkdir $tmp) && echo "Warning: creating insecure temp directory" >&2 ; } ||
  { echo "$me: cannot create a temporary directory in $TMPDIR" >&2 ; exit 1 ; } ;
 dummy=$tmp/dummy ;
 tmpfiles="$dummy.c $dummy.o $dummy.rel $dummy" ;
 case $CC_FOR_BUILD,$HOST_CC,$CC in
  ,,)    echo "int x;" > $dummy.c ;
 	for c in cc gcc c89 c99 ; do
 	  if ($c -c -o $dummy.o $dummy.c) >/dev/null 2>&1 ; then
 	     CC_FOR_BUILD="$c"; break ;
 	  fi ;
 	done ;
 	if test x"$CC_FOR_BUILD" = x ; then
 	  CC_FOR_BUILD=no_compiler_found ;
 	fi
 	;;
  ,,*)   CC_FOR_BUILD=$CC ;;
  ,*,*)  CC_FOR_BUILD=$HOST_CC ;;
-esac ;'
+esac ; set_cc_for_build= ;'
 
 # This is needed to find uname on a Pyramid OSx when run in the BSD universe.
 # (ghazi@noc.rutgers.edu 1994-08-24)
 if (test -f /.attbin/uname) >/dev/null 2>&1 ; then
 	PATH=$PATH:/.attbin ; export PATH
 fi
 
 UNAME_MACHINE=`(uname -m) 2>/dev/null` || UNAME_MACHINE=unknown
@@ -152,16 +156,17 @@ case "${UNAME_MACHINE}:${UNAME_SYSTEM}:$
 	sysctl="sysctl -n hw.machine_arch"
 	UNAME_MACHINE_ARCH=`(/sbin/$sysctl 2>/dev/null || \
 	    /usr/sbin/$sysctl 2>/dev/null || echo unknown)`
 	case "${UNAME_MACHINE_ARCH}" in
 	    armeb) machine=armeb-unknown ;;
 	    arm*) machine=arm-unknown ;;
 	    sh3el) machine=shl-unknown ;;
 	    sh3eb) machine=sh-unknown ;;
+	    sh5el) machine=sh5le-unknown ;;
 	    *) machine=${UNAME_MACHINE_ARCH}-unknown ;;
 	esac
 	# The Operating System including object format, if it has switched
 	# to ELF recently, or will in the future.
 	case "${UNAME_MACHINE_ARCH}" in
 	    arm*|i386|m68k|ns32k|sh3*|sparc|vax)
 		eval $set_cc_for_build
 		if echo __ELF__ | $CC_FOR_BUILD -E - 2>/dev/null \
@@ -190,60 +195,42 @@ case "${UNAME_MACHINE}:${UNAME_SYSTEM}:$
 	    *)
 		release=`echo ${UNAME_RELEASE}|sed -e 's/[-_].*/\./'`
 		;;
 	esac
 	# Since CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM:
 	# contains redundant information, the shorter form:
 	# CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM is used.
 	echo "${machine}-${os}${release}"
-	exit 0 ;;
-    amiga:OpenBSD:*:*)
-	echo m68k-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    arc:OpenBSD:*:*)
-	echo mipsel-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    hp300:OpenBSD:*:*)
-	echo m68k-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    mac68k:OpenBSD:*:*)
-	echo m68k-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    macppc:OpenBSD:*:*)
-	echo powerpc-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    mvme68k:OpenBSD:*:*)
-	echo m68k-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    mvme88k:OpenBSD:*:*)
-	echo m88k-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    mvmeppc:OpenBSD:*:*)
-	echo powerpc-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    pmax:OpenBSD:*:*)
-	echo mipsel-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    sgi:OpenBSD:*:*)
-	echo mipseb-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    sun3:OpenBSD:*:*)
-	echo m68k-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    wgrisc:OpenBSD:*:*)
-	echo mipsel-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     *:OpenBSD:*:*)
-	echo ${UNAME_MACHINE}-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
+	UNAME_MACHINE_ARCH=`arch | sed 's/OpenBSD.//'`
+	echo ${UNAME_MACHINE_ARCH}-unknown-openbsd${UNAME_RELEASE}
+	exit ;;
+    *:ekkoBSD:*:*)
+	echo ${UNAME_MACHINE}-unknown-ekkobsd${UNAME_RELEASE}
+	exit ;;
+    *:SolidBSD:*:*)
+	echo ${UNAME_MACHINE}-unknown-solidbsd${UNAME_RELEASE}
+	exit ;;
+    macppc:MirBSD:*:*)
+	echo powerpc-unknown-mirbsd${UNAME_RELEASE}
+	exit ;;
+    *:MirBSD:*:*)
+	echo ${UNAME_MACHINE}-unknown-mirbsd${UNAME_RELEASE}
+	exit ;;
     alpha:OSF1:*:*)
-	if test $UNAME_RELEASE = "V4.0"; then
+	case $UNAME_RELEASE in
+	*4.0)
 		UNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $3}'`
-	fi
+		;;
+	*5.*)
+	        UNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $4}'`
+		;;
+	esac
 	# According to Compaq, /usr/sbin/psrinfo has been available on
 	# OSF/1 and Tru64 systems produced since 1995.  I hope that
 	# covers most systems running today.  This code pipes the CPU
 	# types through head -n 1, so we only detect the type of CPU 0.
 	ALPHA_CPU_TYPE=`/usr/sbin/psrinfo -v | sed -n -e 's/^  The alpha \(.*\) processor.*$/\1/p' | head -n 1`
 	case "$ALPHA_CPU_TYPE" in
 	    "EV4 (21064)")
 		UNAME_MACHINE="alpha" ;;
@@ -271,147 +258,163 @@ case "${UNAME_MACHINE}:${UNAME_SYSTEM}:$
 		UNAME_MACHINE="alphaev68" ;;
 	    "EV6.9A (21264/EV69A)")
 		UNAME_MACHINE="alphaev69" ;;
 	    "EV7 (21364)")
 		UNAME_MACHINE="alphaev7" ;;
 	    "EV7.9 (21364A)")
 		UNAME_MACHINE="alphaev79" ;;
 	esac
+	# A Pn.n version is a patched version.
 	# A Vn.n version is a released version.
 	# A Tn.n version is a released field test version.
 	# A Xn.n version is an unreleased experimental baselevel.
 	# 1.2 uses "1.2" for uname -r.
-	echo ${UNAME_MACHINE}-dec-osf`echo ${UNAME_RELEASE} | sed -e 's/^[VTX]//' | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`
-	exit 0 ;;
+	echo ${UNAME_MACHINE}-dec-osf`echo ${UNAME_RELEASE} | sed -e 's/^[PVTX]//' | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`
+	exit ;;
     Alpha\ *:Windows_NT*:*)
 	# How do we know it's Interix rather than the generic POSIX subsystem?
 	# Should we change UNAME_MACHINE based on the output of uname instead
 	# of the specific Alpha model?
 	echo alpha-pc-interix
-	exit 0 ;;
+	exit ;;
     21064:Windows_NT:50:3)
 	echo alpha-dec-winnt3.5
-	exit 0 ;;
+	exit ;;
     Amiga*:UNIX_System_V:4.0:*)
 	echo m68k-unknown-sysv4
-	exit 0;;
+	exit ;;
     *:[Aa]miga[Oo][Ss]:*:*)
 	echo ${UNAME_MACHINE}-unknown-amigaos
-	exit 0 ;;
+	exit ;;
     *:[Mm]orph[Oo][Ss]:*:*)
 	echo ${UNAME_MACHINE}-unknown-morphos
-	exit 0 ;;
+	exit ;;
     *:OS/390:*:*)
 	echo i370-ibm-openedition
-	exit 0 ;;
+	exit ;;
+    *:z/VM:*:*)
+	echo s390-ibm-zvmoe
+	exit ;;
+    *:OS400:*:*)
+        echo powerpc-ibm-os400
+	exit ;;
     arm:RISC*:1.[012]*:*|arm:riscix:1.[012]*:*)
 	echo arm-acorn-riscix${UNAME_RELEASE}
-	exit 0;;
+	exit ;;
+    arm:riscos:*:*|arm:RISCOS:*:*)
+	echo arm-unknown-riscos
+	exit ;;
     SR2?01:HI-UX/MPP:*:* | SR8000:HI-UX/MPP:*:*)
 	echo hppa1.1-hitachi-hiuxmpp
-	exit 0;;
+	exit ;;
     Pyramid*:OSx*:*:* | MIS*:OSx*:*:* | MIS*:SMP_DC-OSx*:*:*)
 	# akee@wpdis03.wpafb.af.mil (Earle F. Ake) contributed MIS and NILE.
 	if test "`(/bin/universe) 2>/dev/null`" = att ; then
 		echo pyramid-pyramid-sysv3
 	else
 		echo pyramid-pyramid-bsd
 	fi
-	exit 0 ;;
+	exit ;;
     NILE*:*:*:dcosx)
 	echo pyramid-pyramid-svr4
-	exit 0 ;;
-    DRS?6000:UNIX_SV:4.2*:7*)
+	exit ;;
+    DRS?6000:unix:4.0:6*)
+	echo sparc-icl-nx6
+	exit ;;
+    DRS?6000:UNIX_SV:4.2*:7* | DRS?6000:isis:4.2*:7*)
 	case `/usr/bin/uname -p` in
-	    sparc) echo sparc-icl-nx7 && exit 0 ;;
+	    sparc) echo sparc-icl-nx7; exit ;;
 	esac ;;
     sun4H:SunOS:5.*:*)
 	echo sparc-hal-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
-	exit 0 ;;
+	exit ;;
     sun4*:SunOS:5.*:* | tadpole*:SunOS:5.*:*)
 	echo sparc-sun-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
-	exit 0 ;;
-    i86pc:SunOS:5.*:*)
+	exit ;;
+    i86pc:SunOS:5.*:* | i86xen:SunOS:5.*:*)
 	echo i386-pc-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
-	exit 0 ;;
+	exit ;;
     sun4*:SunOS:6*:*)
 	# According to config.sub, this is the proper way to canonicalize
 	# SunOS6.  Hard to guess exactly what SunOS6 will be like, but
 	# it's likely to be more like Solaris than SunOS4.
 	echo sparc-sun-solaris3`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
-	exit 0 ;;
+	exit ;;
     sun4*:SunOS:*:*)
 	case "`/usr/bin/arch -k`" in
 	    Series*|S4*)
 		UNAME_RELEASE=`uname -v`
 		;;
 	esac
 	# Japanese Language versions have a version number like `4.1.3-JL'.
 	echo sparc-sun-sunos`echo ${UNAME_RELEASE}|sed -e 's/-/_/'`
-	exit 0 ;;
+	exit ;;
     sun3*:SunOS:*:*)
 	echo m68k-sun-sunos${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     sun*:*:4.2BSD:*)
 	UNAME_RELEASE=`(sed 1q /etc/motd | awk '{print substr($5,1,3)}') 2>/dev/null`
 	test "x${UNAME_RELEASE}" = "x" && UNAME_RELEASE=3
 	case "`/bin/arch`" in
 	    sun3)
 		echo m68k-sun-sunos${UNAME_RELEASE}
 		;;
 	    sun4)
 		echo sparc-sun-sunos${UNAME_RELEASE}
 		;;
 	esac
-	exit 0 ;;
+	exit ;;
     aushp:SunOS:*:*)
 	echo sparc-auspex-sunos${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     # The situation for MiNT is a little confusing.  The machine name
     # can be virtually everything (everything which is not
     # "atarist" or "atariste" at least should have a processor
     # > m68000).  The system name ranges from "MiNT" over "FreeMiNT"
     # to the lowercase version "mint" (or "freemint").  Finally
     # the system name "TOS" denotes a system which is actually not
     # MiNT.  But MiNT is downward compatible to TOS, so this should
     # be no problem.
     atarist[e]:*MiNT:*:* | atarist[e]:*mint:*:* | atarist[e]:*TOS:*:*)
         echo m68k-atari-mint${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     atari*:*MiNT:*:* | atari*:*mint:*:* | atarist[e]:*TOS:*:*)
 	echo m68k-atari-mint${UNAME_RELEASE}
-        exit 0 ;;
+        exit ;;
     *falcon*:*MiNT:*:* | *falcon*:*mint:*:* | *falcon*:*TOS:*:*)
         echo m68k-atari-mint${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     milan*:*MiNT:*:* | milan*:*mint:*:* | *milan*:*TOS:*:*)
         echo m68k-milan-mint${UNAME_RELEASE}
-        exit 0 ;;
+        exit ;;
     hades*:*MiNT:*:* | hades*:*mint:*:* | *hades*:*TOS:*:*)
         echo m68k-hades-mint${UNAME_RELEASE}
-        exit 0 ;;
+        exit ;;
     *:*MiNT:*:* | *:*mint:*:* | *:*TOS:*:*)
         echo m68k-unknown-mint${UNAME_RELEASE}
-        exit 0 ;;
+        exit ;;
+    m68k:machten:*:*)
+	echo m68k-apple-machten${UNAME_RELEASE}
+	exit ;;
     powerpc:machten:*:*)
 	echo powerpc-apple-machten${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     RISC*:Mach:*:*)
 	echo mips-dec-mach_bsd4.3
-	exit 0 ;;
+	exit ;;
     RISC*:ULTRIX:*:*)
 	echo mips-dec-ultrix${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     VAX*:ULTRIX*:*:*)
 	echo vax-dec-ultrix${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     2020:CLIX:*:* | 2430:CLIX:*:*)
 	echo clipper-intergraph-clix${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     mips:*:*:UMIPS | mips:*:*:RISCos)
 	eval $set_cc_for_build
 	sed 's/^	//' << EOF >$dummy.c
 #ifdef __cplusplus
 #include <stdio.h>  /* for printf() prototype */
 	int main (int argc, char *argv[]) {
 #else
 	int main (argc, argv) int argc; char *argv[]; {
@@ -425,145 +428,150 @@ case "${UNAME_MACHINE}:${UNAME_SYSTEM}:$
 	#endif
 	#if defined (SYSTYPE_BSD43) || defined(SYSTYPE_BSD)
 	  printf ("mips-mips-riscos%sbsd\n", argv[1]); exit (0);
 	#endif
 	#endif
 	  exit (-1);
 	}
 EOF
-	$CC_FOR_BUILD -o $dummy $dummy.c \
-	  && $dummy `echo "${UNAME_RELEASE}" | sed -n 's/\([0-9]*\).*/\1/p'` \
-	  && exit 0
+	$CC_FOR_BUILD -o $dummy $dummy.c &&
+	  dummyarg=`echo "${UNAME_RELEASE}" | sed -n 's/\([0-9]*\).*/\1/p'` &&
+	  SYSTEM_NAME=`$dummy $dummyarg` &&
+	    { echo "$SYSTEM_NAME"; exit; }
 	echo mips-mips-riscos${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     Motorola:PowerMAX_OS:*:*)
 	echo powerpc-motorola-powermax
-	exit 0 ;;
+	exit ;;
     Motorola:*:4.3:PL8-*)
 	echo powerpc-harris-powermax
-	exit 0 ;;
+	exit ;;
     Night_Hawk:*:*:PowerMAX_OS | Synergy:PowerMAX_OS:*:*)
 	echo powerpc-harris-powermax
-	exit 0 ;;
+	exit ;;
     Night_Hawk:Power_UNIX:*:*)
 	echo powerpc-harris-powerunix
-	exit 0 ;;
+	exit ;;
     m88k:CX/UX:7*:*)
 	echo m88k-harris-cxux7
-	exit 0 ;;
+	exit ;;
     m88k:*:4*:R4*)
 	echo m88k-motorola-sysv4
-	exit 0 ;;
+	exit ;;
     m88k:*:3*:R3*)
 	echo m88k-motorola-sysv3
-	exit 0 ;;
+	exit ;;
     AViiON:dgux:*:*)
         # DG/UX returns AViiON for all architectures
         UNAME_PROCESSOR=`/usr/bin/uname -p`
 	if [ $UNAME_PROCESSOR = mc88100 ] || [ $UNAME_PROCESSOR = mc88110 ]
 	then
 	    if [ ${TARGET_BINARY_INTERFACE}x = m88kdguxelfx ] || \
 	       [ ${TARGET_BINARY_INTERFACE}x = x ]
 	    then
 		echo m88k-dg-dgux${UNAME_RELEASE}
 	    else
 		echo m88k-dg-dguxbcs${UNAME_RELEASE}
 	    fi
 	else
 	    echo i586-dg-dgux${UNAME_RELEASE}
 	fi
- 	exit 0 ;;
+ 	exit ;;
     M88*:DolphinOS:*:*)	# DolphinOS (SVR3)
 	echo m88k-dolphin-sysv3
-	exit 0 ;;
+	exit ;;
     M88*:*:R3*:*)
 	# Delta 88k system running SVR3
 	echo m88k-motorola-sysv3
-	exit 0 ;;
+	exit ;;
     XD88*:*:*:*) # Tektronix XD88 system running UTekV (SVR3)
 	echo m88k-tektronix-sysv3
-	exit 0 ;;
+	exit ;;
     Tek43[0-9][0-9]:UTek:*:*) # Tektronix 4300 system running UTek (BSD)
 	echo m68k-tektronix-bsd
-	exit 0 ;;
+	exit ;;
     *:IRIX*:*:*)
 	echo mips-sgi-irix`echo ${UNAME_RELEASE}|sed -e 's/-/_/g'`
-	exit 0 ;;
+	exit ;;
     ????????:AIX?:[12].1:2)   # AIX 2.2.1 or AIX 2.1.1 is RT/PC AIX.
-	echo romp-ibm-aix      # uname -m gives an 8 hex-code CPU id
-	exit 0 ;;              # Note that: echo "'`uname -s`'" gives 'AIX '
+	echo romp-ibm-aix     # uname -m gives an 8 hex-code CPU id
+	exit ;;               # Note that: echo "'`uname -s`'" gives 'AIX '
     i*86:AIX:*:*)
 	echo i386-ibm-aix
-	exit 0 ;;
+	exit ;;
     ia64:AIX:*:*)
 	if [ -x /usr/bin/oslevel ] ; then
 		IBM_REV=`/usr/bin/oslevel`
 	else
 		IBM_REV=${UNAME_VERSION}.${UNAME_RELEASE}
 	fi
 	echo ${UNAME_MACHINE}-ibm-aix${IBM_REV}
-	exit 0 ;;
+	exit ;;
     *:AIX:2:3)
 	if grep bos325 /usr/include/stdio.h >/dev/null 2>&1; then
 		eval $set_cc_for_build
 		sed 's/^		//' << EOF >$dummy.c
 		#include <sys/systemcfg.h>
 
 		main()
 			{
 			if (!__power_pc())
 				exit(1);
 			puts("powerpc-ibm-aix3.2.5");
 			exit(0);
 			}
 EOF
-		$CC_FOR_BUILD -o $dummy $dummy.c && $dummy && exit 0
-		echo rs6000-ibm-aix3.2.5
+		if $CC_FOR_BUILD -o $dummy $dummy.c && SYSTEM_NAME=`$dummy`
+		then
+			echo "$SYSTEM_NAME"
+		else
+			echo rs6000-ibm-aix3.2.5
+		fi
 	elif grep bos324 /usr/include/stdio.h >/dev/null 2>&1; then
 		echo rs6000-ibm-aix3.2.4
 	else
 		echo rs6000-ibm-aix3.2
 	fi
-	exit 0 ;;
-    *:AIX:*:[45])
+	exit ;;
+    *:AIX:*:[456])
 	IBM_CPU_ID=`/usr/sbin/lsdev -C -c processor -S available | sed 1q | awk '{ print $1 }'`
 	if /usr/sbin/lsattr -El ${IBM_CPU_ID} | grep ' POWER' >/dev/null 2>&1; then
 		IBM_ARCH=rs6000
 	else
 		IBM_ARCH=powerpc
 	fi
 	if [ -x /usr/bin/oslevel ] ; then
 		IBM_REV=`/usr/bin/oslevel`
 	else
 		IBM_REV=${UNAME_VERSION}.${UNAME_RELEASE}
 	fi
 	echo ${IBM_ARCH}-ibm-aix${IBM_REV}
-	exit 0 ;;
+	exit ;;
     *:AIX:*:*)
 	echo rs6000-ibm-aix
-	exit 0 ;;
+	exit ;;
     ibmrt:4.4BSD:*|romp-ibm:BSD:*)
 	echo romp-ibm-bsd4.4
-	exit 0 ;;
+	exit ;;
     ibmrt:*BSD:*|romp-ibm:BSD:*)            # covers RT/PC BSD and
 	echo romp-ibm-bsd${UNAME_RELEASE}   # 4.3 with uname added to
-	exit 0 ;;                           # report: romp-ibm BSD 4.3
+	exit ;;                             # report: romp-ibm BSD 4.3
     *:BOSX:*:*)
 	echo rs6000-bull-bosx
-	exit 0 ;;
+	exit ;;
     DPX/2?00:B.O.S.:*:*)
 	echo m68k-bull-sysv3
-	exit 0 ;;
+	exit ;;
     9000/[34]??:4.3bsd:1.*:*)
 	echo m68k-hp-bsd
-	exit 0 ;;
+	exit ;;
     hp300:4.4BSD:*:* | 9000/[34]??:4.3bsd:2.*:*)
 	echo m68k-hp-bsd4.4
-	exit 0 ;;
+	exit ;;
     9000/[34678]??:HP-UX:*:*)
 	HPUX_REV=`echo ${UNAME_RELEASE}|sed -e 's/[^.]*.[0B]*//'`
 	case "${UNAME_MACHINE}" in
 	    9000/31? )            HP_ARCH=m68000 ;;
 	    9000/[34]?? )         HP_ARCH=m68k ;;
 	    9000/[678][0-9][0-9])
 		if [ -x /usr/bin/getconf ]; then
 		    sc_cpu_version=`/usr/bin/getconf SC_CPU_VERSION 2>/dev/null`
@@ -615,31 +623,41 @@ EOF
               }
 EOF
 		    (CCOPTS= $CC_FOR_BUILD -o $dummy $dummy.c 2>/dev/null) && HP_ARCH=`$dummy`
 		    test -z "$HP_ARCH" && HP_ARCH=hppa
 		fi ;;
 	esac
 	if [ ${HP_ARCH} = "hppa2.0w" ]
 	then
-	    # avoid double evaluation of $set_cc_for_build
-	    test -n "$CC_FOR_BUILD" || eval $set_cc_for_build
-	    if echo __LP64__ | (CCOPTS= $CC_FOR_BUILD -E -) | grep __LP64__ >/dev/null
+	    eval $set_cc_for_build
+
+	    # hppa2.0w-hp-hpux* has a 64-bit kernel and a compiler generating
+	    # 32-bit code.  hppa64-hp-hpux* has the same kernel and a compiler
+	    # generating 64-bit code.  GNU and HP use different nomenclature:
+	    #
+	    # $ CC_FOR_BUILD=cc ./config.guess
+	    # => hppa2.0w-hp-hpux11.23
+	    # $ CC_FOR_BUILD="cc +DA2.0w" ./config.guess
+	    # => hppa64-hp-hpux11.23
+
+	    if echo __LP64__ | (CCOPTS= $CC_FOR_BUILD -E - 2>/dev/null) |
+		grep __LP64__ >/dev/null
 	    then
 		HP_ARCH="hppa2.0w"
 	    else
 		HP_ARCH="hppa64"
 	    fi
 	fi
 	echo ${HP_ARCH}-hp-hpux${HPUX_REV}
-	exit 0 ;;
+	exit ;;
     ia64:HP-UX:*:*)
 	HPUX_REV=`echo ${UNAME_RELEASE}|sed -e 's/[^.]*.[0B]*//'`
 	echo ia64-hp-hpux${HPUX_REV}
-	exit 0 ;;
+	exit ;;
     3050*:HI-UX:*:*)
 	eval $set_cc_for_build
 	sed 's/^	//' << EOF >$dummy.c
 	#include <unistd.h>
 	int
 	main ()
 	{
 	  long cpu = sysconf (_SC_CPU_VERSION);
@@ -657,181 +675,224 @@ EOF
 		}
 	    }
 	  else if (CPU_IS_HP_MC68K (cpu))
 	    puts ("m68k-hitachi-hiuxwe2");
 	  else puts ("unknown-hitachi-hiuxwe2");
 	  exit (0);
 	}
 EOF
-	$CC_FOR_BUILD -o $dummy $dummy.c && $dummy && exit 0
+	$CC_FOR_BUILD -o $dummy $dummy.c && SYSTEM_NAME=`$dummy` &&
+		{ echo "$SYSTEM_NAME"; exit; }
 	echo unknown-hitachi-hiuxwe2
-	exit 0 ;;
+	exit ;;
     9000/7??:4.3bsd:*:* | 9000/8?[79]:4.3bsd:*:* )
 	echo hppa1.1-hp-bsd
-	exit 0 ;;
+	exit ;;
     9000/8??:4.3bsd:*:*)
 	echo hppa1.0-hp-bsd
-	exit 0 ;;
+	exit ;;
     *9??*:MPE/iX:*:* | *3000*:MPE/iX:*:*)
 	echo hppa1.0-hp-mpeix
-	exit 0 ;;
+	exit ;;
     hp7??:OSF1:*:* | hp8?[79]:OSF1:*:* )
 	echo hppa1.1-hp-osf
-	exit 0 ;;
+	exit ;;
     hp8??:OSF1:*:*)
 	echo hppa1.0-hp-osf
-	exit 0 ;;
+	exit ;;
     i*86:OSF1:*:*)
 	if [ -x /usr/sbin/sysversion ] ; then
 	    echo ${UNAME_MACHINE}-unknown-osf1mk
 	else
 	    echo ${UNAME_MACHINE}-unknown-osf1
 	fi
-	exit 0 ;;
+	exit ;;
     parisc*:Lites*:*:*)
 	echo hppa1.1-hp-lites
-	exit 0 ;;
+	exit ;;
     C1*:ConvexOS:*:* | convex:ConvexOS:C1*:*)
 	echo c1-convex-bsd
-        exit 0 ;;
+        exit ;;
     C2*:ConvexOS:*:* | convex:ConvexOS:C2*:*)
 	if getsysinfo -f scalar_acc
 	then echo c32-convex-bsd
 	else echo c2-convex-bsd
 	fi
-        exit 0 ;;
+        exit ;;
     C34*:ConvexOS:*:* | convex:ConvexOS:C34*:*)
 	echo c34-convex-bsd
-        exit 0 ;;
+        exit ;;
     C38*:ConvexOS:*:* | convex:ConvexOS:C38*:*)
 	echo c38-convex-bsd
-        exit 0 ;;
+        exit ;;
     C4*:ConvexOS:*:* | convex:ConvexOS:C4*:*)
 	echo c4-convex-bsd
-        exit 0 ;;
+        exit ;;
     CRAY*Y-MP:*:*:*)
 	echo ymp-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
-	exit 0 ;;
+	exit ;;
     CRAY*[A-Z]90:*:*:*)
 	echo ${UNAME_MACHINE}-cray-unicos${UNAME_RELEASE} \
 	| sed -e 's/CRAY.*\([A-Z]90\)/\1/' \
 	      -e y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/ \
 	      -e 's/\.[^.]*$/.X/'
-	exit 0 ;;
+	exit ;;
     CRAY*TS:*:*:*)
 	echo t90-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
-	exit 0 ;;
+	exit ;;
     CRAY*T3E:*:*:*)
 	echo alphaev5-cray-unicosmk${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
-	exit 0 ;;
+	exit ;;
     CRAY*SV1:*:*:*)
 	echo sv1-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
-	exit 0 ;;
+	exit ;;
     *:UNICOS/mp:*:*)
-	echo nv1-cray-unicosmp${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/' 
-	exit 0 ;;
+	echo craynv-cray-unicosmp${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
+	exit ;;
     F30[01]:UNIX_System_V:*:* | F700:UNIX_System_V:*:*)
 	FUJITSU_PROC=`uname -m | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`
         FUJITSU_SYS=`uname -p | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/\///'`
         FUJITSU_REL=`echo ${UNAME_RELEASE} | sed -e 's/ /_/'`
         echo "${FUJITSU_PROC}-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
-        exit 0 ;;
+        exit ;;
+    5000:UNIX_System_V:4.*:*)
+        FUJITSU_SYS=`uname -p | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/\///'`
+        FUJITSU_REL=`echo ${UNAME_RELEASE} | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/ /_/'`
+        echo "sparc-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
+	exit ;;
     i*86:BSD/386:*:* | i*86:BSD/OS:*:* | *:Ascend\ Embedded/OS:*:*)
 	echo ${UNAME_MACHINE}-pc-bsdi${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     sparc*:BSD/OS:*:*)
 	echo sparc-unknown-bsdi${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     *:BSD/OS:*:*)
 	echo ${UNAME_MACHINE}-unknown-bsdi${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     *:FreeBSD:*:*)
-	# Determine whether the default compiler uses glibc.
-	eval $set_cc_for_build
-	sed 's/^	//' << EOF >$dummy.c
-	#include <features.h>
-	#if __GLIBC__ >= 2
-	LIBC=gnu
-	#else
-	LIBC=
-	#endif
-EOF
-	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep ^LIBC=`
-	echo ${UNAME_MACHINE}-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`${LIBC:+-$LIBC}
-	exit 0 ;;
+	case ${UNAME_MACHINE} in
+	    pc98)
+		echo i386-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'` ;;
+	    amd64)
+		echo x86_64-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'` ;;
+	    *)
+		echo ${UNAME_MACHINE}-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'` ;;
+	esac
+	exit ;;
     i*:CYGWIN*:*)
 	echo ${UNAME_MACHINE}-pc-cygwin
-	exit 0 ;;
-    i*:MINGW*:*)
+	exit ;;
+    *:MINGW*:*)
 	echo ${UNAME_MACHINE}-pc-mingw32
-	exit 0 ;;
-#### MozillaHack 
-# Netscape's hacked uname
-    xx:WINNT:* | xx:WIN95:*)
-	echo i586-pc-msvc
-	exit 0 ;;
-###  End MozillaHack
+	exit ;;
+    i*:windows32*:*)
+    	# uname -m includes "-pc" on this system.
+    	echo ${UNAME_MACHINE}-mingw32
+	exit ;;
     i*:PW*:*)
 	echo ${UNAME_MACHINE}-pc-pw32
-	exit 0 ;;
-    x86:Interix*:3*)
-	echo i586-pc-interix3
-	exit 0 ;;
+	exit ;;
+    *:Interix*:[3456]*)
+    	case ${UNAME_MACHINE} in
+	    x86)
+		echo i586-pc-interix${UNAME_RELEASE}
+		exit ;;
+	    EM64T | authenticamd)
+		echo x86_64-unknown-interix${UNAME_RELEASE}
+		exit ;;
+	    IA64)
+		echo ia64-unknown-interix${UNAME_RELEASE}
+		exit ;;
+	esac ;;
     [345]86:Windows_95:* | [345]86:Windows_98:* | [345]86:Windows_NT:*)
 	echo i${UNAME_MACHINE}-pc-mks
-	exit 0 ;;
+	exit ;;
     i*:Windows_NT*:* | Pentium*:Windows_NT*:*)
 	# How do we know it's Interix rather than the generic POSIX subsystem?
 	# It also conflicts with pre-2.0 versions of AT&T UWIN. Should we
 	# UNAME_MACHINE based on the output of uname instead of i386?
 	echo i586-pc-interix
-	exit 0 ;;
+	exit ;;
     i*:UWIN*:*)
 	echo ${UNAME_MACHINE}-pc-uwin
-	exit 0 ;;
+	exit ;;
+    amd64:CYGWIN*:*:* | x86_64:CYGWIN*:*:*)
+	echo x86_64-unknown-cygwin
+	exit ;;
     p*:CYGWIN*:*)
 	echo powerpcle-unknown-cygwin
-	exit 0 ;;
+	exit ;;
     prep*:SunOS:5.*:*)
 	echo powerpcle-unknown-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
-	exit 0 ;;
+	exit ;;
     *:GNU:*:*)
+	# the GNU system
 	echo `echo ${UNAME_MACHINE}|sed -e 's,[-/].*$,,'`-unknown-gnu`echo ${UNAME_RELEASE}|sed -e 's,/.*$,,'`
-	exit 0 ;;
+	exit ;;
+    *:GNU/*:*:*)
+	# other systems with GNU libc and userland
+	echo ${UNAME_MACHINE}-unknown-`echo ${UNAME_SYSTEM} | sed 's,^[^/]*/,,' | tr '[A-Z]' '[a-z]'``echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`-gnu
+	exit ;;
     i*86:Minix:*:*)
 	echo ${UNAME_MACHINE}-pc-minix
-	exit 0 ;;
+	exit ;;
     arm*:Linux:*:*)
+	eval $set_cc_for_build
+	if echo __ARM_EABI__ | $CC_FOR_BUILD -E - 2>/dev/null \
+	    | grep -q __ARM_EABI__
+	then
+	    echo ${UNAME_MACHINE}-unknown-linux-gnu
+	else
+	    echo ${UNAME_MACHINE}-unknown-linux-gnueabi
+	fi
+	exit ;;
+    avr32*:Linux:*:*)
 	echo ${UNAME_MACHINE}-unknown-linux-gnu
-	exit 0 ;;
+	exit ;;
+    cris:Linux:*:*)
+	echo cris-axis-linux-gnu
+	exit ;;
+    crisv32:Linux:*:*)
+	echo crisv32-axis-linux-gnu
+	exit ;;
+    frv:Linux:*:*)
+    	echo frv-unknown-linux-gnu
+	exit ;;
     ia64:Linux:*:*)
 	echo ${UNAME_MACHINE}-unknown-linux-gnu
-	exit 0 ;;
+	exit ;;
+    m32r*:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	exit ;;
     m68*:Linux:*:*)
 	echo ${UNAME_MACHINE}-unknown-linux-gnu
-	exit 0 ;;
+	exit ;;
     mips:Linux:*:*)
 	eval $set_cc_for_build
 	sed 's/^	//' << EOF >$dummy.c
 	#undef CPU
 	#undef mips
 	#undef mipsel
 	#if defined(__MIPSEL__) || defined(__MIPSEL) || defined(_MIPSEL) || defined(MIPSEL)
 	CPU=mipsel
 	#else
 	#if defined(__MIPSEB__) || defined(__MIPSEB) || defined(_MIPSEB) || defined(MIPSEB)
 	CPU=mips
 	#else
 	CPU=
 	#endif
 	#endif
 EOF
-	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep ^CPU=`
-	test x"${CPU}" != x && echo "${CPU}-unknown-linux-gnu" && exit 0
+	eval "`$CC_FOR_BUILD -E $dummy.c 2>/dev/null | sed -n '
+	    /^CPU/{
+		s: ::g
+		p
+	    }'`"
+	test x"${CPU}" != x && { echo "${CPU}-unknown-linux-gnu"; exit; }
 	;;
     mips64:Linux:*:*)
 	eval $set_cc_for_build
 	sed 's/^	//' << EOF >$dummy.c
 	#undef CPU
 	#undef mips64
 	#undef mips64el
 	#if defined(__MIPSEL__) || defined(__MIPSEL) || defined(_MIPSEL) || defined(MIPSEL)
@@ -839,62 +900,78 @@ EOF
 	#else
 	#if defined(__MIPSEB__) || defined(__MIPSEB) || defined(_MIPSEB) || defined(MIPSEB)
 	CPU=mips64
 	#else
 	CPU=
 	#endif
 	#endif
 EOF
-	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep ^CPU=`
-	test x"${CPU}" != x && echo "${CPU}-unknown-linux-gnu" && exit 0
+	eval "`$CC_FOR_BUILD -E $dummy.c 2>/dev/null | sed -n '
+	    /^CPU/{
+		s: ::g
+		p
+	    }'`"
+	test x"${CPU}" != x && { echo "${CPU}-unknown-linux-gnu"; exit; }
 	;;
+    or32:Linux:*:*)
+	echo or32-unknown-linux-gnu
+	exit ;;
     ppc:Linux:*:*)
 	echo powerpc-unknown-linux-gnu
-	exit 0 ;;
+	exit ;;
     ppc64:Linux:*:*)
 	echo powerpc64-unknown-linux-gnu
-	exit 0 ;;
+	exit ;;
     alpha:Linux:*:*)
 	case `sed -n '/^cpu model/s/^.*: \(.*\)/\1/p' < /proc/cpuinfo` in
 	  EV5)   UNAME_MACHINE=alphaev5 ;;
 	  EV56)  UNAME_MACHINE=alphaev56 ;;
 	  PCA56) UNAME_MACHINE=alphapca56 ;;
 	  PCA57) UNAME_MACHINE=alphapca56 ;;
 	  EV6)   UNAME_MACHINE=alphaev6 ;;
 	  EV67)  UNAME_MACHINE=alphaev67 ;;
 	  EV68*) UNAME_MACHINE=alphaev68 ;;
         esac
 	objdump --private-headers /bin/sh | grep ld.so.1 >/dev/null
 	if test "$?" = 0 ; then LIBC="libc1" ; else LIBC="" ; fi
 	echo ${UNAME_MACHINE}-unknown-linux-gnu${LIBC}
-	exit 0 ;;
+	exit ;;
     parisc:Linux:*:* | hppa:Linux:*:*)
 	# Look for CPU level
 	case `grep '^cpu[^a-z]*:' /proc/cpuinfo 2>/dev/null | cut -d' ' -f2` in
 	  PA7*) echo hppa1.1-unknown-linux-gnu ;;
 	  PA8*) echo hppa2.0-unknown-linux-gnu ;;
 	  *)    echo hppa-unknown-linux-gnu ;;
 	esac
-	exit 0 ;;
+	exit ;;
     parisc64:Linux:*:* | hppa64:Linux:*:*)
 	echo hppa64-unknown-linux-gnu
-	exit 0 ;;
+	exit ;;
     s390:Linux:*:* | s390x:Linux:*:*)
 	echo ${UNAME_MACHINE}-ibm-linux
-	exit 0 ;;
+	exit ;;
+    sh64*:Linux:*:*)
+    	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	exit ;;
     sh*:Linux:*:*)
 	echo ${UNAME_MACHINE}-unknown-linux-gnu
-	exit 0 ;;
+	exit ;;
     sparc:Linux:*:* | sparc64:Linux:*:*)
 	echo ${UNAME_MACHINE}-unknown-linux-gnu
-	exit 0 ;;
+	exit ;;
+    vax:Linux:*:*)
+	echo ${UNAME_MACHINE}-dec-linux-gnu
+	exit ;;
     x86_64:Linux:*:*)
 	echo x86_64-unknown-linux-gnu
-	exit 0 ;;
+	exit ;;
+    xtensa*:Linux:*:*)
+    	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	exit ;;
     i*86:Linux:*:*)
 	# The BFD linker knows what the default object file format is, so
 	# first see if it will tell us. cd to the root directory to prevent
 	# problems with other programs or directories called `ld' in the path.
 	# Set LC_ALL=C to ensure ld outputs messages in English.
 	ld_supported_targets=`cd /; LC_ALL=C ld --help 2>&1 \
 			 | sed -ne '/supported targets:/!d
 				    s/[ 	][ 	]*/ /g
@@ -902,99 +979,113 @@ EOF
 				    s/ .*//
 				    p'`
         case "$ld_supported_targets" in
 	  elf32-i386)
 		TENTATIVE="${UNAME_MACHINE}-pc-linux-gnu"
 		;;
 	  a.out-i386-linux)
 		echo "${UNAME_MACHINE}-pc-linux-gnuaout"
-		exit 0 ;;
+		exit ;;
 	  coff-i386)
 		echo "${UNAME_MACHINE}-pc-linux-gnucoff"
-		exit 0 ;;
+		exit ;;
 	  "")
 		# Either a pre-BFD a.out linker (linux-gnuoldld) or
 		# one that does not give us useful --help.
 		echo "${UNAME_MACHINE}-pc-linux-gnuoldld"
-		exit 0 ;;
+		exit ;;
 	esac
 	# Determine whether the default compiler is a.out or elf
 	eval $set_cc_for_build
 	sed 's/^	//' << EOF >$dummy.c
 	#include <features.h>
 	#ifdef __ELF__
 	# ifdef __GLIBC__
 	#  if __GLIBC__ >= 2
 	LIBC=gnu
 	#  else
 	LIBC=gnulibc1
 	#  endif
 	# else
 	LIBC=gnulibc1
 	# endif
 	#else
-	#ifdef __INTEL_COMPILER
+	#if defined(__INTEL_COMPILER) || defined(__PGI) || defined(__SUNPRO_C) || defined(__SUNPRO_CC)
 	LIBC=gnu
 	#else
 	LIBC=gnuaout
 	#endif
 	#endif
+	#ifdef __dietlibc__
+	LIBC=dietlibc
+	#endif
 EOF
-	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep ^LIBC=`
-	test x"${LIBC}" != x && echo "${UNAME_MACHINE}-pc-linux-${LIBC}" && exit 0
-	test x"${TENTATIVE}" != x && echo "${TENTATIVE}" && exit 0
+	eval "`$CC_FOR_BUILD -E $dummy.c 2>/dev/null | sed -n '
+	    /^LIBC/{
+		s: ::g
+		p
+	    }'`"
+	test x"${LIBC}" != x && {
+		echo "${UNAME_MACHINE}-pc-linux-${LIBC}"
+		exit
+	}
+	test x"${TENTATIVE}" != x && { echo "${TENTATIVE}"; exit; }
 	;;
     i*86:DYNIX/ptx:4*:*)
 	# ptx 4.0 does uname -s correctly, with DYNIX/ptx in there.
 	# earlier versions are messed up and put the nodename in both
 	# sysname and nodename.
 	echo i386-sequent-sysv4
-	exit 0 ;;
+	exit ;;
     i*86:UNIX_SV:4.2MP:2.*)
         # Unixware is an offshoot of SVR4, but it has its own version
         # number series starting with 2...
         # I am not positive that other SVR4 systems won't match this,
 	# I just have to hope.  -- rms.
         # Use sysv4.2uw... so that sysv4* matches it.
 	echo ${UNAME_MACHINE}-pc-sysv4.2uw${UNAME_VERSION}
-	exit 0 ;;
+	exit ;;
     i*86:OS/2:*:*)
 	# If we were able to find `uname', then EMX Unix compatibility
 	# is probably installed.
 	echo ${UNAME_MACHINE}-pc-os2-emx
-	exit 0 ;;
+	exit ;;
     i*86:XTS-300:*:STOP)
 	echo ${UNAME_MACHINE}-unknown-stop
-	exit 0 ;;
+	exit ;;
     i*86:atheos:*:*)
 	echo ${UNAME_MACHINE}-unknown-atheos
-	exit 0 ;;
+	exit ;;
+    i*86:syllable:*:*)
+	echo ${UNAME_MACHINE}-pc-syllable
+	exit ;;
     i*86:LynxOS:2.*:* | i*86:LynxOS:3.[01]*:* | i*86:LynxOS:4.0*:*)
 	echo i386-unknown-lynxos${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     i*86:*DOS:*:*)
 	echo ${UNAME_MACHINE}-pc-msdosdjgpp
-	exit 0 ;;
+	exit ;;
     i*86:*:4.*:* | i*86:SYSTEM_V:4.*:*)
 	UNAME_REL=`echo ${UNAME_RELEASE} | sed 's/\/MP$//'`
 	if grep Novell /usr/include/link.h >/dev/null 2>/dev/null; then
 		echo ${UNAME_MACHINE}-univel-sysv${UNAME_REL}
 	else
 		echo ${UNAME_MACHINE}-pc-sysv${UNAME_REL}
 	fi
-	exit 0 ;;
-    i*86:*:5:[78]*)
+	exit ;;
+    i*86:*:5:[678]*)
+    	# UnixWare 7.x, OpenUNIX and OpenServer 6.
 	case `/bin/uname -X | grep "^Machine"` in
 	    *486*)	     UNAME_MACHINE=i486 ;;
 	    *Pentium)	     UNAME_MACHINE=i586 ;;
 	    *Pent*|*Celeron) UNAME_MACHINE=i686 ;;
 	esac
 	echo ${UNAME_MACHINE}-unknown-sysv${UNAME_RELEASE}${UNAME_SYSTEM}${UNAME_VERSION}
-	exit 0 ;;
+	exit ;;
     i*86:*:3.2:*)
 	if test -f /usr/options/cb.name; then
 		UNAME_REL=`sed -n 's/.*Version //p' </usr/options/cb.name`
 		echo ${UNAME_MACHINE}-pc-isc$UNAME_REL
 	elif /bin/uname -X 2>/dev/null >/dev/null ; then
 		UNAME_REL=`(/bin/uname -X|grep Release|sed -e 's/.*= //')`
 		(/bin/uname -X|grep i80486 >/dev/null) && UNAME_MACHINE=i486
 		(/bin/uname -X|grep '^Machine.*Pentium' >/dev/null) \
@@ -1002,214 +1093,248 @@ EOF
 		(/bin/uname -X|grep '^Machine.*Pent *II' >/dev/null) \
 			&& UNAME_MACHINE=i686
 		(/bin/uname -X|grep '^Machine.*Pentium Pro' >/dev/null) \
 			&& UNAME_MACHINE=i686
 		echo ${UNAME_MACHINE}-pc-sco$UNAME_REL
 	else
 		echo ${UNAME_MACHINE}-pc-sysv32
 	fi
-	exit 0 ;;
+	exit ;;
     pc:*:*:*)
 	# Left here for compatibility:
         # uname -m prints for DJGPP always 'pc', but it prints nothing about
         # the processor, so we play safe by assuming i386.
 	echo i386-pc-msdosdjgpp
-        exit 0 ;;
+        exit ;;
     Intel:Mach:3*:*)
 	echo i386-pc-mach3
-	exit 0 ;;
+	exit ;;
     paragon:*:*:*)
 	echo i860-intel-osf1
-	exit 0 ;;
+	exit ;;
     i860:*:4.*:*) # i860-SVR4
 	if grep Stardent /usr/include/sys/uadmin.h >/dev/null 2>&1 ; then
 	  echo i860-stardent-sysv${UNAME_RELEASE} # Stardent Vistra i860-SVR4
 	else # Add other i860-SVR4 vendors below as they are discovered.
 	  echo i860-unknown-sysv${UNAME_RELEASE}  # Unknown i860-SVR4
 	fi
-	exit 0 ;;
+	exit ;;
     mini*:CTIX:SYS*5:*)
 	# "miniframe"
 	echo m68010-convergent-sysv
-	exit 0 ;;
+	exit ;;
     mc68k:UNIX:SYSTEM5:3.51m)
 	echo m68k-convergent-sysv
-	exit 0 ;;
+	exit ;;
     M680?0:D-NIX:5.3:*)
 	echo m68k-diab-dnix
-	exit 0 ;;
-    M68*:*:R3V[567]*:*)
-	test -r /sysV68 && echo 'm68k-motorola-sysv' && exit 0 ;;
-    3[34]??:*:4.0:3.0 | 3[34]??A:*:4.0:3.0 | 3[34]??,*:*:4.0:3.0 | 3[34]??/*:*:4.0:3.0 | 4400:*:4.0:3.0 | 4850:*:4.0:3.0 | SKA40:*:4.0:3.0 | SDS2:*:4.0:3.0)
+	exit ;;
+    M68*:*:R3V[5678]*:*)
+	test -r /sysV68 && { echo 'm68k-motorola-sysv'; exit; } ;;
+    3[345]??:*:4.0:3.0 | 3[34]??A:*:4.0:3.0 | 3[34]??,*:*:4.0:3.0 | 3[34]??/*:*:4.0:3.0 | 4400:*:4.0:3.0 | 4850:*:4.0:3.0 | SKA40:*:4.0:3.0 | SDS2:*:4.0:3.0 | SHG2:*:4.0:3.0 | S7501*:*:4.0:3.0)
 	OS_REL=''
 	test -r /etc/.relid \
 	&& OS_REL=.`sed -n 's/[^ ]* [^ ]* \([0-9][0-9]\).*/\1/p' < /etc/.relid`
 	/bin/uname -p 2>/dev/null | grep 86 >/dev/null \
-	  && echo i486-ncr-sysv4.3${OS_REL} && exit 0
+	  && { echo i486-ncr-sysv4.3${OS_REL}; exit; }
 	/bin/uname -p 2>/dev/null | /bin/grep entium >/dev/null \
-	  && echo i586-ncr-sysv4.3${OS_REL} && exit 0 ;;
+	  && { echo i586-ncr-sysv4.3${OS_REL}; exit; } ;;
     3[34]??:*:4.0:* | 3[34]??,*:*:4.0:*)
         /bin/uname -p 2>/dev/null | grep 86 >/dev/null \
-          && echo i486-ncr-sysv4 && exit 0 ;;
+          && { echo i486-ncr-sysv4; exit; } ;;
     m68*:LynxOS:2.*:* | m68*:LynxOS:3.0*:*)
 	echo m68k-unknown-lynxos${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     mc68030:UNIX_System_V:4.*:*)
 	echo m68k-atari-sysv4
-	exit 0 ;;
+	exit ;;
     TSUNAMI:LynxOS:2.*:*)
 	echo sparc-unknown-lynxos${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     rs6000:LynxOS:2.*:*)
 	echo rs6000-unknown-lynxos${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     PowerPC:LynxOS:2.*:* | PowerPC:LynxOS:3.[01]*:* | PowerPC:LynxOS:4.0*:*)
 	echo powerpc-unknown-lynxos${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     SM[BE]S:UNIX_SV:*:*)
 	echo mips-dde-sysv${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     RM*:ReliantUNIX-*:*:*)
 	echo mips-sni-sysv4
-	exit 0 ;;
+	exit ;;
     RM*:SINIX-*:*:*)
 	echo mips-sni-sysv4
-	exit 0 ;;
+	exit ;;
     *:SINIX-*:*:*)
 	if uname -p 2>/dev/null >/dev/null ; then
 		UNAME_MACHINE=`(uname -p) 2>/dev/null`
 		echo ${UNAME_MACHINE}-sni-sysv4
 	else
 		echo ns32k-sni-sysv
 	fi
-	exit 0 ;;
+	exit ;;
     PENTIUM:*:4.0*:*) # Unisys `ClearPath HMP IX 4000' SVR4/MP effort
                       # says <Richard.M.Bartel@ccMail.Census.GOV>
         echo i586-unisys-sysv4
-        exit 0 ;;
-#### MozillaHack 
-    *:*OpenVMS*:*:*)
-        case "${UNAME_SYSTEM}" in
-            POSIX_for_OpenVMS_AXP) echo alpha-dec-openvmsposix ;;
-            POSIX_for_OpenVMS_VAX) echo vax-dec-openvmsposix ;;
-            OpenVMS) echo alpha-dec-openvms ;;
-            *) echo unknown-dec-openvms ;;
-        esac
-        exit 0 ;;
-#### End MozillaHack 
+        exit ;;
     *:UNIX_System_V:4*:FTX*)
 	# From Gerald Hewes <hewes@openmarket.com>.
 	# How about differentiating between stratus architectures? -djm
 	echo hppa1.1-stratus-sysv4
-	exit 0 ;;
+	exit ;;
     *:*:*:FTX*)
 	# From seanf@swdc.stratus.com.
 	echo i860-stratus-sysv4
-	exit 0 ;;
+	exit ;;
+    i*86:VOS:*:*)
+	# From Paul.Green@stratus.com.
+	echo ${UNAME_MACHINE}-stratus-vos
+	exit ;;
     *:VOS:*:*)
 	# From Paul.Green@stratus.com.
 	echo hppa1.1-stratus-vos
-	exit 0 ;;
+	exit ;;
     mc68*:A/UX:*:*)
 	echo m68k-apple-aux${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     news*:NEWS-OS:6*:*)
 	echo mips-sony-newsos6
-	exit 0 ;;
+	exit ;;
     R[34]000:*System_V*:*:* | R4000:UNIX_SYSV:*:* | R*000:UNIX_SV:*:*)
 	if [ -d /usr/nec ]; then
 	        echo mips-nec-sysv${UNAME_RELEASE}
 	else
 	        echo mips-unknown-sysv${UNAME_RELEASE}
 	fi
-        exit 0 ;;
+        exit ;;
     BeBox:BeOS:*:*)	# BeOS running on hardware made by Be, PPC only.
 	echo powerpc-be-beos
-	exit 0 ;;
+	exit ;;
     BeMac:BeOS:*:*)	# BeOS running on Mac or Mac clone, PPC only.
 	echo powerpc-apple-beos
-	exit 0 ;;
+	exit ;;
     BePC:BeOS:*:*)	# BeOS running on Intel PC compatible.
 	echo i586-pc-beos
-	exit 0 ;;
+	exit ;;
+    BeMac:Haiku:*:*)
+	echo powerpc-apple-haiku
+	exit ;;
+    BePC:Haiku:*:*)
+	echo i586-pc-haiku
+	exit ;;
     SX-4:SUPER-UX:*:*)
 	echo sx4-nec-superux${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     SX-5:SUPER-UX:*:*)
 	echo sx5-nec-superux${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     SX-6:SUPER-UX:*:*)
 	echo sx6-nec-superux${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
+    SX-7:SUPER-UX:*:*)
+	echo sx7-nec-superux${UNAME_RELEASE}
+	exit ;;
+    SX-8:SUPER-UX:*:*)
+	echo sx8-nec-superux${UNAME_RELEASE}
+	exit ;;
+    SX-8R:SUPER-UX:*:*)
+	echo sx8r-nec-superux${UNAME_RELEASE}
+	exit ;;
     Power*:Rhapsody:*:*)
 	echo powerpc-apple-rhapsody${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     *:Rhapsody:*:*)
 	echo ${UNAME_MACHINE}-apple-rhapsody${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     *:Darwin:*:*)
-	case `uname -p` in
-	    *86) UNAME_PROCESSOR=i686 ;;
-	    powerpc) UNAME_PROCESSOR=powerpc ;;
+	UNAME_PROCESSOR=`uname -p` || UNAME_PROCESSOR=unknown
+	case $UNAME_PROCESSOR in
+	    unknown) UNAME_PROCESSOR=powerpc ;;
 	esac
 	echo ${UNAME_PROCESSOR}-apple-darwin${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     *:procnto*:*:* | *:QNX:[0123456789]*:*)
 	UNAME_PROCESSOR=`uname -p`
 	if test "$UNAME_PROCESSOR" = "x86"; then
 		UNAME_PROCESSOR=i386
 		UNAME_MACHINE=pc
 	fi
 	echo ${UNAME_PROCESSOR}-${UNAME_MACHINE}-nto-qnx${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     *:QNX:*:4*)
 	echo i386-pc-qnx
-	exit 0 ;;
-    NSR-[DGKLNPTVW]:NONSTOP_KERNEL:*:*)
+	exit ;;
+    NSE-?:NONSTOP_KERNEL:*:*)
+	echo nse-tandem-nsk${UNAME_RELEASE}
+	exit ;;
+    NSR-?:NONSTOP_KERNEL:*:*)
 	echo nsr-tandem-nsk${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     *:NonStop-UX:*:*)
 	echo mips-compaq-nonstopux
-	exit 0 ;;
+	exit ;;
     BS2000:POSIX*:*:*)
 	echo bs2000-siemens-sysv
-	exit 0 ;;
+	exit ;;
     DS/*:UNIX_System_V:*:*)
 	echo ${UNAME_MACHINE}-${UNAME_SYSTEM}-${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     *:Plan9:*:*)
 	# "uname -m" is not consistent, so use $cputype instead. 386
 	# is converted to i386 for consistency with other x86
 	# operating systems.
 	if test "$cputype" = "386"; then
 	    UNAME_MACHINE=i386
 	else
 	    UNAME_MACHINE="$cputype"
 	fi
 	echo ${UNAME_MACHINE}-unknown-plan9
-	exit 0 ;;
+	exit ;;
     *:TOPS-10:*:*)
 	echo pdp10-unknown-tops10
-	exit 0 ;;
+	exit ;;
     *:TENEX:*:*)
 	echo pdp10-unknown-tenex
-	exit 0 ;;
+	exit ;;
     KS10:TOPS-20:*:* | KL10:TOPS-20:*:* | TYPE4:TOPS-20:*:*)
 	echo pdp10-dec-tops20
-	exit 0 ;;
+	exit ;;
     XKL-1:TOPS-20:*:* | TYPE5:TOPS-20:*:*)
 	echo pdp10-xkl-tops20
-	exit 0 ;;
+	exit ;;
     *:TOPS-20:*:*)
 	echo pdp10-unknown-tops20
-	exit 0 ;;
+	exit ;;
     *:ITS:*:*)
 	echo pdp10-unknown-its
-	exit 0 ;;
+	exit ;;
+    SEI:*:*:SEIUX)
+        echo mips-sei-seiux${UNAME_RELEASE}
+	exit ;;
+    *:DragonFly:*:*)
+	echo ${UNAME_MACHINE}-unknown-dragonfly`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`
+	exit ;;
+    *:*VMS:*:*)
+    	UNAME_MACHINE=`(uname -p) 2>/dev/null`
+	case "${UNAME_MACHINE}" in
+	    A*) echo alpha-dec-vms ; exit ;;
+	    I*) echo ia64-dec-vms ; exit ;;
+	    V*) echo vax-dec-vms ; exit ;;
+	esac ;;
+    *:XENIX:*:SysV)
+	echo i386-pc-xenix
+	exit ;;
+    i*86:skyos:*:*)
+	echo ${UNAME_MACHINE}-pc-skyos`echo ${UNAME_RELEASE}` | sed -e 's/ .*$//'
+	exit ;;
+    i*86:rdos:*:*)
+	echo ${UNAME_MACHINE}-pc-rdos
+	exit ;;
 esac
 
 #echo '(No uname command or uname output not recognized.)' 1>&2
 #echo "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" 1>&2
 
 eval $set_cc_for_build
 cat >$dummy.c <<EOF
 #ifdef _SEQUENT_
@@ -1231,17 +1356,17 @@ main ()
 #else
 	  ""
 #endif
          ); exit (0);
 #endif
 #endif
 
 #if defined (__arm) && defined (__acorn) && defined (__unix)
-  printf ("arm-acorn-riscix"); exit (0);
+  printf ("arm-acorn-riscix\n"); exit (0);
 #endif
 
 #if defined (hp300) && !defined (hpux)
   printf ("m68k-hp-bsd\n"); exit (0);
 #endif
 
 #if defined (NeXT)
 #if !defined (__ARCHITECTURE__)
@@ -1320,56 +1445,59 @@ main ()
 #if defined (alliant) && defined (i860)
   printf ("i860-alliant-bsd\n"); exit (0);
 #endif
 
   exit (1);
 }
 EOF
 
-$CC_FOR_BUILD -o $dummy $dummy.c 2>/dev/null && $dummy && exit 0
+$CC_FOR_BUILD -o $dummy $dummy.c 2>/dev/null && SYSTEM_NAME=`$dummy` &&
+	{ echo "$SYSTEM_NAME"; exit; }
 
 # Apollos put the system type in the environment.
 
-test -d /usr/apollo && { echo ${ISP}-apollo-${SYSTYPE}; exit 0; }
+test -d /usr/apollo && { echo ${ISP}-apollo-${SYSTYPE}; exit; }
 
 # Convex versions that predate uname can use getsysinfo(1)
 
 if [ -x /usr/convex/getsysinfo ]
 then
     case `getsysinfo -f cpu_type` in
     c1*)
 	echo c1-convex-bsd
-	exit 0 ;;
+	exit ;;
     c2*)
 	if getsysinfo -f scalar_acc
 	then echo c32-convex-bsd
 	else echo c2-convex-bsd
 	fi
-	exit 0 ;;
+	exit ;;
     c34*)
 	echo c34-convex-bsd
-	exit 0 ;;
+	exit ;;
     c38*)
 	echo c38-convex-bsd
-	exit 0 ;;
+	exit ;;
     c4*)
 	echo c4-convex-bsd
-	exit 0 ;;
+	exit ;;
     esac
 fi
 
 cat >&2 <<EOF
 $0: unable to guess system type
 
 This script, last modified $timestamp, has failed to recognize
 the operating system you are using. It is advised that you
 download the most up to date version of the config scripts from
 
-    ftp://ftp.gnu.org/pub/gnu/config/
+  http://savannah.gnu.org/cgi-bin/viewcvs/*checkout*/config/config/config.guess
+and
+  http://savannah.gnu.org/cgi-bin/viewcvs/*checkout*/config/config/config.sub
 
 If the version you run ($0) is already up to date, please
 send the following data and any information you think might be
 pertinent to <config-patches@gnu.org> in order to provide the needed
 information to handle your system.
 
 config.guess timestamp = $timestamp
 
Index: mozilla/nsprpub/build/autoconf/config.sub
===================================================================
RCS file: /cvsroot/mozilla/nsprpub/build/autoconf/config.sub,v
retrieving revision 1.16
diff -u -8 -p -r1.16 config.sub
--- mozilla/nsprpub/build/autoconf/config.sub	18 Apr 2003 19:20:18 -0000	1.16
+++ mozilla/nsprpub/build/autoconf/config.sub	9 Feb 2009 04:04:16 -0000
@@ -1,14 +1,15 @@
 #! /bin/sh
 # Configuration validation subroutine script.
 #   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
-#   2000, 2001, 2002, 2003 Free Software Foundation, Inc.
+#   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
+#   Free Software Foundation, Inc.
 
-timestamp='2003-02-22'
+timestamp='2008-01-16'
 
 # This file is (in principle) common to ALL GNU software.
 # The presence of a machine in this file suggests that SOME GNU software
 # can handle that machine.  It does not imply ALL GNU software can.
 #
 # This file is free software; you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
 # the Free Software Foundation; either version 2 of the License, or
@@ -16,24 +17,25 @@ timestamp='2003-02-22'
 #
 # This program is distributed in the hope that it will be useful,
 # but WITHOUT ANY WARRANTY; without even the implied warranty of
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 # GNU General Public License for more details.
 #
 # You should have received a copy of the GNU General Public License
 # along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place - Suite 330,
-# Boston, MA 02111-1307, USA.
-
+# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
+# 02110-1301, USA.
+#
 # As a special exception to the GNU General Public License, if you
 # distribute this file as part of a program that contains a
 # configuration script generated by Autoconf, you may include it under
 # the same distribution terms that you use for the rest of that program.
 
+
 # Please send patches to <config-patches@gnu.org>.  Submit a context
 # diff and a properly formatted ChangeLog entry.
 #
 # Configuration subroutine to validate and canonicalize a configuration type.
 # Supply the specified configuration type as an argument.
 # If it is invalid, we print an error message on stderr and exit with code 1.
 # Otherwise, we print the canonical config type on stdout and succeed.
 
@@ -65,46 +67,46 @@ Operation modes:
   -t, --time-stamp   print date of last modification, then exit
   -v, --version      print version number, then exit
 
 Report bugs and patches to <config-patches@gnu.org>."
 
 version="\
 GNU config.sub ($timestamp)
 
-Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
-Free Software Foundation, Inc.
+Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
+2002, 2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
 
 This is free software; see the source for copying conditions.  There is NO
 warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
 
 help="
 Try \`$me --help' for more information."
 
 # Parse command line
 while test $# -gt 0 ; do
   case $1 in
     --time-stamp | --time* | -t )
-       echo "$timestamp" ; exit 0 ;;
+       echo "$timestamp" ; exit ;;
     --version | -v )
-       echo "$version" ; exit 0 ;;
+       echo "$version" ; exit ;;
     --help | --h* | -h )
-       echo "$usage"; exit 0 ;;
+       echo "$usage"; exit ;;
     -- )     # Stop option processing
        shift; break ;;
     - )	# Use stdin as input.
        break ;;
     -* )
        echo "$me: invalid option $1$help"
        exit 1 ;;
 
     *local*)
        # First pass through any local machine types.
        echo $1
-       exit 0;;
+       exit ;;
 
     * )
        break ;;
   esac
 done
 
 case $# in
  0) echo "$me: missing argument$help" >&2
@@ -113,17 +115,19 @@ case $# in
  *) echo "$me: too many arguments$help" >&2
     exit 1;;
 esac
 
 # Separate what the user gave into CPU-COMPANY and OS or KERNEL-OS (if any).
 # Here we must recognize all the valid KERNEL-OS combinations.
 maybe_os=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\2/'`
 case $maybe_os in
-  nto-qnx* | linux-gnu* | freebsd*-gnu* | netbsd*-gnu* | storm-chaos* | os2-emx* | rtmk-nova*)
+  nto-qnx* | linux-gnu* | linux-dietlibc | linux-newlib* | linux-uclibc* | \
+  uclinux-uclibc* | uclinux-gnu* | kfreebsd*-gnu* | knetbsd*-gnu* | netbsd*-gnu* | \
+  storm-chaos* | os2-emx* | rtmk-nova*)
     os=-$maybe_os
     basic_machine=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\1/'`
     ;;
   *)
     basic_machine=`echo $1 | sed 's/-[^-]*$//'`
     if [ $basic_machine != $1 ]
     then os=`echo $1 | sed 's/.*-/-/'`
     else os=; fi
@@ -139,17 +143,17 @@ case $os in
 		# Prevent following clause from handling this invalid input.
 		;;
 	-dec* | -mips* | -sequent* | -encore* | -pc532* | -sgi* | -sony* | \
 	-att* | -7300* | -3300* | -delta* | -motorola* | -sun[234]* | \
 	-unicom* | -ibm* | -next | -hp | -isi* | -apollo | -altos* | \
 	-convergent* | -ncr* | -news | -32* | -3600* | -3100* | -hitachi* |\
 	-c[123]* | -convex* | -sun | -crds | -omron* | -dg | -ultra | -tti* | \
 	-harris | -dolphin | -highlevel | -gould | -cbm | -ns | -masscomp | \
-	-apple | -axis)
+	-apple | -axis | -knuth | -cray)
 		os=
 		basic_machine=$1
 		;;
 	-sim | -cisco | -oki | -wec | -winbond)
 		os=
 		basic_machine=$1
 		;;
 	-scout)
@@ -164,32 +168,40 @@ case $os in
 		;;
  	-chorusrdb)
  		os=-chorusrdb
 		basic_machine=$1
  		;;
 	-hiux*)
 		os=-hiuxwe2
 		;;
+	-sco6)
+		os=-sco5v6
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
 	-sco5)
 		os=-sco3.2v5
 		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
 		;;
 	-sco4)
 		os=-sco3.2v4
 		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
 		;;
 	-sco3.2.[4-9]*)
 		os=`echo $os | sed -e 's/sco3.2./sco3.2v/'`
 		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
 		;;
 	-sco3.2v[4-9]*)
 		# Don't forget version if it is 3.2v4 or newer.
 		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
 		;;
+	-sco5v6*)
+		# Don't forget version if it is 3.2v4 or newer.
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
 	-sco*)
 		os=-sco3.2v2
 		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
 		;;
 	-udk*)
 		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
 		;;
 	-isc)
@@ -219,171 +231,196 @@ case $os in
 		os=-mint
 		;;
 esac
 
 # Decode aliases for certain CPU-COMPANY combinations.
 case $basic_machine in
 	# Recognize the basic CPU types without company name.
 	# Some are omitted here because they have special meanings below.
-#### MozillaHack 
-# mips*el
-#### End MozillaHack 
 	1750a | 580 \
 	| a29k \
 	| alpha | alphaev[4-8] | alphaev56 | alphaev6[78] | alphapca5[67] \
 	| alpha64 | alpha64ev[4-8] | alpha64ev56 | alpha64ev6[78] | alpha64pca5[67] \
-	| arc | arm | arm[bl]e | arme[lb] | armv[2345] | armv[345][lb] | avr \
-	| clipper \
+	| am33_2.0 \
+	| arc | arm | arm[bl]e | arme[lb] | armv[2345] | armv[345][lb] | avr | avr32 \
+	| bfin \
+	| c4x | clipper \
 	| d10v | d30v | dlx | dsp16xx \
-	| fr30 | frv \
+	| fido | fr30 | frv \
 	| h8300 | h8500 | hppa | hppa1.[01] | hppa2.0 | hppa2.0[nw] | hppa64 \
 	| i370 | i860 | i960 | ia64 \
-	| ip2k \
-	| m32r | m68000 | m68k | m88k | mcore \
-	| mips | mipsbe | mipseb | mips*el | mipsle \
+	| ip2k | iq2000 \
+	| m32c | m32r | m32rle | m68000 | m68k | m88k \
+	| maxq | mb | microblaze | mcore | mep \
+	| mips | mipsbe | mipseb | mipsel | mipsle \
 	| mips16 \
 	| mips64 | mips64el \
 	| mips64vr | mips64vrel \
 	| mips64orion | mips64orionel \
 	| mips64vr4100 | mips64vr4100el \
 	| mips64vr4300 | mips64vr4300el \
 	| mips64vr5000 | mips64vr5000el \
+	| mips64vr5900 | mips64vr5900el \
 	| mipsisa32 | mipsisa32el \
 	| mipsisa32r2 | mipsisa32r2el \
 	| mipsisa64 | mipsisa64el \
+	| mipsisa64r2 | mipsisa64r2el \
 	| mipsisa64sb1 | mipsisa64sb1el \
 	| mipsisa64sr71k | mipsisa64sr71kel \
 	| mipstx39 | mipstx39el \
 	| mn10200 | mn10300 \
+	| mt \
 	| msp430 \
+	| nios | nios2 \
 	| ns16k | ns32k \
-	| openrisc | or32 \
+	| or32 \
 	| pdp10 | pdp11 | pj | pjl \
 	| powerpc | powerpc64 | powerpc64le | powerpcle | ppcbe \
 	| pyramid \
-	| sh | sh[1234] | sh[23]e | sh[34]eb | shbe | shle | sh[1234]le | sh3ele \
+	| score \
+	| sh | sh[1234] | sh[24]a | sh[23]e | sh[34]eb | sheb | shbe | shle | sh[1234]le | sh3ele \
 	| sh64 | sh64le \
-	| sparc | sparc64 | sparc86x | sparclet | sparclite | sparcv9 | sparcv9b \
-	| strongarm \
-	| tahoe | thumb | tic80 | tron \
+	| sparc | sparc64 | sparc64b | sparc64v | sparc86x | sparclet | sparclite \
+	| sparcv8 | sparcv9 | sparcv9b | sparcv9v \
+	| spu | strongarm \
+	| tahoe | thumb | tic4x | tic80 | tron \
 	| v850 | v850e \
 	| we32k \
-	| x86 | xscale | xstormy16 | xtensa \
+	| x86 | xc16x | xscale | xscalee[bl] | xstormy16 | xtensa \
 	| z8k)
 		basic_machine=$basic_machine-unknown
 		;;
 	m6811 | m68hc11 | m6812 | m68hc12)
 		# Motorola 68HC11/12.
 		basic_machine=$basic_machine-unknown
 		os=-none
 		;;
 	m88110 | m680[12346]0 | m683?2 | m68360 | m5200 | v70 | w65 | z8k)
 		;;
+	ms1)
+		basic_machine=mt-unknown
+		;;
 
 	# We use `pc' rather than `unknown'
 	# because (1) that's what they normally are, and
 	# (2) the word "unknown" tends to confuse beginning users.
 	i*86 | x86_64)
 	  basic_machine=$basic_machine-pc
 	  ;;
 	# Object if more than one company name word.
 	*-*-*)
 		echo Invalid configuration \`$1\': machine \`$basic_machine\' not recognized 1>&2
 		exit 1
 		;;
 	# Recognize the basic CPU types with company name.
-#### MozillaHack 
-# mips*el
-#### End MozillaHack 
 	580-* \
 	| a29k-* \
 	| alpha-* | alphaev[4-8]-* | alphaev56-* | alphaev6[78]-* \
 	| alpha64-* | alpha64ev[4-8]-* | alpha64ev56-* | alpha64ev6[78]-* \
 	| alphapca5[67]-* | alpha64pca5[67]-* | arc-* \
 	| arm-*  | armbe-* | armle-* | armeb-* | armv*-* \
-	| avr-* \
-	| bs2000-* \
+	| avr-* | avr32-* \
+	| bfin-* | bs2000-* \
 	| c[123]* | c30-* | [cjt]90-* | c4x-* | c54x-* | c55x-* | c6x-* \
-	| clipper-* | cydra-* \
+	| clipper-* | craynv-* | cydra-* \
 	| d10v-* | d30v-* | dlx-* \
 	| elxsi-* \
-	| f30[01]-* | f700-* | fr30-* | frv-* | fx80-* \
+	| f30[01]-* | f700-* | fido-* | fr30-* | frv-* | fx80-* \
 	| h8300-* | h8500-* \
 	| hppa-* | hppa1.[01]-* | hppa2.0-* | hppa2.0[nw]-* | hppa64-* \
 	| i*86-* | i860-* | i960-* | ia64-* \
-	| ip2k-* \
-	| m32r-* \
+	| ip2k-* | iq2000-* \
+	| m32c-* | m32r-* | m32rle-* \
 	| m68000-* | m680[012346]0-* | m68360-* | m683?2-* | m68k-* \
-	| m88110-* | m88k-* | mcore-* \
-	| mips-* | mipsbe-* | mipseb-* | mips*el-* | mipsle-* \
+	| m88110-* | m88k-* | maxq-* | mcore-* \
+	| mips-* | mipsbe-* | mipseb-* | mipsel-* | mipsle-* \
 	| mips16-* \
 	| mips64-* | mips64el-* \
 	| mips64vr-* | mips64vrel-* \
 	| mips64orion-* | mips64orionel-* \
 	| mips64vr4100-* | mips64vr4100el-* \
 	| mips64vr4300-* | mips64vr4300el-* \
 	| mips64vr5000-* | mips64vr5000el-* \
+	| mips64vr5900-* | mips64vr5900el-* \
 	| mipsisa32-* | mipsisa32el-* \
 	| mipsisa32r2-* | mipsisa32r2el-* \
 	| mipsisa64-* | mipsisa64el-* \
+	| mipsisa64r2-* | mipsisa64r2el-* \
 	| mipsisa64sb1-* | mipsisa64sb1el-* \
 	| mipsisa64sr71k-* | mipsisa64sr71kel-* \
 	| mipstx39-* | mipstx39el-* \
+	| mmix-* \
+	| mt-* \
 	| msp430-* \
-	| none-* | np1-* | nv1-* | ns16k-* | ns32k-* \
+	| nios-* | nios2-* \
+	| none-* | np1-* | ns16k-* | ns32k-* \
 	| orion-* \
 	| pdp10-* | pdp11-* | pj-* | pjl-* | pn-* | power-* \
 	| powerpc-* | powerpc64-* | powerpc64le-* | powerpcle-* | ppcbe-* \
 	| pyramid-* \
 	| romp-* | rs6000-* \
-	| sh-* | sh[1234]-* | sh[23]e-* | sh[34]eb-* | shbe-* \
+	| sh-* | sh[1234]-* | sh[24]a-* | sh[23]e-* | sh[34]eb-* | sheb-* | shbe-* \
 	| shle-* | sh[1234]le-* | sh3ele-* | sh64-* | sh64le-* \
-	| sparc-* | sparc64-* | sparc86x-* | sparclet-* | sparclite-* \
-	| sparcv9-* | sparcv9b-* | strongarm-* | sv1-* | sx?-* \
+	| sparc-* | sparc64-* | sparc64b-* | sparc64v-* | sparc86x-* | sparclet-* \
+	| sparclite-* \
+	| sparcv8-* | sparcv9-* | sparcv9b-* | sparcv9v-* | strongarm-* | sv1-* | sx?-* \
 	| tahoe-* | thumb-* \
 	| tic30-* | tic4x-* | tic54x-* | tic55x-* | tic6x-* | tic80-* \
 	| tron-* \
 	| v850-* | v850e-* | vax-* \
 	| we32k-* \
-	| x86-* | x86_64-* | xps100-* | xscale-* | xstormy16-* \
-	| xtensa-* \
+	| x86-* | x86_64-* | xc16x-* | xps100-* | xscale-* | xscalee[bl]-* \
+	| xstormy16-* | xtensa*-* \
 	| ymp-* \
 	| z8k-*)
 		;;
+	# Recognize the basic CPU types without company name, with glob match.
+	xtensa*)
+		basic_machine=$basic_machine-unknown
+		;;
 	# Recognize the various machine names and aliases which stand
 	# for a CPU type and a company and sometimes even an OS.
 	386bsd)
 		basic_machine=i386-unknown
 		os=-bsd
 		;;
 	3b1 | 7300 | 7300-att | att-7300 | pc7300 | safari | unixpc)
 		basic_machine=m68000-att
 		;;
 	3b*)
 		basic_machine=we32k-att
 		;;
 	a29khif)
 		basic_machine=a29k-amd
 		os=-udi
 		;;
+    	abacus)
+		basic_machine=abacus-unknown
+		;;
 	adobe68k)
 		basic_machine=m68010-adobe
 		os=-scout
 		;;
 	alliant | fx80)
 		basic_machine=fx80-alliant
 		;;
 	altos | altos3068)
 		basic_machine=m68k-altos
 		;;
 	am29k)
 		basic_machine=a29k-none
 		os=-bsd
 		;;
+	amd64)
+		basic_machine=x86_64-pc
+		;;
+	amd64-*)
+		basic_machine=x86_64-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
 	amdahl)
 		basic_machine=580-amdahl
 		os=-sysv
 		;;
 	amiga | amiga-*)
 		basic_machine=m68k-unknown
 		;;
 	amigaos | amigados)
@@ -405,16 +442,24 @@ case $basic_machine in
 	aux)
 		basic_machine=m68k-apple
 		os=-aux
 		;;
 	balance)
 		basic_machine=ns32k-sequent
 		os=-dynix
 		;;
+	blackfin)
+		basic_machine=bfin-unknown
+		os=-linux
+		;;
+	blackfin-*)
+		basic_machine=bfin-`echo $basic_machine | sed 's/^[^-]*-//'`
+		os=-linux
+		;;
 	c90)
 		basic_machine=c90-cray
 		os=-unicos
 		;;
 	convex-c1)
 		basic_machine=c1-convex
 		os=-bsd
 		;;
@@ -433,22 +478,37 @@ case $basic_machine in
 	convex-c38)
 		basic_machine=c38-convex
 		os=-bsd
 		;;
 	cray | j90)
 		basic_machine=j90-cray
 		os=-unicos
 		;;
+	craynv)
+		basic_machine=craynv-cray
+		os=-unicosmp
+		;;
+	cr16)
+		basic_machine=cr16-unknown
+		os=-elf
+		;;
 	crds | unos)
 		basic_machine=m68k-crds
 		;;
+	crisv32 | crisv32-* | etraxfs*)
+		basic_machine=crisv32-axis
+		;;
 	cris | cris-* | etrax*)
 		basic_machine=cris-axis
 		;;
+	crx)
+		basic_machine=crx-unknown
+		os=-elf
+		;;
 	da30 | da30-*)
 		basic_machine=m68k-da30
 		;;
 	decstation | decstation-3100 | pmax | pmax-* | pmin | dec3100 | decstatn)
 		basic_machine=mips-dec
 		;;
 	decsystem10* | dec10*)
 		basic_machine=pdp10-dec
@@ -461,16 +521,20 @@ case $basic_machine in
 	delta | 3300 | motorola-3300 | motorola-delta \
 	      | 3300-motorola | delta-motorola)
 		basic_machine=m68k-motorola
 		;;
 	delta88)
 		basic_machine=m88k-motorola
 		os=-sysv3
 		;;
+	djgpp)
+		basic_machine=i586-pc
+		os=-msdosdjgpp
+		;;
 	dpx20 | dpx20-*)
 		basic_machine=rs6000-bull
 		os=-bosx
 		;;
 	dpx2* | dpx2*-bull)
 		basic_machine=m68k-bull
 		os=-sysv3
 		;;
@@ -611,66 +675,71 @@ case $basic_machine in
 			os=-irix4
 			;;
 		esac
 		;;
 	isi68 | isi)
 		basic_machine=m68k-isi
 		os=-sysv
 		;;
+	m68knommu)
+		basic_machine=m68k-unknown
+		os=-linux
+		;;
+	m68knommu-*)
+		basic_machine=m68k-`echo $basic_machine | sed 's/^[^-]*-//'`
+		os=-linux
+		;;
 	m88k-omron*)
 		basic_machine=m88k-omron
 		;;
 	magnum | m3230)
 		basic_machine=mips-mips
 		os=-sysv
 		;;
 	merlin)
 		basic_machine=ns32k-utek
 		os=-sysv
 		;;
 	mingw32)
 		basic_machine=i386-pc
 		os=-mingw32
 		;;
-#### MozillaHack 
-	i386-msvc | msvc)
-		basic_machine=i386-pc
-		os=-msvc
+	mingw32ce)
+		basic_machine=arm-unknown
+		os=-mingw32ce
 		;;
-#### End MozillaHack 
 	miniframe)
 		basic_machine=m68000-convergent
 		;;
 	*mint | -mint[0-9]* | *MiNT | *MiNT[0-9]*)
 		basic_machine=m68k-atari
 		os=-mint
 		;;
 	mips3*-*)
 		basic_machine=`echo $basic_machine | sed -e 's/mips3/mips64/'`
 		;;
 	mips3*)
 		basic_machine=`echo $basic_machine | sed -e 's/mips3/mips64/'`-unknown
 		;;
-	mmix*)
-		basic_machine=mmix-knuth
-		os=-mmixware
-		;;
 	monitor)
 		basic_machine=m68k-rom68k
 		os=-coff
 		;;
 	morphos)
 		basic_machine=powerpc-unknown
 		os=-morphos
 		;;
 	msdos)
 		basic_machine=i386-pc
 		os=-msdos
 		;;
+	ms1-*)
+		basic_machine=`echo $basic_machine | sed -e 's/ms1-/mt-/'`
+		;;
 	mvs)
 		basic_machine=i370-ibm
 		os=-mvs
 		;;
 	ncr3000)
 		basic_machine=i486-ncr
 		os=-sysv4
 		;;
@@ -729,30 +798,29 @@ case $basic_machine in
 		;;
 	nonstopux)
 		basic_machine=mips-compaq
 		os=-nonstopux
 		;;
 	np1)
 		basic_machine=np1-gould
 		;;
-	nv1)
-		basic_machine=nv1-cray
-		os=-unicosmp
-		;;
 	nsr-tandem)
 		basic_machine=nsr-tandem
 		;;
 	op50n-* | op60c-*)
 		basic_machine=hppa1.1-oki
 		os=-proelf
 		;;
-	or32 | or32-*)
+	openrisc | openrisc-*)
 		basic_machine=or32-unknown
-		os=-coff
+		;;
+	os400)
+		basic_machine=powerpc-ibm
+		os=-os400
 		;;
 	OSE68000 | ose68000)
 		basic_machine=m68000-ericsson
 		os=-ose
 		;;
 	os68k)
 		basic_machine=m68k-none
 		os=-os68k
@@ -760,43 +828,63 @@ case $basic_machine in
 	pa-hitachi)
 		basic_machine=hppa1.1-hitachi
 		os=-hiuxwe2
 		;;
 	paragon)
 		basic_machine=i860-intel
 		os=-osf
 		;;
+	parisc)
+		basic_machine=hppa-unknown
+		os=-linux
+		;;
+	parisc-*)
+		basic_machine=hppa-`echo $basic_machine | sed 's/^[^-]*-//'`
+		os=-linux
+		;;
 	pbd)
 		basic_machine=sparc-tti
 		;;
 	pbb)
 		basic_machine=m68k-tti
 		;;
 	pc532 | pc532-*)
 		basic_machine=ns32k-pc532
 		;;
+	pc98)
+		basic_machine=i386-pc
+		;;
+	pc98-*)
+		basic_machine=i386-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
 	pentium | p5 | k5 | k6 | nexgen | viac3)
 		basic_machine=i586-pc
 		;;
 	pentiumpro | p6 | 6x86 | athlon | athlon_*)
 		basic_machine=i686-pc
 		;;
-	pentiumii | pentium2)
+	pentiumii | pentium2 | pentiumiii | pentium3)
 		basic_machine=i686-pc
 		;;
+	pentium4)
+		basic_machine=i786-pc
+		;;
 	pentium-* | p5-* | k5-* | k6-* | nexgen-* | viac3-*)
 		basic_machine=i586-`echo $basic_machine | sed 's/^[^-]*-//'`
 		;;
 	pentiumpro-* | p6-* | 6x86-* | athlon-*)
 		basic_machine=i686-`echo $basic_machine | sed 's/^[^-]*-//'`
 		;;
-	pentiumii-* | pentium2-*)
+	pentiumii-* | pentium2-* | pentiumiii-* | pentium3-*)
 		basic_machine=i686-`echo $basic_machine | sed 's/^[^-]*-//'`
 		;;
+	pentium4-*)
+		basic_machine=i786-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
 	pn)
 		basic_machine=pn-gould
 		;;
 	power)	basic_machine=power-ibm
 		;;
 	ppc)	basic_machine=powerpc-unknown
 		;;
 	ppc-*)	basic_machine=powerpc-`echo $basic_machine | sed 's/^[^-]*-//'`
@@ -819,16 +907,20 @@ case $basic_machine in
 		;;
 	ps2)
 		basic_machine=i386-ibm
 		;;
 	pw32)
 		basic_machine=i586-unknown
 		os=-pw32
 		;;
+	rdos)
+		basic_machine=i386-pc
+		os=-rdos
+		;;
 	rom68k)
 		basic_machine=m68k-rom68k
 		os=-coff
 		;;
 	rm[46]00)
 		basic_machine=mips-siemens
 		;;
 	rtpc | rtpc-*)
@@ -845,23 +937,37 @@ case $basic_machine in
 		os=-udi
 		;;
 	sb1)
 		basic_machine=mipsisa64sb1-unknown
 		;;
 	sb1el)
 		basic_machine=mipsisa64sb1el-unknown
 		;;
+	sde)
+		basic_machine=mipsisa32-sde
+		os=-elf
+		;;
+	sei)
+		basic_machine=mips-sei
+		os=-seiux
+		;;
 	sequent)
 		basic_machine=i386-sequent
 		;;
 	sh)
 		basic_machine=sh-hitachi
 		os=-hms
 		;;
+	sh5el)
+		basic_machine=sh5le-unknown
+		;;
+	sh64)
+		basic_machine=sh64-unknown
+		;;
 	sparclite-wrs | simso-wrs)
 		basic_machine=sparclite-wrs
 		os=-vxworks
 		;;
 	sps7)
 		basic_machine=m68k-bull
 		os=-sysv2
 		;;
@@ -926,45 +1032,49 @@ case $basic_machine in
 	t3e)
 		basic_machine=alphaev5-cray
 		os=-unicos
 		;;
 	t90)
 		basic_machine=t90-cray
 		os=-unicos
 		;;
-        tic4x | c4x*)
-		basic_machine=tic4x-unknown
-		os=-coff
-		;;
 	tic54x | c54x*)
 		basic_machine=tic54x-unknown
 		os=-coff
 		;;
 	tic55x | c55x*)
 		basic_machine=tic55x-unknown
 		os=-coff
 		;;
 	tic6x | c6x*)
 		basic_machine=tic6x-unknown
 		os=-coff
 		;;
+	tile*)
+		basic_machine=tile-unknown
+		os=-linux-gnu
+		;;
 	tx39)
 		basic_machine=mipstx39-unknown
 		;;
 	tx39el)
 		basic_machine=mipstx39el-unknown
 		;;
 	toad1)
 		basic_machine=pdp10-xkl
 		os=-tops20
 		;;
 	tower | tower-32)
 		basic_machine=m68k-ncr
 		;;
+	tpf)
+		basic_machine=s390x-ibm
+		os=-tpf
+		;;
 	udi29k)
 		basic_machine=a29k-amd
 		os=-udi
 		;;
 	ultra3)
 		basic_machine=a29k-nyu
 		os=-sym1
 		;;
@@ -998,16 +1108,20 @@ case $basic_machine in
 	w65*)
 		basic_machine=w65-wdc
 		os=-none
 		;;
 	w89k-*)
 		basic_machine=hppa1.1-winbond
 		os=-proelf
 		;;
+	xbox)
+		basic_machine=i686-pc
+		os=-mingw32
+		;;
 	xps | xps100)
 		basic_machine=xps100-honeywell
 		;;
 	ymp)
 		basic_machine=ymp-cray
 		os=-unicos
 		;;
 	z8k-*-coff)
@@ -1028,39 +1142,39 @@ case $basic_machine in
 		basic_machine=hppa1.1-oki
 		;;
 	op60c)
 		basic_machine=hppa1.1-oki
 		;;
 	romp)
 		basic_machine=romp-ibm
 		;;
+	mmix)
+		basic_machine=mmix-knuth
+		;;
 	rs6000)
 		basic_machine=rs6000-ibm
 		;;
 	vax)
 		basic_machine=vax-dec
 		;;
 	pdp10)
 		# there are many clones, so DEC is not a safe bet
 		basic_machine=pdp10-unknown
 		;;
 	pdp11)
 		basic_machine=pdp11-dec
 		;;
 	we32k)
 		basic_machine=we32k-att
 		;;
-	sh3 | sh4 | sh[34]eb | sh[1234]le | sh[23]ele)
+	sh[1234] | sh[24]a | sh[34]eb | sh[1234]le | sh[23]ele)
 		basic_machine=sh-unknown
 		;;
-	sh64)
-		basic_machine=sh64-unknown
-		;;
-	sparc | sparcv9 | sparcv9b)
+	sparc | sparcv8 | sparcv9 | sparcv9b | sparcv9v)
 		basic_machine=sparc-sun
 		;;
 	cydra)
 		basic_machine=cydra-cydrome
 		;;
 	orion)
 		basic_machine=orion-highlevel
 		;;
@@ -1116,40 +1230,40 @@ case $os in
 		;;
 	-gnu/linux*)
 		os=`echo $os | sed -e 's|gnu/linux|linux-gnu|'`
 		;;
 	# First accept the basic system types.
 	# The portable systems comes first.
 	# Each alternative MUST END IN A *, to match a version number.
 	# -sysv* is not here because it comes later, after sysvr4.
-#### MozillaHack 
-# msvc
-#### End MozillaHack 
 	-gnu* | -bsd* | -mach* | -minix* | -genix* | -ultrix* | -irix* \
 	      | -*vms* | -sco* | -esix* | -isc* | -aix* | -sunos | -sunos[34]*\
 	      | -hpux* | -unos* | -osf* | -luna* | -dgux* | -solaris* | -sym* \
 	      | -amigaos* | -amigados* | -msdos* | -newsos* | -unicos* | -aof* \
 	      | -aos* \
 	      | -nindy* | -vxsim* | -vxworks* | -ebmon* | -hms* | -mvs* \
 	      | -clix* | -riscos* | -uniplus* | -iris* | -rtu* | -xenix* \
-	      | -hiux* | -386bsd* | -netbsd* | -openbsd* | -freebsd* | -riscix* \
-	      | -lynxos* | -bosx* | -nextstep* | -cxux* | -aout* | -elf* | -oabi* \
+	      | -hiux* | -386bsd* | -knetbsd* | -mirbsd* | -netbsd* \
+	      | -openbsd* | -solidbsd* \
+	      | -ekkobsd* | -kfreebsd* | -freebsd* | -riscix* | -lynxos* \
+	      | -bosx* | -nextstep* | -cxux* | -aout* | -elf* | -oabi* \
 	      | -ptx* | -coff* | -ecoff* | -winnt* | -domain* | -vsta* \
 	      | -udi* | -eabi* | -lites* | -ieee* | -go32* | -aux* \
 	      | -chorusos* | -chorusrdb* \
 	      | -cygwin* | -pe* | -psos* | -moss* | -proelf* | -rtems* \
-	      | -mingw32* | -linux-gnu* | -uxpv* | -beos* | -mpeix* | -udk* \
+	      | -mingw32* | -linux-gnu* | -linux-newlib* | -linux-uclibc* \
+	      | -uxpv* | -beos* | -mpeix* | -udk* \
 	      | -interix* | -uwin* | -mks* | -rhapsody* | -darwin* | -opened* \
-	      | -msvc* \
 	      | -openstep* | -oskit* | -conix* | -pw32* | -nonstopux* \
 	      | -storm-chaos* | -tops10* | -tenex* | -tops20* | -its* \
 	      | -os2* | -vos* | -palmos* | -uclinux* | -nucleus* \
 	      | -morphos* | -superux* | -rtmk* | -rtmk-nova* | -windiss* \
-	      | -powermax* | -dnix*)
+	      | -powermax* | -dnix* | -nx6 | -nx7 | -sei* | -dragonfly* \
+	      | -skyos* | -haiku* | -rdos* | -toppers* | -drops*)
 	# Remember, each alternative MUST END IN *, to match a version number.
 		;;
 	-qnx*)
 		case $basic_machine in
 		    x86-* | i*86-*)
 			;;
 		    *)
 			os=-nto$os
@@ -1157,34 +1271,40 @@ case $os in
 		esac
 		;;
 	-nto-qnx*)
 		;;
 	-nto*)
 		os=`echo $os | sed -e 's|nto|nto-qnx|'`
 		;;
 	-sim | -es1800* | -hms* | -xray | -os68k* | -none* | -v88r* \
-	      | -windows* | -osx | -abug | -netware* | -os9* | -beos* \
+	      | -windows* | -osx | -abug | -netware* | -os9* | -beos* | -haiku* \
 	      | -macos* | -mpw* | -magic* | -mmixware* | -mon960* | -lnews*)
 		;;
 	-mac*)
 		os=`echo $os | sed -e 's|mac|macos|'`
 		;;
+	-linux-dietlibc)
+		os=-linux-dietlibc
+		;;
 	-linux*)
 		os=`echo $os | sed -e 's|linux|linux-gnu|'`
 		;;
 	-sunos5*)
 		os=`echo $os | sed -e 's|sunos5|solaris2|'`
 		;;
 	-sunos6*)
 		os=`echo $os | sed -e 's|sunos6|solaris3|'`
 		;;
 	-opened*)
 		os=-openedition
 		;;
+        -os400*)
+		os=-os400
+		;;
 	-wince*)
 		os=-wince
 		;;
 	-osfrose*)
 		os=-osfrose
 		;;
 	-osf*)
 		os=-osf
@@ -1196,16 +1316,19 @@ case $os in
 		os=-bsd
 		;;
 	-acis*)
 		os=-aos
 		;;
 	-atheos*)
 		os=-atheos
 		;;
+	-syllable*)
+		os=-syllable
+		;;
 	-386bsd)
 		os=-bsd
 		;;
 	-ctix* | -uts*)
 		os=-sysv
 		;;
 	-nova*)
 		os=-rtmk-nova
@@ -1218,16 +1341,19 @@ case $os in
 		;;
 	# Preserve the version number of sinix5.
 	-sinix5.*)
 		os=`echo $os | sed -e 's|sinix|sysv|'`
 		;;
 	-sinix*)
 		os=-sysv4
 		;;
+        -tpf*)
+		os=-tpf
+		;;
 	-triton*)
 		os=-sysv3
 		;;
 	-oss*)
 		os=-sysv3
 		;;
 	-svr4)
 		os=-sysv4
@@ -1254,16 +1380,19 @@ case $os in
 		os=-mint
 		;;
 	-aros*)
 		os=-aros
 		;;
 	-kaos*)
 		os=-kaos
 		;;
+	-zvmoe)
+		os=-zvmoe
+		;;
 	-none)
 		;;
 	*)
 		# Get rid of the `-' at the beginning of $os.
 		os=`echo $os | sed 's/[^-]*-//'`
 		echo Invalid configuration \`$1\': system \`$os\' not recognized 1>&2
 		exit 1
 		;;
@@ -1276,25 +1405,34 @@ else
 
 # Note that if you're going to try to match "-MANUFACTURER" here (say,
 # "-sun"), then you have to tell the case statement up towards the top
 # that MANUFACTURER isn't an operating system.  Otherwise, code above
 # will signal an error saying that MANUFACTURER isn't an operating
 # system, and we'll never get to this point.
 
 case $basic_machine in
+        score-*)
+		os=-elf
+		;;
+        spu-*)
+		os=-elf
+		;;
 	*-acorn)
 		os=-riscix1.2
 		;;
 	arm*-rebel)
 		os=-linux
 		;;
 	arm*-semi)
 		os=-aout
 		;;
+        c4x-* | tic4x-*)
+        	os=-coff
+		;;
 	# This must come before the *-dec entry.
 	pdp10-*)
 		os=-tops20
 		;;
 	pdp11-*)
 		os=-none
 		;;
 	*-dec | vax-*)
@@ -1310,16 +1448,19 @@ case $basic_machine in
 		os=-sunos3
 		# This also exists in the configure program, but was not the
 		# default.
 		# os=-sunos4
 		;;
 	m68*-cisco)
 		os=-aout
 		;;
+        mep-*)
+		os=-elf
+		;;
 	mips*-cisco)
 		os=-elf
 		;;
 	mips*-*)
 		os=-elf
 		;;
 	or32-*)
 		os=-coff
@@ -1328,19 +1469,25 @@ case $basic_machine in
 		os=-sysv3
 		;;
 	sparc-* | *-sun)
 		os=-sunos4.1.1
 		;;
 	*-be)
 		os=-beos
 		;;
+	*-haiku)
+		os=-haiku
+		;;
 	*-ibm)
 		os=-aix
 		;;
+    	*-knuth)
+		os=-mmixware
+		;;
 	*-wec)
 		os=-proelf
 		;;
 	*-winbond)
 		os=-proelf
 		;;
 	*-oki)
 		os=-proelf
@@ -1463,19 +1610,25 @@ case $basic_machine in
 				vendor=omron
 				;;
 			-genix*)
 				vendor=ns
 				;;
 			-mvs* | -opened*)
 				vendor=ibm
 				;;
+			-os400*)
+				vendor=ibm
+				;;
 			-ptx*)
 				vendor=sequent
 				;;
+			-tpf*)
+				vendor=ibm
+				;;
 			-vxsim* | -vxworks* | -windiss*)
 				vendor=wrs
 				;;
 			-aux*)
 				vendor=apple
 				;;
 			-hms*)
 				vendor=hitachi
@@ -1490,16 +1643,16 @@ case $basic_machine in
 				vendor=stratus
 				;;
 		esac
 		basic_machine=`echo $basic_machine | sed "s/unknown/$vendor/"`
 		;;
 esac
 
 echo $basic_machine$os
-exit 0
+exit
 
 # Local variables:
 # eval: (add-hook 'write-file-hooks 'time-stamp)
 # time-stamp-start: "timestamp='"
 # time-stamp-format: "%:y-%02m-%02d"
 # time-stamp-end: "'"
 # End:
Index: mozilla/nsprpub/lib/ds/Makefile.in
===================================================================
RCS file: /cvsroot/mozilla/nsprpub/lib/ds/Makefile.in,v
retrieving revision 1.35.2.1
diff -u -8 -p -r1.35.2.1 Makefile.in
--- mozilla/nsprpub/lib/ds/Makefile.in	19 Oct 2006 00:39:28 -0000	1.35.2.1
+++ mozilla/nsprpub/lib/ds/Makefile.in	9 Feb 2009 04:04:16 -0000
@@ -180,18 +180,22 @@ endif
 export:: $(TARGETS)
 	$(INSTALL) -m 444 $(HEADERS) $(dist_includedir)
 	$(INSTALL) -m 444 $(TARGETS) $(dist_libdir)
 ifdef SHARED_LIBRARY
 ifeq ($(OS_ARCH),HP-UX)
 	$(INSTALL) -m 755 $(SHARED_LIBRARY) $(dist_libdir)
 	$(INSTALL) -m 755 $(SHARED_LIBRARY) $(dist_bindir)
 else
+ifeq (,$(filter-out BeOS Haiku, $(OS_ARCH)))
+	$(INSTALL) -m 444 $(SHARED_LIBRARY) $(dist_bindir)/lib
+else
 	$(INSTALL) -m 444 $(SHARED_LIBRARY) $(dist_bindir)
 endif
 endif
+endif
 ifeq ($(MOZ_BITS),16)
 	$(INSTALL) -m 444 $(HEADERS) $(MOZ_INCL)
 	$(INSTALL) -m 444 $(TARGETS) $(MOZ_DIST)/lib
 	$(INSTALL) -m 444 $(TARGETS) $(MOZ_DIST)/bin
 endif
 
 
Index: mozilla/nsprpub/lib/libc/src/Makefile.in
===================================================================
RCS file: /cvsroot/mozilla/nsprpub/lib/libc/src/Makefile.in,v
retrieving revision 1.31.2.1
diff -u -8 -p -r1.31.2.1 Makefile.in
--- mozilla/nsprpub/lib/libc/src/Makefile.in	19 Oct 2006 00:39:28 -0000	1.31.2.1
+++ mozilla/nsprpub/lib/libc/src/Makefile.in	9 Feb 2009 04:04:17 -0000
@@ -182,16 +182,20 @@ endif
 
 export:: $(TARGETS)
 	$(INSTALL) -m 444 $(TARGETS) $(dist_libdir)
 ifdef SHARED_LIBRARY
 ifeq ($(OS_ARCH),HP-UX)
 	$(INSTALL) -m 755 $(SHARED_LIBRARY) $(dist_libdir)
 	$(INSTALL) -m 755 $(SHARED_LIBRARY) $(dist_bindir)
 else
+ifeq (,$(filter-out BeOS Haiku, $(OS_ARCH)))
+	$(INSTALL) -m 444 $(SHARED_LIBRARY) $(dist_bindir)/lib
+else
 	$(INSTALL) -m 444 $(SHARED_LIBRARY) $(dist_bindir)
 endif
 endif
+endif
 ifeq ($(MOZ_BITS),16)
 	$(INSTALL) -m 444 $(TARGETS) $(MOZ_DIST)/lib
 	$(INSTALL) -m 444 $(TARGETS) $(MOZ_DIST)/bin
 endif
 
Index: mozilla/nsprpub/lib/prstreams/Makefile.in
===================================================================
RCS file: /cvsroot/mozilla/nsprpub/lib/prstreams/Makefile.in,v
retrieving revision 1.21.2.1
diff -u -8 -p -r1.21.2.1 Makefile.in
--- mozilla/nsprpub/lib/prstreams/Makefile.in	19 Oct 2006 00:39:28 -0000	1.21.2.1
+++ mozilla/nsprpub/lib/prstreams/Makefile.in	9 Feb 2009 04:04:17 -0000
@@ -64,17 +64,17 @@ ifeq ($(OS_ARCH),SunOS)
 endif
 
 ifeq ($(OS_ARCH), IRIX)
     ifneq ($(OS_RELEASE),5.3)
         CCC_ONLY_FLAGS += -exceptions
     endif
 endif
 
-ifeq ($(OS_ARCH), BeOS)
+ifeq (,$(filter-out BeOS Haiku, $(OS_ARCH)))
     CFLAGS += -frtti -fexceptions
 endif
 
 INCLUDES = -I$(dist_includedir)
 
 HEADERS = $(wildcard $(srcdir)/*.h)
 
 CSRCS = \
@@ -113,17 +113,17 @@ else
             MKSHLIB = makeC++SharedLib_r -p 0
         endif
         OS_LIBS += -ldl
       endif
     endif
     endif
 endif
 
-ifeq ($(OS_ARCH),BeOS)
+ifeq (,$(filter-out BeOS Haiku, $(OS_ARCH)))
     OS_LIBS = -lstdc++.r4
 endif
 
 ifeq ($(OS_ARCH), UNIXWARE)
     OS_LIBS += -lC
 endif
 
 EXTRA_LIBS = $(LIBNSPR)
Index: mozilla/nsprpub/pr/include/prio.h
===================================================================
RCS file: /cvsroot/mozilla/nsprpub/pr/include/prio.h,v
retrieving revision 3.40
diff -u -8 -p -r3.40 prio.h
--- mozilla/nsprpub/pr/include/prio.h	25 Apr 2004 15:00:47 -0000	3.40
+++ mozilla/nsprpub/pr/include/prio.h	9 Feb 2009 04:04:25 -0000
@@ -169,38 +169,41 @@ struct PRIPv6Addr {
 #define pr_s6_addr32	_S6_un._S6_u32
 #define pr_s6_addr64 	_S6_un._S6_u64
 
 typedef struct PRIPv6Addr PRIPv6Addr;
 
 union PRNetAddr {
     struct {
         PRUint16 family;                /* address family (0x00ff maskable) */
-#ifdef XP_BEOS
-        char data[10];                  /* Be has a smaller structure */
-#else
+#ifndef XP_BEOS
         char data[14];                  /* raw address data */
+#else
+        char data[30];
 #endif
     } raw;
     struct {
         PRUint16 family;                /* address family (AF_INET) */
         PRUint16 port;                  /* port number */
         PRUint32 ip;                    /* The actual 32 bits of address */
-#ifdef XP_BEOS
-        char pad[4];                    /* Be has a smaller structure */
-#else
+#ifndef XP_BEOS
         char pad[8];
+#else
+        char pad[24];
 #endif
     } inet;
     struct {
         PRUint16 family;                /* address family (AF_INET6) */
         PRUint16 port;                  /* port number */
         PRUint32 flowinfo;              /* routing information */
         PRIPv6Addr ip;                  /* the actual 128 bits of address */
         PRUint32 scope_id;              /* set of interfaces for a scope */
+#ifdef XP_BEOS
+        char pad[4];
+#endif
     } ipv6;
 #if defined(XP_UNIX) || defined(XP_OS2_EMX)
     struct {                            /* Unix domain socket address */
         PRUint16 family;                /* address family (AF_UNIX) */
 #ifdef XP_OS2
         char path[108];                 /* null-terminated pathname */
                                         /* bind fails if size is not 108. */
 #else
Index: mozilla/nsprpub/pr/include/prtypes.h
===================================================================
RCS file: /cvsroot/mozilla/nsprpub/pr/include/prtypes.h,v
retrieving revision 3.30.2.2
diff -u -8 -p -r3.30.2.2 prtypes.h
--- mozilla/nsprpub/pr/include/prtypes.h	5 Apr 2006 21:51:21 -0000	3.30.2.2
+++ mozilla/nsprpub/pr/include/prtypes.h	9 Feb 2009 04:04:26 -0000
@@ -93,29 +93,48 @@
 #define PR_IMPLEMENT_DATA(__type) __declspec(dllexport) __type
 
 #define PR_CALLBACK
 #define PR_CALLBACK_DECL
 #define PR_STATIC_CALLBACK(__x) static __x
 
 #elif defined(XP_BEOS)
 
+/* GCC 3.3 and later support the visibility attribute. */
+#if (__GNUC__ >= 4) || \
+    (__GNUC__ == 3 && __GNUC_MINOR__ >= 3)
+#define PR_VISIBILITY_DEFAULT __attribute__((visibility("default")))
+#define PR_EXPORT(__type) extern PR_VISIBILITY_DEFAULT __type
+#define PR_EXPORT_DATA(__type) extern PR_VISIBILITY_DEFAULT __type
+#define PR_IMPORT(__type) extern PR_VISIBILITY_DEFAULT __type
+#define PR_IMPORT_DATA(__type) extern PR_VISIBILITY_DEFAULT __type
+
+#define PR_EXTERN(__type) extern PR_VISIBILITY_DEFAULT __type
+#define PR_IMPLEMENT(__type) PR_VISIBILITY_DEFAULT __type
+#define PR_EXTERN_DATA(__type) extern PR_VISIBILITY_DEFAULT __type
+#define PR_IMPLEMENT_DATA(__type) PR_VISIBILITY_DEFAULT __type
+#define PR_CALLBACK
+#define PR_CALLBACK_DECL
+#define PR_STATIC_CALLBACK(__x) static __x
+
+#else
 #define PR_EXPORT(__type) extern __declspec(dllexport) __type
 #define PR_EXPORT_DATA(__type) extern __declspec(dllexport) __type
 #define PR_IMPORT(__type) extern __declspec(dllexport) __type
 #define PR_IMPORT_DATA(__type) extern __declspec(dllexport) __type
 
 #define PR_EXTERN(__type) extern __declspec(dllexport) __type
 #define PR_IMPLEMENT(__type) __declspec(dllexport) __type
 #define PR_EXTERN_DATA(__type) extern __declspec(dllexport) __type
 #define PR_IMPLEMENT_DATA(__type) __declspec(dllexport) __type
 
 #define PR_CALLBACK
 #define PR_CALLBACK_DECL
 #define PR_STATIC_CALLBACK(__x) static __x
+#endif
 
 #elif defined(WIN16)
 
 #define PR_CALLBACK_DECL        __cdecl
 
 #if defined(_WINDLL)
 #define PR_EXPORT(__type) extern __type _cdecl _export _loadds
 #define PR_IMPORT(__type) extern __type _cdecl _export _loadds
Index: mozilla/nsprpub/pr/include/md/_beos.cfg
===================================================================
RCS file: /cvsroot/mozilla/nsprpub/pr/include/md/_beos.cfg,v
retrieving revision 3.5.214.1
diff -u -8 -p -r3.5.214.1 _beos.cfg
--- mozilla/nsprpub/pr/include/md/_beos.cfg	5 Apr 2006 22:00:45 -0000	3.5.214.1
+++ mozilla/nsprpub/pr/include/md/_beos.cfg	9 Feb 2009 04:04:27 -0000
@@ -15,16 +15,17 @@
  * The Original Code is the Netscape Portable Runtime (NSPR).
  *
  * The Initial Developer of the Original Code is
  * Netscape Communications Corporation.
  * Portions created by the Initial Developer are Copyright (C) 1998-2000
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
+ * Fredrik Holmqvist <thesuckiestemail@yahoo.se>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
@@ -35,33 +36,38 @@
  *
  * ***** END LICENSE BLOCK ***** */
 
 #ifndef nspr_cpucfg___
 #define nspr_cpucfg___
 
 #ifndef XP_BEOS
 #define XP_BEOS
-#undef XP_UNIX
 #endif
 
 #ifndef BEOS
 #define BEOS
 #endif
 
 #define PR_AF_INET6 5  /* same as AF_INET6 */
 
 #ifdef __powerpc__
 #undef  IS_LITTLE_ENDIAN
 #define IS_BIG_ENDIAN 1
 #else
 #define IS_LITTLE_ENDIAN 1
 #undef  IS_BIG_ENDIAN
 #endif
 
+/*
+ * Fixme: Should be done according to arch
+ * Currently only x86/ia64.
+ */
+#define PR_ALIGN_OF_WORD    4
+
 #define PR_BYTES_PER_BYTE   1
 #define PR_BYTES_PER_SHORT  2
 #define PR_BYTES_PER_INT    4
 #define PR_BYTES_PER_INT64  8
 #define PR_BYTES_PER_LONG   4
 #define PR_BYTES_PER_FLOAT  4
 #define PR_BYTES_PER_DOUBLE 8
 #define PR_BYTES_PER_WORD   4
Index: mozilla/nsprpub/pr/include/md/_beos.h
===================================================================
RCS file: /cvsroot/mozilla/nsprpub/pr/include/md/_beos.h,v
retrieving revision 3.23
diff -u -8 -p -r3.23 _beos.h
--- mozilla/nsprpub/pr/include/md/_beos.h	17 Jan 2005 22:00:53 -0000	3.23
+++ mozilla/nsprpub/pr/include/md/_beos.h	9 Feb 2009 04:04:27 -0000
@@ -15,16 +15,17 @@
  * The Original Code is the Netscape Portable Runtime (NSPR).
  *
  * The Initial Developer of the Original Code is
  * Netscape Communications Corporation.
  * Portions created by the Initial Developer are Copyright (C) 1998-2000
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
+ * Fredrik Holmqvist <thesuckiestemail@yahoo.se>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
@@ -33,27 +34,26 @@
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #ifndef nspr_beos_defs_h___
 #define nspr_beos_defs_h___
 
-#include "prtypes.h"
-#include "prio.h"
-#include "prthread.h"
-#include "prproces.h"
-#include "prmem.h"
-#include "obsolete/prsem.h"
 #include <errno.h>
-
-#include <support/SupportDefs.h>
-#include <kernel/OS.h>
 #include <dirent.h>
+#include <OS.h>
+
+/*
+ * Hack for Cross compile
+ */
+#define FD_SETSIZE 1024
+
+#undef bool
 
 /*
  * Internal configuration macros
  */
 
 #ifdef BONE_VERSION
 #define _PR_HAVE_SOCKADDR_LEN
 #endif
@@ -62,104 +62,66 @@
 #define _PR_SI_SYSNAME  "BEOS"
 #ifdef __powerpc__
 #define _PR_SI_ARCHITECTURE "ppc"
 #else
 #define _PR_SI_ARCHITECTURE "x86"
 #endif
 #define PR_DLL_SUFFIX		".so"
 
-#define _PR_VMBASE              0x30000000
-#define _PR_STACK_VMBASE	0x50000000
 #define _MD_DEFAULT_STACK_SIZE	65536L
-#define _MD_MMAP_FLAGS          MAP_PRIVATE
 
 #undef	HAVE_STACK_GROWING_UP
 #define HAVE_DLL
-#define _PR_NO_CLOCK_TIMER
 
 /*
  * The Atomic operations
  */
 
 #define _PR_HAVE_ATOMIC_OPS
+#ifdef __powerpc__
 #define _MD_INIT_ATOMIC _MD_AtomicInit
+#else
+#define _MD_INIT_ATOMIC()
+#endif
 #define _MD_ATOMIC_INCREMENT _MD_AtomicIncrement
 #define _MD_ATOMIC_ADD _MD_AtomicAdd
 #define _MD_ATOMIC_DECREMENT _MD_AtomicDecrement
 #define _MD_ATOMIC_SET _MD_AtomicSet
 
+/* Makes sure to don't create cvar when creating sem */
 #define HAVE_CVAR_BUILT_ON_SEM
+
+/* Not sure this is needed, but no harm. */
 #define _PR_GLOBAL_THREADS_ONLY
+
 #define _PR_BTHREADS
-#define _PR_NEED_FAKE_POLL
-#define _PR_HAVE_PEEK_BUFFER
-#define _PR_PEEK_BUFFER_MAX (16 * 1024)
-#define _PR_FD_NEED_EMULATE_MSG_PEEK(fd) 1
-#define _PR_CONNECT_DOES_NOT_BIND
+
 #define _PR_HAVE_O_APPEND
 
-/* Define threading functions and objects as native BeOS */
+/* Define threading functions and objects as native BeOS 
+   Used by bthreads. */
+
 struct _MDThread {
     thread_id	tid;	/* BeOS thread handle */
 	sem_id		joinSem;	/* sems used to synchronzie joining */
 	PRBool	is_joining;	/* TRUE if someone is currently waiting to
 						   join this thread */
 };
 
-struct _MDThreadStack {
-    PRInt8	notused;
-};
-
-/*
- * Lock and Semaphore related definitions
- */
-
-struct _MDLock {
-    sem_id semaphoreID;
-    int32  benaphoreCount;
-};
-
-struct _MDCVar {
-    sem_id sem1;
-    sem_id sem2;
-    int16  count;
-};
-
-struct _MDSemaphore {
-    sem_id sid;
-};
-
-/*
-** CPU-related definitions
-*/
-struct _MDCPU {
-    int8		unused;
-};
-
 /*
 ** Process-related definitions
 */
 struct _MDProcess {
     pid_t pid;
 };
 
-struct _MDSegment {
-    PRInt8 notused;
-};
-
 /*
 ** File- and directory-related definitions
 */
-
-#ifndef BONE_VERSION
-#define BE_SOCK_SHUTDOWN_READ	0x01
-#define BE_SOCK_SHUTDOWN_WRITE	0x02
-#endif
-
 struct _MDFileDesc {
     PRInt32	osfd;
     PRInt32	sock_state;
     PRBool	accepted_socket;
     PRNetAddr	peer_addr;
 #ifndef BONE_VERSION
     PRBool	connectValueValid;
     int		connectReturnValue;
@@ -173,441 +135,114 @@ struct _MDDir {
 
 #define PR_DIRECTORY_SEPARATOR		'/'
 #define PR_DIRECTORY_SEPARATOR_STR	"/"
 #define PR_PATH_SEPARATOR		':'
 #define PR_PATH_SEPARATOR_STR		":"
 
 #define GETTIMEOFDAY(tp)	gettimeofday((tp), NULL)
 
-/* --- Memory-mapped files stuff --- not implemented on BeOS */
-
-struct _MDFileMap {
-    PRInt8 unused;
-};
 
 /*
  * Network related definitions.
  */
 
 #ifndef BONE_VERSION
+#define BE_SOCK_SHUTDOWN_READ	0x01
+#define BE_SOCK_SHUTDOWN_WRITE	0x02
+
 #define IPPROTO_IP 0
 #define AF_UNIX 2
 #define TCP_NODELAY SO_NONBLOCK
 #define SO_LINGER -1
 #define SO_ERROR 4
-#endif
-
-#define _PR_INTERRUPT_CHECK_INTERVAL_SECS 5
 
-#ifndef BONE_VERSION
 /* these aren't actually used. if they are, we're screwed */
 struct  protoent {
     char    *p_name;        /* official protocol name */
     char    **p_aliases;    /* alias list */
     int     p_proto;        /* protocol # */
 };
 
 struct protoent* getprotobyname(const char* name);
 struct protoent* getprotobynumber(int number);
 #endif
 
+/* Used by bnet.c */
+#define _PR_INTERRUPT_CHECK_INTERVAL_SECS 5
+
 /*
  * malloc() related definitions.
+ * Avoids prmalloc.c's and prmem's code
  */
-
 #undef _PR_OVERRIDE_MALLOC
 
 /* Miscellaneous */
 
-#define _MD_ERRNO()             (errno)
+#define _MD_ERRNO() (errno)
 
-#define _MD_CLEANUP_BEFORE_EXIT _MD_cleanup_before_exit
-#define _MD_EXIT _MD_exit
+#define _MD_CLEANUP_BEFORE_EXIT()
+#define _MD_EXIT exit
 
 #define _MD_GET_ENV getenv
 #define _MD_PUT_ENV putenv
 
-#define _MD_EARLY_INIT _MD_early_init
-#define _MD_FINAL_INIT _MD_final_init
-
-/* CPU Stuff */
-
-#define _MD_INIT_CPUS _MD_init_cpus
-#define _MD_WAKEUP_CPUS _MD_wakeup_cpus
-#define _MD_START_INTERRUPTS _MD_start_interrupts
-#define _MD_STOP_INTERRUPTS _MD_stop_interrupts
-#define _MD_DISABLE_CLOCK_INTERRUPTS _MD_disable_clock_interrupts
-#define _MD_BLOCK_CLOCK_INTERRUPTS _MD_block_clock_interrupts
-#define _MD_UNBLOCK_CLOCK_INTERRUPTS _MD_unblock_clock_interrupts
-#define _MD_CLOCK_INTERRUPT _MD_clock_interrupt
-#define _MD_INIT_STACK _MD_init_stack
-#define _MD_CLEAR_STACK _MD_clear_stack
-// #define _MD_GET_INTSOFF _MD_get_intsoff
-// #define _MD_SET_INTSOFF _MD_set_intsoff
-#define _MD_CURRENT_CPU _MD_current_cpu
-#define _MD_SET_CURRENT_CPU _MD_set_current_cpu
-#define _MD_INIT_RUNNING_CPU _MD_init_running_cpu
-#define _MD_PAUSE_CPU _MD_pause_cpu
+#define _MD_EARLY_INIT()
+#ifdef BONE_VERSION
+#define _MD_FINAL_INIT()
+#else 
+#define _MD_FINAL_INIT _MD_final_init_netserver
+#endif
 
 /* Thread stuff */
 
 #define _MD_CURRENT_THREAD() PR_GetCurrentThread()
-// #define _MD_GET_ATTACHED_THREAD _MD_get_attached_thread
-#define _MD_LAST_THREAD _MD_last_thread
-#define _MD_SET_CURRENT_THREAD _MD_set_current_THREAD
-#define _MD_SET_LAST_THREAD _MD_set_last_thread
-#define _MD_INIT_THREAD _MD_init_thread
-#define _MD_EXIT_THREAD _MD_exit_thread
-#define _MD_INIT_ATTACHED_THREAD _MD_init_attached_thread
-
-#define _MD_SUSPEND_THREAD _MD_suspend_thread
-#define _MD_RESUME_THREAD _MD_resume_thread
-#define _MD_SUSPEND_CPU _MD_suspend_cpu
-#define _MD_RESUME_CPU _MD_resume_cpu
-#define _MD_BEGIN_SUSPEND_ALL _MD_begin_suspend_all
-#define _MD_END_SUSPEND_ALL _MD_end_suspend_all
-#define _MD_BEGIN_RESUME_ALL _MD_begin_resume_all
-#define _MD_END_RESUME_ALL _MD_end_resume_all
-
-#define _MD_GET_SP _MD_get_sp
-
-#define _MD_CLEAN_THREAD _MD_clean_thread
-#define _MD_CREATE_PRIMORDIAL_USER_THREAD _MD_create_primordial_user_thread
-#define _MD_CREATE_USER_THREAD _MD_create_user_thread
-#define _MD_INIT_PRIMORDIAL_THREAD _MD_init_primordial_thread
-#define _MD_CREATE_THREAD _MD_create_thread
-#define _MD_YIELD _MD_yield
-#define _MD_SET_PRIORITY _MD_set_priority
-
-#define _MD_SUSPENDALL _MD_suspendall
-#define _MD_RESUMEALL _MD_resumeall
-
-#define _MD_SWITCH_CONTEXT _MD_switch_context
-#define _MD_RESTORE_CONTEXT _MD_restore_context
-
-#define _MD_WAIT _MD_wait
-#define _MD_WAKEUP_WAITER _MD_wakeup_waiter
-
-#define _MD_SETTHREADAFFINITYMASK _MD_setthreadaffinitymask
-#define _MD_GETTHREADAFFINITYMASK _MD_getthreadaffinitymask
-
-/* Thread Synchronization */
-
-#define _MD_INIT_LOCKS _MD_init_locks
-#define _MD_NEW_LOCK _MD_new_lock
-#define _MD_FREE_LOCK _MD_free_lock
-#define _MD_LOCK _MD_lock
-#define _MD_TEST_AND_LOCK _MD_test_and_lock
-#define _MD_UNLOCK _MD_unlock
-#define _MD_IOQ_LOCK _MD_ioq_lock
-#define _MD_IOQ_UNLOCK _MD_ioq_unlock
-#define _MD_NEW_SEM _MD_new_sem
-#define _MD_DESTROY_SEM _MD_destroy_sem
-#define _MD_TIMED_WAIT_SEM _MD_timed_wait_sem
-#define _MD_WAIT_SEM _MD_wait_sem
-#define _MD_POST_SEM _MD_post_sem
-// #define _MD_NEW_CV _MD_new_cv
-// #define _MD_FREE_CV _MD_free_cv
-// #define _MD_WAIT_CV _MD_wait_cv
-// #define _MD_NOTIFY_CV _MD_notify_cv
-// #define _MD_NOTIFYALL_CV _MD_notifyall_cv
+
 
 /* File I/O */
 
-/* don't need any I/O initializations */
-#define _MD_INIT_IO()
-#define _MD_INIT_FILEDESC(fd)
-
-#define _MD_OPEN_DIR _MD_open_dir
-#define _MD_READ_DIR _MD_read_dir
-#define _MD_CLOSE_DIR _MD_close_dir
-#define _MD_MAKE_NONBLOCK _MD_make_nonblock
-#define _MD_SET_FD_INHERITABLE _MD_set_fd_inheritable
-#define _MD_INIT_FD_INHERITABLE _MD_init_fd_inheritable
-#define _MD_QUERY_FD_INHERITABLE _MD_query_fd_inheritable
-#define _MD_OPEN _MD_open
-#define _MD_OPEN_FILE _MD_open
-#define _MD_CLOSE_FILE _MD_close_file
-#define _MD_READ _MD_read
-#define _MD_WRITE _MD_write
-#define _MD_WRITEV _MD_writev
+#define _PR_MD_WRITE 
+
+/*
+These are defined in primpl.h so that they are avail for all, but we
+have no calls, and pthreads doesn't either.
 #define _MD_LSEEK _MD_lseek
 #define _MD_LSEEK64 _MD_lseek64
-#define _MD_FSYNC _MD_fsync
-#define _MD_DELETE _MD_delete
+
 #define _MD_GETFILEINFO _MD_getfileinfo
 #define _MD_GETFILEINFO64 _MD_getfileinfo64
 #define _MD_GETOPENFILEINFO _MD_getopenfileinfo
 #define _MD_GETOPENFILEINFO64 _MD_getopenfileinfo64
-#define _MD_RENAME _MD_rename
-#define _MD_ACCESS _MD_access
-#define _MD_STAT stat
-#define _MD_MKDIR _MD_mkdir
-#define _MD_MAKE_DIR _MD_mkdir
-#define _MD_RMDIR _MD_rmdir
-#define _MD_PR_POLL _MD_pr_poll
+*/
 
 /* Network I/O */
 
-#define _MD_CLOSE_SOCKET _MD_close_socket
-#define _MD_CONNECT _MD_connect
-#define _MD_ACCEPT _MD_accept
-#define _MD_BIND _MD_bind
-#define _MD_LISTEN _MD_listen
-#define _MD_SHUTDOWN _MD_shutdown
-#define _MD_RECV _MD_recv
-#define _MD_SEND _MD_send
-#define _MD_ACCEPT_READ _MD_accept_read
-#define _MD_GETSOCKNAME _MD_getsockname
-#define _MD_GETPEERNAME _MD_getpeername
-#define _MD_GETSOCKOPT _MD_getsockopt
-#define _MD_SETSOCKOPT _MD_setsockopt
-#define _MD_RECVFROM _MD_recvfrom
-#define _MD_SENDTO _MD_sendto
-#define _MD_SOCKETPAIR _MD_socketpair
-#define _MD_SOCKET _MD_socket
-#define _MD_SOCKETAVAILABLE _MD_socketavailable
-#define _MD_PIPEAVAILABLE _MD_socketavailable
-
-#define _MD_GET_SOCKET_ERROR()	(errno)
+#define _MD_GET_SOCKET_ERROR() (errno)
 #define _MD_GETHOSTNAME _MD_gethostname
 
-#define _MD_SELECT select
-
 /* Process management */
 
 #define _MD_CREATE_PROCESS _MD_create_process
 #define _MD_DETACH_PROCESS _MD_detach_process
 #define _MD_WAIT_PROCESS _MD_wait_process
 #define _MD_KILL_PROCESS _MD_kill_process
 
-/* Atomic data operations */
-
-// #define _MD_INIT_ATOMIC _MD_init_atomic
-// #define _MD_ATOMIC_INCREMENT _MD_atomic_increment
-// #define _MD_ATOMIC_DECREMENT _MD_atomic_decrement
-// #define _MD_ATOMIC_SET _MD_atomic_set
-
-/* memory management */
-
-#define _MD_INIT_SEGS _MD_init_segs
-#define _MD_ALLOC_SEGMENT _MD_alloc_segment
-#define _MD_FREE_SEGMENT _MD_free_segment
-
 /* Memory mapped file I/O */
 
 #define _MD_CREATE_FILE_MAP _MD_create_file_map
 #define _MD_GET_MEM_MAP_ALIGNMENT _MD_get_mem_map_alignment
 #define _MD_MEM_MAP _MD_mem_map
 #define _MD_MEM_UNMAP _MD_mem_unmap
 #define _MD_CLOSE_FILE_MAP _MD_close_file_map
 
 /* Time related */
 
-#define _MD_NOW _MD_now
-#define _MD_INTERVAL_INIT _MD_interval_init
+#define _MD_INTERVAL_INIT()
 #define _MD_GET_INTERVAL _MD_get_interval
 #define _MD_INTERVAL_PER_SEC _MD_interval_per_sec
 
 /* File locking */
 
 #define _MD_LOCKFILE _MD_lockfile
 #define _MD_TLOCKFILE _MD_tlockfile
 #define _MD_UNLOCKFILE _MD_unlockfile
 
-/**
- * Prototypes for machine dependent function implementations. (Too bad
- * NSPR's MD system blows so much that we have to reiterate every stinking
- * thing we implement here in our MD header file.)
- */
-
-/* Miscellaneous */
-
-NSPR_API(void) _MD_cleanup_before_exit(void);
-NSPR_API(void) _MD_exit(PRIntn status);
-
-NSPR_API(char*) _MD_get_env(const char *name);
-NSPR_API(PRIntn) _MD_put_env(const char *name);
-
-NSPR_API(void) _MD_early_init(void);
-NSPR_API(void) _MD_final_init(void);
-
-/* CPU Stuff */
-
-NSPR_API(void) _MD_init_cpus();
-NSPR_API(void) _MD_wakeup_cpus();
-NSPR_API(void) _MD_start_interrupts(void);
-NSPR_API(void) _MD_stop_interrupts(void);
-NSPR_API(void) _MD_disable_clock_interrupts(void);
-NSPR_API(void) _MD_block_clock_interrupts(void);
-NSPR_API(void) _MD_unblock_clock_interrupts(void);
-NSPR_API(void) _MD_clock_interrupt(void);
-// NSPR_API(void) _MD_init_stack(PRThreadStack *ts, PRIntn redzone);
-// NSPR_API(void) _MD_clear_stack(PRThreadStack* ts);
-// NSPR_API(PRInt32) _MD_get_intsoff(void);
-// NSPR_API(void) _MD_set_intsoff(PRInt32 _val);
-// NSPR_API(_PRCPU*) _MD_current_cpu(void);
-// NSPR_API(void) _MD_set_current_cpu(_PRCPU *cpu);
-// NSPR_API(void) _MD_init_running_cpu(_PRCPU *cpu);
-NSPR_API(PRInt32) _MD_pause_cpu(PRIntervalTime timeout);
-
-/* Thread stuff */
-
-// NSPR_API(PRThread*) _MD_current_thread(void);
-NSPR_API(PRThread*) _MD_get_attached_thread(void);
-NSPR_API(PRThread*) _MD_last_thread(void);
-NSPR_API(void) _MD_set_current_thread(PRThread *thread);
-NSPR_API(void) _MD_set_last_thread(PRThread *thread);
-NSPR_API(PRStatus) _MD_init_thread(PRThread *thread);
-NSPR_API(void) _MD_exit_thread(PRThread *thread);
-NSPR_API(PRStatus) _MD_init_attached_thread(PRThread *thread);
-
-NSPR_API(void) _MD_suspend_thread(PRThread *thread);
-NSPR_API(void) _MD_resume_thread(PRThread *thread);
-// NSPR_API(void) _MD_suspend_cpu(_PRCPU  *cpu);
-// NSPR_API(void) _MD_resume_cpu(_PRCPU  *cpu);
-NSPR_API(void) _MD_begin_suspend_all(void);
-NSPR_API(void) _MD_end_suspend_all(void);
-NSPR_API(void) _MD_begin_resume_all(void);
-NSPR_API(void) _MD_end_resume_all(void);
-
-NSPR_API(void *) _MD_get_sp(PRThread *thread);
-
-NSPR_API(void) _MD_clean_thread(PRThread *thread);
-NSPR_API(void) _MD_create_primordial_user_thread(PRThread *);
-NSPR_API(PRThread*) _MD_create_user_thread(PRUint32 stacksize, void (*start)(void *), void *arg);
-NSPR_API(void) _MD_init_primordial_thread(PRThread *thread);
-NSPR_API(PRStatus) _MD_create_thread(PRThread *thread, void (*start)(void *), PRThreadPriority priority, PRThreadScope scope, PRThreadState state, PRUint32 stackSize);
-NSPR_API(void) _MD_yield(void);
-NSPR_API(void) _MD_set_priority(struct _MDThread *md, PRThreadPriority newPri);
-
-NSPR_API(void) _MD_suspendall(void);
-NSPR_API(void) _MD_resumeall(void);
-
-NSPR_API(void) _MD_init_context(PRThread *thread, char *top, void (*start) (void), PRBool *status);
-NSPR_API(void) _MD_switch_context(PRThread *thread);
-NSPR_API(void) _MD_restore_context(PRThread *thread);
-
-NSPR_API(PRStatus) _MD_wait(PRThread *, PRIntervalTime timeout);
-NSPR_API(PRStatus) _MD_wakeup_waiter(PRThread *);
-
-NSPR_API(PRInt32) _MD_setthreadaffinitymask(PRThread *thread, PRUint32 mask );
-NSPR_API(PRInt32) _MD_getthreadaffinitymask(PRThread *thread, PRUint32 *mask);
-
-/* Thread Synchronization */
-
-NSPR_API(void) _MD_init_locks(void);
-NSPR_API(PRStatus) _MD_new_lock(struct _MDLock *md);
-NSPR_API(void) _MD_free_lock(struct _MDLock *md);
-NSPR_API(void) _MD_lock(struct _MDLock *md);
-NSPR_API(PRIntn) _MD_test_and_lock(struct _MDLock *md);
-NSPR_API(void) _MD_unlock(struct _MDLock *md);
-NSPR_API(void) _MD_ioq_lock(void);
-NSPR_API(void) _MD_ioq_unlock(void);
-NSPR_API(void) _MD_new_sem(struct _MDSemaphore *md, PRUintn value);
-NSPR_API(void) _MD_destroy_sem(struct _MDSemaphore *md);
-NSPR_API(PRStatus) _MD_timed_wait_sem(struct _MDSemaphore *md, PRIntervalTime timeout);
-NSPR_API(PRStatus) _MD_wait_sem(struct _MDSemaphore *md);
-NSPR_API(void) _MD_post_sem(struct _MDSemaphore *md);
-// NSPR_API(PRInt32) _MD_new_cv(struct _MDCVar *md);
-// NSPR_API(void) _MD_free_cv(struct _MDCVar *md);
-// NSPR_API(void) _MD_wait_cv(struct _MDCVar *mdCVar, struct _MDLock *mdLock, PRIntervalTime timeout);
-// NSPR_API(void) _MD_notify_cv(struct _MDCVar *md, struct _MDLock *lock);
-// NSPR_API(void) _MD_notifyall_cv(struct _MDCVar *md, struct _MDLock *lock);
-
-/* File I/O */
-
-// NSPR_API(void) _MD_init_io(void);
-NSPR_API(PRStatus) _MD_open_dir(struct _MDDir *md,const char *name);
-NSPR_API(char *) _MD_read_dir(struct _MDDir *md, PRIntn flags);
-NSPR_API(PRInt32) _MD_close_dir(struct _MDDir *md);
-NSPR_API(void) _MD_make_nonblock(PRFileDesc *fd);
-NSPR_API(void) _MD_init_fd_inheritable(PRFileDesc *fd, PRBool imported);
-NSPR_API(void) _MD_query_fd_inheritable(PRFileDesc *fd);
-NSPR_API(PRInt32) _MD_open(const char *name, PRIntn osflags, PRIntn mode);
-NSPR_API(PRInt32) _MD_close_file(PRInt32 osfd);
-NSPR_API(PRInt32) _MD_read(PRFileDesc *fd, void *buf, PRInt32 amount);
-NSPR_API(PRInt32) _MD_write(PRFileDesc *fd, const void *buf, PRInt32 amount);
-NSPR_API(PRInt32) _MD_writev(PRFileDesc *fd, const PRIOVec *iov, PRInt32 iov_size, PRIntervalTime timeout);
-NSPR_API(PRInt32) _MD_lseek(PRFileDesc *fd, PRInt32 offset, int whence);
-NSPR_API(PRInt64) _MD_lseek64(PRFileDesc *fd, PRInt64 offset, int whence);
-NSPR_API(PRInt32) _MD_fsync(PRFileDesc *fd);
-NSPR_API(PRInt32) _MD_delete(const char *name);
-NSPR_API(PRInt32) _MD_getfileinfo(const char *fn, PRFileInfo *info);
-NSPR_API(PRInt32) _MD_getfileinfo64(const char *fn, PRFileInfo64 *info);
-NSPR_API(PRInt32) _MD_getopenfileinfo(const PRFileDesc *fd, PRFileInfo *info);
-NSPR_API(PRInt32) _MD_getopenfileinfo64(const PRFileDesc *fd, PRFileInfo64 *info);
-NSPR_API(PRInt32) _MD_rename(const char *from, const char *to);
-NSPR_API(PRInt32) _MD_access(const char *name, PRIntn how);
-NSPR_API(PRInt32) _MD_stat(const char *name, struct stat *buf);
-NSPR_API(PRInt32) _MD_mkdir(const char *name, PRIntn mode);
-NSPR_API(PRInt32) _MD_rmdir(const char *name);
-NSPR_API(PRInt32) _MD_pr_poll(PRPollDesc *pds, PRIntn npds, PRIntervalTime timeout);
-
-/* Network I/O */
-NSPR_API(PRInt32) _MD_close_socket(PRInt32 osfd);
-NSPR_API(PRInt32) _MD_connect(PRFileDesc *fd, const PRNetAddr *addr, PRUint32 addrlen, PRIntervalTime timeout);
-NSPR_API(PRInt32) _MD_accept(PRFileDesc *fd, PRNetAddr *addr, PRUint32 *addrlen, PRIntervalTime timeout);
-NSPR_API(PRInt32) _MD_bind(PRFileDesc *fd, const PRNetAddr *addr, PRUint32 addrlen);
-NSPR_API(PRInt32) _MD_listen(PRFileDesc *fd, PRIntn backlog);
-NSPR_API(PRInt32) _MD_shutdown(PRFileDesc *fd, PRIntn how);
-NSPR_API(PRInt32) _MD_recv(PRFileDesc *fd, void *buf, PRInt32 amount, PRIntn flags, PRIntervalTime timeout);
-NSPR_API(PRInt32) _MD_send(PRFileDesc *fd, const void *buf, PRInt32 amount, PRIntn flags, PRIntervalTime timeout);
-NSPR_API(PRInt32) _MD_accept_read(PRFileDesc *sd, PRInt32 *newSock, PRNetAddr **raddr, void *buf, PRInt32 amount, PRIntervalTime timeout);
-// NSPR_API(PRInt32) _MD_fast_accept(PRFileDesc *fd, PRNetAddr *addr, PRUint32 *addrlen, PRIntervalTime timeout, PRBool fast, _PR_AcceptTimeoutCallback callback, void *callbackArg);
-// NSPR_API(PRInt32) _MD_fast_accept_read(PRFileDesc *sd, PRInt32 *newSock, PRNetAddr **raddr, void *buf, PRInt32 amount, PRIntervalTime timeout, PRBool fast, _PR_AcceptTimeoutCallback callback, void *callbackArg);
-// NSPR_API(void) _MD_update_accept_context(PRInt32 s, PRInt32 ls);
-NSPR_API(PRStatus) _MD_getsockname(PRFileDesc *fd, PRNetAddr *addr, PRUint32 *addrlen);
-NSPR_API(PRStatus) _MD_getpeername(PRFileDesc *fd, PRNetAddr *addr, PRUint32 *addrlen);
-NSPR_API(PRStatus) _MD_getsockopt(PRFileDesc *fd, PRInt32 level, PRInt32 optname, char* optval, PRInt32* optlen);
-NSPR_API(PRStatus) _MD_setsockopt(PRFileDesc *fd, PRInt32 level, PRInt32 optname, const char* optval, PRInt32 optlen);
-NSPR_API(PRInt32) _MD_recvfrom(PRFileDesc *fd, void *buf, PRInt32 amount, PRIntn flags, PRNetAddr *addr, PRUint32 *addrlen, PRIntervalTime timeout);
-NSPR_API(PRInt32) _MD_sendto(PRFileDesc *fd, const void *buf, PRInt32 amount, PRIntn flags, const PRNetAddr *addr, PRUint32 addrlen, PRIntervalTime timeout);
-NSPR_API(PRInt32) _MD_socketpair(int af, int type, int flags, PRInt32 *osfd);
-NSPR_API(PRInt32) _MD_socket(int af, int type, int flags);
-NSPR_API(PRInt32) _MD_socketavailable(PRFileDesc *fd);
-
-// NSPR_API(PRInt32) _MD_get_socket_error(void);
-NSPR_API(PRStatus) _MD_gethostname(char *name, PRUint32 namelen);
-
-/* Process management */
-
-NSPR_API(PRProcess *) _MD_create_process(const char *path, char *const *argv, char *const *envp, const PRProcessAttr *attr);
-NSPR_API(PRStatus) _MD_detach_process(PRProcess *process);
-NSPR_API(PRStatus) _MD_wait_process(PRProcess *process, PRInt32 *exitCode);
-NSPR_API(PRStatus) _MD_kill_process(PRProcess *process);
-
-/* Atomic data operations */
-
-// NSPR_API(void) _MD_init_atomic(void);
-// NSPR_API(PRInt32) _MD_atomic_increment(PRInt32 *);
-// NSPR_API(PRInt32) _MD_atomic_decrement(PRInt32 *);
-// NSPR_API(PRInt32) _MD_atomic_set(PRInt32 *, PRInt32);
-
-/* Memory management */
-
-NSPR_API(void) _MD_init_segs(void);
-NSPR_API(PRStatus) _MD_alloc_segment(PRSegment *seg, PRUint32 size, void *vaddr);
-NSPR_API(void) _MD_free_segment(PRSegment *seg);
-
-/* Memory mapped file I/O */
-
-NSPR_API(PRStatus) _MD_create_file_map(PRFileMap *fmap, PRInt64 size);
-NSPR_API(PRInt32) _MD_get_mem_map_alignment(void);
-NSPR_API(void *) _MD_mem_map(PRFileMap *fmap, PRInt64 offset, PRUint32 len);
-NSPR_API(PRStatus) _MD_mem_unmap(void *addr, PRUint32 size);
-NSPR_API(PRStatus) _MD_close_file_map(PRFileMap *fmap);
-
-/* Time related */
-
-NSPR_API(PRTime) _MD_now(void);
-NSPR_API(void) _MD_interval_init(void);
-NSPR_API(PRIntervalTime) _MD_get_interval(void);
-NSPR_API(PRIntervalTime) _MD_interval_per_sec(void);
-
-/* File locking */
-
-NSPR_API(PRStatus) _MD_lockfile(PRInt32 osfd);
-NSPR_API(PRStatus) _MD_tlockfile(PRInt32 osfd);
-NSPR_API(PRStatus) _MD_unlockfile(PRInt32 osfd);
-
 #endif /* _nspr_beos_defs_h___*/
Index: mozilla/nsprpub/pr/include/private/primpl.h
===================================================================
RCS file: /cvsroot/mozilla/nsprpub/pr/include/private/primpl.h,v
retrieving revision 3.84.2.2
diff -u -8 -p -r3.84.2.2 primpl.h
--- mozilla/nsprpub/pr/include/private/primpl.h	25 Jul 2007 07:08:28 -0000	3.84.2.2
+++ mozilla/nsprpub/pr/include/private/primpl.h	9 Feb 2009 04:04:34 -0000
@@ -45,20 +45,16 @@
  * This macro causes chaos if signal.h gets included before pthread.h.
  * To be safe, we include pthread.h first.
  */
 
 #if defined(_PR_PTHREADS)
 #include <pthread.h>
 #endif
 
-#if defined(_PR_BTHREADS)
-#include <kernel/OS.h>
-#endif
-
 #ifdef WINNT
 /* Need to force service-pack 3 extensions to be defined by
 ** setting _WIN32_WINNT to NT 4.0 for winsock.h, winbase.h, winnt.h.
 */
 #ifndef  _WIN32_WINNT
     #define _WIN32_WINNT 0x0400
 #elif   (_WIN32_WINNT < 0x0400)
     #undef  _WIN32_WINNT
@@ -223,16 +219,30 @@ typedef struct PTDebug
 } PTDebug;
 
 #endif /* defined(DEBUG) */
 
 NSPR_API(void) PT_FPrintStats(PRFileDesc *fd, const char *msg);
 
 #else /* defined(_PR_PTHREADS) */
 
+#ifdef _PR_BTHREADS
+#define _MD_GET_ATTACHED_THREAD()        (_PR_MD_CURRENT_THREAD())
+
+#define _PR_IS_NATIVE_THREAD(thread) 1
+#define _PR_IS_NATIVE_THREAD_SUPPORTED() 1
+/*
+extern PRInt32 _PR_MD_WRITE(PRFileDesc *fd, const void *buf, PRInt32 amount);
+#define    _PR_MD_WRITE _MD_WRITE
+*/
+NSPR_API(PRThread*) _PR_MD_CURRENT_THREAD(void);
+#define    _PR_MD_CURRENT_THREAD _MD_CURRENT_THREAD
+
+#else /* defined(_PR_BTHREADS) */
+
 NSPR_API(void) PT_FPrintStats(PRFileDesc *fd, const char *msg);
 
 /*
 ** This section is contains those parts needed to implement NSPR on
 ** platforms in general. One would assume that the pthreads implementation
 ** included lots of the same types, at least conceptually.
 */
 
@@ -1296,16 +1306,17 @@ extern PRStatus _PR_MD_SET_FD_INHERITABL
                 PR_SetError( PR_PENDING_INTERRUPT_ERROR, 0); \
         } else { \
                 PR_SetError(PR_IO_TIMEOUT_ERROR, 0); \
         }                                                        
                 
 extern void *_PR_MD_GET_SP(PRThread *thread);
 #define    _PR_MD_GET_SP _MD_GET_SP
 
+#endif /* defined(_PR_BTHREADS) */
 #endif /* defined(_PR_PTHREADS) */
 
 /************************************************************************/
 /*************************************************************************
 ** The remainder of the definitions are shared by pthreads and the classic
 ** NSPR code. These too may be conditionalized.
 *************************************************************************/
 /************************************************************************/
@@ -1550,17 +1561,20 @@ struct PRThreadStack {
     char *stackTop;             /* top of stack from C's point of view */
     PRUint32 stackSize;         /* size of usable portion of the stack */
 
     PRSegment *seg;
         PRThread* thr;          /* back pointer to thread owning this stack */
 
 #if defined(_PR_PTHREADS)
 #else /* defined(_PR_PTHREADS) */
+#if defined(_PR_BTHREADS)
+#else /* defined(_PR_BTHREADS) */
     _MDThreadStack md;
+#endif /* defined(_PR_BTHREADS) */
 #endif /* defined(_PR_PTHREADS) */
 };
 
 extern void _PR_DestroyThreadPrivate(PRThread*);
 
 typedef void (PR_CALLBACK *_PRStartFn)(void *);
 
 struct PRThread {
@@ -1603,19 +1617,16 @@ struct PRThread {
     PRUint32 syspoll_count;         /* number of elements in syspoll_list */
 #if defined(_PR_POLL_WITH_SELECT)
     int *selectfd_list;             /* Unix fd's that PR_Poll selects on */
     PRUint32 selectfd_count;        /* number of elements in selectfd_list */
 #endif
 #elif defined(_PR_BTHREADS)
     PRUint32 flags;
     _MDThread md;
-    PRBool io_pending;
-    PRInt32 io_fd;
-    PRBool io_suspended;
 #else /* not pthreads or Be threads */
     _MDLock threadLock;             /* Lock to protect thread state variables.
                                      * Protects the following fields:
                                      *     state
                                      *     priority
                                      *     links
                                      *     wait
                                      *     cpu
@@ -1689,17 +1700,19 @@ struct PRProcessAttr {
 
 struct PRProcess {
     _MDProcess md;
 };
 
 struct PRFileMap {
     PRFileDesc *fd;
     PRFileMapProtect prot;
+#if !defined(XP_BEOS)
     _MDFileMap md;
+#endif /* !defined(XP_BEOS) */
 };
 
 /************************************************************************/
 
 /*
 ** File descriptors of the NSPR layer can be in one of the
 ** following states (stored in the 'state' field of struct
 ** PRFilePrivate):
@@ -1760,18 +1773,20 @@ struct PRDir {
 #ifdef MOZ_UNICODE
 struct PRDirUTF16 { 
     PRDirEntry d; 
     _MDDirUTF16 md; 
 }; 
 #endif /* MOZ_UNICODE */
 
 extern void _PR_InitSegs(void);
+#if !defined(_PR_BTHREADS)
 extern void _PR_InitStacks(void);
 extern void _PR_InitTPD(void);
+#endif /* !defined(_PR_BTHREADS) */
 extern void _PR_InitMem(void);
 extern void _PR_InitEnv(void);
 extern void _PR_InitCMon(void);
 extern void _PR_InitIO(void);
 extern void _PR_InitLog(void);
 extern void _PR_InitNet(void);
 extern void _PR_InitClock(void);
 extern void _PR_InitLinker(void);
@@ -1812,17 +1827,20 @@ extern PRBool _PR_Obsolete(const char *o
 /************************************************************************/
 
 struct PRSegment {
     void *vaddr;
     PRUint32 size;
     PRUintn flags;
 #if defined(_PR_PTHREADS)
 #else  /* defined(_PR_PTHREADS) */
+#if defined(_PR_BTHREADS) 
+#else /* defined(_PR_BTHREADS) */
     _MDSegment md;
+#endif /* defined(_PR_BTHREADS) */
 #endif /* defined(_PR_PTHREADS) */
 };
 
 /* PRSegment.flags */
 #define _PR_SEG_VM    0x1
 
 /************************************************************************/
 
@@ -2109,28 +2127,28 @@ extern void _PR_MD_QUERY_FD_INHERITABLE(
 /* --- PR_GetRandomNoise() related things --- */
 
 extern PRSize _PR_MD_GetRandomNoise( void *buf, PRSize size );
 #define _PR_MD_GET_RANDOM_NOISE(buf,size) _PR_MD_GetRandomNoise((buf),(size))
 extern PRSize _pr_CopyLowBits( void *dest, PRSize dstlen, void *src, PRSize srclen );
 
 /* end PR_GetRandomNoise() related */
 
-#ifdef XP_BEOS
+#if defined(XP_BEOS) && !defined(BONE_VERSION)
 
 extern PRLock *_connectLock;
 
 typedef struct _ConnectListNode {
 	PRInt32		osfd;
 	PRNetAddr	addr;
 	PRUint32	addrlen;
 	PRIntervalTime	timeout;
 } ConnectListNode;
 
 extern ConnectListNode connectList[64];
 
 extern PRUint32 connectCount;
 
-#endif /* XP_BEOS */
+#endif /* XP_BEOS && !BONE_VERSION */
 
 PR_END_EXTERN_C
 
 #endif /* primpl_h___ */
Index: mozilla/nsprpub/pr/src/Makefile.in
===================================================================
RCS file: /cvsroot/mozilla/nsprpub/pr/src/Makefile.in,v
retrieving revision 1.40.2.2
diff -u -8 -p -r1.40.2.2 Makefile.in
--- mozilla/nsprpub/pr/src/Makefile.in	19 Oct 2006 00:39:28 -0000	1.40.2.2
+++ mozilla/nsprpub/pr/src/Makefile.in	9 Feb 2009 04:04:35 -0000
@@ -270,36 +270,33 @@ endif
 
 ifdef USE_PTHREADS
 OBJS += \
     pthreads/$(OBJDIR)/ptsynch.$(OBJ_SUFFIX) \
     pthreads/$(OBJDIR)/ptio.$(OBJ_SUFFIX) \
     pthreads/$(OBJDIR)/ptthread.$(OBJ_SUFFIX) \
     pthreads/$(OBJDIR)/ptmisc.$(OBJ_SUFFIX)
 else
+ifndef USE_BTHREADS
 OBJS += \
     io/$(OBJDIR)/prdir.$(OBJ_SUFFIX) \
     io/$(OBJDIR)/prfile.$(OBJ_SUFFIX) \
     io/$(OBJDIR)/prio.$(OBJ_SUFFIX) \
     io/$(OBJDIR)/prsocket.$(OBJ_SUFFIX) \
-    misc/$(OBJDIR)/pripcsem.$(OBJ_SUFFIX)
-
-ifndef USE_BTHREADS
-OBJS += \
-	threads/$(OBJDIR)/prcthr.$(OBJ_SUFFIX) \
-	threads/$(OBJDIR)/prdump.$(OBJ_SUFFIX) \
-	threads/$(OBJDIR)/prmon.$(OBJ_SUFFIX) \
-	threads/$(OBJDIR)/prsem.$(OBJ_SUFFIX) \
-	threads/combined/$(OBJDIR)/prucpu.$(OBJ_SUFFIX) \
-	threads/combined/$(OBJDIR)/prucv.$(OBJ_SUFFIX) \
-	threads/combined/$(OBJDIR)/prulock.$(OBJ_SUFFIX) \
-	threads/combined/$(OBJDIR)/prustack.$(OBJ_SUFFIX) \
-	threads/combined/$(OBJDIR)/pruthr.$(OBJ_SUFFIX)
+    misc/$(OBJDIR)/pripcsem.$(OBJ_SUFFIX) \
+    threads/$(OBJDIR)/prcthr.$(OBJ_SUFFIX) \
+    threads/$(OBJDIR)/prdump.$(OBJ_SUFFIX) \
+    threads/$(OBJDIR)/prmon.$(OBJ_SUFFIX) \
+    threads/$(OBJDIR)/prsem.$(OBJ_SUFFIX) \
+    threads/combined/$(OBJDIR)/prucpu.$(OBJ_SUFFIX) \
+    threads/combined/$(OBJDIR)/prucv.$(OBJ_SUFFIX) \
+    threads/combined/$(OBJDIR)/prulock.$(OBJ_SUFFIX) \
+    threads/combined/$(OBJDIR)/prustack.$(OBJ_SUFFIX) \
+    threads/combined/$(OBJDIR)/pruthr.$(OBJ_SUFFIX)
 endif
-
 endif
 
 ifeq ($(USE_CPLUS), 1)
 OBJS += \
 	cplus/$(OBJDIR)/rcbase.$(OBJ_SUFFIX) \
 	cplus/$(OBJDIR)/rccv.$(OBJ_SUFFIX) \
 	cplus/$(OBJDIR)/rcfileio.$(OBJ_SUFFIX) \
 	cplus/$(OBJDIR)/rcinrval.$(OBJ_SUFFIX) \
@@ -397,19 +394,23 @@ endif
 
 export:: $(TARGETS)
 	$(INSTALL) -m 444 $(TARGETS) $(dist_libdir)
 ifdef SHARED_LIBRARY
 ifeq ($(OS_ARCH),HP-UX)
 	$(INSTALL) -m 755 $(SHARED_LIBRARY) $(dist_libdir)
 	$(INSTALL) -m 755 $(SHARED_LIBRARY) $(dist_bindir)
 else
+ifeq (,$(filter-out BeOS Haiku, $(OS_ARCH)))
+	$(INSTALL) -m 444 $(SHARED_LIBRARY) $(dist_bindir)/lib
+else 
 	$(INSTALL) -m 444 $(SHARED_LIBRARY) $(dist_bindir)
 endif
 endif
+endif
 ifeq ($(MOZ_BITS),16)
 	$(INSTALL) -m 444 $(TARGETS) $(MOZ_DIST)/lib
 	$(INSTALL) -m 444 $(TARGETS) $(MOZ_DIST)/bin
 endif
 
 ifeq ($(BUILD_AIX_RTL_LIBC),1)
 $(AIX_RTL_LIBC): /usr/ccs/lib/libc.a
 	rtl_enable -o $@ $<
Index: mozilla/nsprpub/pr/src/bthreads/bsrcs.mk
===================================================================
RCS file: /cvsroot/mozilla/nsprpub/pr/src/bthreads/bsrcs.mk,v
retrieving revision 3.6
diff -u -8 -p -r3.6 bsrcs.mk
--- mozilla/nsprpub/pr/src/bthreads/bsrcs.mk	25 Apr 2004 15:00:57 -0000	3.6
+++ mozilla/nsprpub/pr/src/bthreads/bsrcs.mk	9 Feb 2009 04:04:35 -0000
@@ -15,16 +15,17 @@
 # The Original Code is the Netscape Portable Runtime (NSPR).
 #
 # The Initial Developer of the Original Code is
 # Netscape Communications Corporation.
 # Portions created by the Initial Developer are Copyright (C) 1998-2000
 # the Initial Developer. All Rights Reserved.
 #
 # Contributor(s):
+# Fredrik Holmqvist <thesuckiestemail@yahoo.se>
 #
 # Alternatively, the contents of this file may be used under the terms of
 # either the GNU General Public License Version 2 or later (the "GPL"), or
 # the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 # in which case the provisions of the GPL or the LGPL are applicable instead
 # of those above. If you wish to allow use of your version of this file only
 # under the terms of either the GPL or the LGPL, and not to allow others to
 # use your version of this file under the terms of the MPL, indicate your
@@ -41,9 +42,11 @@
 
 BTCSRCS = \
 	btthread.c \
 	btlocks.c \
 	btcvar.c \
 	btmon.c \
 	btsem.c \
 	btmisc.c \
+	btfile.c \
+	btio.c \
 	$(NULL)
Index: mozilla/nsprpub/pr/src/bthreads/btcvar.c
===================================================================
RCS file: /cvsroot/mozilla/nsprpub/pr/src/bthreads/btcvar.c,v
retrieving revision 3.9
diff -u -8 -p -r3.9 btcvar.c
--- mozilla/nsprpub/pr/src/bthreads/btcvar.c	23 Feb 2005 17:43:13 -0000	3.9
+++ mozilla/nsprpub/pr/src/bthreads/btcvar.c	9 Feb 2009 04:04:36 -0000
@@ -15,33 +15,32 @@
  * The Original Code is the Netscape Portable Runtime (NSPR).
  *
  * The Initial Developer of the Original Code is
  * Netscape Communications Corporation.
  * Portions created by the Initial Developer are Copyright (C) 1998-2000
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
- *
+ * Fredrik Holmqvist <thesuckiestemail@yahoo.se>
+ * 
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
-#include <kernel/OS.h>
-
 #include "primpl.h"
 
 /*
 ** Create a new condition variable.
 **
 ** 	"lock" is the lock used to protect the condition variable.
 **
 ** Condition variables are synchronization objects that threads can use
@@ -52,25 +51,25 @@
 */
 PR_IMPLEMENT(PRCondVar*)
     PR_NewCondVar (PRLock *lock)
 {
     PRCondVar *cv = PR_NEW( PRCondVar );
     PR_ASSERT( NULL != lock );
     if( NULL != cv )
     {
-	cv->lock = lock;
-	cv->sem = create_sem(0, "CVSem");
-	cv->handshakeSem = create_sem(0, "CVHandshake");
-	cv->signalSem = create_sem( 0, "CVSignal");
-	cv->signalBenCount = 0;
-	cv->ns = cv->nw = 0;
-	PR_ASSERT( cv->sem >= B_NO_ERROR );
-	PR_ASSERT( cv->handshakeSem >= B_NO_ERROR );
-	PR_ASSERT( cv->signalSem >= B_NO_ERROR );
+        cv->lock = lock;
+        cv->sem = create_sem(0, "CVSem");
+        cv->handshakeSem = create_sem(0, "CVHandshake");
+        cv->signalSem = create_sem( 0, "CVSignal");
+        cv->signalBenCount = 0;
+        cv->ns = cv->nw = 0;
+        PR_ASSERT( cv->sem >= B_NO_ERROR );
+        PR_ASSERT( cv->handshakeSem >= B_NO_ERROR );
+        PR_ASSERT( cv->signalSem >= B_NO_ERROR );
     }
     return cv;
 } /* PR_NewCondVar */
 
 /*
 ** Destroy a condition variable. There must be no thread
 ** waiting on the condvar. The caller is responsible for guaranteeing
 ** that the condvar is no longer in use.
@@ -118,69 +117,69 @@ PR_IMPLEMENT(void)
 ** Returns PR_FAILURE if the caller has not locked the lock associated
 ** with the condition variable or the thread was interrupted (PR_Interrupt()).
 ** The particular reason can be extracted with PR_GetError().
 */
 PR_IMPLEMENT(PRStatus)
     PR_WaitCondVar (PRCondVar *cvar, PRIntervalTime timeout)
 {
     status_t err;
-    if( timeout == PR_INTERVAL_NO_WAIT ) 
+    if( timeout == PR_INTERVAL_NO_WAIT )
     {
         PR_Unlock( cvar->lock );
         PR_Lock( cvar->lock );
         return PR_SUCCESS;
     }
 
-    if( atomic_add( &cvar->signalBenCount, 1 ) > 0 ) 
+    if( _MD_ATOMIC_INCREMENT( &cvar->signalBenCount ) > 1 )
     {
-        if (acquire_sem(cvar->signalSem) == B_INTERRUPTED) 
+        if (acquire_sem(cvar->signalSem) == B_INTERRUPTED)
         {
-            atomic_add( &cvar->signalBenCount, -1 );
+            _MD_ATOMIC_DECREMENT( &cvar->signalBenCount );
             return PR_FAILURE;
         }
     }
     cvar->nw += 1;
-    if( atomic_add( &cvar->signalBenCount, -1 ) > 1 ) 
+    if( _MD_ATOMIC_DECREMENT( &cvar->signalBenCount ) > 0 )
     {
         release_sem_etc(cvar->signalSem, 1, B_DO_NOT_RESCHEDULE);
     }
 
     PR_Unlock( cvar->lock );
-    if( timeout==PR_INTERVAL_NO_TIMEOUT ) 
+    if( timeout==PR_INTERVAL_NO_TIMEOUT )
     {
-    	err = acquire_sem(cvar->sem);
-    } 
-    else 
+        err = acquire_sem(cvar->sem);
+    }
+    else
     {
-    	err = acquire_sem_etc(cvar->sem, 1, B_RELATIVE_TIMEOUT, PR_IntervalToMicroseconds(timeout) );
+        err = acquire_sem_etc(cvar->sem, 1, B_RELATIVE_TIMEOUT, PR_IntervalToMicroseconds(timeout) );
     }
 
-    if( atomic_add( &cvar->signalBenCount, 1 ) > 0 ) 
+    if( _MD_ATOMIC_INCREMENT( &cvar->signalBenCount ) > 1 )
     {
         while (acquire_sem(cvar->signalSem) == B_INTERRUPTED);
     }
 
     if (cvar->ns > 0)
     {
         release_sem_etc(cvar->handshakeSem, 1, B_DO_NOT_RESCHEDULE);
         cvar->ns -= 1;
     }
     cvar->nw -= 1;
-    if( atomic_add( &cvar->signalBenCount, -1 ) > 1 ) 
+    if( _MD_ATOMIC_DECREMENT( &cvar->signalBenCount ) > 0 )
     {
         release_sem_etc(cvar->signalSem, 1, B_DO_NOT_RESCHEDULE);
     }
 
     PR_Lock( cvar->lock );
-    if(err!=B_NO_ERROR) 
+    if(err==B_NO_ERROR  || (err == B_TIMED_OUT && timeout!=PR_INTERVAL_NO_TIMEOUT))
     {
-        return PR_FAILURE;
+        return PR_SUCCESS;
     }
-    return PR_SUCCESS;
+    return PR_FAILURE;
 }
 
 /*
 ** Notify ONE thread that is currently waiting on 'cvar'. Which thread is
 ** dependent on the implementation of the runtime. Common sense would dictate
 ** that all threads waiting on a single condition have identical semantics,
 ** therefore which one gets notified is not significant. 
 **
@@ -189,88 +188,88 @@ PR_IMPLEMENT(PRStatus)
 ** notify is called.
 **
 ** Returns PR_FAILURE if the caller has not locked the lock associated
 ** with the condition variable.
 */
 PR_IMPLEMENT(PRStatus)
     PR_NotifyCondVar (PRCondVar *cvar)
 {
-    status_t err ;
-    if( atomic_add( &cvar->signalBenCount, 1 ) > 0 ) 
+    status_t err;
+    if( _MD_ATOMIC_INCREMENT( &cvar->signalBenCount) > 1 )
     {
-        if (acquire_sem(cvar->signalSem) == B_INTERRUPTED) 
+        if (acquire_sem(cvar->signalSem) == B_INTERRUPTED)
         {
-            atomic_add( &cvar->signalBenCount, -1 );
+            _MD_ATOMIC_DECREMENT( &cvar->signalBenCount );
             return PR_FAILURE;
         }
     }
     if (cvar->nw > cvar->ns)
     {
         cvar->ns += 1;
         release_sem_etc(cvar->sem, 1, B_DO_NOT_RESCHEDULE);
-        if( atomic_add( &cvar->signalBenCount, -1 ) > 1 ) 
+        if( _MD_ATOMIC_DECREMENT( &cvar->signalBenCount) > 0 )
         {
             release_sem_etc(cvar->signalSem, 1, B_DO_NOT_RESCHEDULE);
         }
 
-        while (acquire_sem(cvar->handshakeSem) == B_INTERRUPTED) 
+        while (acquire_sem(cvar->handshakeSem) == B_INTERRUPTED)
         {
-            err = B_INTERRUPTED; 
+            err = B_INTERRUPTED;
         }
     }
     else
     {
-        if( atomic_add( &cvar->signalBenCount, -1 ) > 1 )
+        if( _MD_ATOMIC_DECREMENT( &cvar->signalBenCount ) > 0 )
         {
             release_sem_etc(cvar->signalSem, 1, B_DO_NOT_RESCHEDULE);
         }
     }
-    return PR_SUCCESS; 
+    return PR_SUCCESS;
 }
 
 /*
 ** Notify all of the threads waiting on the condition variable. The order
 ** that the threads are notified is indeterminant. The lock that protects
 ** the condition must be held.
 **
 ** Returns PR_FAILURE if the caller has not locked the lock associated
 ** with the condition variable.
 */
 PR_IMPLEMENT(PRStatus)
     PR_NotifyAllCondVar (PRCondVar *cvar)
 {
     int32 handshakes;
     status_t err = B_OK;
 
-    if( atomic_add( &cvar->signalBenCount, 1 ) > 0 ) 
+    if( _MD_ATOMIC_INCREMENT( &cvar->signalBenCount) > 1 )
     {
-        if (acquire_sem(cvar->signalSem) == B_INTERRUPTED) 
+        if (acquire_sem(cvar->signalSem) == B_INTERRUPTED)
         {
-            atomic_add( &cvar->signalBenCount, -1 );
+            _MD_ATOMIC_DECREMENT( &cvar->signalBenCount );
             return PR_FAILURE;
         }
     }
 
     if (cvar->nw > cvar->ns)
     {
         handshakes = cvar->nw - cvar->ns;
-        cvar->ns = cvar->nw;				
-        release_sem_etc(cvar->sem, handshakes, B_DO_NOT_RESCHEDULE);	
-        if( atomic_add( &cvar->signalBenCount, -1 ) > 1 ) 
+        cvar->ns = cvar->nw;
+        release_sem_etc(cvar->sem, handshakes, B_DO_NOT_RESCHEDULE);
+        if( _MD_ATOMIC_DECREMENT( &cvar->signalBenCount ) > 0 )
         {
             release_sem_etc(cvar->signalSem, 1, B_DO_NOT_RESCHEDULE);
         }
 
-        while (acquire_sem_etc(cvar->handshakeSem, handshakes, 0, 0) == B_INTERRUPTED) 
+        while (acquire_sem_etc(cvar->handshakeSem, handshakes, 0, 0) == B_INTERRUPTED)
         {
-            err = B_INTERRUPTED; 
+            err = B_INTERRUPTED;
         }
     }
     else
     {
-        if( atomic_add( &cvar->signalBenCount, -1 ) > 1 ) 
+        if( _MD_ATOMIC_DECREMENT( &cvar->signalBenCount ) > 0 )
         {
             release_sem_etc(cvar->signalSem, 1, B_DO_NOT_RESCHEDULE);
         }
     }
     return PR_SUCCESS;
 }
Index: mozilla/nsprpub/pr/src/bthreads/btfile.c
===================================================================
RCS file: mozilla/nsprpub/pr/src/bthreads/btfile.c
diff -N mozilla/nsprpub/pr/src/bthreads/btfile.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ mozilla/nsprpub/pr/src/bthreads/btfile.c	5 Nov 2008 20:51:44 -0000
@@ -0,0 +1,994 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Netscape Portable Runtime (NSPR).
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1998-2000
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Roy Yokoyama <yokoyama@netscape.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "primpl.h"
+
+static PRLock *_pr_flock_lock;  /* For PR_LockFile() etc. */
+static PRCondVar *_pr_flock_cv;  /* For PR_LockFile() etc. */
+
+PRErrorCode
+map_default_error(int err)
+{
+    switch (err) {
+        case EACCES:
+            return PR_NO_ACCESS_RIGHTS_ERROR;
+        case EADDRINUSE:
+            return PR_ADDRESS_IN_USE_ERROR;
+        case EADDRNOTAVAIL:
+            return PR_ADDRESS_NOT_AVAILABLE_ERROR;
+        case EAFNOSUPPORT:
+            return PR_ADDRESS_NOT_SUPPORTED_ERROR;
+        /*Same as EWOULDBLOCK*/
+        case EAGAIN:
+            return PR_WOULD_BLOCK_ERROR;
+#if EALREADY != EBUSY
+        case EALREADY:
+            return PR_ALREADY_INITIATED_ERROR;
+#endif
+        case EBADF:
+            return PR_BAD_DESCRIPTOR_ERROR;
+        case EBUSY:
+            return PR_FILESYSTEM_MOUNTED_ERROR;
+        case ECONNABORTED:
+            return PR_CONNECT_ABORTED_ERROR;
+        case ECONNREFUSED:
+            return PR_CONNECT_REFUSED_ERROR;
+        case EDEADLK:
+            return PR_DEADLOCK_ERROR;
+        case EEXIST:
+            return PR_FILE_EXISTS_ERROR;
+        case EFAULT:
+            return PR_ACCESS_FAULT_ERROR;
+        case EFBIG:
+            return PR_FILE_TOO_BIG_ERROR;
+        case EHOSTUNREACH:
+            return PR_HOST_UNREACHABLE_ERROR;
+        case EINPROGRESS:
+            return PR_IN_PROGRESS_ERROR;
+        case EINTR:
+            return PR_PENDING_INTERRUPT_ERROR;
+        case EINVAL:
+            return PR_INVALID_ARGUMENT_ERROR;
+        case EIO:
+            return PR_IO_ERROR;
+        case EISCONN:
+            return PR_IS_CONNECTED_ERROR;
+        case EISDIR:
+            return PR_IS_DIRECTORY_ERROR;
+        case ELOOP:
+            return PR_LOOP_ERROR;
+        case EMFILE:
+            return PR_PROC_DESC_TABLE_FULL_ERROR;
+        case EMLINK:
+            return PR_MAX_DIRECTORY_ENTRIES_ERROR;
+        case EMSGSIZE:
+            return PR_INVALID_ARGUMENT_ERROR;
+        case ENAMETOOLONG:
+            return PR_NAME_TOO_LONG_ERROR;
+        case ENETUNREACH:
+            return PR_NETWORK_UNREACHABLE_ERROR;
+        case ENFILE:
+            return PR_SYS_DESC_TABLE_FULL_ERROR;
+        case ENOBUFS:
+            return PR_INSUFFICIENT_RESOURCES_ERROR;
+        case ENODEV:
+        case ENOENT:
+            return PR_FILE_NOT_FOUND_ERROR;
+        case ENOLCK:
+            return PR_FILE_IS_LOCKED_ERROR;
+#if 0
+        case ENOLINK:
+            return PR_REMOTE_FILE_ERROR;
+#endif
+        case ENOMEM:
+            return PR_OUT_OF_MEMORY_ERROR;
+        case ENOPROTOOPT:
+            return PR_INVALID_ARGUMENT_ERROR;
+        case ENOSPC:
+            return PR_NO_DEVICE_SPACE_ERROR;
+        case ENOTCONN:
+            return PR_NOT_CONNECTED_ERROR;
+        case ENOTDIR:
+            return PR_NOT_DIRECTORY_ERROR;
+        case ENOTSOCK:
+            return PR_NOT_SOCKET_ERROR;
+        case ENXIO:
+            return PR_FILE_NOT_FOUND_ERROR;
+        case EOPNOTSUPP:
+            return PR_NOT_TCP_SOCKET_ERROR;
+        case EOVERFLOW:
+            return PR_BUFFER_OVERFLOW_ERROR;
+        case EPERM:
+            return PR_NO_ACCESS_RIGHTS_ERROR;
+        case EPIPE:
+            return PR_CONNECT_RESET_ERROR;
+        case EPROTONOSUPPORT:
+            return PR_PROTOCOL_NOT_SUPPORTED_ERROR;
+        case EPROTOTYPE:
+            return PR_ADDRESS_NOT_SUPPORTED_ERROR;
+        case ERANGE:
+            return PR_INVALID_METHOD_ERROR;
+        case EROFS:
+            return PR_READ_ONLY_FILESYSTEM_ERROR;
+        case ESPIPE:
+            return PR_INVALID_METHOD_ERROR;
+        case ETIMEDOUT:
+            return PR_IO_TIMEOUT_ERROR;
+        case EXDEV:
+            return PR_NOT_SAME_DEVICE_ERROR;
+        default:
+            return PR_UNKNOWN_ERROR;
+    }
+}
+
+
+inline void
+set_open_error(int err)
+{
+    PRErrorCode prError;
+    switch (err) {
+        case EAGAIN:
+        case ENOMEM:
+            prError = PR_INSUFFICIENT_RESOURCES_ERROR;
+            break;
+        case EBUSY:
+            prError = PR_IO_ERROR;
+            break;
+        case ENODEV:
+            prError = PR_FILE_NOT_FOUND_ERROR;
+            break;
+        case EOVERFLOW:
+            prError = PR_FILE_TOO_BIG_ERROR;
+            break;
+        case ETIMEDOUT:
+            prError = PR_REMOTE_FILE_ERROR;
+            break;
+        default:
+            prError = map_default_error(err);
+    }
+    PR_SetError(prError, err);
+}
+
+
+inline void
+set_rename_error(int err)
+{
+    PR_SetError(err == EEXIST ? PR_DIRECTORY_NOT_EMPTY_ERROR : map_default_error(err), err);
+}
+
+
+inline void
+set_unlink_error(int err)
+{
+    PR_SetError(err == EPERM ? PR_IS_DIRECTORY_ERROR : map_default_error(err), err);
+}
+
+
+inline void 
+set_opendir_error(int err)
+{
+    PR_SetError(map_default_error(err), err);
+}
+
+inline void
+set_closedir_error(int err)
+{
+    PR_SetError( err == EINVAL ? PR_BAD_DESCRIPTOR_ERROR : map_default_error(err), err);
+}
+
+inline void 
+set_readdir_error(int err)
+{
+    PRErrorCode prError;
+    switch (err) {
+        case 0:
+        case ENOENT:
+            prError = PR_NO_MORE_FILES_ERROR;
+            break;
+        case EOVERFLOW:
+        case EINVAL:
+        case ENXIO:
+            prError = PR_IO_ERROR;
+            break;
+        default:
+            prError = map_default_error(err);
+    }
+    PR_SetError(prError, err);
+}
+
+
+inline void
+set_mkdir_error(int err)
+{
+    PR_SetError(map_default_error(err), err);
+}
+
+
+inline void
+set_rmdir_error(int err)
+{
+    PRErrorCode prError;
+    switch (err) {
+        case ENOTEMPTY:
+        case EEXIST:
+        case EINVAL:
+            prError = PR_DIRECTORY_NOT_EMPTY_ERROR;
+            break;
+        case ETIMEDOUT:
+            prError = PR_REMOTE_FILE_ERROR;
+            break;
+        default:
+            prError = map_default_error(err);
+    }
+    PR_SetError(prError, err);
+}
+
+
+inline void
+set_close_error(int err)
+{
+    PR_SetError( err == ETIMEDOUT ? PR_REMOTE_FILE_ERROR : map_default_error(err), err);
+}
+
+
+inline void
+set_read_error(int err)
+{
+    PRErrorCode prError;
+    switch (err) {
+        case EINVAL:
+            prError = PR_INVALID_METHOD_ERROR;
+            break;
+        case ENXIO:
+            prError = PR_INVALID_ARGUMENT_ERROR;
+            break;
+        default:
+            prError = map_default_error(err);
+    }
+    PR_SetError(prError, err);
+}
+
+
+inline void
+set_write_error(int err)
+{
+    PRErrorCode prError;
+    switch (err) {
+        case EINVAL:
+            prError = PR_INVALID_METHOD_ERROR;
+            break;
+        case ENXIO:
+            prError = PR_INVALID_ARGUMENT_ERROR;
+            break;
+        case ETIMEDOUT:
+            prError = PR_REMOTE_FILE_ERROR;
+            break;
+        default:
+            prError = map_default_error(err);
+    }
+    PR_SetError(prError, err);
+}
+
+
+inline void 
+set_lseek_error(int err)
+{
+    PR_SetError(map_default_error(err), err);
+}
+
+
+inline void
+set_fsync_error(int err)
+{
+    PRErrorCode prError;
+    switch (err) {
+        case EINVAL:
+            prError = PR_INVALID_METHOD_ERROR;
+            break;
+        case ETIMEDOUT:
+            prError = PR_REMOTE_FILE_ERROR;
+            break;
+        default:
+            prError = map_default_error(err);
+    }
+    PR_SetError(prError, err);
+}
+
+
+inline void
+set_fstat_error(int err)
+{
+    PR_SetError(err == ETIMEDOUT ? PR_REMOTE_FILE_ERROR : map_default_error(err), err);
+}
+
+/* TODO: using uint8 instead of bool due to code that uses bool as var name in hard to change places
+   therefore we had to undef it. Or we need to change Haiku's headers around so we can include
+   everything we need except the bool decl. */
+PRFileDesc * bt_CreateFileDesc(PRIntn osfd, const PRIOMethods * methods, _PRTriStateBool inheritable, uint8 nonblocking) {
+    const int blocking = 1;
+    PRFileDesc *fd = _PR_Getfd();
+    if (fd == NULL)
+    {
+        PR_SetError(PR_OUT_OF_MEMORY_ERROR, 0);
+        return NULL;
+    }
+    fd->secret->md.osfd = osfd;
+    fd->secret->state = _PR_FILEDESC_OPEN;
+    fd->secret->inheritable = inheritable;
+    fd->methods = methods;
+    if (nonblocking)
+        setsockopt(osfd, SOL_SOCKET, SO_NONBLOCK, &blocking, sizeof(blocking));
+    return fd;
+}
+
+
+PR_IMPLEMENT(PRFileDesc*) PR_GetSpecialFD(PRSpecialFD osfd)
+{
+    PR_ASSERT(osfd >= PR_StandardInput && osfd <= PR_StandardError);
+
+    if (!_pr_initialized) _PR_ImplicitInitialization();
+
+    switch (osfd)
+    {
+        case PR_StandardInput: return _pr_stdin;
+        case PR_StandardOutput: return _pr_stdout;
+        case PR_StandardError: return _pr_stderr;
+        default:
+            PR_SetError(PR_INVALID_ARGUMENT_ERROR, 0);
+    }
+    return NULL;
+}  /* PR_GetSpecialFD */
+
+
+PR_IMPLEMENT(PRFileDesc*) PR_Open(const char *name, PRIntn flags, PRIntn mode)
+{
+    return PR_OpenFile(name, flags, mode);
+}  /* PR_Open */
+
+PR_IMPLEMENT(PRFileDesc*) PR_OpenFile(const char *name, PRIntn flags, PRIntn mode)
+{
+    PRFileDesc *fd = NULL;
+    PRInt32 osflags;
+    PRInt32 osfd, err;
+
+    if (flags & PR_RDWR) {
+        osflags = O_RDWR;
+    } else if (flags & PR_WRONLY) {
+        osflags = O_WRONLY;
+    } else {
+        osflags = O_RDONLY;
+    }
+
+    if (flags & PR_EXCL)
+        osflags |= O_EXCL;
+    if (flags & PR_APPEND)
+        osflags |= O_APPEND;
+    if (flags & PR_TRUNCATE)
+        osflags |= O_TRUNC;
+    if (flags & PR_SYNC) {
+/* Ummmm.  BeOS doesn't appear to
+   support sync in any way shape or
+   form. */
+        return PR_NOT_IMPLEMENTED_ERROR;
+    }
+
+    if (flags & PR_CREATE_FILE)
+    {
+        osflags |= O_CREAT;
+    }
+    
+    osfd = open(name, osflags, mode);
+    if (osfd < 0) {
+        err = _MD_ERRNO();
+        set_open_error(err);
+    }
+
+    if(osfd>=0) {
+        fd = bt_CreateFileDesc(osfd, PR_GetFileMethods(), _PR_TRI_TRUE, false);
+        if (fd == NULL) close(osfd);  /* $$$ whoops! this is bad $$$ */
+    }
+    return fd;
+} /* PR_OpenFile */
+
+/*
+** Import an existing OS file to NSPR
+*/
+PR_IMPLEMENT(PRFileDesc*) PR_ImportFile(PRInt32 osfd)
+{
+    PRFileDesc *fd = NULL;
+
+    if (!_pr_initialized) _PR_ImplicitInitialization();
+
+    fd = bt_CreateFileDesc(osfd, PR_GetFileMethods(), _PR_TRI_UNKNOWN, false);
+    if (NULL == fd) close(osfd);
+    return fd;
+}
+
+/*
+** Import an existing OS pipe to NSPR 
+*/
+PR_IMPLEMENT(PRFileDesc*) PR_ImportPipe(PRInt32 osfd)
+{
+    PRFileDesc *fd = NULL;
+
+    if (!_pr_initialized) _PR_ImplicitInitialization();
+    fd = bt_CreateFileDesc(osfd, PR_GetPipeMethods(), _PR_TRI_UNKNOWN, true);
+
+    if (NULL == fd) close(osfd);
+    return fd;
+}
+
+
+PR_IMPLEMENT(PRStatus) PR_Rename(const char *from, const char *to)
+{
+    PRInt32 rv = -1, err;
+
+    if (0 == access(to, F_OK))
+        PR_SetError(PR_FILE_EXISTS_ERROR, 0);
+    else
+    {
+        rv = rename(from, to);
+        if (rv < 0) {
+            err = _MD_ERRNO();
+            set_rename_error(err);
+        }
+    }
+    if (rv < 0) {
+        return PR_FAILURE;
+    } else {
+        return PR_SUCCESS;
+    }
+}
+
+PR_IMPLEMENT(PRStatus) PR_Delete(const char *name)
+{
+    PRInt32 rv, err;
+
+    rv = unlink(name);
+    if (rv < 0) {
+        err = _MD_ERRNO();
+        set_unlink_error(err);
+        return PR_FAILURE;
+    } else
+        return PR_SUCCESS;
+}
+
+
+PR_IMPLEMENT(PRDir*) PR_OpenDir(const char *name)
+{
+    PRDir *dir;
+    PRInt32 err;
+
+    dir = PR_NEW(PRDir);
+    if (dir) {
+        dir->md.d = opendir(name);
+        if (NULL == dir->md.d) {
+            err = _MD_ERRNO();
+            set_opendir_error(err);
+            PR_DELETE(dir);
+            return NULL;
+        }
+    } else {
+        PR_SetError(PR_OUT_OF_MEMORY_ERROR, 0);
+    }
+    return dir;
+}
+
+PR_IMPLEMENT(PRDirEntry*) PR_ReadDir(PRDir *dir, PRDirFlags flags)
+{
+    PRInt32 err;
+    struct dirent *de;
+    for (;;) {
+        /*
+         * XXX: readdir() is not MT-safe
+         */
+        _MD_ERRNO() = 0;
+        de = readdir(dir->md.d);
+
+        if (!de) {
+            err = _MD_ERRNO();
+            set_readdir_error(err);
+            return 0;
+        }
+
+        if ((flags & PR_SKIP_DOT) &&
+            (de->d_name[0] == '.') && (de->d_name[1] == 0))
+            continue;
+
+        if ((flags & PR_SKIP_DOT_DOT) &&
+            (de->d_name[0] == '.') && (de->d_name[1] == '.') &&
+            (de->d_name[2] == 0))
+            continue;
+
+        if ((flags & PR_SKIP_HIDDEN) && (de->d_name[1] == '.'))
+            continue;
+
+        break;
+    }
+
+    dir->d.name = de->d_name;
+    return de->d_name ? &dir->d : NULL;
+}
+
+PR_IMPLEMENT(PRStatus) PR_CloseDir(PRDir *dir)
+{
+    PRInt32 rv, err;
+
+    if (dir && dir->md.d) {
+        rv = closedir(dir->md.d);
+        PR_DELETE(dir);
+        if (rv < 0) {
+            err = _MD_ERRNO();
+            set_closedir_error(err);
+            return PR_FAILURE;
+        } 
+    }
+    return PR_SUCCESS;
+}
+
+PR_IMPLEMENT(PRStatus) PR_MkDir(const char *name, PRIntn mode)
+{
+    status_t rv;
+    int err;
+
+    rv = mkdir(name, mode);
+
+    if (rv < 0) {
+        err = _MD_ERRNO();
+        set_mkdir_error(err);
+        return PR_FAILURE;
+    }
+    return PR_SUCCESS; 
+}
+
+PR_IMPLEMENT(PRStatus) PR_MakeDir(const char *name, PRIntn mode)
+{
+    if (!_pr_initialized) _PR_ImplicitInitialization();
+    return PR_MkDir(name, mode);
+}
+
+PR_IMPLEMENT(PRStatus) PR_RmDir(const char *name)
+{
+    PRInt32 rv, err;
+
+    rv = rmdir(name);
+    if (rv < 0) {
+        err = _MD_ERRNO();
+        set_rmdir_error(err);
+        return PR_FAILURE;
+    } else
+        return PR_SUCCESS;
+}
+
+PR_IMPLEMENT(PRInt32)
+PR_FileDesc2NativeHandle(PRFileDesc *fd)
+{
+    if (fd) {
+        fd = PR_GetIdentitiesLayer(fd, PR_NSPR_IO_LAYER);
+    }
+    if (!fd) {
+        PR_SetError(PR_INVALID_ARGUMENT_ERROR, 0);
+        return -1;
+    }
+
+    return fd->secret->md.osfd;
+}
+
+#ifdef MOZ_UNICODE
+/*
+ *  UTF16 Interface
+ */
+PR_IMPLEMENT(PRDirUTF16*) PR_OpenDirUTF16(const PRUnichar *name)
+{
+    PRDirUTF16 *dir;
+    PRStatus sts;
+
+    dir = PR_NEW(PRDirUTF16);
+    if (dir) {
+        sts = _PR_MD_OPEN_DIR_UTF16(&dir->md,name);
+        if (sts != PR_SUCCESS) {
+            PR_DELETE(dir);
+            return NULL;
+        }
+    } else {
+        PR_SetError(PR_OUT_OF_MEMORY_ERROR, 0);
+    }
+    return dir;
+}
+
+PR_IMPLEMENT(PRDirEntryUTF16*) PR_ReadDirUTF16(PRDirUTF16 *dir, PRDirFlags flags)
+{
+    /*
+     * _MD_READ_DIR_UTF16 return a PRUnichar* to the name; allocation in
+     * machine-dependent code
+     */
+    PRUnichar* name = _PR_MD_READ_DIR_UTF16(&dir->md, flags);
+    dir->d.name = name;
+    return name ? &dir->d : NULL;
+}
+ 
+PR_IMPLEMENT(PRStatus) PR_CloseDirUTF16(PRDirUTF16 *dir)
+{
+    PRInt32 rv;
+
+    if (dir) {
+        rv = _PR_MD_CLOSE_DIR_UTF16(&dir->md);
+        PR_DELETE(dir);
+        if (rv < 0)
+            return PR_FAILURE;
+        else
+            return PR_SUCCESS;
+    } 
+    return PR_SUCCESS;
+}
+
+#endif /* MOZ_UNICODE */
+
+
+static PRStatus PR_CALLBACK FileClose(PRFileDesc *fd)
+{
+    PRInt32 err;
+    if (!fd || !fd->secret
+            || (fd->secret->state != _PR_FILEDESC_OPEN
+            && fd->secret->state != _PR_FILEDESC_CLOSED)) {
+        PR_SetError(PR_BAD_DESCRIPTOR_ERROR, 0);
+        return PR_FAILURE;
+    }
+
+    if (fd->secret->state == _PR_FILEDESC_OPEN) {
+        if (close(fd->secret->md.osfd) < 0) {
+            err = _MD_ERRNO();
+            set_close_error(err);
+            return PR_FAILURE;
+        }
+        fd->secret->state = _PR_FILEDESC_CLOSED;
+    }
+    PR_ASSERT(fd);
+    _PR_Putfd(fd);
+    return PR_SUCCESS;
+}
+
+static PRInt32 PR_CALLBACK FileRead(PRFileDesc *fd, void *buf, PRInt32 amount)
+{
+    PRInt32 rv,err = 0;
+
+    rv = read(fd->secret->md.osfd, buf, amount);
+    if (rv < 0) {
+        err = _MD_ERRNO();
+        set_read_error(err);
+        PR_ASSERT(rv == -1);
+    }
+    PR_LOG(_pr_io_lm, PR_LOG_MAX, ("read -> %d", rv));
+    return rv;
+}
+
+static PRInt32 PR_CALLBACK FileWrite(PRFileDesc *fd, const void *buf, PRInt32 amount)
+{
+    PRInt32 rv,err = 0;
+    PRInt32 temp, count;
+
+    count = 0;
+    while (amount > 0) {
+        temp = write(fd->secret->md.osfd, buf, amount);
+        if (temp < 0) {
+            err = _MD_ERRNO();
+            set_write_error(err);
+            count = -1;
+            break;
+        }
+        count += temp;
+        if (fd->secret->nonblocking) {
+            break;
+        }
+        buf = (const void*) ((const char*)buf + temp);
+        amount -= temp;
+    }
+    PR_LOG(_pr_io_lm, PR_LOG_MAX, ("write -> %d", count));
+    return count;
+}
+
+static PRInt32 PR_CALLBACK FileAvailable(PRFileDesc *fd)
+{
+    PRInt32 result, cur, end, err;
+
+    cur = lseek(fd->secret->md.osfd, 0, PR_SEEK_CUR);
+
+    if (cur >= 0)
+        end = lseek(fd->secret->md.osfd, 0, PR_SEEK_END);
+
+    if ((cur < 0) || (end < 0)) {
+        err = _MD_ERRNO();
+        set_lseek_error(err);
+        return -1;
+    }
+
+    result = end - cur;
+    lseek(fd->secret->md.osfd, cur, PR_SEEK_SET);
+    
+    return result;
+}
+
+static PRInt64 PR_CALLBACK FileAvailable64(PRFileDesc *fd)
+{
+    PRInt64 result, cur, end;
+    PRInt64 minus_one;
+    PRInt32 err;
+
+    cur = lseek(fd->secret->md.osfd, LL_ZERO, PR_SEEK_CUR);
+
+    if (LL_GE_ZERO(cur))
+        end = lseek(fd->secret->md.osfd, LL_ZERO, PR_SEEK_END);
+
+    if (!LL_GE_ZERO(cur) || !LL_GE_ZERO(end)) {
+        LL_I2L(minus_one, -1);
+        err = _MD_ERRNO();
+        set_lseek_error(err);
+        return minus_one;
+    }
+    LL_SUB(result, end, cur);
+    lseek(fd->secret->md.osfd, cur, PR_SEEK_SET);
+    return result;
+}
+
+static PRStatus PR_CALLBACK FileSync(PRFileDesc *fd)
+{
+    PRInt32 result, err;
+    result = fsync(fd->secret->md.osfd);
+    if (result < 0) {
+        err = _MD_ERRNO();
+        set_fsync_error(err);
+        return PR_FAILURE;
+    }
+    return PR_SUCCESS;
+}
+
+static PROffset32 PR_CALLBACK FileSeek(PRFileDesc *fd, PROffset32 offset, PRSeekWhence whence)
+{
+    PROffset32 result;
+    PRInt32 err;
+    result = lseek(fd->secret->md.osfd, offset, whence);
+    if(result<0) {
+        err = _MD_ERRNO();
+        set_lseek_error(err);
+    }
+    return result;
+}
+
+static PROffset64 PR_CALLBACK FileSeek64(PRFileDesc *fd, PROffset64 offset, PRSeekWhence whence)
+{
+    PROffset64 result;
+    PRInt32 err;
+    
+    result = lseek(fd->secret->md.osfd, offset, whence);
+    if(!LL_GE_ZERO(result)) {
+        err = _MD_ERRNO();
+        set_lseek_error(err);
+    }    
+    return result;
+}
+
+static PRStatus PR_CALLBACK FileGetInfo(PRFileDesc *fd, PRFileInfo *info)
+{
+    struct stat sb;
+    PRInt64 s, s2us;
+    PRInt32 rv, err;
+        
+    rv = fstat(fd->secret->md.osfd, &sb);
+    if (rv < 0) {
+        err = _MD_ERRNO();
+        set_fstat_error(err);
+        return PR_FAILURE;
+    }
+    if(info) {
+        if (S_IFREG & sb.st_mode)
+            info->type = PR_FILE_FILE ;
+        else if (S_IFDIR & sb.st_mode)
+            info->type = PR_FILE_DIRECTORY;
+        else
+            info->type = PR_FILE_OTHER;
+        /* Use lower 32 bits of file size */
+        info->size = ( sb.st_size & 0xffffffff);
+        LL_I2L(s, sb.st_mtime);
+        LL_I2L(s2us, PR_USEC_PER_SEC);
+        LL_MUL(s, s, s2us);
+        info->modifyTime = s;
+        LL_I2L(s, sb.st_ctime);
+        LL_MUL(s, s, s2us);
+        info->creationTime = s;
+    }
+    return PR_SUCCESS;
+}
+
+static PRStatus PR_CALLBACK FileGetInfo64(PRFileDesc *fd, PRFileInfo64 *info)
+{
+    struct stat sb;
+    PRInt64 s, s2us;
+    PRInt32 rv, err;
+
+    rv = fstat(fd->secret->md.osfd, &sb);
+    if (rv < 0) {
+        err = _MD_ERRNO();
+        set_fstat_error(err);
+        return PR_FAILURE;
+    }
+    if(info) {
+        if (S_IFREG & sb.st_mode)
+            info->type = PR_FILE_FILE ;
+        else if (S_IFDIR & sb.st_mode)
+            info->type = PR_FILE_DIRECTORY;
+        else
+            info->type = PR_FILE_OTHER;
+        info->size = sb.st_size;
+        LL_I2L(s, sb.st_mtime);
+        LL_I2L(s2us, PR_USEC_PER_SEC);
+        LL_MUL(s, s, s2us);
+        info->modifyTime = s;
+        LL_I2L(s, sb.st_ctime);
+        LL_MUL(s, s, s2us);
+        info->creationTime = s;
+    }
+    return PR_SUCCESS;
+}
+
+static PRInt16 PR_CALLBACK FilePoll(
+    PRFileDesc *fd, PRInt16 in_flags, PRInt16 *out_flags)
+{
+    *out_flags = 0;
+    return in_flags;
+}  /* FilePoll */
+
+
+static PRIOMethods _pr_fileMethods = {
+    PR_DESC_FILE,
+    FileClose,
+    FileRead,
+    FileWrite,
+    FileAvailable,
+    FileAvailable64,
+    FileSync,
+    FileSeek,
+    FileSeek64,
+    FileGetInfo,
+    FileGetInfo64,
+    (PRWritevFN)_PR_InvalidInt,
+    (PRConnectFN)_PR_InvalidStatus,
+    (PRAcceptFN)_PR_InvalidDesc,
+    (PRBindFN)_PR_InvalidStatus,
+    (PRListenFN)_PR_InvalidStatus,
+    (PRShutdownFN)_PR_InvalidStatus,
+    (PRRecvFN)_PR_InvalidInt,
+    (PRSendFN)_PR_InvalidInt,
+    (PRRecvfromFN)_PR_InvalidInt,
+    (PRSendtoFN)_PR_InvalidInt,
+    FilePoll,
+    (PRAcceptreadFN)_PR_InvalidInt,
+    (PRTransmitfileFN)_PR_InvalidInt,
+    (PRGetsocknameFN)_PR_InvalidStatus,
+    (PRGetpeernameFN)_PR_InvalidStatus,
+    (PRReservedFN)_PR_InvalidInt,
+    (PRReservedFN)_PR_InvalidInt,
+    (PRGetsocketoptionFN)_PR_InvalidStatus,
+    (PRSetsocketoptionFN)_PR_InvalidStatus,
+    (PRSendfileFN)_PR_InvalidInt,
+    (PRConnectcontinueFN)_PR_InvalidStatus,
+    (PRReservedFN)_PR_InvalidInt,
+    (PRReservedFN)_PR_InvalidInt,
+    (PRReservedFN)_PR_InvalidInt,
+    (PRReservedFN)_PR_InvalidInt
+};
+
+PR_IMPLEMENT(const PRIOMethods*) PR_GetFileMethods(void)
+{
+    return &_pr_fileMethods;
+}
+
+
+static PRInt32 PR_CALLBACK PipeAvailable(PRFileDesc *fd)
+{
+    PRInt32 rv;
+    rv =  _bt_socketavailable(fd);
+    return rv;
+}
+
+static PRInt64 PR_CALLBACK PipeAvailable64(PRFileDesc *fd)
+{
+    PRInt64 rv;
+    LL_I2L(rv, _bt_socketavailable(fd));
+    return rv;
+}
+
+static PRStatus PR_CALLBACK PipeSync(PRFileDesc *fd)
+{
+    return PR_SUCCESS;
+}
+
+
+static PRIOMethods _pr_pipeMethods = {
+    PR_DESC_PIPE,
+    FileClose,
+    FileRead,
+    FileWrite,
+    PipeAvailable,
+    PipeAvailable64,
+    PipeSync,
+    (PRSeekFN)_PR_InvalidInt,
+    (PRSeek64FN)_PR_InvalidInt64,
+    (PRFileInfoFN)_PR_InvalidStatus,
+    (PRFileInfo64FN)_PR_InvalidStatus,
+    (PRWritevFN)_PR_InvalidInt,
+    (PRConnectFN)_PR_InvalidStatus,
+    (PRAcceptFN)_PR_InvalidDesc,
+    (PRBindFN)_PR_InvalidStatus,
+    (PRListenFN)_PR_InvalidStatus,
+    (PRShutdownFN)_PR_InvalidStatus,
+    (PRRecvFN)_PR_InvalidInt,
+    (PRSendFN)_PR_InvalidInt,
+    (PRRecvfromFN)_PR_InvalidInt,
+    (PRSendtoFN)_PR_InvalidInt,
+    FilePoll,
+    (PRAcceptreadFN)_PR_InvalidInt,
+    (PRTransmitfileFN)_PR_InvalidInt,
+    (PRGetsocknameFN)_PR_InvalidStatus,
+    (PRGetpeernameFN)_PR_InvalidStatus,
+    (PRReservedFN)_PR_InvalidInt,
+    (PRReservedFN)_PR_InvalidInt,
+    (PRGetsocketoptionFN)_PR_InvalidStatus,
+    (PRSetsocketoptionFN)_PR_InvalidStatus,
+    (PRSendfileFN)_PR_InvalidInt,
+    (PRConnectcontinueFN)_PR_InvalidStatus,
+    (PRReservedFN)_PR_InvalidInt,
+    (PRReservedFN)_PR_InvalidInt,
+    (PRReservedFN)_PR_InvalidInt,
+    (PRReservedFN)_PR_InvalidInt
+};
+
+PR_IMPLEMENT(const PRIOMethods*) PR_GetPipeMethods(void)
+{
+    return &_pr_pipeMethods;
+}
+
+void _PR_InitIO(void) {
+    const PRIOMethods *methods = PR_GetFileMethods();
+    _PR_InitFdCache();
+    _pr_flock_lock = PR_NewLock();
+    _pr_flock_cv = PR_NewCondVar(_pr_flock_lock);
+    _pr_stdin = bt_CreateFileDesc(0, PR_GetFileMethods(), _PR_TRI_UNKNOWN, false);
+    _pr_stdout = bt_CreateFileDesc(1, PR_GetFileMethods(), _PR_TRI_UNKNOWN, false);
+    _pr_stderr = bt_CreateFileDesc(2, PR_GetFileMethods(), _PR_TRI_UNKNOWN, false);
+}
+
Index: mozilla/nsprpub/pr/src/bthreads/btio.c
===================================================================
RCS file: mozilla/nsprpub/pr/src/bthreads/btio.c
diff -N mozilla/nsprpub/pr/src/bthreads/btio.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ mozilla/nsprpub/pr/src/bthreads/btio.c	5 Nov 2008 20:51:44 -0000
@@ -0,0 +1,2424 @@
+/* -*- Mode: C++; c-basic-offset: 4 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Netscape Portable Runtime (NSPR).
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1998-2000
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "primpl.h"
+#include <stdio.h>
+#include <sys/ioctl.h>
+#include <sys/time.h>
+
+#define READ_FD     1
+#define WRITE_FD    2
+
+#ifdef BONE_VERSION
+inline int closesocket(int socket) {
+    return close(socket);
+}
+#endif
+
+
+inline void 
+set_stat_error(int err)
+{
+    PR_SetError(err == ETIMEDOUT ? PR_REMOTE_FILE_ERROR : map_default_error(err), err);
+}
+
+inline void 
+set_access_error(int err)
+{
+    PR_SetError(err == ETIMEDOUT ? PR_REMOTE_FILE_ERROR : map_default_error(err), err);
+}
+
+inline void 
+set_select_error(int err)
+{
+    PR_SetError(map_default_error(err), err);
+}
+
+inline void
+set_writev_error(int err)
+{
+    PR_SetError(map_default_error(err), err);
+}
+
+inline void
+set_connect_error(int err)
+{
+    PRErrorCode prError;
+    switch (err) {
+        case EACCES:
+        case ELOOP:
+        case ENOENT:
+            prError = PR_ADDRESS_NOT_SUPPORTED_ERROR;        
+            break;
+        case ENXIO:
+            prError = PR_IO_ERROR;
+            break;
+        default:
+            prError = map_default_error(err);
+    }
+    PR_SetError(prError, err);
+
+}
+
+inline void 
+set_accept_error(int err)
+{
+    PR_SetError(err == ENODEV ? PR_NOT_TCP_SOCKET_ERROR : map_default_error(err), err);
+}
+
+
+inline void 
+set_bind_error(int err)
+{
+    PRErrorCode prError;
+    switch (err) {
+        case EINVAL:
+            prError = PR_SOCKET_ADDRESS_IS_BOUND_ERROR;
+            break;
+        case EIO:
+        case EISDIR:
+        case ELOOP:
+        case ENOENT:
+        case ENOTDIR:
+        case EROFS:
+            prError = PR_ADDRESS_NOT_SUPPORTED_ERROR;
+            break;
+        case ENXIO:
+            prError = PR_IO_ERROR;
+            break;
+        default:
+            prError = map_default_error(err);
+    }
+    PR_SetError(prError, err);
+}
+
+inline void
+set_listen_error(int err)
+{
+    PR_SetError(map_default_error(err), err);
+}
+
+inline void 
+set_shutdown_error(int err)
+{
+    PR_SetError(map_default_error(err), err);
+}
+
+inline void 
+set_socketpair_error(int err)
+{
+    PR_SetError(err == ENOMEM ? PR_INSUFFICIENT_RESOURCES_ERROR : map_default_error(err), err);
+}
+
+inline void
+set_recv_error(int err)
+{
+    PR_SetError(map_default_error(err), err);
+}
+
+inline void
+set_recvfrom_error(int err)
+{
+    PR_SetError(map_default_error(err), err);
+}
+
+
+inline void 
+set_send_error(int err)
+{
+    PR_SetError(map_default_error(err), err);
+}
+
+inline void 
+set_sendto_error(int err)
+{
+    PR_SetError(map_default_error(err), err);
+}
+
+inline void
+set_getsockname_error(int err)
+{
+    PR_SetError(err == ENOMEM ? PR_INSUFFICIENT_RESOURCES_ERROR : map_default_error(err), err);
+}
+
+
+inline void
+set_getpeername_error(int err)
+{
+    PR_SetError(err == ENOMEM ? PR_INSUFFICIENT_RESOURCES_ERROR : map_default_error(err), err);
+}
+
+
+inline void 
+set_getsockopt_error(int err)
+{
+    PRErrorCode prError;
+    switch (err) {
+        case EINVAL:
+            prError = PR_BUFFER_OVERFLOW_ERROR;
+            break;
+        case ENOMEM:
+            prError = PR_INSUFFICIENT_RESOURCES_ERROR;
+            break;
+        default:
+            prError = map_default_error(err);
+    }
+    PR_SetError(prError, err);
+}
+
+inline void 
+set_setsockopt_error(int err)
+{
+    PRErrorCode prError;
+    switch (err) {
+        case EINVAL:
+            prError = PR_BUFFER_OVERFLOW_ERROR;
+            break;
+        case ENOMEM:
+            prError = PR_INSUFFICIENT_RESOURCES_ERROR;
+            break;
+        default:
+            prError = map_default_error(err);
+    }
+    PR_SetError(prError, err);
+}
+
+
+inline void 
+set_socket_error(int err)
+{
+    PR_SetError( err == ENOMEM ? PR_INSUFFICIENT_RESOURCES_ERROR : map_default_error(err), err);
+}
+
+
+PR_IMPLEMENT(PRStatus) PR_GetFileInfo(const char *fn, PRFileInfo *info)
+{
+    struct stat sb;
+    PRInt32 rv, err;
+    PRInt64 s, s2us;
+
+    if (!_pr_initialized) _PR_ImplicitInitialization();
+    rv = stat(fn, &sb);
+    if (rv < 0) {
+        err = _MD_ERRNO();
+        set_stat_error(err);
+        return PR_FAILURE;
+    }
+    if (info) {
+        if (S_IFREG & sb.st_mode)
+            info->type = PR_FILE_FILE;
+        else if (S_IFDIR & sb.st_mode)
+            info->type = PR_FILE_DIRECTORY;
+        else
+            info->type = PR_FILE_OTHER;
+
+        /* Use lower 32 bits of file size */
+        info->size = sb.st_size  & 0xffffffff;
+        LL_I2L(s, sb.st_mtime);
+        LL_I2L(s2us, PR_USEC_PER_SEC);
+        LL_MUL(s, s, s2us);
+        info->modifyTime = s;
+        LL_I2L(s, sb.st_ctime);
+        LL_MUL(s, s, s2us);
+        info->creationTime = s;
+    }
+
+    return PR_SUCCESS;
+}
+
+
+PR_IMPLEMENT(PRStatus) PR_GetFileInfo64(const char *fn, PRFileInfo64 *info)
+{
+    struct stat sb;
+    PRInt32 rv, err;
+    PRInt64 s, s2us;
+
+    if (!_pr_initialized) _PR_ImplicitInitialization();
+    rv = stat(fn, &sb);
+    if (rv < 0) {
+        err = _MD_ERRNO();
+        set_stat_error(err);
+        return PR_FAILURE;
+    }
+    if (info) {
+        if (S_IFREG & sb.st_mode)
+            info->type = PR_FILE_FILE;
+        else if (S_IFDIR & sb.st_mode)
+            info->type = PR_FILE_DIRECTORY;
+        else
+            info->type = PR_FILE_OTHER;
+
+        /* For the 64 bit version we can use
+         * the native st_size without modification
+         */
+        info->size = sb.st_size;
+        LL_I2L(s, sb.st_mtime);
+        LL_I2L(s2us, PR_USEC_PER_SEC);
+        LL_MUL(s, s, s2us);
+        info->modifyTime = s;
+        LL_I2L(s, sb.st_ctime);
+        LL_MUL(s, s, s2us);
+        info->creationTime = s;
+    }
+
+    return PR_SUCCESS;
+}
+
+PR_IMPLEMENT(PRStatus) PR_Access(const char *name, PRAccessHow how)
+{
+    PRInt32 rv, err;
+    int checkFlags;
+    struct stat buf;
+
+    switch (how) {
+        case PR_ACCESS_WRITE_OK:
+            checkFlags = S_IWUSR | S_IWGRP | S_IWOTH;
+            break;
+        
+        case PR_ACCESS_READ_OK:
+            checkFlags = S_IRUSR | S_IRGRP | S_IROTH;
+            break;
+        
+        case PR_ACCESS_EXISTS:
+            /* we don't need to examine st_mode. */
+            break;
+        
+        default: {
+            PR_SetError(PR_INVALID_ARGUMENT_ERROR, 0);
+            return PR_FAILURE;
+        }
+    }
+
+    rv = stat(name, &buf);
+    if (rv == 0 && how != PR_ACCESS_EXISTS && (!(buf.st_mode & checkFlags))) {
+        PR_SetError(PR_NO_ACCESS_RIGHTS_ERROR, 0);
+        return PR_FAILURE;
+    }
+
+    if (rv < 0) {
+        err = _MD_ERRNO();
+        set_access_error(err);
+        return PR_FAILURE;
+    } else
+        return PR_SUCCESS;
+}
+
+
+PRInt32
+_bt_socketavailable (PRFileDesc *fd)
+{
+#ifdef BONE_VERSION
+    PRInt32 result;
+
+    if (ioctl(fd->secret->md.osfd, FIONREAD, &result) < 0) {
+        PR_SetError(PR_BAD_DESCRIPTOR_ERROR, _MD_ERRNO());
+        return -1;
+    }
+    return result;
+#else
+    return PR_NOT_IMPLEMENTED_ERROR;
+#endif
+}
+
+
+#if defined(DEBUG)
+
+PRBool IsValidNetAddr(const PRNetAddr *addr)
+{
+    if ((addr != NULL)
+        && (addr->raw.family != PR_AF_INET6)
+        && (addr->raw.family != PR_AF_INET)) {
+        return PR_FALSE;
+    }
+    return PR_TRUE;
+}
+
+static PRBool IsValidNetAddrLen(const PRNetAddr *addr, PRInt32 addr_len)
+{
+    /*
+     * The definition of the length of a Unix domain socket address
+     * is not uniform, so we don't check it.
+     */
+    if ((addr != NULL)
+            && (PR_NETADDR_SIZE(addr) != addr_len)) {
+         return PR_FALSE;
+    }
+    return PR_TRUE;
+}
+
+#endif /* DEBUG */
+
+static PRInt32 socket_io_wait(PRInt32 osfd, PRInt32 fd_type,
+                              PRIntervalTime timeout)
+{
+    PRInt32 rv = -1;
+    struct timeval tv;
+    PRIntervalTime epoch, now, elapsed, remaining;
+    PRBool wait_for_remaining;
+    PRInt32 syserror;
+    fd_set rd_wr;
+
+    switch (timeout) {
+    case PR_INTERVAL_NO_WAIT:
+        PR_SetError(PR_IO_TIMEOUT_ERROR, 0);
+        break;
+    case PR_INTERVAL_NO_TIMEOUT:
+        /*
+         * This is a special case of the 'default' case below.
+         * Please see the comments there.
+         */
+        tv.tv_sec = _PR_INTERRUPT_CHECK_INTERVAL_SECS;
+        tv.tv_usec = 0;
+        FD_ZERO(&rd_wr);
+        do {
+            FD_SET(osfd, &rd_wr);
+            if (fd_type == READ_FD)
+                rv = select(osfd + 1, &rd_wr, NULL, NULL, &tv);
+            else
+                rv = select(osfd + 1, NULL, &rd_wr, NULL, &tv);
+            if (rv == -1 && (syserror = _MD_ERRNO()) != EINTR) {
+#ifdef BONE_VERSION
+                set_select_error(syserror);
+#else
+                if (syserror == EBADF) {
+                    PR_SetError(PR_BAD_DESCRIPTOR_ERROR, EBADF);
+                } else {
+                    PR_SetError(PR_UNKNOWN_ERROR, syserror);
+                }
+#endif
+                break;
+            }
+        } while (rv == 0 || (rv == -1 && syserror == EINTR));
+        break;
+    default:
+        now = epoch = PR_IntervalNow();
+        remaining = timeout;
+        FD_ZERO(&rd_wr);
+        do {
+            /*
+             * We block in select for at most
+             * _PR_INTERRUPT_CHECK_INTERVAL_SECS seconds,
+             * so that there is an upper limit on the delay
+             * before the interrupt bit is checked.
+             */
+            wait_for_remaining = PR_TRUE;
+            tv.tv_sec = PR_IntervalToSeconds(remaining);
+            if (tv.tv_sec > _PR_INTERRUPT_CHECK_INTERVAL_SECS) {
+                wait_for_remaining = PR_FALSE;
+                tv.tv_sec = _PR_INTERRUPT_CHECK_INTERVAL_SECS;
+                tv.tv_usec = 0;
+            } else {
+                tv.tv_usec = PR_IntervalToMicroseconds(
+                                 remaining -
+                                 PR_SecondsToInterval(tv.tv_sec));
+            }
+            FD_SET(osfd, &rd_wr);
+            if (fd_type == READ_FD)
+                rv = select(osfd + 1, &rd_wr, NULL, NULL, &tv);
+            else
+                rv = select(osfd + 1, NULL, &rd_wr, NULL, &tv);
+            /*
+             * we don't consider EINTR a real error
+             */
+            if (rv == -1 && (syserror = _MD_ERRNO()) != EINTR) {
+#ifdef BONE_VERSION
+                set_select_error(syserror);
+#else
+                if (syserror == EBADF) {
+                    PR_SetError(PR_BAD_DESCRIPTOR_ERROR, EBADF);
+                } else {
+                    PR_SetError(PR_UNKNOWN_ERROR, syserror);
+                }
+#endif
+                break;
+            }
+            /*
+             * We loop again if select timed out or got interrupted
+             * by a signal, and the timeout deadline has not passed yet.
+             */
+            if (rv == 0 || (rv == -1 && syserror == EINTR)) {
+                /*
+                 * If select timed out, we know how much time
+                 * we spent in blocking, so we can avoid a
+                 * PR_IntervalNow() call.
+                 */
+                if (rv == 0) {
+                    if (wait_for_remaining) {
+                        now += remaining;
+                    } else {
+                        now += PR_SecondsToInterval(tv.tv_sec)
+                               + PR_MicrosecondsToInterval(tv.tv_usec);
+                    }
+                } else {
+                    now = PR_IntervalNow();
+                }
+                elapsed = (PRIntervalTime) (now - epoch);
+                if (elapsed >= timeout) {
+                    PR_SetError(PR_IO_TIMEOUT_ERROR, 0);
+                    rv = -1;
+                    break;
+                } else {
+                    remaining = timeout - elapsed;
+                }
+            }
+        } while (rv == 0 || (rv == -1 && syserror == EINTR));
+        break;
+    }
+    return(rv);
+}
+
+
+static PRInt32 PR_CALLBACK SocketWritev(PRFileDesc *fd, const PRIOVec *iov,
+PRInt32 iov_size, PRIntervalTime timeout)
+{
+#ifdef BONE_VERSION
+    int w, err = 0;
+    const PRIOVec *tmp_iov;
+#define LOCAL_MAXIOV    8
+    PRIOVec local_iov[LOCAL_MAXIOV];
+    PRIOVec *iov_copy = NULL;
+    int tmp_out;
+    int index, iov_cnt;
+    int count=0, sz = 0;    /* 'count' is the return value. */
+    int i, amount = 0;
+
+    /*
+     * Assume the first writev will succeed.  Copy iov's only on
+     * failure.
+     */
+    tmp_iov = iov;
+    for (index = 0; index < iov_size; index++)
+        sz += iov[index].iov_len;
+
+    iov_cnt = iov_size;
+
+    while (sz > 0) {
+/*
+    /*
+     * Calculate the total number of bytes to be sent; needed for
+     * optimization later.
+     * We could avoid this if this number was passed in; but it is
+     * probably not a big deal because iov_size is usually small (less than
+     * 3)
+     */
+    if (!fd->secret->nonblocking) {
+        for (i=0; i<iov_cnt; i++) {
+            amount += tmp_iov[i].iov_len;
+        }
+    }
+
+    while ((w = writev(fd->secret->md.osfd, (const struct iovec*)tmp_iov, iov_size)) == -1) {
+        err = _MD_ERRNO();
+        if ((err == EAGAIN) || (err == EWOULDBLOCK))    {
+            if (fd->secret->nonblocking) {
+                break;
+            }
+            if ((w = socket_io_wait(fd->secret->md.osfd, WRITE_FD, timeout))<0)
+                goto done;
+
+        } else if (err == EINTR) {
+            continue;
+        } else {
+            break;
+        }
+    }
+    /*
+     * optimization; if bytes sent is less than "amount" call
+     * select before returning. This is because it is likely that
+     * the next writev() call will return EWOULDBLOCK.
+     */
+    if ((!fd->secret->nonblocking) && (w > 0) && (w < amount)
+        && (timeout != PR_INTERVAL_NO_WAIT)) {
+        if (socket_io_wait(fd->secret->md.osfd, WRITE_FD, timeout) < 0) {
+            w = -1;
+            goto done;
+        }
+    }
+
+    if (w < 0) {
+        set_writev_error(err);
+    }
+done:
+
+
+        if (w < 0) {
+            count = -1;
+            break;
+        }
+        count += w;
+        if (fd->secret->nonblocking) {
+            break;
+        }
+        sz -= w;
+
+        if (sz > 0) {
+            /* find the next unwritten vector */
+            for ( index = 0, tmp_out = count;
+                tmp_out >= iov[index].iov_len;
+                tmp_out -= iov[index].iov_len, index++){;} /* nothing to execute */
+
+            if (tmp_iov == iov) {
+                /*
+                 * The first writev failed so we
+                 * must copy iov's around.
+                 * Avoid calloc/free if there
+                 * are few enough iov's.
+                 */
+                if (iov_size - index <= LOCAL_MAXIOV)
+                    iov_copy = local_iov;
+                else if ((iov_copy = (PRIOVec *) PR_CALLOC((iov_size - index) *
+                    sizeof *iov_copy)) == NULL) {
+                    PR_SetError(PR_OUT_OF_MEMORY_ERROR, 0);
+                    return -1;
+                }
+                tmp_iov = iov_copy;
+            }
+
+            PR_ASSERT(tmp_iov == iov_copy);
+
+            /* fill in the first partial read */
+            iov_copy[0].iov_base = &(((char *)iov[index].iov_base)[tmp_out]);
+            iov_copy[0].iov_len = iov[index].iov_len - tmp_out;
+            index++;
+
+            /* copy the remaining vectors */
+            for (iov_cnt=1; index<iov_size; iov_cnt++, index++) {
+                iov_copy[iov_cnt].iov_base = iov[index].iov_base;
+                iov_copy[iov_cnt].iov_len = iov[index].iov_len;
+            }
+        }
+    }
+
+    if (iov_copy != local_iov)
+        PR_DELETE(iov_copy);
+    return count;
+#else
+    return PR_NOT_IMPLEMENTED_ERROR;
+#endif    
+}
+
+PRInt32
+_bt_CONNECT (PRFileDesc *fd, const PRNetAddr *addr, PRUint32 addrlen,
+             PRIntervalTime timeout)
+{
+    PRInt32 rv, err;
+    PRInt32 osfd = fd->secret->md.osfd;
+
+#ifndef BONE_VERSION
+    fd->secret->md.connectValueValid = PR_FALSE;
+#endif
+#ifdef _PR_HAVE_SOCKADDR_LEN
+    PRNetAddr addrCopy;
+
+    addrCopy = *addr;
+    ((struct sockaddr *) &addrCopy)->sa_len = addrlen;
+    ((struct sockaddr *) &addrCopy)->sa_family = addr->raw.family;
+#endif
+
+    /* (Copied from unix.c)
+     * We initiate the connection setup by making a nonblocking connect()
+     * call.  If the connect() call fails, there are two cases we handle
+     * specially:
+     * 1. The connect() call was interrupted by a signal.  In this case
+     *    we simply retry connect().
+     * 2. The NSPR socket is nonblocking and connect() fails with
+     *    EINPROGRESS.  We first wait until the socket becomes writable.
+     *    Then we try to find out whether the connection setup succeeded
+     *    or failed.
+     */
+
+retry:
+#ifdef _PR_HAVE_SOCKADDR_LEN
+    if ((rv = connect(osfd, (struct sockaddr *)&addrCopy, addrlen)) == -1) {
+#else
+    if ((rv = connect(osfd, (struct sockaddr *)addr, addrlen)) == -1) {
+#endif
+        err = _MD_ERRNO();
+#ifndef BONE_VERSION
+        fd->secret->md.connectReturnValue = rv;
+        fd->secret->md.connectReturnError = err;
+        fd->secret->md.connectValueValid = PR_TRUE;
+#endif
+        if( err == EINTR ) {
+#ifndef BONE_VERSION
+            snooze( 100000L );
+#endif
+            goto retry;
+        }
+
+#ifndef BONE_VERSION
+        if(!fd->secret->nonblocking && ((err == EINPROGRESS) || (err==EAGAIN) || (err==EALREADY))) {
+
+            /*
+            ** There's no timeout on this connect, but that's not
+            ** a big deal, since the connect times out anyways
+            ** after 30 seconds.   Just sleep for 1/10th of a second
+            ** and retry until we go through or die.
+            */
+            goto retry;
+        }
+
+        if( fd->secret->nonblocking && ((err == EAGAIN) || (err == EINPROGRESS))) {
+            PR_Lock(_connectLock);
+            if (connectCount < sizeof(connectList)/sizeof(connectList[0])) {
+                connectList[connectCount].osfd = osfd;
+                memcpy(&connectList[connectCount].addr, addr, addrlen);
+                connectList[connectCount].addrlen = addrlen;
+                connectList[connectCount].timeout = timeout;
+                connectCount++;
+                PR_Unlock(_connectLock);
+                set_connect_error(err);
+            } else {
+                PR_Unlock(_connectLock);
+                PR_SetError(PR_INSUFFICIENT_RESOURCES_ERROR, 0);
+            }
+            return rv;
+        }
+#else /* BONE_VERSION */
+        if(!fd->secret->nonblocking && (err == EINTR)) {
+
+            rv = socket_io_wait(osfd, WRITE_FD, timeout);
+            if (rv == -1) {
+                return -1;
+            }
+
+            PR_ASSERT(rv == 1);
+/* _MD_beos_get_nonblocking_connect_error always return PR_NOT_IMPLEMENTED..
+            err = _MD_beos_get_nonblocking_connect_error(osfd);
+            if (err != 0) {
+                set_connect_error(err);
+                return -1;
+            }
+*/
+            return 0;
+        }
+#endif
+
+        set_connect_error(err);
+    }
+
+    return rv;
+}
+
+
+static PRStatus PR_CALLBACK SocketConnect(
+    PRFileDesc *fd, const PRNetAddr *addr, PRIntervalTime timeout)
+{
+    PRInt32 rv;    /* Return value of _PR_MD_CONNECT */
+    const PRNetAddr *addrp = addr;
+#if defined(_PR_INET6)
+    PRNetAddr addrCopy;
+    if (addr->raw.family == PR_AF_INET6) {
+        addrCopy = *addr;
+        addrCopy.raw.family = AF_INET6;
+        addrp = &addrCopy;
+    }
+#endif
+
+    rv = _bt_CONNECT(fd, addrp, PR_NETADDR_SIZE(addr), timeout);
+    PR_LOG(_pr_io_lm, PR_LOG_MAX, ("connect -> %d", rv));
+    if (rv == 0)
+        return PR_SUCCESS;
+    else
+        return PR_FAILURE;
+}
+
+static PRStatus PR_CALLBACK SocketConnectContinue(
+    PRFileDesc *fd, PRInt16 out_flags)
+{
+    PRInt32 osfd;
+    int err;
+    int rv;
+
+    if (out_flags & PR_POLL_NVAL) {
+        PR_SetError(PR_BAD_DESCRIPTOR_ERROR, 0);
+        return PR_FAILURE;
+    }
+    if ((out_flags & (PR_POLL_WRITE | PR_POLL_EXCEPT | PR_POLL_ERR)) == 0) {
+        PR_ASSERT(out_flags == 0);
+        PR_SetError(PR_IN_PROGRESS_ERROR, 0);
+        return PR_FAILURE;
+    }
+
+    osfd = fd->secret->md.osfd;
+
+
+#ifdef BONE_VERSION  /* bug 122364 */
+    /* temporary workaround until getsockopt(SO_ERROR) works in BONE */
+    if (out_flags & PR_POLL_EXCEPT) {
+        PR_SetError(PR_CONNECT_REFUSED_ERROR, 0);
+        return PR_FAILURE;
+    }
+    PR_ASSERT(out_flags & PR_POLL_WRITE);
+    return PR_SUCCESS;
+#else
+    rv = recv(fd->secret->md.osfd, NULL, 0, 0);
+    PR_ASSERT(-1 == rv || 0 == rv);
+
+    if (-1 == rv && 0 != errno && errno != EAGAIN && errno != EWOULDBLOCK ) {
+        set_connect_error(errno);
+        return PR_FAILURE;
+    }
+    else
+        return PR_SUCCESS;
+#endif
+}
+
+PRInt32
+_bt_accept (PRFileDesc *fd, PRNetAddr *addr, PRUint32 *addrlen,
+            PRIntervalTime timeout)
+{
+    PRInt32 osfd = fd->secret->md.osfd;
+    PRInt32 rv, err;
+
+    while ((rv = accept(osfd, (struct sockaddr *) addr,
+                        (int *)addrlen)) == -1) {
+        err = _MD_ERRNO();
+
+        if ((err == EAGAIN) || (err == EWOULDBLOCK)) {
+            if (fd->secret->nonblocking) {
+                break;
+            }
+            /* If it's SUPPOSED to be a blocking thread, wait
+             * a while to see if the triggering condition gets
+             * satisfied.
+             */
+            /* Assume that we're always using a native thread */
+            if ((rv = socket_io_wait(osfd, READ_FD, timeout)) < 0)
+                goto done;
+        } else if (err == EINTR) {
+            continue;
+        } else {
+            break;
+        }
+    }
+    if (rv < 0) {
+        set_accept_error(err);
+    } else if (addr != NULL) {
+        /* bug 134099 */
+        err = getpeername(rv, (struct sockaddr *) addr, (int *)addrlen);
+    }
+done:
+#ifdef _PR_HAVE_SOCKADDR_LEN
+    if (rv != -1) {
+        /* Mask off the first byte of struct sockaddr (the length field) */
+        if (addr) {
+            addr->raw.family = ((struct sockaddr *) addr)->sa_family;
+        }
+    }
+#endif /* _PR_HAVE_SOCKADDR_LEN */
+    return(rv);
+}
+
+
+
+static PRFileDesc* PR_CALLBACK SocketAccept(PRFileDesc *fd, PRNetAddr *addr,
+PRIntervalTime timeout)
+{
+    PRInt32 osfd;
+    PRFileDesc *fd2;
+    PRUint32 al;
+
+    al = sizeof(PRNetAddr);
+    osfd = _bt_accept(fd, addr, &al, timeout);
+    if (osfd == -1)
+        return 0;
+    fd2 = bt_CreateFileDesc(osfd, PR_GetTCPMethods(), _PR_TRI_TRUE, true);
+    if (!fd2) {
+        closesocket(osfd);
+
+        return NULL;
+    }
+
+    fd2->secret->nonblocking = fd->secret->nonblocking;
+    fd2->secret->inheritable = fd->secret->inheritable;
+
+#ifdef _PR_INET6
+    if (addr && (AF_INET6 == addr->raw.family))
+        addr->raw.family = PR_AF_INET6;
+#endif
+    PR_ASSERT(IsValidNetAddr(addr) == PR_TRUE);
+    PR_ASSERT(IsValidNetAddrLen(addr, al) == PR_TRUE);
+
+    return fd2;
+}
+
+
+static PRStatus PR_CALLBACK SocketBind(PRFileDesc *fd, const PRNetAddr *addr)
+{
+    PRInt32 result, err;
+    const PRNetAddr *addrp = addr;
+#if defined(_PR_INET6) || defined(_PR_HAVE_SOCKADDR_LEN)
+    PRNetAddr addrCopy;
+#endif
+
+    PR_ASSERT(IsValidNetAddr(addr) == PR_TRUE);
+#if defined(_PR_INET6)
+    if (addr->raw.family == PR_AF_INET6) {
+        addrCopy = *addr;
+        addrCopy.raw.family = AF_INET6;
+        addrp = &addrCopy;
+    }
+#endif
+
+#ifdef _PR_HAVE_SOCKADDR_LEN
+    addrCopy = *addrp;
+    ((struct sockaddr *) &addrCopy)->sa_len = PR_NETADDR_SIZE(addrp);
+    ((struct sockaddr *) &addrCopy)->sa_family = addr->raw.family;
+    result = bind(fd->secret->md.osfd, (struct sockaddr *) &addrCopy, PR_NETADDR_SIZE(addrp));
+#else
+    result = bind(fd->secret->md.osfd, (struct sockaddr *) addrp, PR_NETADDR_SIZE(addrp));
+#endif
+
+
+    if (result < 0) {
+        err = _MD_ERRNO();
+        set_bind_error(err);
+        return PR_FAILURE;
+    }
+    return PR_SUCCESS;
+}
+
+static PRStatus PR_CALLBACK SocketListen(PRFileDesc *fd, PRIntn backlog)
+{
+    PRInt32 result,err;
+#ifndef BONE_VERSION
+    /* Bug workaround!  Setting listen to 0 on Be accepts no connections.
+    ** On most UN*Xes this sets the default.
+    */
+
+    if( backlog == 0 ) backlog = 5;
+#endif
+    result = listen(fd->secret->md.osfd, backlog);
+    if (result < 0) {
+        err = _MD_ERRNO();
+                set_listen_error(err);
+        return PR_FAILURE;
+    }
+    return PR_SUCCESS;
+}
+
+static PRStatus PR_CALLBACK SocketShutdown(PRFileDesc *fd, PRIntn how)
+{
+    PRInt32 result,err;
+#ifndef BONE_VERSION
+    if (how == PR_SHUTDOWN_SEND)
+        fd->secret->md.sock_state = BE_SOCK_SHUTDOWN_WRITE;
+    else if (how == PR_SHUTDOWN_RCV)
+        fd->secret->md.sock_state = BE_SOCK_SHUTDOWN_READ;
+    else if (how == PR_SHUTDOWN_BOTH) {
+        fd->secret->md.sock_state = (BE_SOCK_SHUTDOWN_WRITE | BE_SOCK_SHUTDOWN_READ);
+    }
+#else /* BONE_VERSION */
+    result = shutdown(fd->secret->md.osfd, how);
+    if (result < 0) {
+        err = _MD_ERRNO();
+        set_shutdown_error(err);
+        return PR_FAILURE;
+    }
+#endif
+    return PR_SUCCESS;
+}
+
+PRInt32
+_bt_recv (PRFileDesc *fd, void *buf, PRInt32 amount, PRInt32 flags,
+          PRIntervalTime timeout)
+{
+    PRInt32 osfd = fd->secret->md.osfd;
+    PRInt32 rv, err;
+
+#ifndef BONE_VERSION
+    if (fd->secret->md.sock_state & BE_SOCK_SHUTDOWN_READ) {
+        set_recv_error(EPIPE);
+        return -1;
+    }
+#endif
+
+#ifdef BONE_VERSION
+    /*
+    ** Gah, stupid hack.  If reading a zero amount, instantly return success.
+    ** BONE beta 6 returns EINVAL for reads of zero bytes, which parts of
+    ** mozilla use to check for socket availability.
+    */
+
+    if( 0 == amount ) return(0);
+#endif
+
+    while ((rv = recv(osfd, buf, amount, flags)) == -1) {
+        err = _MD_ERRNO();
+
+        if ((err == EAGAIN) || (err == EWOULDBLOCK)) {
+            if (fd->secret->nonblocking) {
+                break;
+            }
+            /* If socket was supposed to be blocking,
+            wait a while for the condition to be
+            satisfied. */
+            if ((rv = socket_io_wait(osfd, READ_FD, timeout)) < 0)
+                goto done;
+        } else if (err == EINTR) {
+            continue;
+        } else
+            break;
+    }
+
+    if (rv < 0) {
+        set_recv_error(err);
+    }
+
+done:
+    return(rv);
+}
+
+static PRInt32 PR_CALLBACK SocketRecv(PRFileDesc *fd, void *buf, PRInt32 amount, PRIntn flags,
+PRIntervalTime timeout)
+{
+    PRInt32 rv;
+
+    if ((flags != 0) && (flags != PR_MSG_PEEK)) {
+        PR_SetError(PR_INVALID_ARGUMENT_ERROR, 0);
+        return -1;
+    }
+
+    PR_LOG(_pr_io_lm, PR_LOG_MAX, ("recv: fd=%p osfd=%d buf=%p amount=%d flags=%d",
+                                    fd, fd->secret->md.osfd, buf, amount, flags));
+
+
+    rv = _bt_recv(fd, buf, amount, flags, timeout);
+    PR_LOG(_pr_io_lm, PR_LOG_MAX, ("recv -> %d, error = %d, os error = %d",
+        rv, PR_GetError(), PR_GetOSError()));
+
+    return rv;
+}
+
+static PRInt32 PR_CALLBACK SocketRead(PRFileDesc *fd, void *buf, PRInt32 amount)
+{
+    return SocketRecv(fd, buf, amount, 0, PR_INTERVAL_NO_TIMEOUT);
+}
+
+PRInt32
+_bt_send (PRFileDesc *fd, const void *buf, PRInt32 amount, PRInt32 flags,
+          PRIntervalTime timeout)
+{
+    PRInt32 osfd = fd->secret->md.osfd;
+    PRInt32 rv, err;
+
+#ifndef BONE_VERSION
+    if (fd->secret->md.sock_state & BE_SOCK_SHUTDOWN_WRITE)
+    {
+        set_send_error(EPIPE);
+        return -1;
+    }
+#endif
+
+    while ((rv = send(osfd, buf, amount, flags)) == -1) {
+        err = _MD_ERRNO();
+
+        if ((err == EAGAIN) || (err == EWOULDBLOCK)) {
+            if (fd->secret->nonblocking) {
+                break;
+            }
+
+#ifndef BONE_VERSION
+
+            /* in UNIX implementations, you could do a socket_io_wait here.
+             * but since BeOS doesn't yet support WRITE notification in select,
+             * you're spanked.
+             */
+            snooze( 10000L );
+            continue;
+#else /* BONE_VERSION */
+            if ((rv = socket_io_wait(osfd, WRITE_FD, timeout))< 0)
+                goto done;
+#endif
+
+        } else if (err == EINTR) {
+            continue;
+        } else {
+            break;
+        }
+    }
+
+#ifdef BONE_VERSION
+    /*
+     * optimization; if bytes sent is less than "amount" call
+     * select before returning. This is because it is likely that
+     * the next writev() call will return EWOULDBLOCK.
+     */
+    if ((!fd->secret->nonblocking) && (rv > 0) && (rv < amount)
+        && (timeout != PR_INTERVAL_NO_WAIT)) {
+        if (socket_io_wait(osfd, WRITE_FD, timeout) < 0) {
+            rv = -1;
+            goto done;
+        }
+    }
+#endif /* BONE_VERSION */
+    
+    if (rv < 0) {
+        set_send_error(err);
+    }
+
+#ifdef BONE_VERSION
+done:
+#endif
+    return(rv);
+}
+
+
+static PRInt32 PR_CALLBACK SocketSend(PRFileDesc *fd, const void *buf, PRInt32 amount,
+PRIntn flags, PRIntervalTime timeout)
+{
+    PRInt32 temp, count;
+
+    count = 0;
+    while (amount > 0) {
+        PR_LOG(_pr_io_lm, PR_LOG_MAX,
+            ("send: fd=%p osfd=%d buf=%p amount=%d",
+            fd, fd->secret->md.osfd, buf, amount));
+        temp = _bt_send(fd, buf, amount, flags, timeout);
+        if (temp < 0) {
+                    count = -1;
+                    break;
+                }
+
+        count += temp;
+        if (fd->secret->nonblocking) {
+            break;
+        }
+        buf = (const void*) ((const char*)buf + temp);
+
+        amount -= temp;
+    }
+    PR_LOG(_pr_io_lm, PR_LOG_MAX, ("send -> %d", count));
+    return count;
+}
+
+static PRInt32 PR_CALLBACK SocketWrite(PRFileDesc *fd, const void *buf, PRInt32 amount)
+{
+    return SocketSend(fd, buf, amount, 0, PR_INTERVAL_NO_TIMEOUT);
+}
+
+static PRStatus PR_CALLBACK SocketClose(PRFileDesc *fd)
+{
+    if (!fd || !fd->secret
+            || (fd->secret->state != _PR_FILEDESC_OPEN
+            && fd->secret->state != _PR_FILEDESC_CLOSED)) {
+        PR_SetError(PR_BAD_DESCRIPTOR_ERROR, 0);
+        return PR_FAILURE;
+    }
+
+    if (fd->secret->state == _PR_FILEDESC_OPEN) {
+        if (closesocket(fd->secret->md.osfd) < 0) {
+            return PR_FAILURE;
+        }
+
+        fd->secret->state = _PR_FILEDESC_CLOSED;
+    }
+
+    PR_ASSERT(fd);
+    _PR_Putfd(fd);
+    return PR_SUCCESS;
+}
+
+static PRInt32 PR_CALLBACK SocketAvailable(PRFileDesc *fd)
+{
+    PRInt32 rv;
+    rv =  _bt_socketavailable(fd);
+    return rv;        
+}
+
+static PRInt64 PR_CALLBACK SocketAvailable64(PRFileDesc *fd)
+{
+    PRInt64 rv;
+    LL_I2L(rv, _bt_socketavailable(fd));
+    return rv;        
+}
+
+static PRStatus PR_CALLBACK SocketSync(PRFileDesc *fd)
+{
+    return PR_SUCCESS;
+}
+
+PRInt32
+_bt_sendto (PRFileDesc *fd, const void *buf, PRInt32 amount, PRIntn flags,
+            const PRNetAddr *addr, PRUint32 addrlen, PRIntervalTime timeout)
+{
+    PRInt32 osfd = fd->secret->md.osfd;
+    PRInt32 rv, err;
+
+#ifdef _PR_HAVE_SOCKADDR_LEN
+    PRNetAddr addrCopy;
+
+    addrCopy = *addr;
+    ((struct sockaddr *) &addrCopy)->sa_len = addrlen;
+    ((struct sockaddr *) &addrCopy)->sa_family = addr->raw.family;
+
+    while ((rv = sendto(osfd, buf, amount, flags,
+                        (struct sockaddr *) &addrCopy, addrlen)) == -1) {
+#else
+    while ((rv = sendto(osfd, buf, amount, flags,
+                        (struct sockaddr *) addr, addrlen)) == -1) {
+#endif
+        err = _MD_ERRNO();
+
+        if ((err == EAGAIN) || (err == EWOULDBLOCK)) {
+            if (fd->secret->nonblocking) {
+                break;
+            }
+
+#ifdef BONE_VERSION
+            if ((rv = socket_io_wait(osfd, WRITE_FD, timeout))< 0)
+                goto done;
+#endif
+        } else if (err == EINTR) {
+            continue;
+
+        } else {
+            break;
+        }
+    }
+
+    if (rv < 0) {
+        set_sendto_error(err);
+    }
+
+#ifdef BONE_VERSION
+done:
+#endif
+    return(rv);
+}
+
+
+static PRInt32 PR_CALLBACK SocketSendTo(
+    PRFileDesc *fd, const void *buf, PRInt32 amount,
+    PRIntn flags, const PRNetAddr *addr, PRIntervalTime timeout)
+{
+    PRInt32 temp, count;
+    const PRNetAddr *addrp = addr;
+#if defined(_PR_INET6)
+    PRNetAddr addrCopy;
+#endif
+
+    PR_ASSERT(IsValidNetAddr(addr) == PR_TRUE);
+#if defined(_PR_INET6)
+    if (addr->raw.family == PR_AF_INET6) {
+        addrCopy = *addr;
+        addrCopy.raw.family = AF_INET6;
+        addrp = &addrCopy;
+    }
+#endif
+
+    count = 0;
+    while (amount > 0) {
+        temp = _bt_sendto(fd, buf, amount, flags,
+            addrp, PR_NETADDR_SIZE(addr), timeout);
+        if (temp < 0) {
+                    count = -1;
+                    break;
+                }
+        count += temp;
+        if (fd->secret->nonblocking) {
+            break;
+        }
+        buf = (const void*) ((const char*)buf + temp);
+        amount -= temp;
+    }
+    return count;
+}
+
+PRInt32
+_bt_recvfrom (PRFileDesc *fd, void *buf, PRInt32 amount, PRIntn flags,
+              PRNetAddr *addr, PRUint32 *addrlen, PRIntervalTime timeout)
+{
+    PRInt32 osfd = fd->secret->md.osfd;
+    PRInt32 rv, err;
+
+    while ((*addrlen = PR_NETADDR_SIZE(addr)),
+            ((rv = recvfrom(osfd, buf, amount, flags,
+                            (struct sockaddr *) addr,
+                            (int *)addrlen)) == -1)) {
+        err = _MD_ERRNO();
+
+        if ((err == EAGAIN) || (err == EWOULDBLOCK)) {
+            if (fd->secret->nonblocking) {
+                break;
+            }
+            if ((rv = socket_io_wait(osfd, READ_FD, timeout)) < 0)
+                goto done;
+
+        } else if (err == EINTR) {
+            continue;
+        } else {
+            break;
+        }
+    }
+
+    if (rv < 0) {
+        set_recvfrom_error(err);
+    }
+
+done:
+#ifdef _PR_HAVE_SOCKADDR_LEN
+    if (rv != -1) {
+        /* ignore the sa_len field of struct sockaddr */
+        if (addr) {
+            addr->raw.family = ((struct sockaddr *) addr)->sa_family;
+        }
+    }
+#endif /* _PR_HAVE_SOCKADDR_LEN */
+    return(rv);
+}
+
+
+
+static PRInt32 PR_CALLBACK SocketRecvFrom(PRFileDesc *fd, void *buf, PRInt32 amount,
+PRIntn flags, PRNetAddr *addr, PRIntervalTime timeout)
+{
+    PRInt32 rv;
+    PRUint32 al;
+
+    al = sizeof(PRNetAddr);
+    rv = _bt_recvfrom(fd, buf, amount, flags, addr, &al, timeout);
+#ifdef _PR_INET6
+    if (addr && (AF_INET6 == addr->raw.family))
+        addr->raw.family = PR_AF_INET6;
+#endif
+    return rv;
+}
+
+static PRInt32 PR_CALLBACK SocketAcceptRead(PRFileDesc *sd, PRFileDesc **nd, 
+PRNetAddr **raddr, void *buf, PRInt32 amount,
+PRIntervalTime timeout)
+{
+    /* The socket must be in blocking mode. */
+    if (sd->secret->nonblocking) {
+        PR_SetError(PR_INVALID_ARGUMENT_ERROR, 0);
+        return -1;
+    }
+    *nd = NULL;
+
+    return PR_EmulateAcceptRead(sd, nd, raddr, buf, amount, timeout);
+}
+
+
+static PRInt32 PR_CALLBACK SocketSendFile(
+    PRFileDesc *sd, PRSendFileData *sfd,
+    PRTransmitFileFlags flags, PRIntervalTime timeout)
+{
+    /* The socket must be in blocking mode. */
+    if (sd->secret->nonblocking) {
+        PR_SetError(PR_INVALID_ARGUMENT_ERROR, 0);
+        return -1;
+    }
+    return PR_EmulateSendFile(sd, sfd, flags, timeout);
+}
+
+static PRInt32 PR_CALLBACK SocketTransmitFile(PRFileDesc *sd, PRFileDesc *fd, 
+const void *headers, PRInt32 hlen, PRTransmitFileFlags flags,
+PRIntervalTime timeout)
+{
+    PRSendFileData sfd;
+
+    sfd.fd = fd;
+    sfd.file_offset = 0;
+    sfd.file_nbytes = 0;
+    sfd.header = headers;
+    sfd.hlen = hlen;
+    sfd.trailer = NULL;
+    sfd.tlen = 0;
+
+    return(SocketSendFile(sd, &sfd, flags, timeout));
+}
+
+static PRStatus PR_CALLBACK SocketGetName(PRFileDesc *fd, PRNetAddr *addr)
+{
+    PRInt32 result, err;
+    PRUint32 addrlen;
+
+    addrlen = sizeof(PRNetAddr);
+    result = getsockname(fd->secret->md.osfd, (struct sockaddr *) addr, &addrlen);
+    if (result < 0) {
+        err = _MD_ERRNO();
+               set_getsockname_error(err);
+        return PR_FAILURE;
+    }
+#ifdef _PR_HAVE_SOCKADDR_LEN
+    if (result == 0) {
+        /* ignore the sa_len field of struct sockaddr */
+        if (addr) {
+            addr->raw.family = ((struct sockaddr *) addr)->sa_family;
+        }
+    }
+#endif /* _PR_HAVE_SOCKADDR_LEN */
+
+#ifdef _PR_INET6
+    if (AF_INET6 == addr->raw.family)
+        addr->raw.family = PR_AF_INET6;
+#endif
+    PR_ASSERT(IsValidNetAddr(addr) == PR_TRUE);
+    PR_ASSERT(IsValidNetAddrLen(addr, addrlen) == PR_TRUE);
+    return PR_SUCCESS;
+}
+
+static PRStatus PR_CALLBACK SocketGetPeerName(PRFileDesc *fd, PRNetAddr *addr)
+{
+    PRInt32 result, err;
+    PRUint32 addrlen;
+
+    addrlen = sizeof(PRNetAddr);
+    result = getpeername(fd->secret->md.osfd, (struct sockaddr *) addr, &addrlen);
+    if (result < 0) {
+        err = _MD_ERRNO();
+        set_getpeername_error(err);
+        return PR_FAILURE;
+    }
+#ifdef _PR_HAVE_SOCKADDR_LEN
+    if (result == 0) {
+        /* ignore the sa_len field of struct sockaddr */
+        if (addr) {
+            addr->raw.family = ((struct sockaddr *) addr)->sa_family;
+        }
+    }
+#endif /* _PR_HAVE_SOCKADDR_LEN */
+    
+#ifdef _PR_INET6
+    if (AF_INET6 == addr->raw.family)
+        addr->raw.family = PR_AF_INET6;
+#endif
+    PR_ASSERT(IsValidNetAddr(addr) == PR_TRUE);
+    PR_ASSERT(IsValidNetAddrLen(addr, addrlen) == PR_TRUE);
+    return PR_SUCCESS;
+}
+
+static PRInt16 PR_CALLBACK SocketPoll(
+    PRFileDesc *fd, PRInt16 in_flags, PRInt16 *out_flags)
+{
+    *out_flags = 0;
+    return in_flags;
+}  /* SocketPoll */
+
+
+PRStatus PR_CALLBACK SocketGetOption(PRFileDesc *fd, PRSocketOptionData *data)
+{
+    PRStatus rv;
+    PRInt32 level, name, length, err;
+
+    /*
+     * PR_SockOpt_Nonblocking is a special case that does not
+     * translate to a getsockopt() call
+     */
+    if (PR_SockOpt_Nonblocking == data->option)
+    {
+        data->value.non_blocking = fd->secret->nonblocking;
+        return PR_SUCCESS;
+    }
+
+    rv = _PR_MapOptionName(data->option, &level, &name);
+    if (PR_SUCCESS != rv) return rv;
+    
+    switch (data->option)
+    {
+        case PR_SockOpt_Linger:
+        {
+#ifdef BONE_VERSION
+            struct linger linger;
+            length = sizeof(linger);
+            if (0 == getsockopt(
+                fd->secret->md.osfd, level, name, (char *) &linger, &length))
+            {
+                PR_ASSERT(sizeof(linger) == length);
+                data->value.linger.polarity =
+                    (linger.l_onoff) ? PR_TRUE : PR_FALSE;
+                data->value.linger.linger =
+                    PR_SecondsToInterval(linger.l_linger);
+                return PR_SUCCESS;
+            }
+            break;
+#else
+                PR_SetError( PR_NOT_IMPLEMENTED_ERROR, 0 );
+                return PR_FAILURE;
+#endif
+        }
+        case PR_SockOpt_Reuseaddr:
+        case PR_SockOpt_Keepalive:
+        case PR_SockOpt_NoDelay:
+        case PR_SockOpt_Broadcast:
+        {
+            PRIntn value;
+            length = sizeof(value);
+            if (0 == getsockopt(
+                fd->secret->md.osfd, level, name, (char *) &value, &length))
+            {
+                data->value.reuse_addr = (0 == value) ? PR_FALSE : PR_TRUE;
+                return PR_SUCCESS;
+            }        
+            break;
+        }
+        case PR_SockOpt_McastLoopback:
+        {
+            PRUint8 bool;
+            length = sizeof(bool);
+            if (0 == getsockopt(
+                fd->secret->md.osfd, level, name, (char*)&bool, &length))
+            {
+                data->value.mcast_loopback = (0 == bool) ? PR_FALSE : PR_TRUE;
+                return PR_SUCCESS;
+            }
+            break;
+        }
+        case PR_SockOpt_RecvBufferSize:
+        case PR_SockOpt_SendBufferSize:
+        case PR_SockOpt_MaxSegment:
+        {
+            PRIntn value;
+            length = sizeof(value);
+            if (0 == getsockopt(
+                fd->secret->md.osfd, level, name, (char*)&value, &length))
+            {
+                data->value.recv_buffer_size = value;
+                return PR_SUCCESS;
+            }
+            break;
+        }
+        case PR_SockOpt_IpTimeToLive:
+        case PR_SockOpt_IpTypeOfService:
+        {
+            /* These options should really be an int (or PRIntn). */
+            length = sizeof(PRUintn);
+            if (0 == getsockopt(
+                fd->secret->md.osfd, level, name, (char*)&data->value.ip_ttl, &length))
+                return PR_SUCCESS;
+            break;
+        }
+        case PR_SockOpt_McastTimeToLive:
+        {
+            PRUint8 ttl;
+            length = sizeof(ttl);
+            if (0 == getsockopt(
+                fd->secret->md.osfd, level, name, (char*)&ttl, &length))
+            {
+                data->value.mcast_ttl = ttl;
+                return PR_SUCCESS;
+            }
+            break;
+        }
+#ifdef IP_ADD_MEMBERSHIP
+        case PR_SockOpt_AddMember:
+        case PR_SockOpt_DropMember:
+        {
+            struct ip_mreq mreq;
+            length = sizeof(mreq);
+            if (0 == getsockopt(
+                fd->secret->md.osfd, level, name, (char*)&mreq, &length))
+            {
+                data->value.add_member.mcaddr.inet.ip =
+                    mreq.imr_multiaddr.s_addr;
+                data->value.add_member.ifaddr.inet.ip =
+                    mreq.imr_interface.s_addr;
+                return PR_SUCCESS;
+            }
+            break;
+        }
+#endif /* IP_ADD_MEMBERSHIP */
+        case PR_SockOpt_McastInterface:
+        {
+            /* This option is a struct in_addr. */
+            length = sizeof(data->value.mcast_if.inet.ip);
+            if (0 == getsockopt(
+                fd->secret->md.osfd, level, name,
+                (char*)&data->value.mcast_if.inet.ip, &length))
+                return PR_SUCCESS;
+            break;
+        }
+        default:
+            PR_NOT_REACHED("Unknown socket option");
+            break;
+    }  
+    err = _MD_ERRNO();
+    set_getsockopt_error(err);
+    return PR_FAILURE;
+}  /* SocketGetOption */
+
+PRStatus PR_CALLBACK SocketSetOption(PRFileDesc *fd, const PRSocketOptionData *data)
+{
+    PRStatus rv;
+    PRInt32 level, name, result, err;
+
+    /*
+     * PR_SockOpt_Nonblocking is a special case that does not
+     * translate to a setsockopt call.
+     */
+    if (PR_SockOpt_Nonblocking == data->option)
+    {
+        fd->secret->nonblocking = data->value.non_blocking;
+        return PR_SUCCESS;
+    }
+    
+    rv = _PR_MapOptionName(data->option, &level, &name);
+    if (PR_SUCCESS != rv) return rv;
+
+    switch (data->option)
+    {
+        case PR_SockOpt_Linger:
+        {
+#ifdef BONE_VERSION
+            struct linger linger;
+            linger.l_onoff = data->value.linger.polarity;
+            linger.l_linger = PR_IntervalToSeconds(data->value.linger.linger);
+            result = setsockopt(
+                fd->secret->md.osfd, level, name, (char*)&linger, sizeof(linger));
+            break;
+#else
+            PR_SetError( PR_NOT_IMPLEMENTED_ERROR, 0 );
+            return PR_FAILURE;
+#endif
+        }
+        case PR_SockOpt_Reuseaddr:
+        case PR_SockOpt_Keepalive:
+        case PR_SockOpt_NoDelay:
+        case PR_SockOpt_Broadcast:
+        {
+            PRIntn value;
+            value = (data->value.reuse_addr) ? 1 : 0;
+            result = setsockopt(
+                fd->secret->md.osfd, level, name, (char*)&value, sizeof(value));
+            break;
+        }
+        case PR_SockOpt_McastLoopback:
+        {
+            PRUint8 bool;
+            bool = data->value.mcast_loopback ? 1 : 0;
+            result = setsockopt(
+                fd->secret->md.osfd, level, name, (char*)&bool, sizeof(bool));
+            break;
+        }
+        case PR_SockOpt_RecvBufferSize:
+        case PR_SockOpt_SendBufferSize:
+        case PR_SockOpt_MaxSegment:
+        {
+            PRIntn value = data->value.recv_buffer_size;
+            result = setsockopt(
+                fd->secret->md.osfd, level, name, (char*)&value, sizeof(value));
+            break;
+        }
+        case PR_SockOpt_IpTimeToLive:
+        case PR_SockOpt_IpTypeOfService:
+        {
+            /* These options should really be an int (or PRIntn). */
+            result = setsockopt(
+                fd->secret->md.osfd, level, name, (char*)&data->value.ip_ttl, sizeof(PRUintn));
+            break;
+        }
+        case PR_SockOpt_McastTimeToLive:
+        {
+            PRUint8 ttl;
+            ttl = data->value.mcast_ttl;
+            result = setsockopt(
+                fd->secret->md.osfd, level, name, (char*)&ttl, sizeof(ttl));
+            break;
+        }
+#ifdef IP_ADD_MEMBERSHIP
+        case PR_SockOpt_AddMember:
+        case PR_SockOpt_DropMember:
+        {
+            struct ip_mreq mreq;
+            mreq.imr_multiaddr.s_addr =
+                data->value.add_member.mcaddr.inet.ip;
+            mreq.imr_interface.s_addr =
+                data->value.add_member.ifaddr.inet.ip;
+            result = setsockopt(
+                fd->secret->md.osfd, level, name, (char*)&mreq, sizeof(mreq));
+            break;
+        }
+#endif /* IP_ADD_MEMBERSHIP */
+        case PR_SockOpt_McastInterface:
+        {
+            /* This option is a struct in_addr. */
+            result = setsockopt(
+                fd->secret->md.osfd, level, name, (char*)&data->value.mcast_if.inet.ip,
+                sizeof(data->value.mcast_if.inet.ip));
+            break;
+        }
+        default:
+            PR_NOT_REACHED("Unknown socket option");
+            break;
+    }
+    if (0 == result)
+        return PR_SUCCESS;
+    err = _MD_ERRNO();
+    set_setsockopt_error(err);
+    return PR_FAILURE;
+}  /* SocketSetOption */
+
+
+
+static PRIOMethods tcpMethods = {
+    PR_DESC_SOCKET_TCP,
+    SocketClose,
+    SocketRead,
+    SocketWrite,
+    SocketAvailable,
+    SocketAvailable64,
+    SocketSync,
+    (PRSeekFN)_PR_InvalidInt,
+    (PRSeek64FN)_PR_InvalidInt64,
+    (PRFileInfoFN)_PR_InvalidStatus,
+    (PRFileInfo64FN)_PR_InvalidStatus,
+    SocketWritev,
+    SocketConnect,
+    SocketAccept,
+    SocketBind,
+    SocketListen,
+    SocketShutdown,
+    SocketRecv,
+    SocketSend,
+    (PRRecvfromFN)_PR_InvalidInt,
+    (PRSendtoFN)_PR_InvalidInt,
+    SocketPoll,
+    SocketAcceptRead,
+    SocketTransmitFile,
+    SocketGetName,
+    SocketGetPeerName,
+    (PRReservedFN)_PR_InvalidInt,
+    (PRReservedFN)_PR_InvalidInt,
+    SocketGetOption,
+    SocketSetOption,
+    SocketSendFile, 
+    SocketConnectContinue,
+    (PRReservedFN)_PR_InvalidInt, 
+    (PRReservedFN)_PR_InvalidInt, 
+    (PRReservedFN)_PR_InvalidInt, 
+    (PRReservedFN)_PR_InvalidInt
+};
+
+static PRIOMethods udpMethods = {
+    PR_DESC_SOCKET_UDP,
+    SocketClose,
+    SocketRead,
+    SocketWrite,
+    SocketAvailable,
+    SocketAvailable64,
+    SocketSync,
+    (PRSeekFN)_PR_InvalidInt,
+    (PRSeek64FN)_PR_InvalidInt64,
+    (PRFileInfoFN)_PR_InvalidStatus,
+    (PRFileInfo64FN)_PR_InvalidStatus,
+    SocketWritev,
+    SocketConnect,
+    (PRAcceptFN)_PR_InvalidDesc,
+    SocketBind,
+    SocketListen,
+    SocketShutdown,
+    SocketRecv,
+    SocketSend,
+    SocketRecvFrom,
+    SocketSendTo,
+    SocketPoll,
+    (PRAcceptreadFN)_PR_InvalidInt,
+    (PRTransmitfileFN)_PR_InvalidInt,
+    SocketGetName,
+    SocketGetPeerName,
+    (PRReservedFN)_PR_InvalidInt,
+    (PRReservedFN)_PR_InvalidInt,
+    SocketGetOption,
+    SocketSetOption,
+    (PRSendfileFN)_PR_InvalidInt, 
+    (PRConnectcontinueFN)_PR_InvalidStatus, 
+    (PRReservedFN)_PR_InvalidInt, 
+    (PRReservedFN)_PR_InvalidInt, 
+    (PRReservedFN)_PR_InvalidInt, 
+    (PRReservedFN)_PR_InvalidInt
+};
+
+
+static PRIOMethods socketpollfdMethods = {
+    (PRDescType) 0,
+    (PRCloseFN)_PR_InvalidStatus,
+    (PRReadFN)_PR_InvalidInt,
+    (PRWriteFN)_PR_InvalidInt,
+    (PRAvailableFN)_PR_InvalidInt,
+    (PRAvailable64FN)_PR_InvalidInt64,
+    (PRFsyncFN)_PR_InvalidStatus,
+    (PRSeekFN)_PR_InvalidInt,
+    (PRSeek64FN)_PR_InvalidInt64,
+    (PRFileInfoFN)_PR_InvalidStatus,
+    (PRFileInfo64FN)_PR_InvalidStatus,
+    (PRWritevFN)_PR_InvalidInt,
+    (PRConnectFN)_PR_InvalidStatus,
+    (PRAcceptFN)_PR_InvalidDesc,
+    (PRBindFN)_PR_InvalidStatus,
+    (PRListenFN)_PR_InvalidStatus,
+    (PRShutdownFN)_PR_InvalidStatus,
+    (PRRecvFN)_PR_InvalidInt,
+    (PRSendFN)_PR_InvalidInt,
+    (PRRecvfromFN)_PR_InvalidInt,
+    (PRSendtoFN)_PR_InvalidInt,
+    SocketPoll,
+    (PRAcceptreadFN)_PR_InvalidInt,
+    (PRTransmitfileFN)_PR_InvalidInt,
+    (PRGetsocknameFN)_PR_InvalidStatus,
+    (PRGetpeernameFN)_PR_InvalidStatus,
+    (PRReservedFN)_PR_InvalidInt,
+    (PRReservedFN)_PR_InvalidInt,
+    (PRGetsocketoptionFN)_PR_InvalidStatus,
+    (PRSetsocketoptionFN)_PR_InvalidStatus,
+    (PRSendfileFN)_PR_InvalidInt,
+    (PRConnectcontinueFN)_PR_InvalidStatus,
+    (PRReservedFN)_PR_InvalidInt,
+    (PRReservedFN)_PR_InvalidInt,
+    (PRReservedFN)_PR_InvalidInt,
+    (PRReservedFN)_PR_InvalidInt
+};
+
+static PRIOMethods _pr_socketpollfd_methods = {
+    (PRDescType) 0,
+    (PRCloseFN)_PR_InvalidStatus,
+    (PRReadFN)_PR_InvalidInt,
+    (PRWriteFN)_PR_InvalidInt,
+    (PRAvailableFN)_PR_InvalidInt,
+    (PRAvailable64FN)_PR_InvalidInt64,
+    (PRFsyncFN)_PR_InvalidStatus,
+    (PRSeekFN)_PR_InvalidInt,
+    (PRSeek64FN)_PR_InvalidInt64,
+    (PRFileInfoFN)_PR_InvalidStatus,
+    (PRFileInfo64FN)_PR_InvalidStatus,
+    (PRWritevFN)_PR_InvalidInt,
+    (PRConnectFN)_PR_InvalidStatus,
+    (PRAcceptFN)_PR_InvalidDesc,
+    (PRBindFN)_PR_InvalidStatus,
+    (PRListenFN)_PR_InvalidStatus,
+    (PRShutdownFN)_PR_InvalidStatus,
+    (PRRecvFN)_PR_InvalidInt,
+    (PRSendFN)_PR_InvalidInt,
+    (PRRecvfromFN)_PR_InvalidInt,
+    (PRSendtoFN)_PR_InvalidInt,
+    SocketPoll,
+    (PRAcceptreadFN)_PR_InvalidInt,
+    (PRTransmitfileFN)_PR_InvalidInt,
+    (PRGetsocknameFN)_PR_InvalidStatus,
+    (PRGetpeernameFN)_PR_InvalidStatus,
+    (PRReservedFN)_PR_InvalidInt,
+    (PRReservedFN)_PR_InvalidInt,
+    (PRGetsocketoptionFN)_PR_InvalidStatus,
+    (PRSetsocketoptionFN)_PR_InvalidStatus,
+    (PRSendfileFN)_PR_InvalidInt,
+    (PRConnectcontinueFN)_PR_InvalidStatus,
+    (PRReservedFN)_PR_InvalidInt,
+    (PRReservedFN)_PR_InvalidInt,
+    (PRReservedFN)_PR_InvalidInt,
+    (PRReservedFN)_PR_InvalidInt
+};
+
+PR_IMPLEMENT(const PRIOMethods*) PR_GetTCPMethods()
+{
+    return &tcpMethods;
+}
+
+PR_IMPLEMENT(const PRIOMethods*) PR_GetUDPMethods()
+{
+    return &udpMethods;
+}
+
+static const PRIOMethods* PR_GetSocketPollFdMethods(void)
+{
+    return &_pr_socketpollfd_methods;
+}  /* PR_GetSocketPollFdMethods */
+
+PR_IMPLEMENT(PRInt32) PR_Poll(PRPollDesc *pds, PRIntn npds, PRIntervalTime timeout)
+{
+    PRInt32 rv = 0;
+    /*
+     * This code is almost a duplicate of w32poll.c's _PR_MD_PR_POLL().
+     */
+    fd_set rd, wt, ex;
+    PRFileDesc *bottom;
+    PRPollDesc *pd, *epd;
+    PRInt32 maxfd = -1, ready, err;
+    PRIntervalTime remaining, elapsed, start;
+
+    struct timeval tv, *tvp = NULL;
+
+    if (0 == npds) {
+        PR_Sleep(timeout);
+        return rv;
+    }
+
+    FD_ZERO(&rd);
+    FD_ZERO(&wt);
+    FD_ZERO(&ex);
+
+    ready = 0;
+    for (pd = pds, epd = pd + npds; pd < epd; pd++)
+    {
+        PRInt16 in_flags_read = 0, in_flags_write = 0;
+        PRInt16 out_flags_read = 0, out_flags_write = 0; 
+        
+        if ((NULL != pd->fd) && (0 != pd->in_flags))
+        {
+            if (pd->in_flags & PR_POLL_READ)
+            {
+                in_flags_read = (pd->fd->methods->poll)(pd->fd, pd->in_flags & ~PR_POLL_WRITE, &out_flags_read);
+            }
+            if (pd->in_flags & PR_POLL_WRITE)
+            {
+                in_flags_write = (pd->fd->methods->poll)(pd->fd, pd->in_flags & ~PR_POLL_READ, &out_flags_write);
+            }
+            if ((0 != (in_flags_read & out_flags_read))
+                || (0 != (in_flags_write & out_flags_write)))
+            {
+                /* this one's ready right now */
+                if (0 == ready)
+                {
+                    /*
+                     * We will have to return without calling the
+                     * system poll/select function.  So zero the
+                     * out_flags fields of all the poll descriptors
+                     * before this one. 
+                     */
+                    PRPollDesc *prev;
+                    for (prev = pds; prev < pd; prev++)
+                    {
+                        prev->out_flags = 0;
+                    }
+                }
+                ready += 1;
+                pd->out_flags = out_flags_read | out_flags_write;
+            }
+            else
+            {
+                pd->out_flags = 0;  /* pre-condition */
+                
+                /* make sure this is an NSPR supported stack */
+                bottom = PR_GetIdentitiesLayer(pd->fd, PR_NSPR_IO_LAYER);
+                PR_ASSERT(NULL != bottom);  /* what to do about that? */
+                if ((NULL != bottom)
+                    && (_PR_FILEDESC_OPEN == bottom->secret->state))
+                {
+                    if (0 == ready)
+                    {
+                        PRInt32 osfd = bottom->secret->md.osfd; 
+                        if (osfd > maxfd) maxfd = osfd;
+                        if (in_flags_read & PR_POLL_READ)
+                        {
+                            pd->out_flags |= _PR_POLL_READ_SYS_READ;
+                            FD_SET(osfd, &rd);
+                        }
+                        if (in_flags_read & PR_POLL_WRITE)
+                        {
+                            pd->out_flags |= _PR_POLL_READ_SYS_WRITE;
+                            FD_SET(osfd, &wt);
+                        }
+                        if (in_flags_write & PR_POLL_READ)
+                        {
+                            pd->out_flags |= _PR_POLL_WRITE_SYS_READ;
+                            FD_SET(osfd, &rd);
+                        }
+                        if (in_flags_write & PR_POLL_WRITE)
+                        {
+                            pd->out_flags |= _PR_POLL_WRITE_SYS_WRITE;
+                            FD_SET(osfd, &wt);
+                        }
+                        if (pd->in_flags & PR_POLL_EXCEPT) FD_SET(osfd, &ex);
+                    }
+                }
+                else
+                {
+                    if (0 == ready)
+                    {
+                        PRPollDesc *prev;
+                        for (prev = pds; prev < pd; prev++)
+                        {
+                            prev->out_flags = 0;
+                        }
+                    }
+                    ready += 1;  /* this will cause an abrupt return */
+                    pd->out_flags = PR_POLL_NVAL;  /* bogii */
+                }
+            }
+        }
+        else
+        {
+            pd->out_flags = 0;
+        }
+    }
+
+    if (0 != ready) return ready;  /* no need to block */
+
+    remaining = timeout;
+    start = PR_IntervalNow(); 
+
+ retry:
+    if (timeout != PR_INTERVAL_NO_TIMEOUT)
+    {
+        PRInt32 ticksPerSecond = PR_TicksPerSecond();
+        tv.tv_sec = remaining / ticksPerSecond;
+        tv.tv_usec = PR_IntervalToMicroseconds( remaining % ticksPerSecond );
+        tvp = &tv;
+    }
+    
+    ready = select(maxfd + 1, &rd, &wt, &ex, tvp);
+    
+    if (ready == -1 && errno == EINTR)
+    {
+        if (timeout == PR_INTERVAL_NO_TIMEOUT) goto retry;
+        else
+        {
+            elapsed = (PRIntervalTime) (PR_IntervalNow() - start);
+            if (elapsed > timeout) ready = 0;  /* timed out */
+            else
+            {
+                remaining = timeout - elapsed;
+                goto retry; 
+            }
+        }
+    } 
+
+    /*
+    ** Now to unravel the select sets back into the client's poll
+    ** descriptor list. Is this possibly an area for pissing away
+    ** a few cycles or what?
+    */
+    if (ready > 0)
+    {
+        ready = 0;
+        for (pd = pds, epd = pd + npds; pd < epd; pd++)
+        {
+            PRInt16 out_flags = 0;
+            if ((NULL != pd->fd) && (0 != pd->in_flags))
+            {
+                PRInt32 osfd;
+                bottom = PR_GetIdentitiesLayer(pd->fd, PR_NSPR_IO_LAYER);
+                PR_ASSERT(NULL != bottom);
+                
+                osfd = bottom->secret->md.osfd; 
+                
+                if (FD_ISSET(osfd, &rd))
+                {
+                    if (pd->out_flags & _PR_POLL_READ_SYS_READ)
+                        out_flags |= PR_POLL_READ;
+                    if (pd->out_flags & _PR_POLL_WRITE_SYS_READ)
+                        out_flags |= PR_POLL_WRITE;
+                }
+                if (FD_ISSET(osfd, &wt))
+                {
+                    if (pd->out_flags & _PR_POLL_READ_SYS_WRITE)
+                        out_flags |= PR_POLL_READ;
+                    if (pd->out_flags & _PR_POLL_WRITE_SYS_WRITE)
+                        out_flags |= PR_POLL_WRITE;
+                }
+                if (FD_ISSET(osfd, &ex)) out_flags |= PR_POLL_EXCEPT;
+
+/* Workaround for nonblocking connects under net_server */
+#ifndef BONE_VERSION         
+                if (out_flags)
+                {
+                    /* check if it is a pending connect */
+                    int i = 0, j = 0;
+                    PR_Lock( _connectLock );
+                    for( i = 0; i < connectCount; i++ ) 
+                    {
+                        if(connectList[i].osfd == osfd)
+                        {
+                            int connectError;
+                            int connectResult;
+
+                            connectResult = connect(connectList[i].osfd,
+                                                    &connectList[i].addr,
+                                                    connectList[i].addrlen);
+                            connectError = errno;
+
+                            if(connectResult < 0 ) 
+                            {
+                                if(connectError == EINTR || connectError == EWOULDBLOCK ||
+                                 connectError == EINPROGRESS || connectError == EALREADY)
+                                {
+                                    break;
+                                }
+                            }
+
+                            if(i == (connectCount - 1))
+                            {
+                                connectList[i].osfd = -1;
+                            } else {
+                                for(j = i; j < connectCount; j++ )
+                                {
+                                    memcpy( &connectList[j], &connectList[j+1],
+                                            sizeof(connectList[j]));
+                                }
+                            }
+                            connectCount--;
+
+                            bottom->secret->md.connectReturnValue = connectResult;
+                            bottom->secret->md.connectReturnError = connectError;
+                            bottom->secret->md.connectValueValid = PR_TRUE;
+                            break;
+                        }
+                    }
+                    PR_Unlock( _connectLock );
+                }
+#endif
+            }
+            pd->out_flags = out_flags;
+            if (out_flags) ready++;
+        }
+        PR_ASSERT(ready > 0);
+    }
+    else if (ready < 0)
+    { 
+        err = _MD_ERRNO();
+        if (err == EBADF)
+        {
+            /* Find the bad fds */
+            ready = 0;
+            for (pd = pds, epd = pd + npds; pd < epd; pd++)
+            {
+                pd->out_flags = 0;
+                if ((NULL != pd->fd) && (0 != pd->in_flags))
+                {
+                    bottom = PR_GetIdentitiesLayer(pd->fd, PR_NSPR_IO_LAYER);
+                    if (fcntl(bottom->secret->md.osfd, F_GETFL, 0) == -1)
+                    {
+                        pd->out_flags = PR_POLL_NVAL;
+                        ready++;
+                    }
+                }
+            }
+            PR_ASSERT(ready > 0);
+        }
+        else set_select_error(err);
+    }
+    
+    return ready;
+}  /* PR_POLL */
+
+PR_IMPLEMENT(PRFileDesc*) PR_CreateSocketPollFd(PRInt32 osfd)
+{
+    PRFileDesc *fd;
+
+    if (!_pr_initialized) _PR_ImplicitInitialization();
+
+    fd = _PR_Getfd();
+
+    if (fd == NULL) PR_SetError(PR_OUT_OF_MEMORY_ERROR, 0);
+    else
+    {
+        fd->secret->md.osfd = osfd;
+        fd->secret->inheritable = _PR_TRI_FALSE;
+        fd->secret->state = _PR_FILEDESC_OPEN;
+        fd->methods = PR_GetSocketPollFdMethods();
+    }
+
+    return fd;
+}  /* PR_CreateSocketPollFD */
+
+PR_IMPLEMENT(PRStatus) PR_DestroySocketPollFd(PRFileDesc *fd)
+{
+    if (NULL == fd)
+    {
+        PR_SetError(PR_BAD_DESCRIPTOR_ERROR, 0);
+        return PR_FAILURE;
+    }
+    fd->secret->state = _PR_FILEDESC_CLOSED;
+    _PR_Putfd(fd);
+    return PR_SUCCESS;
+}  /* PR_DestroySocketPollFd */
+
+
+PR_IMPLEMENT(PRFileDesc *) PR_ImportTCPSocket(PRInt32 osfd)
+{
+    PRFileDesc *fd;
+
+    if (!_pr_initialized) _PR_ImplicitInitialization();
+    fd = bt_CreateFileDesc(osfd, PR_GetTCPMethods(), _PR_TRI_UNKNOWN, true);
+    if (fd == NULL)
+        closesocket(osfd);
+    return(fd);
+}
+
+PR_IMPLEMENT(PRFileDesc *) PR_ImportUDPSocket(PRInt32 osfd)
+{
+    PRFileDesc *fd;
+
+    if (!_pr_initialized) _PR_ImplicitInitialization();
+    fd = bt_CreateFileDesc(osfd, PR_GetUDPMethods(), _PR_TRI_UNKNOWN, true);
+    if (fd == NULL)
+        closesocket(osfd);
+    return(fd);
+}
+
+
+#ifndef XP_HAIKU
+int socketpair (int family, int type, int protocol, int sv[2])
+{
+    int insock, outsock, acceptedsock;
+    struct sockaddr_in addrs[2];
+    int alen;
+    /* that's really only so we can build... */
+    /*fprintf(stderr, "socketpair(%d, %d, %d)\n", family, type, protocol);*/
+    if (family != AF_INET) {
+        /*fatal*/fprintf(stderr, "socketpair(%d, %d, %d): family not supported\n", family, type, protocol);
+        errno = EPFNOSUPPORT;
+        return -1;
+    }
+    if (type != SOCK_DGRAM && type != SOCK_STREAM) {
+        errno = EPROTONOSUPPORT;
+        return -1;
+    }
+    addrs[0].sin_family = AF_INET;
+    addrs[0].sin_port = 0;
+    addrs[0].sin_addr.s_addr = htonl(INADDR_LOOPBACK);
+    addrs[1].sin_family = AF_INET;
+    addrs[1].sin_port = 0;
+    addrs[1].sin_addr.s_addr = htonl(INADDR_LOOPBACK);
+    alen = sizeof(struct sockaddr_in);
+
+    insock = socket(family, type, protocol);
+    if (insock < 0)
+        goto err1;
+    if (bind(insock, (struct sockaddr *)&addrs[0], alen) < 0)
+        goto err2;
+    if (getsockname(insock, (struct sockaddr *)&addrs[0], &alen) < 0)
+        goto err2;
+    if (type == SOCK_STREAM)
+        listen(insock, 2);
+
+    outsock = socket(family, type, protocol);
+    if (outsock < 0)
+        goto err2;
+    alen = sizeof(struct sockaddr_in);
+    if (bind(outsock, (struct sockaddr *)&addrs[1], alen) < 0)
+        goto err2;
+    if (getsockname(outsock, (struct sockaddr *)&addrs[1], &alen) < 0)
+        goto err3;
+    addrs[0].sin_addr.s_addr = htonl(INADDR_LOOPBACK);
+    addrs[1].sin_addr.s_addr = htonl(INADDR_LOOPBACK);
+    /*fprintf(stderr, "socketpair: %08lx:%d <-> %08lx:%d\n", 
+        ((struct sockaddr_in *)&addrs[0])->sin_addr.s_addr,
+        ((struct sockaddr_in *)&addrs[0])->sin_port,
+        ((struct sockaddr_in *)&addrs[1])->sin_addr.s_addr,
+        ((struct sockaddr_in *)&addrs[1])->sin_port);*/
+
+    if (connect(outsock, (struct sockaddr *)&addrs[0], alen) < 0)
+        goto err3;
+    if (type == SOCK_DGRAM) {
+        if (connect(insock, (struct sockaddr *)&addrs[1], alen) < 0)
+            goto err3;
+        sv[0] = insock;
+    } else {
+        acceptedsock = accept(insock, (struct sockaddr *)&addrs[1], &alen);
+        if (acceptedsock < 0)
+            goto err3;
+        closesocket(insock);
+        sv[0] = acceptedsock;
+    }
+    sv[1] = outsock;
+    return 0;
+err3:
+    closesocket(outsock);
+err2:
+    closesocket(insock);
+err1:
+    fprintf(stderr,"socketpair: error 0x%08x\n", errno);
+    return -1;
+}
+#endif
+
+PR_IMPLEMENT(PRStatus) PR_NewTCPSocketPair(PRFileDesc *f[])
+{
+    PRInt32 rv, osfd[2];
+
+    if (!_pr_initialized) _PR_ImplicitInitialization();
+#ifdef XP_HAIKU
+    rv = socketpair(AF_UNIX, SOCK_STREAM, 0, osfd);
+#else
+    rv = socketpair(AF_INET, SOCK_STREAM, 0, osfd);
+#endif
+    if (rv == -1) {
+        return PR_FAILURE;
+    }
+    f[0] = bt_CreateFileDesc(osfd[0], PR_GetTCPMethods(), _PR_TRI_TRUE, true);
+    if (NULL == f[0]) {
+        closesocket(osfd[0]);
+        closesocket(osfd[1]);
+        /* PR_AllocFileDesc() has invoked PR_SetError(). */
+        return PR_FAILURE;
+    }
+    f[1] = bt_CreateFileDesc(osfd[1], PR_GetTCPMethods(), _PR_TRI_TRUE, true);
+    if (NULL == f[1]) {
+        PR_Close(f[0]);
+        closesocket(osfd[1]);
+        /* PR_AllocFileDesc() has invoked PR_SetError(). */
+        return PR_FAILURE;
+    }
+    return PR_SUCCESS;
+}
+
+
+PR_IMPLEMENT(PRStatus) PR_GetConnectStatus(const PRPollDesc *pd) {
+    PRInt32 osfd;
+#ifndef BONE_VERSION
+    int rv;
+#endif
+    PRFileDesc *bottom;
+
+    if (pd->out_flags & PR_POLL_NVAL) {
+        PR_SetError(PR_BAD_DESCRIPTOR_ERROR, 0);
+        return PR_FAILURE;
+    }
+
+    if ((pd->out_flags & (PR_POLL_WRITE | PR_POLL_EXCEPT | PR_POLL_ERR)) == 0) {
+        PR_ASSERT(pd->out_flags == 0);
+        PR_SetError(PR_IN_PROGRESS_ERROR, 0);
+        return PR_FAILURE;
+    }
+
+
+    /* Find the NSPR layer and invoke its connectcontinue method */
+    bottom = PR_GetIdentitiesLayer(pd->fd, PR_NSPR_IO_LAYER);
+    if (NULL == bottom) 
+    {
+        PR_SetError(PR_INVALID_ARGUMENT_ERROR, 0);
+        return PR_FAILURE;
+    }
+
+    osfd = bottom->secret->md.osfd;
+#ifdef BONE_VERSION  /* bug 122364 */
+    /* temporary workaround until getsockopt(SO_ERROR) works in BONE */
+    if (pd->out_flags & PR_POLL_EXCEPT) {
+        PR_SetError(PR_CONNECT_REFUSED_ERROR, 0);
+        return PR_FAILURE;
+    }
+    PR_ASSERT(pd->out_flags & PR_POLL_WRITE);
+    return PR_SUCCESS;
+#else
+    rv = recv(bottom->secret->md.osfd, NULL, 0, 0);
+    PR_ASSERT(-1 == rv || 0 == rv);
+
+    if (-1 == rv && 0 != errno && errno != EAGAIN && errno != EWOULDBLOCK ) {
+        set_connect_error(errno);
+        return PR_FAILURE;
+    }
+    else
+        return PR_SUCCESS;
+#endif /* BONE_VERSION */
+}
+
+PR_IMPLEMENT(PRFileDesc*) PR_Socket(PRInt32 domain, PRInt32 type, PRInt32 proto)
+{
+    PRInt32 osfd, err;
+    PRFileDesc *fd;
+    PRInt32 tmp_domain = domain;
+
+    if (!_pr_initialized) _PR_ImplicitInitialization();
+    if (PR_AF_INET != domain
+        && PR_AF_INET6 != domain
+    ) {
+        PR_SetError(PR_ADDRESS_NOT_SUPPORTED_ERROR, 0);
+        return NULL;
+    }
+    if( type != SOCK_STREAM && type != SOCK_DGRAM )
+    {
+        PR_SetError(PR_ADDRESS_NOT_SUPPORTED_ERROR, 0);
+        return NULL;
+    }
+
+#if defined(_PR_INET6_PROBE)
+    if (PR_AF_INET6 == domain) {
+        if (_pr_ipv6_is_present == PR_FALSE) 
+            domain = AF_INET;
+        else
+            domain = AF_INET6;
+    }
+#elif defined(_PR_INET6)
+    if (PR_AF_INET6 == domain)
+        domain = AF_INET6;
+#else
+    if (PR_AF_INET6 == domain)
+        domain = AF_INET;
+#endif    /* _PR_INET6 */
+#ifndef BONE_VERSION
+    osfd = socket(domain, type, 0);
+#else
+    osfd = socket(domain, type, proto);
+#endif
+    if (osfd == -1) {
+        err = _MD_ERRNO();
+        set_socket_error(err);
+        return 0;
+    }
+    fd = bt_CreateFileDesc(osfd, SOCK_STREAM == type?PR_GetTCPMethods() : PR_GetUDPMethods(), _PR_TRI_TRUE, true);
+
+    if (fd != NULL) {
+#if defined(_PR_INET6_PROBE) || !defined(_PR_INET6)
+        /*
+         * For platforms with no support for IPv6 
+         * create layered socket for IPv4-mapped IPv6 addresses
+         */
+        if (PR_AF_INET6 == tmp_domain && PR_AF_INET == domain) {
+            if (PR_FAILURE == _pr_push_ipv6toipv4_layer(fd)) {
+                PR_Close(fd);
+                fd = NULL;
+            }
+        }
+#endif
+    } else
+        closesocket(osfd);
+
+    return fd;
+}
+
+
+PR_IMPLEMENT(PRFileDesc *) PR_NewTCPSocket(void)
+{
+    return PR_Socket(AF_INET, SOCK_STREAM, 0);
+}
+
+PR_IMPLEMENT(PRFileDesc*) PR_NewUDPSocket(void)
+{
+    return PR_Socket(AF_INET, SOCK_DGRAM, 0);
+}
+
+PR_IMPLEMENT(PRFileDesc *) PR_OpenTCPSocket(PRIntn af)
+{
+    return PR_Socket(af, SOCK_STREAM, 0);
+}
+
+PR_IMPLEMENT(PRFileDesc*) PR_OpenUDPSocket(PRIntn af)
+{
+    return PR_Socket(af, SOCK_DGRAM, 0);
+}
+
Index: mozilla/nsprpub/pr/src/bthreads/btlocks.c
===================================================================
RCS file: /cvsroot/mozilla/nsprpub/pr/src/bthreads/btlocks.c,v
retrieving revision 3.7
diff -u -8 -p -r3.7 btlocks.c
--- mozilla/nsprpub/pr/src/bthreads/btlocks.c	23 Feb 2005 17:43:13 -0000	3.7
+++ mozilla/nsprpub/pr/src/bthreads/btlocks.c	9 Feb 2009 04:04:36 -0000
@@ -38,44 +38,38 @@
 /*
 ** File:        btlocks.c
 ** Description: Implemenation for thread locks using bthreads
 ** Exports:     prlock.h
 */
 
 #include "primpl.h"
 
-#include <string.h>
-#include <sys/time.h>
-
 void
 _PR_InitLocks (void)
 {
 }
 
 PR_IMPLEMENT(PRLock*)
     PR_NewLock (void)
 {
     PRLock *lock;
     status_t semresult;
 
     if (!_pr_initialized) _PR_ImplicitInitialization();
 
     lock = PR_NEWZAP(PRLock);
     if (lock != NULL) {
-
-	lock->benaphoreCount = 0;
-	lock->semaphoreID = create_sem( 0, "nsprLockSem" );
-	if( lock->semaphoreID < B_NO_ERROR ) {
-
-	    PR_DELETE( lock );
-	    lock = NULL;
-	}
+        lock->benaphoreCount = 0;
+        lock->semaphoreID = create_sem( 0, "nsprLockSem" );
+        if( lock->semaphoreID < B_NO_ERROR ) {
+            PR_DELETE( lock );
+            lock = NULL;
+        }
     }
-
     return lock;
 }
 
 PR_IMPLEMENT(void)
     PR_DestroyLock (PRLock* lock)
 {
     status_t result;
 
@@ -83,34 +77,34 @@ PR_IMPLEMENT(void)
     result = delete_sem(lock->semaphoreID);
     PR_ASSERT(result == B_NO_ERROR);
     PR_DELETE(lock);
 }
 
 PR_IMPLEMENT(void)
     PR_Lock (PRLock* lock)
 {
+    status_t result;
+    
     PR_ASSERT(lock != NULL);
 
-    if( atomic_add( &lock->benaphoreCount, 1 ) > 0 ) {
-
-	if( acquire_sem(lock->semaphoreID ) != B_NO_ERROR ) {
-
-	    atomic_add( &lock->benaphoreCount, -1 );
-	    return;
-	}
+    if( _MD_ATOMIC_INCREMENT( &lock->benaphoreCount) > 1 ) {
+        result = acquire_sem(lock->semaphoreID );   
+        PR_ASSERT(result == B_NO_ERROR);
+        if( result != B_NO_ERROR ) {
+            _MD_ATOMIC_DECREMENT( &lock->benaphoreCount);
+            return;
+        }
     }
-
     lock->owner = find_thread( NULL );
 }
 
 PR_IMPLEMENT(PRStatus)
     PR_Unlock (PRLock* lock)
 {
     PR_ASSERT(lock != NULL);
     lock->owner = NULL;
-    if( atomic_add( &lock->benaphoreCount, -1 ) > 1 ) {
-
-	release_sem_etc( lock->semaphoreID, 1, B_DO_NOT_RESCHEDULE );
+    if( _MD_ATOMIC_DECREMENT( &lock->benaphoreCount ) > 0 ) {
+        release_sem_etc( lock->semaphoreID, 1, B_DO_NOT_RESCHEDULE );
     }
 
     return PR_SUCCESS;
 }
Index: mozilla/nsprpub/pr/src/bthreads/btmisc.c
===================================================================
RCS file: /cvsroot/mozilla/nsprpub/pr/src/bthreads/btmisc.c,v
retrieving revision 3.5
diff -u -8 -p -r3.5 btmisc.c
--- mozilla/nsprpub/pr/src/bthreads/btmisc.c	25 Apr 2004 15:00:57 -0000	3.5
+++ mozilla/nsprpub/pr/src/bthreads/btmisc.c	9 Feb 2009 04:04:37 -0000
@@ -15,17 +15,18 @@
  * The Original Code is the Netscape Portable Runtime (NSPR).
  *
  * The Initial Developer of the Original Code is
  * Netscape Communications Corporation.
  * Portions created by the Initial Developer are Copyright (C) 1998-2000
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
- *
+ * Fredrik Holmqvist <thesuckiestemail@yahoo.se>
+ * 
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
@@ -33,72 +34,38 @@
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "primpl.h"
 #include <stdio.h>
 
-// void _PR_InitCPUs(void) {PT_LOG("_PR_InitCPUs")}
-// void _MD_StartInterrupts(void) {PT_LOG("_MD_StartInterrupts")}
-
-/* this is a total hack.. */
-
+/* this is a total hack.. 
+ * It's needed for netserver to compile.
+ * See nsprpub/pr/include/prnetdb.h
+ */
+#ifndef BONE_VERSION
 struct protoent* getprotobyname(const char* name)
 {
     return 0;
 }
 
 struct protoent* getprotobynumber(int number)
 {
     return 0;
 }
-
-/* this is needed by prinit for some reason */
-void
-_PR_InitStacks (void)
-{
-}
-
-/* this is needed by prinit for some reason */
-void
-_PR_InitTPD (void)
-{
-}
-
-/*
-** Create extra virtual processor threads. Generally used with MP systems.
-*/
-PR_IMPLEMENT(void)
-    PR_SetConcurrency (PRUintn numCPUs)
-{
-}
-
-/*
-** Set thread recycle mode to on (1) or off (0)
-*/
-PR_IMPLEMENT(void)
-    PR_SetThreadRecycleMode (PRUint32 flag)
-{
-}
+#endif
 
 /*
 ** Get context registers, return with error for now.
 */
-
 PR_IMPLEMENT(PRWord *)
 _MD_HomeGCRegisters( PRThread *t, int isCurrent, int *np )
 {
      return 0;
 }
 
-PR_IMPLEMENT(void *)
-PR_GetSP( PRThread *t )
-{
-    return 0;
-}
-
 PR_IMPLEMENT(PRStatus)
 PR_EnumerateThreads( PREnumerator func, void *arg )
 {
     return PR_FAILURE;
 }
Index: mozilla/nsprpub/pr/src/bthreads/btsem.c
===================================================================
RCS file: /cvsroot/mozilla/nsprpub/pr/src/bthreads/btsem.c,v
retrieving revision 3.7
diff -u -8 -p -r3.7 btsem.c
--- mozilla/nsprpub/pr/src/bthreads/btsem.c	23 Feb 2005 17:43:13 -0000	3.7
+++ mozilla/nsprpub/pr/src/bthreads/btsem.c	9 Feb 2009 04:04:37 -0000
@@ -33,51 +33,52 @@
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include <kernel/OS.h>
 
 #include "primpl.h"
+#include "obsolete/prsem.h"
 
 /*
 ** Create a new semaphore object.
 */
 PR_IMPLEMENT(PRSemaphore*)
     PR_NewSem (PRUintn value)
 {
-	PRSemaphore *semaphore;
+    PRSemaphore *semaphore;
 
-	if (!_pr_initialized) _PR_ImplicitInitialization();
+    if (!_pr_initialized) _PR_ImplicitInitialization();
 
-	semaphore = PR_NEWZAP(PRSemaphore);
-	if (NULL != semaphore) {
-		if ((semaphore->sem = create_sem(value, "nspr_sem")) < B_NO_ERROR)
-			return NULL;
-		else 
-			return semaphore;
-	}
-	return NULL;
+    semaphore = PR_NEWZAP(PRSemaphore);
+    if (NULL != semaphore) {
+        if ((semaphore->sem = create_sem(value, "nspr_sem")) < B_NO_ERROR)
+            return NULL;
+        else 
+            return semaphore;
+    }
+    return NULL;
 }
 
 /*
 ** Destroy the given semaphore object.
 **
 */
 PR_IMPLEMENT(void)
     PR_DestroySem (PRSemaphore *sem)
 {
-	status_t result;
+    status_t result;
 
-	PR_ASSERT(sem != NULL);
-	result = delete_sem(sem->sem);
-	PR_ASSERT(result == B_NO_ERROR);
-	PR_DELETE(sem);
-} 
+    PR_ASSERT(sem != NULL);
+    result = delete_sem(sem->sem);
+    PR_ASSERT(result == B_NO_ERROR);
+    PR_DELETE(sem);
+}
 
 /*
 ** Wait on a Semaphore.
 ** 
 ** This routine allows a calling thread to wait or proceed depending upon
 ** the state of the semahore sem. The thread can proceed only if the
 ** counter value of the semaphore sem is currently greater than 0. If the
 ** value of semaphore sem is positive, it is decremented by one and the
@@ -86,45 +87,45 @@ PR_IMPLEMENT(void)
 ** semaphore to be released by another thread.
 ** 
 ** This routine can return PR_PENDING_INTERRUPT if the waiting thread 
 ** has been interrupted.
 */
 PR_IMPLEMENT(PRStatus)
     PR_WaitSem (PRSemaphore *sem)
 {
-	PR_ASSERT(sem != NULL);
-	if (acquire_sem(sem->sem) == B_NO_ERROR)
-		return PR_SUCCESS;
-	else
-		return PR_FAILURE;
+    PR_ASSERT(sem != NULL);
+    if (acquire_sem(sem->sem) == B_NO_ERROR)
+        return PR_SUCCESS;
+    else
+        return PR_FAILURE;
 }
 
 /*
 ** This routine increments the counter value of the semaphore. If other
 ** threads are blocked for the semaphore, then the scheduler will
 ** determine which ONE thread will be unblocked.
 */
 PR_IMPLEMENT(void)
     PR_PostSem (PRSemaphore *sem)
 {
-	status_t result;
+    status_t result;
 
-	PR_ASSERT(sem != NULL);
-	result = release_sem_etc(sem->sem, 1, B_DO_NOT_RESCHEDULE);
-	PR_ASSERT(result == B_NO_ERROR);
+    PR_ASSERT(sem != NULL);
+    result = release_sem_etc(sem->sem, 1, B_DO_NOT_RESCHEDULE);
+    PR_ASSERT(result == B_NO_ERROR);
 }
 
 /*
 ** Returns the value of the semaphore referenced by sem without affecting
 ** the state of the semaphore.  The value represents the semaphore value
 ** at the time of the call, but may not be the actual value when the
 ** caller inspects it.
 */
 PR_IMPLEMENT(PRUintn)
     PR_GetValueSem (PRSemaphore *sem)
 {
-	sem_info	info;
+    sem_info info;
 
-	PR_ASSERT(sem != NULL);
-	get_sem_info(sem->sem, &info);
-	return info.count;
+    PR_ASSERT(sem != NULL);
+    get_sem_info(sem->sem, &info);
+    return info.count;
 }
Index: mozilla/nsprpub/pr/src/bthreads/btthread.c
===================================================================
RCS file: /cvsroot/mozilla/nsprpub/pr/src/bthreads/btthread.c,v
retrieving revision 3.8
diff -u -8 -p -r3.8 btthread.c
--- mozilla/nsprpub/pr/src/bthreads/btthread.c	25 Apr 2004 15:00:57 -0000	3.8
+++ mozilla/nsprpub/pr/src/bthreads/btthread.c	9 Feb 2009 04:04:39 -0000
@@ -45,39 +45,39 @@
 
 #include <stdlib.h>
 #include <string.h>
 #include <signal.h>
 
 /* values for PRThread.state */
 #define BT_THREAD_PRIMORD   0x01    /* this is the primordial thread */
 #define BT_THREAD_SYSTEM    0x02    /* this is a system thread */
-#define BT_THREAD_JOINABLE  0x04	/* this is a joinable thread */
+#define BT_THREAD_JOINABLE  0x04    /* this is a joinable thread */
 
 struct _BT_Bookeeping
 {
     PRLock *ml;                 /* a lock to protect ourselves */
-	sem_id cleanUpSem;		/* the primoridal thread will block on this
-							   sem while waiting for the user threads */
-    PRInt32 threadCount;	/* user thred count */
+    sem_id cleanUpSem;      /* the primoridal thread will block on this
+                               sem while waiting for the user threads */
+    PRInt32 threadCount;    /* user thred count */
 
 } bt_book = { NULL, B_ERROR, 0 };
 
 
-#define BT_TPD_LIMIT 128	/* number of TPD slots we'll provide (arbitrary) */
+#define BT_TPD_LIMIT 128    /* number of TPD slots we'll provide (arbitrary) */
 
 /* these will be used to map an index returned by PR_NewThreadPrivateIndex()
    to the corresponding beos native TLS slot number, and to the destructor
    for that slot - note that, because it is allocated globally, this data
    will be automatically zeroed for us when the program begins */
 static int32 tpd_beosTLSSlots[BT_TPD_LIMIT];
 static PRThreadPrivateDTOR tpd_dtors[BT_TPD_LIMIT];
 
-static vint32 tpd_slotsUsed=0;	/* number of currently-allocated TPD slots */
-static int32 tls_prThreadSlot;	/* TLS slot in which PRThread will be stored */
+static vint32 tpd_slotsUsed=0;  /* number of currently-allocated TPD slots */
+static int32 tls_prThreadSlot;  /* TLS slot in which PRThread will be stored */
 
 /* this mutex will be used to synchronize access to every
    PRThread.md.joinSem and PRThread.md.is_joining (we could
    actually allocate one per thread, but that seems a bit excessive,
    especially considering that there will probably be little
    contention, PR_JoinThread() is allowed to block anyway, and the code
    protected by the mutex is short/fast) */
 static PRLock *joinSemLock;
@@ -89,355 +89,346 @@ static PRThread *_bt_AttachThread();
 
 void
 _PR_InitThreads (PRThreadType type, PRThreadPriority priority,
                  PRUintn maxPTDs)
 {
     PRThread *primordialThread;
     PRUint32  beThreadPriority;
 
-	/* allocate joinSem mutex */
-	joinSemLock = PR_NewLock();
-	if (joinSemLock == NULL)
-	{
-		PR_SetError(PR_OUT_OF_MEMORY_ERROR, 0);
-		return;
+    /* allocate joinSem mutex */
+    joinSemLock = PR_NewLock();
+    if (joinSemLock == NULL)
+    {
+        PR_SetError(PR_OUT_OF_MEMORY_ERROR, 0);
+        return;
     }
 
     /*
     ** Create and initialize NSPR structure for our primordial thread.
     */
     
     primordialThread = PR_NEWZAP(PRThread);
     if( NULL == primordialThread )
     {
         PR_SetError( PR_OUT_OF_MEMORY_ERROR, 0 );
         return;
     }
 
-	primordialThread->md.joinSem = B_ERROR;
+    primordialThread->md.joinSem = B_ERROR;
 
     /*
     ** Set the priority to the desired level.
     */
 
     beThreadPriority = _bt_MapNSPRToNativePriority( priority );
-    
     set_thread_priority( find_thread( NULL ), beThreadPriority );
-    
     primordialThread->priority = priority;
 
-
-	/* set the thread's state - note that the thread is not joinable */
+    /* set the thread's state - note that the thread is not joinable */
     primordialThread->state |= BT_THREAD_PRIMORD;
-	if (type == PR_SYSTEM_THREAD)
-		primordialThread->state |= BT_THREAD_SYSTEM;
+    if (type == PR_SYSTEM_THREAD)
+        primordialThread->state |= BT_THREAD_SYSTEM;
 
     /*
     ** Allocate a TLS slot for the PRThread structure (just using
     ** native TLS, as opposed to NSPR TPD, will make PR_GetCurrentThread()
     ** somewhat faster, and will leave one more TPD slot for our client)
     */
-	
-	tls_prThreadSlot = tls_allocate();
+    
+    tls_prThreadSlot = tls_allocate();
 
     /*
     ** Stuff our new PRThread structure into our thread specific
     ** slot.
     */
 
-	tls_set(tls_prThreadSlot, primordialThread);
+    tls_set(tls_prThreadSlot, primordialThread);
     
-	/* allocate lock for bt_book */
+    /* allocate lock for bt_book */
     bt_book.ml = PR_NewLock();
     if( NULL == bt_book.ml )
     {
-    	PR_SetError( PR_OUT_OF_MEMORY_ERROR, 0 );
-	return;
+        PR_SetError( PR_OUT_OF_MEMORY_ERROR, 0 );
+        return;
     }
 }
 
 PRUint32
 _bt_MapNSPRToNativePriority( PRThreadPriority priority )
-    {
+{
     switch( priority )
     {
-    	case PR_PRIORITY_LOW:	 return( B_LOW_PRIORITY );
-	case PR_PRIORITY_NORMAL: return( B_NORMAL_PRIORITY );
-	case PR_PRIORITY_HIGH:	 return( B_DISPLAY_PRIORITY );
-	case PR_PRIORITY_URGENT: return( B_URGENT_DISPLAY_PRIORITY );
-	default:		 return( B_NORMAL_PRIORITY );
+        case PR_PRIORITY_LOW:    return( B_LOW_PRIORITY );
+        case PR_PRIORITY_NORMAL: return( B_NORMAL_PRIORITY );
+        case PR_PRIORITY_HIGH:   return( B_DISPLAY_PRIORITY );
+        case PR_PRIORITY_URGENT: return( B_URGENT_DISPLAY_PRIORITY );
+        default:                 return( B_NORMAL_PRIORITY );
     }
 }
 
 PRThreadPriority
 _bt_MapNativeToNSPRPriority(PRUint32 priority)
-    {
-	if (priority < B_NORMAL_PRIORITY)
-		return PR_PRIORITY_LOW;
-	if (priority < B_DISPLAY_PRIORITY)
-		return PR_PRIORITY_NORMAL;
-	if (priority < B_URGENT_DISPLAY_PRIORITY)
-		return PR_PRIORITY_HIGH;
-	return PR_PRIORITY_URGENT;
+{
+    if (priority < B_NORMAL_PRIORITY)
+        return PR_PRIORITY_LOW;
+    if (priority < B_DISPLAY_PRIORITY)
+        return PR_PRIORITY_NORMAL;
+    if (priority < B_URGENT_DISPLAY_PRIORITY)
+        return PR_PRIORITY_HIGH;
+    return PR_PRIORITY_URGENT;
 }
 
 PRUint32
 _bt_mapNativeToNSPRPriority( int32 priority )
 {
     switch( priority )
     {
-    	case PR_PRIORITY_LOW:	 return( B_LOW_PRIORITY );
-	case PR_PRIORITY_NORMAL: return( B_NORMAL_PRIORITY );
-	case PR_PRIORITY_HIGH:	 return( B_DISPLAY_PRIORITY );
-	case PR_PRIORITY_URGENT: return( B_URGENT_DISPLAY_PRIORITY );
-	default:		 return( B_NORMAL_PRIORITY );
+        case PR_PRIORITY_LOW:    return( B_LOW_PRIORITY );
+        case PR_PRIORITY_NORMAL: return( B_NORMAL_PRIORITY );
+        case PR_PRIORITY_HIGH:   return( B_DISPLAY_PRIORITY );
+        case PR_PRIORITY_URGENT: return( B_URGENT_DISPLAY_PRIORITY );
+        default:                 return( B_NORMAL_PRIORITY );
     }
 }
 
 /* This method is called by all NSPR threads as they exit */
 void _bt_CleanupThread(void *arg)
 {
-	PRThread *me = PR_GetCurrentThread();
-	int32 i;
+    PRThread *me = PR_GetCurrentThread();
+    int32 i;
 
-	/* first, clean up all thread-private data */
-	for (i = 0; i < tpd_slotsUsed; i++)
-	{
-		void *oldValue = tls_get(tpd_beosTLSSlots[i]);
-		if ( oldValue != NULL && tpd_dtors[i] != NULL )
-			(*tpd_dtors[i])(oldValue);
-	}
-
-	/* if this thread is joinable, wait for someone to join it */
-	if (me->state & BT_THREAD_JOINABLE)
-	{
-		/* protect access to our joinSem */
-		PR_Lock(joinSemLock);
-
-		if (me->md.is_joining)
-		{
-			/* someone is already waiting to join us (they've
-			   allocated a joinSem for us) - let them know we're
-			   ready */
-			delete_sem(me->md.joinSem);
-
-			PR_Unlock(joinSemLock);
-
-		}
-		else
-    {
-			/* noone is currently waiting for our demise - it
-			   is our responsibility to allocate the joinSem
-			   and block on it */
-			me->md.joinSem = create_sem(0, "join sem");
-
-			/* we're done accessing our joinSem */
-			PR_Unlock(joinSemLock);
-
-			/* wait for someone to join us */
-			while (acquire_sem(me->md.joinSem) == B_INTERRUPTED);
-	    }
-	}
-
-	/* if this is a user thread, we must update our books */
-	if ((me->state & BT_THREAD_SYSTEM) == 0)
-	{
-		/* synchronize access to bt_book */
-    PR_Lock( bt_book.ml );
-
-		/* decrement the number of currently-alive user threads */
-	bt_book.threadCount--;
+    /* first, clean up all thread-private data */
+    for (i = 0; i < tpd_slotsUsed; i++)
+    {
+        void *oldValue = tls_get(tpd_beosTLSSlots[i]);
+        if ( oldValue != NULL && tpd_dtors[i] != NULL )
+            (*tpd_dtors[i])(oldValue);
+    }
+
+    /* if this thread is joinable, wait for someone to join it */
+    if (me->state & BT_THREAD_JOINABLE)
+    {
+        /* protect access to our joinSem */
+        PR_Lock(joinSemLock);
+
+        if (me->md.is_joining)
+        {
+            /* someone is already waiting to join us (they've
+               allocated a joinSem for us) - let them know we're
+               ready */
+            delete_sem(me->md.joinSem);
+            PR_Unlock(joinSemLock);
+        }
+        else
+        {
+            /* noone is currently waiting for our demise - it
+               is our responsibility to allocate the joinSem
+               and block on it */
+            me->md.joinSem = create_sem(0, "join sem");
+            /* we're done accessing our joinSem */
+            PR_Unlock(joinSemLock);
+            /* wait for someone to join us */
+            while (acquire_sem(me->md.joinSem) == B_INTERRUPTED);
+        }
+    }
 
-		if (bt_book.threadCount == 0 && bt_book.cleanUpSem != B_ERROR) {
-			/* we are the last user thread, and the primordial thread is
-			   blocked in PR_Cleanup() waiting for us to finish - notify
-			   it */
-			delete_sem(bt_book.cleanUpSem);
-	}
+    /* if this is a user thread, we must update our books */
+    if ((me->state & BT_THREAD_SYSTEM) == 0)
+    {
+        /* synchronize access to bt_book */
+        PR_Lock( bt_book.ml );
+        /* decrement the number of currently-alive user threads */
+        bt_book.threadCount--;
+        if (bt_book.threadCount == 0 && bt_book.cleanUpSem != B_ERROR) {
+            /* we are the last user thread, and the primordial thread is
+               blocked in PR_Cleanup() waiting for us to finish - notify
+               it */
+            delete_sem(bt_book.cleanUpSem);
+    }
 
     PR_Unlock( bt_book.ml );
-	}
+    }
 
-	/* finally, delete this thread's PRThread */
-	PR_DELETE(me);
+    /* finally, delete this thread's PRThread */
+    PR_DELETE(me);
 }
 
 /**
  * This is a wrapper that all threads invoke that allows us to set some
  * things up prior to a thread's invocation and clean up after a thread has
  * exited.
  */
 static void*
 _bt_root (void* arg)
-	{
+{
     PRThread *thred = (PRThread*)arg;
     PRIntn rv;
     void *privData;
     status_t result;
     int i;
 
-	/* save our PRThread object into our TLS */
-	tls_set(tls_prThreadSlot, thred);
-
+    /* save our PRThread object into our TLS */
+    tls_set(tls_prThreadSlot, thred);
     thred->startFunc(thred->arg);  /* run the dang thing */
+    /* clean up */
+    _bt_CleanupThread(NULL);
 
-	/* clean up */
-	_bt_CleanupThread(NULL);
-
-	return 0;
+    return 0;
 }
 
 PR_IMPLEMENT(PRThread*)
     PR_CreateThread (PRThreadType type, void (*start)(void* arg), void* arg,
                      PRThreadPriority priority, PRThreadScope scope,
                      PRThreadState state, PRUint32 stackSize)
 {
     PRUint32 bePriority;
-
     PRThread* thred;
 
     if (!_pr_initialized) _PR_ImplicitInitialization();
 
-	thred = PR_NEWZAP(PRThread);
- 	if (thred == NULL)
-	{
+    thred = PR_NEWZAP(PRThread);
+    if (thred == NULL)
+    {
         PR_SetError(PR_OUT_OF_MEMORY_ERROR, 0);
         return NULL;
     }
 
     thred->md.joinSem = B_ERROR;
+    thred->arg = arg;
+    thred->startFunc = start;
+    thred->priority = priority;
 
-        thred->arg = arg;
-        thred->startFunc = start;
-        thred->priority = priority;
-
-	if( state == PR_JOINABLE_THREAD )
-	{
-	    thred->state |= BT_THREAD_JOINABLE;
-	}
-
-        /* keep some books */
-
-	PR_Lock( bt_book.ml );
-
-	if (type == PR_USER_THREAD)
-	{
-	    bt_book.threadCount++;
-        }
+    if( state == PR_JOINABLE_THREAD )
+    {
+        thred->state |= BT_THREAD_JOINABLE;
+    }
 
-	PR_Unlock( bt_book.ml );
+    /* keep some books */
+    PR_Lock( bt_book.ml );
 
-	bePriority = _bt_MapNSPRToNativePriority( priority );
+    if (type == PR_USER_THREAD)
+    {
+        bt_book.threadCount++;
+    }
 
-        thred->md.tid = spawn_thread((thread_func)_bt_root, "moz-thread",
+    PR_Unlock( bt_book.ml );
+    bePriority = _bt_MapNSPRToNativePriority( priority );
+    thred->md.tid = spawn_thread((thread_func)_bt_root, "moz-thread",
                                      bePriority, thred);
-        if (thred->md.tid < B_OK) {
-            PR_SetError(PR_UNKNOWN_ERROR, thred->md.tid);
-            PR_DELETE(thred);
-			return NULL;
-        }
+    if (thred->md.tid < B_OK) {
+        PR_SetError(PR_UNKNOWN_ERROR, thred->md.tid);
+        PR_DELETE(thred);
+        return NULL;
+    }
 
-        if (resume_thread(thred->md.tid) < B_OK) {
-            PR_SetError(PR_UNKNOWN_ERROR, 0);
-            PR_DELETE(thred);
-			return NULL;
-        }
+    if (resume_thread(thred->md.tid) < B_OK) {
+        PR_SetError(PR_UNKNOWN_ERROR, 0);
+        PR_DELETE(thred);
+        return NULL;
+    }
 
     return thred;
-    }
+}
 
 PR_IMPLEMENT(PRThread*)
-	PR_AttachThread(PRThreadType type, PRThreadPriority priority,
-					PRThreadStack *stack)
+    PR_AttachThread(PRThreadType type, PRThreadPriority priority,
+                    PRThreadStack *stack)
 {
-	/* PR_GetCurrentThread() will attach a thread if necessary */
-	return PR_GetCurrentThread();
+    /* PR_GetCurrentThread() will attach a thread if necessary */
+    return PR_GetCurrentThread();
 }
 
 PR_IMPLEMENT(void)
-	PR_DetachThread()
+    PR_DetachThread()
 {
-	/* we don't support detaching */
+    /* we don't support detaching */
 }
 
 PR_IMPLEMENT(PRStatus)
     PR_JoinThread (PRThread* thred)
 {
     status_t eval, status;
 
     PR_ASSERT(thred != NULL);
 
-	if ((thred->state & BT_THREAD_JOINABLE) == 0)
+    if ((thred->state & BT_THREAD_JOINABLE) == 0)
+    {
+        PR_SetError( PR_INVALID_ARGUMENT_ERROR, 0 );
+        return( PR_FAILURE );
+    }
+
+    /* synchronize access to the thread's joinSem */
+    PR_Lock(joinSemLock);
+    
+    if (thred->md.is_joining)
     {
-	PR_SetError( PR_INVALID_ARGUMENT_ERROR, 0 );
-	return( PR_FAILURE );
+        /* another thread is already waiting to join the specified
+           thread - we must fail */
+        PR_Unlock(joinSemLock);
+        return PR_FAILURE;
     }
 
-	/* synchronize access to the thread's joinSem */
-	PR_Lock(joinSemLock);
-	
-	if (thred->md.is_joining)
-	{
-		/* another thread is already waiting to join the specified
-		   thread - we must fail */
-		PR_Unlock(joinSemLock);
-		return PR_FAILURE;
-	}
-
-	/* let others know we are waiting to join */
-	thred->md.is_joining = PR_TRUE;
-
-	if (thred->md.joinSem == B_ERROR)
-	{
-		/* the thread hasn't finished yet - it is our responsibility to
-		   allocate a joinSem and wait on it */
-		thred->md.joinSem = create_sem(0, "join sem");
-
-		/* we're done changing the joinSem now */
-		PR_Unlock(joinSemLock);
-
-		/* wait for the thread to finish */
-		while (acquire_sem(thred->md.joinSem) == B_INTERRUPTED);
-
-	}
-	else
-	{
-		/* the thread has already finished, and has allocated the
-		   joinSem itself - let it know it can finally die */
-		delete_sem(thred->md.joinSem);
-		
-		PR_Unlock(joinSemLock);
+    /* let others know we are waiting to join */
+    thred->md.is_joining = PR_TRUE;
+
+    if (thred->md.joinSem == B_ERROR)
+    {
+        /* the thread hasn't finished yet - it is our responsibility to
+           allocate a joinSem and wait on it */
+        thred->md.joinSem = create_sem(0, "join sem");
+
+        /* we're done changing the joinSem now */
+        PR_Unlock(joinSemLock);
+
+        /* wait for the thread to finish */
+        while (acquire_sem(thred->md.joinSem) == B_INTERRUPTED);
+
+    }
+    else
+    {
+        /* the thread has already finished, and has allocated the
+           joinSem itself - let it know it can finally die */
+        delete_sem(thred->md.joinSem);
+        
+        PR_Unlock(joinSemLock);
     }
 
-	/* make sure the thread is dead */
+    /* make sure the thread is dead */
     wait_for_thread(thred->md.tid, &eval);
 
     return PR_SUCCESS;
 }
 
 PR_IMPLEMENT(PRThread*)
     PR_GetCurrentThread ()
 {
     PRThread* thred;
 
     if (!_pr_initialized) _PR_ImplicitInitialization();
 
     thred = (PRThread *)tls_get( tls_prThreadSlot);
-	if (thred == NULL)
-	{
-		/* this thread doesn't have a PRThread structure (it must be
-		   a native thread not created by the NSPR) - assimilate it */
-		thred = _bt_AttachThread();
-	}
+    if (thred == NULL)
+    {
+        /* this thread doesn't have a PRThread structure (it must be
+           a native thread not created by the NSPR) - assimilate it */
+        thred = _bt_AttachThread();
+    }
     PR_ASSERT(NULL != thred);
 
     return thred;
 }
 
+PR_IMPLEMENT(void*)PR_GetSP(PRThread *thred)
+{
+    thread_info tInfo;
+    get_thread_info(thred->md.tid, &tInfo);
+    return tInfo.stack_base;  /* or should it be _end? */
+}
+
 PR_IMPLEMENT(PRThreadScope)
     PR_GetThreadScope (const PRThread* thred)
 {
     PR_ASSERT(thred != NULL);
     return PR_GLOBAL_THREAD;
 }
 
 PR_IMPLEMENT(PRThreadType)
@@ -448,17 +439,17 @@ PR_IMPLEMENT(PRThreadType)
         PR_SYSTEM_THREAD : PR_USER_THREAD;
 }
 
 PR_IMPLEMENT(PRThreadState)
     PR_GetThreadState (const PRThread* thred)
 {
     PR_ASSERT(thred != NULL);
     return (thred->state & BT_THREAD_JOINABLE)?
-    					PR_JOINABLE_THREAD: PR_UNJOINABLE_THREAD;
+                        PR_JOINABLE_THREAD: PR_UNJOINABLE_THREAD;
 }
 
 PR_IMPLEMENT(PRThreadPriority)
     PR_GetThreadPriority (const PRThread* thred)
 {
     PR_ASSERT(thred != NULL);
     return thred->priority;
 }  /* PR_GetThreadPriority */
@@ -474,82 +465,82 @@ PR_IMPLEMENT(void) PR_SetThreadPriority(
     bePriority = _bt_MapNSPRToNativePriority( newPri );
     set_thread_priority( thred->md.tid, bePriority );
 }
 
 PR_IMPLEMENT(PRStatus)
     PR_NewThreadPrivateIndex (PRUintn* newIndex,
                               PRThreadPrivateDTOR destructor)
 {
-	int32    index;
+    int32    index;
 
     if (!_pr_initialized) _PR_ImplicitInitialization();
 
-	/* reserve the next available tpd slot */
-	index = atomic_add( &tpd_slotsUsed, 1 );
-	if (index >= BT_TPD_LIMIT)
-	{
-		/* no slots left - decrement value, then fail */
-		atomic_add( &tpd_slotsUsed, -1 );
-		PR_SetError( PR_TPD_RANGE_ERROR, 0 );
-	    return( PR_FAILURE );
-	}
-
-	/* allocate a beos-native TLS slot for this index (the new slot
-	   automatically contains NULL) */
-	tpd_beosTLSSlots[index] = tls_allocate();
+    /* reserve the next available tpd slot */
+    index = atomic_add( &tpd_slotsUsed, 1 );
+    if (index >= BT_TPD_LIMIT)
+    {
+        /* no slots left - decrement value, then fail */
+        atomic_add( &tpd_slotsUsed, -1 );
+        PR_SetError( PR_TPD_RANGE_ERROR, 0 );
+        return( PR_FAILURE );
+    }
+
+    /* allocate a beos-native TLS slot for this index (the new slot
+       automatically contains NULL) */
+    tpd_beosTLSSlots[index] = tls_allocate();
 
-	/* remember the destructor */
-	tpd_dtors[index] = destructor;
+    /* remember the destructor */
+    tpd_dtors[index] = destructor;
 
     *newIndex = (PRUintn)index;
 
     return( PR_SUCCESS );
 }
 
 PR_IMPLEMENT(PRStatus)
     PR_SetThreadPrivate (PRUintn index, void* priv)
 {
-	void *oldValue;
+    void *oldValue;
 
     /*
     ** Sanity checking
     */
 
     if(index < 0 || index >= tpd_slotsUsed || index >= BT_TPD_LIMIT)
     {
-		PR_SetError( PR_TPD_RANGE_ERROR, 0 );
-	return( PR_FAILURE );
+        PR_SetError( PR_TPD_RANGE_ERROR, 0 );
+        return( PR_FAILURE );
     }
 
-	/* if the old value isn't NULL, and the dtor for this slot isn't
-	   NULL, we must destroy the data */
-	oldValue = tls_get(tpd_beosTLSSlots[index]);
-	if (oldValue != NULL && tpd_dtors[index] != NULL)
-		(*tpd_dtors[index])(oldValue);
+    /* if the old value isn't NULL, and the dtor for this slot isn't
+       NULL, we must destroy the data */
+    oldValue = tls_get(tpd_beosTLSSlots[index]);
+    if (oldValue != NULL && tpd_dtors[index] != NULL)
+        (*tpd_dtors[index])(oldValue);
 
-	/* save new value */
-	tls_set(tpd_beosTLSSlots[index], priv);
+    /* save new value */
+    tls_set(tpd_beosTLSSlots[index], priv);
 
-	    return( PR_SUCCESS );
-	}
+    return( PR_SUCCESS );
+}
 
 PR_IMPLEMENT(void*)
     PR_GetThreadPrivate (PRUintn index)
 {
-	/* make sure the index is valid */
-	if (index < 0 || index >= tpd_slotsUsed || index >= BT_TPD_LIMIT)
+    /* make sure the index is valid */
+    if (index < 0 || index >= tpd_slotsUsed || index >= BT_TPD_LIMIT)
     {   
-		PR_SetError( PR_TPD_RANGE_ERROR, 0 );
-		return NULL;
+        PR_SetError( PR_TPD_RANGE_ERROR, 0 );
+        return NULL;
     }
 
-	/* return the value */
-	return tls_get( tpd_beosTLSSlots[index] );
-	}
+    /* return the value */
+    return tls_get( tpd_beosTLSSlots[index] );
+}
 
 
 PR_IMPLEMENT(PRStatus)
     PR_Interrupt (PRThread* thred)
 {
     PRIntn rv;
 
     PR_ASSERT(thred != NULL);
@@ -622,73 +613,73 @@ PR_IMPLEMENT(PRStatus)
 
     PR_ASSERT(me->state & BT_THREAD_PRIMORD);
     if ((me->state & BT_THREAD_PRIMORD) == 0) {
         return PR_FAILURE;
     }
 
     PR_Lock( bt_book.ml );
 
-	if (bt_book.threadCount != 0)
+    if (bt_book.threadCount != 0)
     {
-		/* we'll have to wait for some threads to finish - create a
-		   sem to block on */
-		bt_book.cleanUpSem = create_sem(0, "cleanup sem");
+        /* we'll have to wait for some threads to finish - create a
+           sem to block on */
+        bt_book.cleanUpSem = create_sem(0, "cleanup sem");
     }
 
     PR_Unlock( bt_book.ml );
 
-	/* note that, if all the user threads were already dead, we
-	   wouldn't have created a sem above, so this acquire_sem()
-	   will fail immediately */
-	while (acquire_sem(bt_book.cleanUpSem) == B_INTERRUPTED);
+    /* note that, if all the user threads were already dead, we
+       wouldn't have created a sem above, so this acquire_sem()
+       will fail immediately */
+    while (acquire_sem(bt_book.cleanUpSem) == B_INTERRUPTED);
 
     return PR_SUCCESS;
 }
 
 PR_IMPLEMENT(void)
     PR_ProcessExit (PRIntn status)
 {
     exit(status);
 }
 
 PRThread *_bt_AttachThread()
 {
-	PRThread *thread;
-	thread_info tInfo;
+    PRThread *thread;
+    thread_info tInfo;
 
-	/* make sure this thread doesn't already have a PRThread structure */
-	PR_ASSERT(tls_get(tls_prThreadSlot) == NULL);
+    /* make sure this thread doesn't already have a PRThread structure */
+    PR_ASSERT(tls_get(tls_prThreadSlot) == NULL);
 
-	/* allocate a PRThread structure for this thread */
-	thread = PR_NEWZAP(PRThread);
-	if (thread == NULL)
-	{
-		PR_SetError(PR_OUT_OF_MEMORY_ERROR, 0);
-		return NULL;
-	}
-
-	/* get the native thread's current state */
-	get_thread_info(find_thread(NULL), &tInfo);
-
-	/* initialize new PRThread */
-	thread->md.tid = tInfo.thread;
-	thread->md.joinSem = B_ERROR;
-	thread->priority = _bt_MapNativeToNSPRPriority(tInfo.priority);
-
-	/* attached threads are always non-joinable user threads */
-	thread->state = 0;
-
-	/* increment user thread count */
-	PR_Lock(bt_book.ml);
-	bt_book.threadCount++;
-	PR_Unlock(bt_book.ml);
-
-	/* store this thread's PRThread */
-	tls_set(tls_prThreadSlot, thread);
-	
-	/* the thread must call _bt_CleanupThread() before it dies, in order
-	   to clean up its PRThread, synchronize with the primordial thread,
-	   etc. */
-	on_exit_thread(_bt_CleanupThread, NULL);
-	
-	return thread;
+    /* allocate a PRThread structure for this thread */
+    thread = PR_NEWZAP(PRThread);
+    if (thread == NULL)
+    {
+        PR_SetError(PR_OUT_OF_MEMORY_ERROR, 0);
+        return NULL;
+    }
+
+    /* get the native thread's current state */
+    get_thread_info(find_thread(NULL), &tInfo);
+
+    /* initialize new PRThread */
+    thread->md.tid = tInfo.thread;
+    thread->md.joinSem = B_ERROR;
+    thread->priority = _bt_MapNativeToNSPRPriority(tInfo.priority);
+
+    /* attached threads are always non-joinable user threads */
+    thread->state = 0;
+
+    /* increment user thread count */
+    PR_Lock(bt_book.ml);
+    bt_book.threadCount++;
+    PR_Unlock(bt_book.ml);
+
+    /* store this thread's PRThread */
+    tls_set(tls_prThreadSlot, thread);
+    
+    /* the thread must call _bt_CleanupThread() before it dies, in order
+       to clean up its PRThread, synchronize with the primordial thread,
+       etc. */
+    on_exit_thread(_bt_CleanupThread, NULL);
+    
+    return thread;
 }
Index: mozilla/nsprpub/pr/src/io/Makefile.in
===================================================================
RCS file: /cvsroot/mozilla/nsprpub/pr/src/io/Makefile.in,v
retrieving revision 1.13
diff -u -8 -p -r1.13 Makefile.in
--- mozilla/nsprpub/pr/src/io/Makefile.in	25 Apr 2004 15:00:58 -0000	1.13
+++ mozilla/nsprpub/pr/src/io/Makefile.in	9 Feb 2009 04:04:39 -0000
@@ -64,23 +64,25 @@ CSRCS = \
 	prmmap.c \
     prpolevt.c \
 	prprf.c \
 	prscanf.c \
 	prstdio.c  \
 	$(NULL)
 
 ifndef USE_PTHREADS
+ifndef USE_BTHREADS
     CSRCS += \
 	    prdir.c \
 	    prfile.c \
 	    prio.c \
 	    prsocket.c \
 	    $(NULL)
 endif
+endif
 
 TARGETS	= $(OBJS)
 
 INCLUDES = -I$(dist_includedir) -I$(topsrcdir)/pr/include -I$(topsrcdir)/pr/include/private
 
 DEFINES	+= -D_NSPR_BUILD_
 
 include $(topsrcdir)/config/rules.mk
Index: mozilla/nsprpub/pr/src/io/prmapopt.c
===================================================================
RCS file: /cvsroot/mozilla/nsprpub/pr/src/io/prmapopt.c,v
retrieving revision 3.18
diff -u -8 -p -r3.18 prmapopt.c
--- mozilla/nsprpub/pr/src/io/prmapopt.c	25 Apr 2004 15:00:58 -0000	3.18
+++ mozilla/nsprpub/pr/src/io/prmapopt.c	9 Feb 2009 04:04:40 -0000
@@ -69,17 +69,17 @@
 /* NEXTSTEP is special: this must come before netinet/tcp.h. */
 #include <netinet/in_systm.h>  /* n_short, n_long, n_time */
 #endif
 
 #if defined(XP_UNIX) || defined(OS2) || (defined(XP_BEOS) && defined(BONE_VERSION))
 #include <netinet/tcp.h>  /* TCP_NODELAY, TCP_MAXSEG */
 #endif
 
-#ifndef _PR_PTHREADS
+#if !defined(_PR_PTHREADS) && !defined(_PR_BTHREADS)
 
 PRStatus PR_CALLBACK _PR_SocketGetSocketOption(PRFileDesc *fd, PRSocketOptionData *data)
 {
     PRStatus rv;
     PRInt32 length;
     PRInt32 level, name;
 
     /*
@@ -94,34 +94,29 @@ PRStatus PR_CALLBACK _PR_SocketGetSocket
 
     rv = _PR_MapOptionName(data->option, &level, &name);
     if (PR_SUCCESS == rv)
     {
         switch (data->option)
         {
             case PR_SockOpt_Linger:
             {
-#if !defined(XP_BEOS) || defined(BONE_VERSION)
                 struct linger linger;
                 length = sizeof(linger);
                 rv = _PR_MD_GETSOCKOPT(
                     fd, level, name, (char *) &linger, &length);
                 if (PR_SUCCESS == rv)
                 {
                     PR_ASSERT(sizeof(linger) == length);
                     data->value.linger.polarity =
                         (linger.l_onoff) ? PR_TRUE : PR_FALSE;
                     data->value.linger.linger =
                         PR_SecondsToInterval(linger.l_linger);
                 }
                 break;
-#else
-                PR_SetError( PR_NOT_IMPLEMENTED_ERROR, 0 );
-                return PR_FAILURE;
-#endif
             }
             case PR_SockOpt_Reuseaddr:
             case PR_SockOpt_Keepalive:
             case PR_SockOpt_NoDelay:
             case PR_SockOpt_Broadcast:
             {
 #ifdef WIN32 /* Winsock */
                 BOOL value;
@@ -252,27 +247,22 @@ PRStatus PR_CALLBACK _PR_SocketSetSocket
 
     rv = _PR_MapOptionName(data->option, &level, &name);
     if (PR_SUCCESS == rv)
     {
         switch (data->option)
         {
             case PR_SockOpt_Linger:
             {
-#if !defined(XP_BEOS) || defined(BONE_VERSION)
                 struct linger linger;
                 linger.l_onoff = data->value.linger.polarity;
                 linger.l_linger = PR_IntervalToSeconds(data->value.linger.linger);
                 rv = _PR_MD_SETSOCKOPT(
                     fd, level, name, (char*)&linger, sizeof(linger));
                 break;
-#else
-                PR_SetError( PR_NOT_IMPLEMENTED_ERROR, 0 );
-                return PR_FAILURE;
-#endif
             }
             case PR_SockOpt_Reuseaddr:
             case PR_SockOpt_Keepalive:
             case PR_SockOpt_NoDelay:
             case PR_SockOpt_Broadcast:
             {
 #ifdef WIN32 /* Winsock */
                 BOOL value;
@@ -350,17 +340,17 @@ PRStatus PR_CALLBACK _PR_SocketSetSocket
             default:
                 PR_NOT_REACHED("Unknown socket option");
                 break;
         }  
     }
     return rv;
 }  /* _PR_SocketSetSocketOption */
 
-#endif /* ! _PR_PTHREADS */
+#endif /* ! _PR_PTHREADS && ! _PR_BTHREADS */
 
 /*
  *********************************************************************
  *********************************************************************
  **
  ** Make sure that the following is at the end of this file,
  ** because we will be playing with macro redefines.
  **
Index: mozilla/nsprpub/pr/src/io/prsocket.c
===================================================================
RCS file: /cvsroot/mozilla/nsprpub/pr/src/io/prsocket.c,v
retrieving revision 3.57.2.2
diff -u -8 -p -r3.57.2.2 prsocket.c
--- mozilla/nsprpub/pr/src/io/prsocket.c	7 Nov 2007 22:24:04 -0000	3.57.2.2
+++ mozilla/nsprpub/pr/src/io/prsocket.c	9 Feb 2009 04:04:44 -0000
@@ -59,17 +59,17 @@ PRBool IsValidNetAddr(const PRNetAddr *a
 
 static PRBool IsValidNetAddrLen(const PRNetAddr *addr, PRInt32 addr_len)
 {
     /*
      * The definition of the length of a Unix domain socket address
      * is not uniform, so we don't check it.
      */
     if ((addr != NULL)
-#if defined(XP_UNIX) || defined(XP_OS2_EMX)
+#if defined(XP_UNIX) || defined(XP_OS2_EMX) || defined(XP_BEOS)
             && (addr->raw.family != AF_UNIX)
 #endif
             && (PR_NETADDR_SIZE(addr) != addr_len)) {
 #if defined(LINUX) && __GLIBC__ == 2 && __GLIBC_MINOR__ == 1
         /*
          * In glibc 2.1, struct sockaddr_in6 is 24 bytes.  In glibc 2.2
          * and in the 2.4 kernel, struct sockaddr_in6 has the scope_id
          * field and is 28 bytes.  It is possible for socket functions
Index: mozilla/nsprpub/pr/src/linking/prlink.c
===================================================================
RCS file: /cvsroot/mozilla/nsprpub/pr/src/linking/prlink.c,v
retrieving revision 3.81.2.5
diff -u -8 -p -r3.81.2.5 prlink.c
--- mozilla/nsprpub/pr/src/linking/prlink.c	6 Oct 2006 23:36:22 -0000	3.81.2.5
+++ mozilla/nsprpub/pr/src/linking/prlink.c	9 Feb 2009 04:04:49 -0000
@@ -194,18 +194,20 @@ struct PRLibrary {
     NSModule                    dlh;
 #else
     void*                       dlh;
 #endif 
 #endif 
 
 #ifdef XP_BEOS
     void*                       dlh;
+#ifndef XP_HAIKU
     void*                       stub_dlh;
 #endif
+#endif
 };
 
 static PRLibrary *pr_loadmap;
 static PRLibrary *pr_exe_loadmap;
 static PRMonitor *pr_linker_lock;
 static char* _pr_currentLibPath = NULL;
 
 static PRLibrary *pr_LoadLibraryByPathname(const char *name, PRIntn flags);
@@ -844,16 +846,29 @@ pr_LoadLibraryByPathname(const char *nam
     }
     /* the list of loaded library names are always kept in UTF-8 
      * on Win32 platforms */
     result = pr_UnlockedFindLibrary(utf8name);
 #else
     result = pr_UnlockedFindLibrary(name);
 #endif
 
+#ifdef XP_BEOS
+    /* Havn't seen this happen so far, but it doesn't slow anything
+       down so let's keep it */
+    for (result = pr_loadmap; result != NULL; result = result->next) {
+        /* hopefully, our caller will always use the same string
+           to refer to the same library */
+        if (strcmp(name, result->name) == 0) {
+            result->refCount++;
+            break;
+        }
+    }
+#endif
+
     if (result != NULL) goto unlock;
 
     lm = PR_NEWZAP(PRLibrary);
     if (lm == NULL) {
         oserr = _MD_ERRNO();
         goto unlock;
     }
     lm->staticTable = NULL;
@@ -997,108 +1012,97 @@ pr_LoadLibraryByPathname(const char *nam
     lm->name = strdup(name);
     lm->dlh = h;
     lm->next = pr_loadmap;
     pr_loadmap = lm;
     }
 #endif /* HAVE_DLL */
 #endif /* XP_UNIX */
 
-    lm->refCount = 1;
-
 #ifdef XP_BEOS
-    {
-        image_info info;
-        int32 cookie = 0;
+    {	/* Code block to allow variable inits. :/ */
+        /* it appears the library isn't yet loaded - load it now */
+#ifdef XP_HAIKU
+        image_id imageid = load_add_on(name);
+#else
         image_id imageid = B_ERROR;
         image_id stubid = B_ERROR;
-        PRLibrary *p;
+        char stubName [B_PATH_NAME_LENGTH + 1];
 
-        for (p = pr_loadmap; p != NULL; p = p->next) {
-            /* hopefully, our caller will always use the same string
-               to refer to the same library */
-            if (strcmp(name, p->name) == 0) {
-                /* we've already loaded this library */
-                imageid = info.id;
-                lm->refCount++;
-                break;
-            }
-        }
+        /* the following is a work-around to a "bug" in the beos -
+           the beos system loader allows only 32M (system-wide)
+           to be used by code loaded as "add-ons" (code loaded
+           through the 'load_add_on()' system call, which includes
+           mozilla components), but allows 256M to be used by
+           shared libraries.
+
+           unfortunately, mozilla is too large to fit into the
+           "add-on" space, so we must trick the loader into
+           loading some of the components as shared libraries.  this
+           is accomplished by creating a "stub" add-on (an empty
+           shared object), and linking it with the component
+           (the actual .so file generated by the build process,
+           without any modifications).  when this stub is loaded
+           by load_add_on(), the loader will automatically load the
+           component into the shared library space.
+        */
 
-        if(imageid == B_ERROR) {
-            /* it appears the library isn't yet loaded - load it now */
-            char stubName [B_PATH_NAME_LENGTH + 1];
-
-            /* the following is a work-around to a "bug" in the beos -
-               the beos system loader allows only 32M (system-wide)
-               to be used by code loaded as "add-ons" (code loaded
-               through the 'load_add_on()' system call, which includes
-               mozilla components), but allows 256M to be used by
-               shared libraries.
-               
-               unfortunately, mozilla is too large to fit into the
-               "add-on" space, so we must trick the loader into
-               loading some of the components as shared libraries.  this
-               is accomplished by creating a "stub" add-on (an empty
-               shared object), and linking it with the component
-               (the actual .so file generated by the build process,
-               without any modifications).  when this stub is loaded
-               by load_add_on(), the loader will automatically load the
-               component into the shared library space.
-            */
-
-            strcpy(stubName, name);
-            strcat(stubName, ".stub");
-
-            /* first, attempt to load the stub (thereby loading the
-               component as a shared library */
-            if ((stubid = load_add_on(stubName)) > B_ERROR) {
-                /* the stub was loaded successfully. */
-                imageid = B_FILE_NOT_FOUND;
-
-                cookie = 0;
-                while (get_next_image_info(0, &cookie, &info) == B_OK) {
-                    const char *endOfSystemName = strrchr(info.name, '/');
-                    const char *endOfPassedName = strrchr(name, '/');
-                    if( 0 == endOfSystemName ) 
-                        endOfSystemName = info.name;
-                    else
-                        endOfSystemName++;
-                    if( 0 == endOfPassedName )
-                        endOfPassedName = name;
-                    else
-                        endOfPassedName++;
-                    if (strcmp(endOfSystemName, endOfPassedName) == 0) {
-                        /* this is the actual component - remember it */
-                        imageid = info.id;
-                        break;
-                    }
-                }
+        strcpy(stubName, name);
+        strcat(stubName, ".stub");
 
-            } else {
-                /* we failed to load the "stub" - try to load the
-                   component directly as an add-on */
-                stubid = B_ERROR;
-                imageid = load_add_on(name);
+        /* first, attempt to load the stub (thereby loading the
+           component as a shared library */
+        if ((stubid = load_add_on(stubName)) > B_ERROR) {
+
+            const char *endOfPassedName = strrchr(name, '/');
+            image_info info;
+            int32 cookie = 0;
+
+            /* the stub was loaded successfully. */
+            imageid = B_FILE_NOT_FOUND;
+            if( 0 == endOfPassedName )
+                endOfPassedName = name;
+            else
+                endOfPassedName++;
+
+            while (get_next_image_info(0, &cookie, &info) == B_OK) {
+                const char *endOfSystemName = strrchr(info.name, '/');
+                if( 0 == endOfSystemName ) 
+                    endOfSystemName = info.name;
+                else
+                    endOfSystemName++;
+                if (strcmp(endOfSystemName, endOfPassedName) == 0) {
+                    /* this is the actual component - remember it */
+                    imageid = info.id;
+                    break;
+                }
             }
+        } else {
+            /* we failed to load the "stub" - try to load the
+               component directly as an add-on */
+            stubid = B_ERROR;
+            imageid = load_add_on(name);
         }
-
+#endif /* XP_HAIKU */
         if (imageid <= B_ERROR) {
             oserr = imageid;
-            PR_DELETE( lm );
+            PR_DELETE(lm);
             goto unlock;
         }
         lm->name = strdup(name);
         lm->dlh = (void*)imageid;
+#ifndef XP_HAIKU
         lm->stub_dlh = (void*)stubid;
+#endif
         lm->next = pr_loadmap;
         pr_loadmap = lm;
     }
-#endif
+#endif /* XP_BEOS */
 
+    lm->refCount = 1;
     result = lm;    /* success */
     PR_LOG(_pr_linker_lm, PR_LOG_MIN, ("Loaded library %s (load lib)", lm->name));
 
   unlock:
     if (result == NULL) {
         PR_SetError(PR_LOAD_LIBRARY_ERROR, oserr);
         DLLErrorInternal(oserr);  /* sets error text */
     }
@@ -1249,21 +1253,25 @@ PR_UnloadLibrary(PRLibrary *lib)
     if (--lib->refCount > 0) {
     PR_LOG(_pr_linker_lm, PR_LOG_MIN,
            ("%s decr => %d",
         lib->name, lib->refCount));
     goto done;
     }
 
 #ifdef XP_BEOS
+#ifdef XP_HAIKU
+    unload_add_on( (image_id) lib->dlh );
+#else
     if(((image_id)lib->stub_dlh) == B_ERROR)
         unload_add_on( (image_id) lib->dlh );
     else
         unload_add_on( (image_id) lib->stub_dlh);
-#endif
+#endif /* XP_HAIKU */
+#endif /* XP_BEOS */
 
 #ifdef XP_UNIX
 #ifdef HAVE_DLL
 #ifdef USE_DLFCN
     result = dlclose(lib->dlh);
 #elif defined(USE_HPSHL)
     result = shl_unload(lib->dlh);
 #elif defined(USE_MACH_DYLD)
Index: mozilla/nsprpub/pr/src/md/beos/beos.c
===================================================================
RCS file: /cvsroot/mozilla/nsprpub/pr/src/md/beos/beos.c,v
retrieving revision 3.5
diff -u -8 -p -r3.5 beos.c
--- mozilla/nsprpub/pr/src/md/beos/beos.c	25 Apr 2004 15:00:59 -0000	3.5
+++ mozilla/nsprpub/pr/src/md/beos/beos.c	9 Feb 2009 04:04:50 -0000
@@ -32,233 +32,178 @@
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "primpl.h"
 
-#include <signal.h>
-#include <unistd.h>
-#include <memory.h>
-#include <fcntl.h>
-#include <sys/types.h>
-#include <sys/socket.h>
 #include <sys/time.h>
-#include <sys/ioctl.h>
-#include <errno.h>
-
 /*
  * Make sure _PRSockLen_t is 32-bit, because we will cast a PRUint32* or
  * PRInt32* pointer to a _PRSockLen_t* pointer.
  */
 #define _PRSockLen_t int
 
-/*
-** Global lock variable used to bracket calls into rusty libraries that
-** aren't thread safe (like libc, libX, etc).
-*/
-static PRLock *_pr_rename_lock = NULL;
-static PRMonitor *_pr_Xfe_mon = NULL;
 
-/*
- * Variables used by the GC code, initialized in _MD_InitSegs().
- * _pr_zero_fd should be a static variable.  Unfortunately, there is
- * still some Unix-specific code left in function PR_GrowSegment()
- * in file memory/prseg.c that references it, so it needs
- * to be a global variable for now.
- */
-PRInt32 _pr_zero_fd = -1;
-static PRLock *_pr_md_lock = NULL;
+#ifndef BONE_VERSION
+PRLock *_connectLock = NULL;
 
-sigset_t timer_set;
+/* Workaround for nonblocking connects under net_server */
+PRUint32 connectCount = 0;
+ConnectListNode connectList[64];
 
-void _PR_UnixInit()
+void
+_MD_final_init_netserver(void)
 {
-	struct sigaction sigact;
-	int rv;
-
-	sigemptyset(&timer_set);
-
-	sigact.sa_handler = SIG_IGN;
-	sigemptyset(&sigact.sa_mask);
-	sigact.sa_flags = 0;
-	rv = sigaction(SIGPIPE, &sigact, 0);
-	PR_ASSERT(0 == rv);
-
-	_pr_rename_lock = PR_NewLock();
-	PR_ASSERT(NULL != _pr_rename_lock);
-	_pr_Xfe_mon = PR_NewMonitor();
-	PR_ASSERT(NULL != _pr_Xfe_mon);
+    _connectLock = PR_NewLock();
+    PR_ASSERT(NULL != _connectLock); 
+    /* Workaround for nonblocking connects under net_server */
+    connectCount = 0;
 }
+#endif /* !BONE_VERSION */
 
-/*
- *-----------------------------------------------------------------------
- *
- * PR_Now --
- *
- *     Returns the current time in microseconds since the epoch.
- *     The epoch is midnight January 1, 1970 GMT.
- *     The implementation is machine dependent.  This is the Unix
- *     implementation.
- *     Cf. time_t time(time_t *tp)
- *
- *-----------------------------------------------------------------------
- */
-
-PR_IMPLEMENT(PRTime)
-PR_Now(void)
-{
-	struct timeval tv;
-	PRInt64 s, us, s2us;
 
-	GETTIMEOFDAY(&tv);
-	LL_I2L(s2us, PR_USEC_PER_SEC);
-	LL_I2L(s, tv.tv_sec);
-	LL_I2L(us, tv.tv_usec);
-	LL_MUL(s, s, s2us);
-	LL_ADD(s, s, us);
-	return s;
-}
+#ifdef __powerpc__
+static PRLock *monitor = NULL;
 
-PRIntervalTime
-_PR_UNIX_GetInterval()
+void
+_MD_AtomicInit(void)
 {
-	struct timeval time;
-	PRIntervalTime ticks;
-
-	(void)GETTIMEOFDAY(&time);  /* fallicy of course */
-	ticks = (PRUint32)time.tv_sec * PR_MSEC_PER_SEC;  /* that's in milliseconds */
-	ticks += (PRUint32)time.tv_usec / PR_USEC_PER_MSEC;  /* so's that */
-	return ticks;
-}  /* _PR_SUNOS_GetInterval */
-
-PRIntervalTime _PR_UNIX_TicksPerSecond()
-{
-	return 1000;  /* this needs some work :) */
+    if (monitor == NULL) {
+        monitor = PR_NewLock();
+    }
 }
-
-/************************************************************************/
+#endif /* __powerpc__ */
 
 /*
-** Special hacks for xlib. Xlib/Xt/Xm is not re-entrant nor is it thread
-** safe.  Unfortunately, neither is mozilla. To make these programs work
-** in a pre-emptive threaded environment, we need to use a lock.
+** This is exceedingly messy.  atomic_add returns the last value, NSPR
+** expects the new value. We just add or subtract 1 from the result.
+** The actual memory update is atomic.
 */
 
-void PR_XLock()
+PRInt32
+_MD_AtomicAdd( PRInt32 *ptr, PRInt32 val )
 {
-	PR_EnterMonitor(_pr_Xfe_mon);
+    return atomic_add( (long *)ptr, val ) + val;
 }
 
-void PR_XUnlock()
+PRInt32
+_MD_AtomicIncrement( PRInt32 *val )
 {
-	PR_ExitMonitor(_pr_Xfe_mon);
+    return atomic_add( (long *)val, 1 ) + 1;
 }
 
-PRBool PR_XIsLocked()
+PRInt32
+_MD_AtomicDecrement( PRInt32 *val )
 {
-	return (PR_InMonitor(_pr_Xfe_mon)) ? PR_TRUE : PR_FALSE;
+    return atomic_add( (long *)val, -1 ) - 1;
 }
 
-void PR_XWait(int ms)
+PRInt32
+_MD_AtomicSet( PRInt32 *val, PRInt32 newval )
 {
-	PR_Wait(_pr_Xfe_mon, PR_MillisecondsToInterval(ms));
-}
-
-void PR_XNotify(void)
-{
-	PR_Notify(_pr_Xfe_mon);
-}
+    PRInt32 result;
+#ifdef __powerpc__
+    if (!_pr_initialized) {
+        _PR_ImplicitInitialization();
+    }
+    PR_Lock(monitor);
+    result = *val;
+    *val = newval;
+    PR_Unlock(monitor);
+#else
+    asm volatile ("xchgl %0, %1" 
+                : "=r"(result), "=m"(*val)
+                : "0"(newval), "m"(*val));
 
-void PR_XNotifyAll(void)
-{
-	PR_NotifyAll(_pr_Xfe_mon);
+#endif /* __powerpc__ */
+  return result;
 }
 
-#if !defined(BEOS)
-#ifdef HAVE_BSD_FLOCK
-
-#include <sys/file.h>
+/*
+ *-----------------------------------------------------------------------
+ *
+ * PR_Now --
+ *
+ *     Returns the current time in microseconds since the epoch.
+ *     The epoch is midnight January 1, 1970 GMT.
+ *     The implementation is machine dependent.  
+ *
+ *-----------------------------------------------------------------------
+ */
 
-PR_IMPLEMENT(PRStatus)
-_MD_LOCKFILE (PRInt32 f)
+PR_IMPLEMENT(PRTime)
+PR_Now(void)
 {
-	PRInt32 rv;
-	rv = flock(f, LOCK_EX);
-	if (rv == 0)
-		return PR_SUCCESS;
-	_PR_MD_MAP_FLOCK_ERROR(_MD_ERRNO());
-	return PR_FAILURE;
+    return (PRTime) real_time_clock_usecs();
 }
 
-PR_IMPLEMENT(PRStatus)
-_MD_TLOCKFILE (PRInt32 f)
+PRIntervalTime
+_MD_get_interval(void)
 {
-	PRInt32 rv;
-	rv = flock(f, LOCK_EX|LOCK_NB);
-	if (rv == 0)
-		return PR_SUCCESS;
-	_PR_MD_MAP_FLOCK_ERROR(_MD_ERRNO());
-	return PR_FAILURE;
+    return (PRIntervalTime) real_time_clock_usecs() / 10;
 }
 
-PR_IMPLEMENT(PRStatus)
-_MD_UNLOCKFILE (PRInt32 f)
+PRIntervalTime
+_MD_interval_per_sec(void)
 {
-	PRInt32 rv;
-	rv = flock(f, LOCK_UN);
-	if (rv == 0)
-		return PR_SUCCESS;
-	_PR_MD_MAP_FLOCK_ERROR(_MD_ERRNO());
-	return PR_FAILURE;
+    return 100000L;
 }
-#else
 
-PR_IMPLEMENT(PRStatus)
-_MD_LOCKFILE (PRInt32 f)
+PRSize
+_PR_MD_GetRandomNoise( void *buf, PRSize size )
 {
-	PRInt32 rv;
-	rv = lockf(f, F_LOCK, 0);
-	if (rv == 0)
-		return PR_SUCCESS;
-	_PR_MD_MAP_LOCKF_ERROR(_MD_ERRNO());
-	return PR_FAILURE;
-}
+    struct timeval tv;
+    int n = 0;
+    int s;
 
-PR_IMPLEMENT(PRStatus)
-_MD_TLOCKFILE (PRInt32 f)
-{
-	PRInt32 rv;
-	rv = lockf(f, F_TLOCK, 0);
-	if (rv == 0)
-		return PR_SUCCESS;
-	_PR_MD_MAP_LOCKF_ERROR(_MD_ERRNO());
-	return PR_FAILURE;
-}
+    GETTIMEOFDAY(&tv);
+
+    if ( size >= 0 ) {
+        s = _pr_CopyLowBits((char*)buf+n, size, &tv.tv_usec, sizeof(tv.tv_usec));
+        size -= s;
+        n += s;
+    }
+    if ( size >= 0 ) {
+        s = _pr_CopyLowBits((char*)buf+n, size, &tv.tv_sec, sizeof(tv.tv_sec));
+        size -= s;
+        n += s;
+    }
+    return n;
+} /* end _PR_MD_GetRandomNoise() */
 
-PR_IMPLEMENT(PRStatus)
-_MD_UNLOCKFILE (PRInt32 f)
+
+/* Needed by prinit.c:612 */
+void
+_PR_MD_QUERY_FD_INHERITABLE(PRFileDesc *fd)
 {
-	PRInt32 rv;
-	rv = lockf(f, F_ULOCK, 0);
-	if (rv == 0)
-		return PR_SUCCESS;
-	_PR_MD_MAP_LOCKF_ERROR(_MD_ERRNO());
-	return PR_FAILURE;
+    int flags;
+
+    PR_ASSERT(_PR_TRI_UNKNOWN == fd->secret->inheritable);
+    flags = fcntl(fd->secret->md.osfd, F_GETFD, 0);
+    PR_ASSERT(-1 != flags);
+    fd->secret->inheritable = (flags & FD_CLOEXEC) ?
+        _PR_TRI_FALSE : _PR_TRI_TRUE;
 }
-#endif
 
-PR_IMPLEMENT(PRStatus)
-  _MD_GETHOSTNAME (char *name, PRUint32 namelen)
+PRStatus
+_MD_gethostname(char *name, PRUint32 namelen)
 {
-    PRIntn rv;
+    PRInt32 rv, err;
 
     rv = gethostname(name, namelen);
-    if (0 == rv) {
-		return PR_SUCCESS;
+    if (rv == 0)
+    {
+        err = _MD_ERRNO();
+        switch (err) {
+            case EFAULT:
+                PR_SetError(PR_ACCESS_FAULT_ERROR, err);
+                break;
+            default:
+                PR_SetError(PR_UNKNOWN_ERROR, err);
+                break;
+        }
+        return PR_FAILURE;
     }
-	_PR_MD_MAP_GETHOSTNAME_ERROR(_MD_ERRNO());
-    return PR_FAILURE;
+    return PR_SUCCESS;
 }
-
-#endif
Index: mozilla/nsprpub/pr/src/md/beos/bproc.c
===================================================================
RCS file: /cvsroot/mozilla/nsprpub/pr/src/md/beos/bproc.c,v
retrieving revision 3.6
diff -u -8 -p -r3.6 bproc.c
--- mozilla/nsprpub/pr/src/md/beos/bproc.c	25 Apr 2004 15:00:59 -0000	3.6
+++ mozilla/nsprpub/pr/src/md/beos/bproc.c	9 Feb 2009 04:04:50 -0000
@@ -31,207 +31,209 @@
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "primpl.h"
-#include <stdio.h>
+#include <errno.h>
 #include <signal.h>
+#include <stdio.h>
+#include <sys/wait.h>
 
 #define _PR_SIGNALED_EXITSTATUS 256
 
 PRProcess*
 _MD_create_process (const char *path, char *const *argv,
-		    char *const *envp, const PRProcessAttr *attr)
+            char *const *envp, const PRProcessAttr *attr)
 {
-	PRProcess *process;
-	int nEnv, idx;
-	char *const *childEnvp;
-	char **newEnvp = NULL;
-	int flags;
-
-	process = PR_NEW(PRProcess);
-	if (!process) {
-		PR_SetError(PR_OUT_OF_MEMORY_ERROR, 0);
-		return NULL;
-	}
-
-	childEnvp = envp;
-	if (attr && attr->fdInheritBuffer) {
-		if (NULL == childEnvp) {
-			childEnvp = environ;
-		}
-		for (nEnv = 0; childEnvp[nEnv]; nEnv++) {
-		}
-		newEnvp = (char **) PR_MALLOC((nEnv + 2) * sizeof(char *));
-		if (NULL == newEnvp) {
-			PR_DELETE(process);
-			PR_SetError(PR_OUT_OF_MEMORY_ERROR, 0);
-			return NULL;
-		}
-		for (idx = 0; idx < nEnv; idx++) {
-			newEnvp[idx] = childEnvp[idx];
-		}
-		newEnvp[idx++] = attr->fdInheritBuffer;
-		newEnvp[idx] = NULL;
-		childEnvp = newEnvp;
-	}
-
-	process->md.pid = fork();
-
-	if ((pid_t) -1 == process->md.pid) {
-		PR_SetError(PR_INSUFFICIENT_RESOURCES_ERROR, errno);
-		PR_DELETE(process);
-		if (newEnvp) {
-			PR_DELETE(newEnvp);
-		}
-		return NULL;
-	} else if (0 == process->md.pid) {  /* the child process */
-		/*
-		 * If the child process needs to exit, it must call _exit().
-		 * Do not call exit(), because exit() will flush and close
-		 * the standard I/O file descriptors, and hence corrupt
-		 * the parent process's standard I/O data structures.
-		 */
-
-		if (attr) {
-			/* the osfd's to redirect stdin, stdout, and stderr to */
-			int in_osfd = -1, out_osfd = -1, err_osfd = -1;
-
-			if (attr->stdinFd
-			    && attr->stdinFd->secret->md.osfd != 0) {
-				in_osfd = attr->stdinFd->secret->md.osfd;
-				if (dup2(in_osfd, 0) != 0) {
-					_exit(1);  /* failed */
-				}
-				flags = fcntl(0, F_GETFL, 0);
-				if (flags & O_NONBLOCK) {
-					fcntl(0, F_SETFL, flags & ~O_NONBLOCK);
-				}
-			}
-			if (attr->stdoutFd
-			    && attr->stdoutFd->secret->md.osfd != 1) {
-				out_osfd = attr->stdoutFd->secret->md.osfd;
-				if (dup2(out_osfd, 1) != 1) {
-					_exit(1);  /* failed */
-				}
-				flags = fcntl(1, F_GETFL, 0);
-				if (flags & O_NONBLOCK) {
-					fcntl(1, F_SETFL, flags & ~O_NONBLOCK);
-				}
-			}
-			if (attr->stderrFd
-			    && attr->stderrFd->secret->md.osfd != 2) {
-				err_osfd = attr->stderrFd->secret->md.osfd;
-				if (dup2(err_osfd, 2) != 2) {
-					_exit(1);  /* failed */
-				}
-				flags = fcntl(2, F_GETFL, 0);
-				if (flags & O_NONBLOCK) {
-					fcntl(2, F_SETFL, flags & ~O_NONBLOCK);
-				}
-			}
-			if (in_osfd != -1) {
-				close(in_osfd);
-			}
-			if (out_osfd != -1 && out_osfd != in_osfd) {
-				close(out_osfd);
-			}
-			if (err_osfd != -1 && err_osfd != in_osfd
-			    && err_osfd != out_osfd) {
-				close(err_osfd);
-			}
-			if (attr->currentDirectory) {
-				if (chdir(attr->currentDirectory) < 0) {
-					_exit(1);  /* failed */
-				}
-			}
-		}
-
-		if (childEnvp) {
-			(void)execve(path, argv, childEnvp);
-		} else {
-			/* Inherit the environment of the parent. */
-			(void)execv(path, argv);
-		}
-		/* Whoops! It returned. That's a bad sign. */
-		_exit(1);
-	}
-
-	if (newEnvp) {
-		PR_DELETE(newEnvp);
-	}
+    PRProcess *process;
+    int nEnv, idx;
+    char *const *childEnvp;
+    char **newEnvp = NULL;
+    int flags;
+
+    process = PR_NEW(PRProcess);
+    if (!process) {
+        PR_SetError(PR_OUT_OF_MEMORY_ERROR, 0);
+        return NULL;
+    }
+
+    childEnvp = envp;
+    if (attr && attr->fdInheritBuffer) {
+        if (NULL == childEnvp) {
+            childEnvp = environ;
+        }
+        for (nEnv = 0; childEnvp[nEnv]; nEnv++) {
+        }
+        newEnvp = (char **) PR_MALLOC((nEnv + 2) * sizeof(char *));
+        if (NULL == newEnvp) {
+            PR_DELETE(process);
+            PR_SetError(PR_OUT_OF_MEMORY_ERROR, 0);
+            return NULL;
+        }
+        for (idx = 0; idx < nEnv; idx++) {
+            newEnvp[idx] = childEnvp[idx];
+        }
+        newEnvp[idx++] = attr->fdInheritBuffer;
+        newEnvp[idx] = NULL;
+        childEnvp = newEnvp;
+    }
+
+    process->md.pid = fork();
+
+    if ((pid_t) -1 == process->md.pid) {
+        PR_SetError(PR_INSUFFICIENT_RESOURCES_ERROR, errno);
+        PR_DELETE(process);
+        if (newEnvp) {
+            PR_DELETE(newEnvp);
+        }
+        return NULL;
+    } else if (0 == process->md.pid) {  /* the child process */
+        /*
+         * If the child process needs to exit, it must call _exit().
+         * Do not call exit(), because exit() will flush and close
+         * the standard I/O file descriptors, and hence corrupt
+         * the parent process's standard I/O data structures.
+         */
+
+        if (attr) {
+            /* the osfd's to redirect stdin, stdout, and stderr to */
+            int in_osfd = -1, out_osfd = -1, err_osfd = -1;
+
+            if (attr->stdinFd
+                && attr->stdinFd->secret->md.osfd != 0) {
+                in_osfd = attr->stdinFd->secret->md.osfd;
+                if (dup2(in_osfd, 0) != 0) {
+                    _exit(1);  /* failed */
+                }
+                flags = fcntl(0, F_GETFL, 0);
+                if (flags & O_NONBLOCK) {
+                    fcntl(0, F_SETFL, flags & ~O_NONBLOCK);
+                }
+            }
+            if (attr->stdoutFd
+                && attr->stdoutFd->secret->md.osfd != 1) {
+                out_osfd = attr->stdoutFd->secret->md.osfd;
+                if (dup2(out_osfd, 1) != 1) {
+                    _exit(1);  /* failed */
+                }
+                flags = fcntl(1, F_GETFL, 0);
+                if (flags & O_NONBLOCK) {
+                    fcntl(1, F_SETFL, flags & ~O_NONBLOCK);
+                }
+            }
+            if (attr->stderrFd
+                && attr->stderrFd->secret->md.osfd != 2) {
+                err_osfd = attr->stderrFd->secret->md.osfd;
+                if (dup2(err_osfd, 2) != 2) {
+                    _exit(1);  /* failed */
+                }
+                flags = fcntl(2, F_GETFL, 0);
+                if (flags & O_NONBLOCK) {
+                    fcntl(2, F_SETFL, flags & ~O_NONBLOCK);
+                }
+            }
+            if (in_osfd != -1) {
+                close(in_osfd);
+            }
+            if (out_osfd != -1 && out_osfd != in_osfd) {
+                close(out_osfd);
+            }
+            if (err_osfd != -1 && err_osfd != in_osfd
+                && err_osfd != out_osfd) {
+                close(err_osfd);
+            }
+            if (attr->currentDirectory) {
+                if (chdir(attr->currentDirectory) < 0) {
+                    _exit(1);  /* failed */
+                }
+            }
+        }
+
+        if (childEnvp) {
+            (void)execve(path, argv, childEnvp);
+        } else {
+            /* Inherit the environment of the parent. */
+            (void)execv(path, argv);
+        }
+        /* Whoops! It returned. That's a bad sign. */
+        _exit(1);
+    }
+
+    if (newEnvp) {
+        PR_DELETE(newEnvp);
+    }
 
-	return process;
+    return process;
 }
 
 PRStatus
 _MD_detach_process (PRProcess *process)
 {
-	/* If we kept a process table like unix does,
-	 * we'd remove the entry here.
-	 * Since we dont', just delete the process variable
-	 */
-	PR_DELETE(process);
-	return PR_SUCCESS;
+    /* If we kept a process table like unix does,
+     * we'd remove the entry here.
+     * Since we dont', just delete the process variable
+     */
+    PR_DELETE(process);
+    return PR_SUCCESS;
 }
 
 PRStatus
 _MD_wait_process (PRProcess *process, PRInt32 *exitCode)
 {
-	PRStatus retVal = PR_SUCCESS;
-	int ret, status;
-	
-	/* Ignore interruptions */
-	do {
-		ret = waitpid(process->md.pid, &status, 0);
-	} while (ret == -1 && errno == EINTR);
-
-	/*
-	 * waitpid() cannot return 0 because we did not invoke it
-	 * with the WNOHANG option.
-	 */ 
-	PR_ASSERT(0 != ret);
+    PRStatus retVal = PR_SUCCESS;
+    int ret, status;
+    
+    /* Ignore interruptions */
+    do {
+        ret = waitpid(process->md.pid, &status, 0);
+    } while (ret == -1 && errno == EINTR);
+
+    /*
+     * waitpid() cannot return 0 because we did not invoke it
+     * with the WNOHANG option.
+     */ 
+    PR_ASSERT(0 != ret);
 
-	if (ret < 0) {
+    if (ret < 0) {
                 PR_SetError(PR_UNKNOWN_ERROR, _MD_ERRNO());
-		return PR_FAILURE;
-	}
+        return PR_FAILURE;
+    }
 
-	/* If child process exited normally, return child exit code */
-	if (WIFEXITED(status)) {
-		*exitCode = WEXITSTATUS(status);
-	} else {
-		PR_ASSERT(WIFSIGNALED(status));
-		*exitCode = _PR_SIGNALED_EXITSTATUS;
-	}		
+    /* If child process exited normally, return child exit code */
+    if (WIFEXITED(status)) {
+        *exitCode = WEXITSTATUS(status);
+    } else {
+        PR_ASSERT(WIFSIGNALED(status));
+        *exitCode = _PR_SIGNALED_EXITSTATUS;
+    }       
 
-	PR_DELETE(process);
-	return PR_SUCCESS;
+    PR_DELETE(process);
+    return PR_SUCCESS;
 }
 
 PRStatus
 _MD_kill_process (PRProcess *process)
 {
-	PRErrorCode prerror;
-	PRInt32 oserror;
-	
-	if (kill(process->md.pid, SIGKILL) == 0) {
-		return PR_SUCCESS;
-	}
-	oserror = errno;
-	switch (oserror) {
+    PRErrorCode prerror;
+    PRInt32 oserror;
+    
+    if (kill(process->md.pid, SIGKILL) == 0) {
+        return PR_SUCCESS;
+    }
+    oserror = errno;
+    switch (oserror) {
         case EPERM:
-		prerror = PR_NO_ACCESS_RIGHTS_ERROR;
-		break;
+        prerror = PR_NO_ACCESS_RIGHTS_ERROR;
+        break;
         case ESRCH:
-		prerror = PR_INVALID_ARGUMENT_ERROR;
-		break;
+        prerror = PR_INVALID_ARGUMENT_ERROR;
+        break;
         default:
-		prerror = PR_UNKNOWN_ERROR;
-		break;
-	}
-	PR_SetError(prerror, oserror);
-	return PR_FAILURE;
+        prerror = PR_UNKNOWN_ERROR;
+        break;
+    }
+    PR_SetError(prerror, oserror);
+    return PR_FAILURE;
 }
Index: mozilla/nsprpub/pr/src/md/beos/bsrcs.mk
===================================================================
RCS file: /cvsroot/mozilla/nsprpub/pr/src/md/beos/bsrcs.mk,v
retrieving revision 3.6
diff -u -8 -p -r3.6 bsrcs.mk
--- mozilla/nsprpub/pr/src/md/beos/bsrcs.mk	25 Apr 2004 15:00:59 -0000	3.6
+++ mozilla/nsprpub/pr/src/md/beos/bsrcs.mk	9 Feb 2009 04:04:50 -0000
@@ -15,16 +15,17 @@
 # The Original Code is the Netscape Portable Runtime (NSPR).
 #
 # The Initial Developer of the Original Code is
 # Netscape Communications Corporation.
 # Portions created by the Initial Developer are Copyright (C) 1998-2000
 # the Initial Developer. All Rights Reserved.
 #
 # Contributor(s):
+# Fredrik Holmqvist <thesuckiestemail@yahoo.se>
 #
 # Alternatively, the contents of this file may be used under the terms of
 # either the GNU General Public License Version 2 or later (the "GPL"), or
 # the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 # in which case the provisions of the GPL or the LGPL are applicable instead
 # of those above. If you wish to allow use of your version of this file only
 # under the terms of either the GPL or the LGPL, and not to allow others to
 # use your version of this file under the terms of the MPL, indicate your
@@ -37,18 +38,11 @@
 
 
 # this file lists the source files to be compiled (used in Makefile) and
 # then enumerated as object files (in objs.mk) for inclusion in the NSPR
 # shared library
 
 MDCSRCS =             \
 	beos.c        \
-	beos_errors.c \
-	bfile.c       \
-	bmisc.c       \
-	bnet.c        \
 	bproc.c       \
-	brng.c        \
-	bseg.c        \
-	btime.c       \
 	bmmap.c       \
 	$(NULL)
Index: mozilla/nsprpub/pr/src/memory/prseg.c
===================================================================
RCS file: /cvsroot/mozilla/nsprpub/pr/src/memory/prseg.c,v
retrieving revision 3.8
diff -u -8 -p -r3.8 prseg.c
--- mozilla/nsprpub/pr/src/memory/prseg.c	25 Apr 2004 15:01:01 -0000	3.8
+++ mozilla/nsprpub/pr/src/memory/prseg.c	9 Feb 2009 04:04:51 -0000
@@ -32,26 +32,26 @@
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "primpl.h"
 
-#if defined(_PR_PTHREADS)
+#if defined(_PR_PTHREADS) || defined(_PR_BTHREADS)
 
 /*
 ** The pthreads version doesn't use these functions.
 */
 void _PR_InitSegs(void)
 {
 }
 
-#else /* _PR_PTHREADS */
+#else /* _PR_PTHREADS || defined(_PR_BTHREADS) */
 
 void _PR_InitSegs(void)
 {
 	_PR_MD_INIT_SEGS();
 }
 
 /*
 ** Allocate a memory segment. The size value is rounded up to the native
@@ -85,9 +85,9 @@ PRSegment* _PR_NewSegment(PRUint32 size,
 ** Free a memory segment.
 */
 void _PR_DestroySegment(PRSegment *seg)
 {
 	_PR_MD_FREE_SEGMENT(seg);
     PR_DELETE(seg);
 }
 
-#endif /* _PR_PTHREADS */
+#endif /* _PR_PTHREADS || defined(_PR_BTHREADS) */
Index: mozilla/nsprpub/pr/src/misc/Makefile.in
===================================================================
RCS file: /cvsroot/mozilla/nsprpub/pr/src/misc/Makefile.in,v
retrieving revision 1.19
diff -u -8 -p -r1.19 Makefile.in
--- mozilla/nsprpub/pr/src/misc/Makefile.in	8 Nov 2004 02:52:56 -0000	1.19
+++ mozilla/nsprpub/pr/src/misc/Makefile.in	9 Feb 2009 04:04:52 -0000
@@ -66,20 +66,22 @@ CSRCS = \
 	prsystem.c \
 	prtime.c   \
 	prthinfo.c \
 	prtpool.c \
 	prtrace.c  \
 	$(NULL)
 
 ifndef USE_PTHREADS
+ifndef USE_BTHREADS
 CSRCS += \
 	pripcsem.c \
 	$(NULL)
 endif
+endif
 
 TARGETS	= $(OBJS)
 
 INCLUDES = -I$(dist_includedir) -I$(topsrcdir)/pr/include -I$(topsrcdir)/pr/include/private
 
 DEFINES	+= -D_NSPR_BUILD_
 
 RELEASE_BINS = $(srcdir)/compile-et.pl $(srcdir)/prerr.properties
Index: mozilla/nsprpub/pr/src/misc/prinit.c
===================================================================
RCS file: /cvsroot/mozilla/nsprpub/pr/src/misc/prinit.c,v
retrieving revision 3.43.2.1
diff -u -8 -p -r3.43.2.1 prinit.c
--- mozilla/nsprpub/pr/src/misc/prinit.c	1 Dec 2006 00:34:11 -0000	3.43.2.1
+++ mozilla/nsprpub/pr/src/misc/prinit.c	9 Feb 2009 04:04:54 -0000
@@ -195,18 +195,20 @@ static void _PR_InitStuff(void)
 	_pr_shma_lm = PR_NewLogModule("shma");
       
     /* NOTE: These init's cannot depend on _PR_MD_CURRENT_THREAD() */ 
     _PR_MD_EARLY_INIT();
 
     _PR_InitLocks();
     _PR_InitAtomic();
     _PR_InitSegs();
+#if !defined(_PR_BTHREADS)
     _PR_InitStacks();
 	_PR_InitTPD();
+#endif /*!defined(_PR_BTHREADS) */
     _PR_InitEnv();
     _PR_InitLayerCache();
     _PR_InitClock();
 
     _pr_sleeplock = PR_NewLock();
     PR_ASSERT(NULL != _pr_sleeplock);
 
 #ifdef GC_LEAK_DETECTOR
Index: mozilla/nsprpub/pr/src/misc/pripcsem.c
===================================================================
RCS file: /cvsroot/mozilla/nsprpub/pr/src/misc/pripcsem.c,v
retrieving revision 3.5
diff -u -8 -p -r3.5 pripcsem.c
--- mozilla/nsprpub/pr/src/misc/pripcsem.c	25 Apr 2004 15:01:01 -0000	3.5
+++ mozilla/nsprpub/pr/src/misc/pripcsem.c	9 Feb 2009 04:04:54 -0000
@@ -41,19 +41,19 @@
  * Description: implements the named semaphores API in prsemipc.h
  * for classic NSPR.  If _PR_HAVE_NAMED_SEMAPHORES is not defined,
  * the named semaphore functions all fail with the error code
  * PR_NOT_IMPLEMENTED_ERROR.
  */
 
 #include "primpl.h"
 
-#ifdef _PR_PTHREADS
+#if defined(_PR_PTHREADS) || defined(_PR_BTHREADS)
 
-#error "This file should not be compiled for the pthreads version"
+#error "This file should not be compiled for the pthreads or bthreads version"
 
 #else
 
 #ifndef _PR_HAVE_NAMED_SEMAPHORES
 
 PRSem * _PR_MD_OPEN_SEMAPHORE(
     const char *osname, PRIntn flags, PRIntn mode, PRUintn value)
 {
@@ -122,9 +122,9 @@ PR_IMPLEMENT(PRStatus) PR_DeleteSemaphor
     if (!_pr_initialized) _PR_ImplicitInitialization();
     if (_PR_MakeNativeIPCName(name, osname, sizeof(osname), _PRIPCSem)
             == PR_FAILURE) {
         return PR_FAILURE;
     }
     return _PR_MD_DELETE_SEMAPHORE(osname);
 }
 
-#endif /* _PR_PTHREADS */
+#endif /* _PR_PTHREADS || _PR_BTHREADS */
Index: mozilla/security/coreconf/BeOS.mk
===================================================================
RCS file: /cvsroot/mozilla/security/coreconf/BeOS.mk,v
retrieving revision 1.2
diff -u -8 -p -r1.2 BeOS.mk
--- mozilla/security/coreconf/BeOS.mk	25 Apr 2004 15:02:17 -0000	1.2
+++ mozilla/security/coreconf/BeOS.mk	9 Feb 2009 04:05:05 -0000
@@ -56,17 +56,17 @@ ifeq ($(OS_TEST),ppc)
 	CPU_ARCH	= ppc
 else
 	OS_REL_CFLAGS	= -Di386
 	CPU_ARCH	= x86
 endif
 
 MKSHLIB		= $(CC) -nostart -Wl,-soname -Wl,$(@:$(OBJDIR)/%.so=%.so)
 ifdef BUILD_OPT
-	OPTIMIZER	= -O2
+	OPTIMIZER	= -O3
 endif
 
 OS_CFLAGS		= $(DSO_CFLAGS) $(OS_REL_CFLAGS) -Wall -pipe
 OS_LIBS			= -lbe
 
 DEFINES			+= -DBEOS
 
 ifdef USE_PTHREADS
Index: mozilla/security/coreconf/arch.mk
===================================================================
RCS file: /cvsroot/mozilla/security/coreconf/arch.mk,v
retrieving revision 1.19.2.1
diff -u -8 -p -r1.19.2.1 arch.mk
--- mozilla/security/coreconf/arch.mk	14 Nov 2007 22:47:33 -0000	1.19.2.1
+++ mozilla/security/coreconf/arch.mk	9 Feb 2009 04:05:06 -0000
@@ -57,16 +57,17 @@
 ifeq ($(USE_64), 1)
 	64BIT_TAG=_64
 else
 	64BIT_TAG=
 endif
 
 OS_ARCH := $(subst /,_,$(shell uname -s))
 
+
 #
 # Attempt to differentiate between sparc and x86 Solaris
 #
 
 OS_TEST := $(shell uname -m)
 ifeq ($(OS_TEST),i86pc)
     OS_RELEASE := $(shell uname -r)_$(OS_TEST)
 else
Index: mozilla/security/coreconf/config.mk
===================================================================
RCS file: /cvsroot/mozilla/security/coreconf/config.mk,v
retrieving revision 1.17.28.3
diff -u -8 -p -r1.17.28.3 config.mk
--- mozilla/security/coreconf/config.mk	4 May 2007 06:54:05 -0000	1.17.28.3
+++ mozilla/security/coreconf/config.mk	9 Feb 2009 04:05:07 -0000
@@ -32,16 +32,17 @@
 # and other provisions required by the GPL or the LGPL. If you do not delete
 # the provisions above, a recipient may use your version of this file under
 # the terms of any one of the MPL, the GPL or the LGPL.
 #
 # ***** END LICENSE BLOCK *****
 
 # Configuration information for building in the "Core Components" source module
 
+
 #######################################################################
 # [1.0] Master "Core Components" source and release <architecture>    #
 #       tags                                                          #
 #######################################################################
 ifndef MK_ARCH
 include $(CORE_DEPTH)/coreconf/arch.mk
 endif
 
@@ -57,24 +58,30 @@ endif
 # [3.0] Master "Core Components" <architecture>-specific macros       #
 #       (dependent upon <architecture> tags)                          #
 #                                                                     #
 #       We are moving towards just having a $(OS_TARGET).mk file      #
 #       as opposed to multiple $(OS_TARGET)$(OS_RELEASE).mk files,    #
 #       one for each OS release.                                      #
 #######################################################################
 
+
+
 TARGET_OSES = FreeBSD BSD_OS NetBSD OpenUNIX OS2 QNX Darwin BeOS OpenBSD \
               OpenVMS AIX
 
 ifeq (,$(filter-out $(TARGET_OSES),$(OS_TARGET)))
 include $(CORE_DEPTH)/coreconf/$(OS_TARGET).mk
 else
+ifeq ($(OS_ARCH), Haiku)
+include $(CORE_DEPTH)/coreconf/BeOS.mk
+else
 include $(CORE_DEPTH)/coreconf/$(OS_TARGET)$(OS_RELEASE).mk
 endif
+endif
 
 #######################################################################
 # [4.0] Master "Core Components" source and release <platform> tags   #
 #       (dependent upon <architecture> tags)                          #
 #######################################################################
 PLATFORM = $(OBJDIR_NAME)
 
 #######################################################################
Index: mozilla/security/manager/Makefile.in
===================================================================
RCS file: /cvsroot/mozilla/security/manager/Makefile.in,v
retrieving revision 1.57.4.6
diff -u -8 -p -r1.57.4.6 Makefile.in
--- mozilla/security/manager/Makefile.in	23 May 2008 23:45:26 -0000	1.57.4.6
+++ mozilla/security/manager/Makefile.in	9 Feb 2009 04:05:08 -0000
@@ -257,30 +257,45 @@ ifndef MOZ_NATIVE_NSS
 	$(MAKE) -C $(topsrcdir)/security/nss-fips/lib/util $(DEFAULT_GMAKE_FLAGS) clean
 	# In NSS 3.11.8-3.11.9, lib/ssl/derive.c includes cmd/lib/secutil.h.
 	$(MAKE) -C $(topsrcdir)/security/nss/cmd/lib $(DEFAULT_GMAKE_FLAGS) export
 	$(MAKE) -C $(topsrcdir)/security/nss/lib $(DEFAULT_GMAKE_FLAGS) DIRS="util base dev pki pki1 certdb certhigh pk11wrap cryptohi nss ssl pkcs12 pkcs7 smime crmf jar ckfw ckfw/builtins"
 ifndef SKIP_CHK
 	$(MAKE) -C $(topsrcdir)/security/nss/cmd/lib $(DEFAULT_GMAKE_FLAGS)
 	$(MAKE) -C $(topsrcdir)/security/nss/cmd/shlibsign $(DEFAULT_GMAKE_FLAGS)
 endif
+ifeq (,$(filter-out BeOS Haiku, $(OS_ARCH)))
+	$(INSTALL) -m 755 $(DIST)/lib/$(LOADABLE_ROOT_MODULE) $(DIST)/bin/add-ons
+else
 	$(INSTALL) -m 755 $(DIST)/lib/$(LOADABLE_ROOT_MODULE) $(DIST)/bin
+endif
 ifndef SKIP_CHK
 	$(INSTALL) -m 644 $(DIST)/lib/$(SOFTOKEN3_CHK) $(DIST)/bin
 endif
+ifeq (,$(filter-out BeOS Haiku, $(OS_ARCH)))
+	$(INSTALL) -m 755 $(DIST)/lib/$(SOFTOKEN3_LIB) $(DIST)/bin/lib
+	$(INSTALL) -m 755 $(DIST)/lib/$(NSS3_LIB) $(DIST)/bin/lib
+	$(INSTALL) -m 755 $(DIST)/lib/$(SSL3_LIB) $(DIST)/bin/lib
+	$(INSTALL) -m 755 $(DIST)/lib/$(SMIME3_LIB) $(DIST)/bin/lib
+else
 	$(INSTALL) -m 755 $(DIST)/lib/$(SOFTOKEN3_LIB) $(DIST)/bin
 	$(INSTALL) -m 755 $(DIST)/lib/$(NSS3_LIB) $(DIST)/bin
 	$(INSTALL) -m 755 $(DIST)/lib/$(SSL3_LIB) $(DIST)/bin
 	$(INSTALL) -m 755 $(DIST)/lib/$(SMIME3_LIB) $(DIST)/bin
+endif
 ifdef HAVE_FREEBL_LIBS
 ifndef SKIP_CHK
 	$(INSTALL) -m 644 $(DIST)/lib/$(FREEBL_CHK) $(DIST)/bin
 endif
+ifeq (,$(filter-out BeOS Haiku, $(OS_ARCH)))
+	$(INSTALL) -m 755 $(DIST)/lib/$(FREEBL_LIB) $(DIST)/bin/add-ons
+else
 	$(INSTALL) -m 755 $(DIST)/lib/$(FREEBL_LIB) $(DIST)/bin
 endif
+endif
 ifdef HAVE_FREEBL_LIBS_32
 ifndef SKIP_CHK
 	$(INSTALL) -m 644 $(DIST)/lib/$(FREEBL_32INT_CHK) $(DIST)/bin
 	$(INSTALL) -m 644 $(DIST)/lib/$(FREEBL_32FPU_CHK) $(DIST)/bin
 endif
 	$(INSTALL) -m 755 $(DIST)/lib/$(FREEBL_32INT_LIB) $(DIST)/bin
 	$(INSTALL) -m 755 $(DIST)/lib/$(FREEBL_32FPU_LIB) $(DIST)/bin
 endif
Index: mozilla/security/nss/cmd/lib/secutil.h
===================================================================
RCS file: /cvsroot/mozilla/security/nss/cmd/lib/secutil.h,v
retrieving revision 1.18.24.1
diff -u -8 -p -r1.18.24.1 secutil.h
--- mozilla/security/nss/cmd/lib/secutil.h	19 Jul 2006 00:25:03 -0000	1.18.24.1
+++ mozilla/security/nss/cmd/lib/secutil.h	9 Feb 2009 04:05:13 -0000
@@ -407,16 +407,16 @@ SECU_GetOptionArg(secuCommand *cmd, int 
 /* Return informative error string */
 char *SECU_ErrorString(int16 err);
 
 /* Return informative error string. Does not call XP_GetString */
 char *SECU_ErrorStringRaw(int16 err);
 
 void printflags(char *trusts, unsigned int flags);
 
-#ifndef XP_UNIX
+#if !defined(XP_UNIX) && !defined(XP_BEOS)
 extern int ffs(unsigned int i);
 #endif
 
 #include "secerr.h"
 #include "sslerr.h"
 
 #endif /* _SEC_UTIL_H_ */
Index: mozilla/security/nss/lib/dev/ckhelper.c
===================================================================
RCS file: /cvsroot/mozilla/security/nss/lib/dev/ckhelper.c,v
retrieving revision 1.34.28.1
diff -u -8 -p -r1.34.28.1 ckhelper.c
--- mozilla/security/nss/lib/dev/ckhelper.c	16 Nov 2007 05:25:07 -0000	1.34.28.1
+++ mozilla/security/nss/lib/dev/ckhelper.c	9 Feb 2009 04:05:17 -0000
@@ -225,33 +225,33 @@ NSS_IMPLEMENT PRBool
 nssCKObject_IsAttributeTrue (
   CK_OBJECT_HANDLE object,
   CK_ATTRIBUTE_TYPE attribute,
   nssSession *session,
   NSSSlot *slot,
   PRStatus *rvStatus
 )
 {
-    CK_BBOOL bool;
+    CK_BBOOL boolval;
     CK_ATTRIBUTE_PTR attr;
     CK_ATTRIBUTE atemplate = { 0, NULL, 0 };
     CK_RV ckrv;
     void *epv = nssSlot_GetCryptokiEPV(slot);
     attr = &atemplate;
-    NSS_CK_SET_ATTRIBUTE_VAR(attr, attribute, bool);
+    NSS_CK_SET_ATTRIBUTE_VAR(attr, attribute, boolval);
     nssSession_EnterMonitor(session);
     ckrv = CKAPI(epv)->C_GetAttributeValue(session->handle, object, 
                                            &atemplate, 1);
     nssSession_ExitMonitor(session);
     if (ckrv != CKR_OK) {
 	*rvStatus = PR_FAILURE;
 	return PR_FALSE;
     }
     *rvStatus = PR_SUCCESS;
-    return (PRBool)(bool == CK_TRUE);
+    return (PRBool)(boolval == CK_TRUE);
 }
 
 NSS_IMPLEMENT PRStatus 
 nssCKObject_SetAttributes (
   CK_OBJECT_HANDLE object,
   CK_ATTRIBUTE_PTR obj_template,
   CK_ULONG count,
   nssSession *session,
Index: mozilla/security/nss/lib/ssl/config.mk
===================================================================
RCS file: /cvsroot/mozilla/security/nss/lib/ssl/config.mk,v
retrieving revision 1.21.2.1
diff -u -8 -p -r1.21.2.1 config.mk
--- mozilla/security/nss/lib/ssl/config.mk	1 May 2007 06:09:31 -0000	1.21.2.1
+++ mozilla/security/nss/lib/ssl/config.mk	9 Feb 2009 04:05:19 -0000
@@ -103,17 +103,17 @@ EXTRA_SHARED_LIBS += \
 	-L$(DIST)/lib \
 	-lnss3 \
 	-L$(NSPR_LIB_DIR) \
 	-lplc4 \
 	-lplds4 \
 	-lnspr4 \
 	$(NULL)
 
-ifeq ($(OS_ARCH), BeOS)
+ifeq (,$(filter-out BeOS Haiku, $(OS_ARCH))) 
 EXTRA_SHARED_LIBS += -lbe
 endif
 
 ifeq ($(OS_ARCH), Darwin)
 EXTRA_SHARED_LIBS += -dylib_file @executable_path/libsoftokn3.dylib:$(DIST)/lib/libsoftokn3.dylib
 endif
 
 ifeq ($(OS_TARGET),SunOS)
Index: mozilla/security/nss/lib/freebl/unix_rand.c
===================================================================
RCS file: /cvsroot/mozilla/security/nss/lib/freebl/unix_rand.c,v
retrieving revision 1.17.10.5
diff -u -r1.17.10.5 unix_rand.c
--- mozilla/security/nss/lib/freebl/unix_rand.c	12 Oct 2006 22:50:48 -0000	1.17.10.5
+++ mozilla/security/nss/lib/freebl/unix_rand.c	27 Feb 2008 22:18:39 -0000
@@ -666,7 +666,7 @@
 #endif /* VMS */
 
 #ifdef BEOS
-#include <be/kernel/OS.h>
+#include <kernel/OS.h>
 
 static size_t
 GetHighResClock(void *buf, size_t maxbytes)
Index: mozilla/security/nss-fips/lib/freebl/unix_rand.c
===================================================================
RCS file: /cvsroot/mozilla/security/nss/lib/freebl/unix_rand.c,v
retrieving revision 1.17.10.5
diff -u -8 -p -r1.17.10.5 unix_rand.c
--- mozilla/security/nss-fips/lib/freebl/unix_rand.c	12 Oct 2006 22:50:48 -0000	1.17.10.5
+++ mozilla/security/nss-fips/lib/freebl/unix_rand.c	9 Feb 2009 04:05:28 -0000
@@ -661,17 +661,17 @@ GetHighResClock(void *buf, size_t maxbyt
  
     t = asm("rpcc %v0");
     return CopyLowBits(buf, maxbytes, &t, sizeof(t));
 }
  
 #endif /* VMS */
 
 #ifdef BEOS
-#include <be/kernel/OS.h>
+#include <kernel/OS.h>
 
 static size_t
 GetHighResClock(void *buf, size_t maxbytes)
 {
     bigtime_t bigtime; /* Actually an int64 */
 
     bigtime = real_time_clock_usecs();
     return CopyLowBits(buf, maxbytes, &bigtime, sizeof(bigtime));
Index: mozilla/security/nss-fips/lib/ssl/config.mk
===================================================================
RCS file: /cvsroot/mozilla/security/nss/lib/ssl/config.mk,v
retrieving revision 1.21
diff -u -8 -p -r1.21 config.mk
--- mozilla/security/nss-fips/lib/ssl/config.mk	19 Oct 2005 01:04:16 -0000	1.21
+++ mozilla/security/nss-fips/lib/ssl/config.mk	9 Feb 2009 04:05:30 -0000
@@ -99,17 +99,17 @@ EXTRA_SHARED_LIBS += \
 	-L$(DIST)/lib \
 	-lnss3 \
 	-L$(NSPR_LIB_DIR) \
 	-lplc4 \
 	-lplds4 \
 	-lnspr4 \
 	$(NULL)
 
-ifeq ($(OS_ARCH), BeOS)
+ifeq (,$(filter-out BeOS Haiku, $(OS_ARCH)))
 EXTRA_SHARED_LIBS += -lbe
 endif
 
 ifeq ($(OS_ARCH), Darwin)
 EXTRA_SHARED_LIBS += -dylib_file @executable_path/libsoftokn3.dylib:$(DIST)/lib/libsoftokn3.dylib
 endif
 
 ifeq ($(OS_TARGET),SunOS)
Index: mozilla/toolkit/library/Makefile.in
===================================================================
RCS file: /cvsroot/mozilla/toolkit/library/Makefile.in,v
retrieving revision 1.16.2.10
diff -u -8 -p -r1.16.2.10 Makefile.in
--- mozilla/toolkit/library/Makefile.in	31 Aug 2007 02:40:21 -0000	1.16.2.10
+++ mozilla/toolkit/library/Makefile.in	9 Feb 2009 04:05:45 -0000
@@ -359,17 +359,17 @@ endif
 ifdef MOZ_ENABLE_XPRINT
 EXTRA_DSO_LDOPTS += $(MOZ_XPRINT_LDFLAGS)
 endif
 
 ifdef MOZ_ENABLE_PANGO
 EXTRA_DSO_LDOPTS += $(MOZ_PANGO_LIBS)
 endif
 
-ifeq ($(OS_ARCH),BeOS)
+ifeq (,$(filter-out BeOS Haiku, $(OS_ARCH)))
 EXTRA_DSO_LDOPTS += -lbe
 endif
 
 ifeq ($(OS_ARCH),WINNT)
 EXTRA_DSO_LDOPTS += $(call EXPAND_LIBNAME,shell32 ole32 uuid version winspool comdlg32)
 ifneq (,$(MOZ_DEBUG)$(NS_TRACE_MALLOC))
 EXTRA_DSO_LDOPTS += $(call EXPAND_LIBNAME,imagehlp)
 endif
Index: mozilla/toolkit/mozapps/installer/package-name.mk
===================================================================
RCS file: /cvsroot/mozilla/toolkit/mozapps/installer/package-name.mk,v
retrieving revision 1.4.8.3
diff -u -8 -p -r1.4.8.3 package-name.mk
--- mozilla/toolkit/mozapps/installer/package-name.mk	4 Apr 2008 09:21:26 -0000	1.4.8.3
+++ mozilla/toolkit/mozapps/installer/package-name.mk	9 Feb 2009 04:05:47 -0000
@@ -54,16 +54,19 @@ ifeq ($(OS_ARCH),Darwin)
 MOZ_PKG_PLATFORM := mac
 endif
 ifeq ($(TARGET_OS),linux-gnu)
 MOZ_PKG_PLATFORM := linux-$(TARGET_CPU)
 endif
 ifeq ($(OS_ARCH),OS2)
 MOZ_PKG_PLATFORM := os2
 endif
+ifeq ($(OS_ARCH), Haiku)
+MOZ_PKG_PLATFORM := Haiku
+endif
 ifeq ($(OS_ARCH), BeOS)
 ifeq (,$(filter-out 6.%, $(OS_RELEASE)))
 MOZ_PKG_PLATFORM := Zeta
 else
 ifeq (,$(filter-out 5.1, $(OS_RELEASE)))
 MOZ_PKG_PLATFORM := BeOS-bone
 else
 ifeq (,$(filter-out 5.0.4, $(OS_RELEASE)))
Index: mozilla/toolkit/mozapps/installer/packager.mk
===================================================================
RCS file: /cvsroot/mozilla/toolkit/mozapps/installer/packager.mk,v
retrieving revision 1.16.2.18
diff -u -8 -p -r1.16.2.18 packager.mk
--- mozilla/toolkit/mozapps/installer/packager.mk	4 Apr 2008 20:31:10 -0000	1.16.2.18
+++ mozilla/toolkit/mozapps/installer/packager.mk	9 Feb 2009 04:05:49 -0000
@@ -43,21 +43,24 @@ include $(topsrcdir)/toolkit/mozapps/ins
 # This is how we create the Unix binary packages we release to the public.
 # Currently the only format is tar.gz (TGZ), but it should be fairly easy
 # to add .rpm (RPM) and .deb (DEB) later.
 
 ifndef MOZ_PKG_FORMAT
 ifneq (,$(filter mac cocoa,$(MOZ_WIDGET_TOOLKIT)))
 MOZ_PKG_FORMAT  = DMG
 else
-ifeq (,$(filter-out OS2 WINNT BeOS, $(OS_ARCH)))
+ifeq (,$(filter-out OS2 WINNT BeOS Haiku, $(OS_ARCH)))
 MOZ_PKG_FORMAT  = ZIP
 ifeq ($(OS_ARCH),OS2)
 INSTALLER_DIR   = os2
 else
+ifeq (,$(filter-out BeOS Haiku, $(OS_ARCH)))
+INSTALLER_DIR = beos
+endif
 ifeq ($(OS_ARCH), WINNT)
 INSTALLER_DIR   = windows
 endif
 endif
 else
 ifeq (,$(filter-out SunOS, $(OS_ARCH)))
 MOZ_PKG_FORMAT  = BZ2
 else
@@ -246,19 +249,19 @@ $(MOZ_PKG_REMOVALS_GEN): $(MOZ_PKG_REMOV
 	$(PERL) $(topsrcdir)/config/preprocessor.pl -Fsubstitution $(DEFINES) $(ACDEFINES) $(MOZ_PKG_REMOVALS) > $(MOZ_PKG_REMOVALS_GEN)
 endif
 
 GARBAGE		+= $(DIST)/$(PACKAGE) $(PACKAGE)
 
 ifeq ($(OS_ARCH),IRIX)
 STRIP_FLAGS	= -f
 endif
-ifeq ($(OS_ARCH),BeOS)
+ifeq (,$(filter-out BeOS Haiku, $(OS_ARCH)))
 STRIP_FLAGS	= -g
-PLATFORM_EXCLUDE_LIST = ! -name "*.stub" ! -name "$(MOZ_PKG_APPNAME)-bin"
+PLATFORM_EXCLUDE_LIST = ! -name "*.stub" ! -name "$(MOZ_PKG_APPNAME)"
 endif
 ifeq ($(OS_ARCH),OS2)
 STRIP		= $(srcdir)/os2/strip.cmd
 STRIP_FLAGS	=
 PLATFORM_EXCLUDE_LIST = ! -name "*.ico"
 endif
 
 ifneq (,$(filter WINNT OS2,$(OS_ARCH)))
Index: mozilla/toolkit/xre/nsXREDirProvider.cpp
===================================================================
RCS file: /cvsroot/mozilla/toolkit/xre/nsXREDirProvider.cpp,v
retrieving revision 1.37.2.11
diff -u -8 -p -r1.37.2.11 nsXREDirProvider.cpp
--- mozilla/toolkit/xre/nsXREDirProvider.cpp	8 May 2007 19:25:29 -0000	1.37.2.11
+++ mozilla/toolkit/xre/nsXREDirProvider.cpp	9 Feb 2009 04:05:57 -0000
@@ -71,17 +71,17 @@
 #ifndef CSIDL_PROGRAM_FILES
 #define CSIDL_PROGRAM_FILES             0x0026
 #endif
 #endif
 #ifdef XP_MACOSX
 #include "nsILocalFileMac.h"
 #endif
 #ifdef XP_BEOS
-#include <be/kernel/image.h>
+#include <kernel/image.h>
 #include <FindDirectory.h>
 #endif
 #ifdef XP_UNIX
 #include <ctype.h>
 #endif
 #ifdef XP_OS2
 #define INCL_DOS
 #include <os2.h>
Index: mozilla/widget/src/beos/nsDragService.cpp
===================================================================
RCS file: /cvsroot/mozilla/widget/src/beos/nsDragService.cpp,v
retrieving revision 1.13.28.5
diff -u -8 -p -r1.13.28.5 nsDragService.cpp
--- mozilla/widget/src/beos/nsDragService.cpp	13 Aug 2008 12:41:28 -0000	1.13.28.5
+++ mozilla/widget/src/beos/nsDragService.cpp	9 Feb 2009 04:06:02 -0000
@@ -250,17 +250,17 @@ nsDragService::InvokeDragSession (nsIDOM
         dragRect = view->Frame();
         // do we need to offset?
     }
         
     PR_LOG(sDragLm, PR_LOG_DEBUG, ("invoking mDragView->DragMessage"));
     bool noBitmap = true;
 
 //This is the code for image-dragging, currently disabled. See comments in beginning of file.
-# ifdef 0
+#if 0
     do
     {
         PRUint32 dataSize;
         PRUint32 noItems;
         mSourceDataItems->Count(&noItems);
         if (noItems!=1) 
         {
             PR_LOG(sDragLm, PR_LOG_DEBUG, ("Transferables are not ==1, no drag bitmap!"));
@@ -307,17 +307,17 @@ nsDragService::InvokeDragSession (nsIDOM
         if (aBitmap==NULL || !aBitmap->IsValid()) {
             PR_LOG(sDragLm, PR_LOG_DEBUG, ("Could not get BBitmap, no drag bitmap %s!", aBitmap==NULL?"(null)":"(not valid)" ));
             break;        
         }
 
         view->DragMessage(mDragMessage, aBitmap, B_OP_OVER, BPoint(-4,-4), view); 
         noBitmap = false;
     } while(false);
-# endif    
+#endif    
     
     if (noBitmap) 
         view->DragMessage(mDragMessage, dragRect, view);
     
     StartDragSession();
     view->UnlockLooper();
     return NS_OK;
 }
Index: mozilla/xpcom/build/Makefile.in
===================================================================
RCS file: /cvsroot/mozilla/xpcom/build/Makefile.in,v
retrieving revision 1.90.2.3
diff -u -8 -p -r1.90.2.3 Makefile.in
--- mozilla/xpcom/build/Makefile.in	29 Mar 2008 06:56:29 -0000	1.90.2.3
+++ mozilla/xpcom/build/Makefile.in	9 Feb 2009 04:06:06 -0000
@@ -168,17 +168,17 @@ ifdef GC_LEAK_DETECTOR
 DEFINES += -DGC_LEAK_DETECTOR
 endif
 
 ifneq (,$(filter mac cocoa,$(MOZ_WIDGET_TOOLKIT)))
 CXXFLAGS	+= $(TK_CFLAGS)
 EXTRA_DSO_LDOPTS += $(TK_LIBS)
 endif
 
-ifeq ($(OS_ARCH),BeOS)
+ifeq (,$(filter-out BeOS Haiku, $(OS_ARCH)))
 EXTRA_DSO_LDOPTS += -lbe
 endif
 
 ifneq (,$(filter gtk2,$(MOZ_WIDGET_TOOLKIT)))
 EXTRA_DSO_LDOPTS += $(MOZ_GTK2_LIBS)
 endif
 
 ifeq ($(OS_ARCH),WINNT)
Index: mozilla/xpcom/obsolete/Makefile.in
===================================================================
RCS file: /cvsroot/mozilla/xpcom/obsolete/Makefile.in,v
retrieving revision 1.17
diff -u -8 -p -r1.17 Makefile.in
--- mozilla/xpcom/obsolete/Makefile.in	30 Jan 2005 21:33:45 -0000	1.17
+++ mozilla/xpcom/obsolete/Makefile.in	9 Feb 2009 04:06:09 -0000
@@ -115,17 +115,17 @@ DEFINES		+= -D_IMPL_NS_COM_OBSOLETE
 
 EXTRA_DSO_LDOPTS += $(MOZ_COMPONENT_LIBS)
 
 ifneq (,$(filter mac cocoa,$(MOZ_WIDGET_TOOLKIT)))
 CXXFLAGS	+= $(TK_CFLAGS)
 EXTRA_DSO_LDOPTS += $(TK_LIBS)
 endif
 
-ifeq ($(OS_ARCH),BeOS)
+ifeq (,$(filter-out BeOS Haiku, $(OS_ARCH)))
 EXTRA_DSO_LDOPTS += -lbe
 endif
 
 ifeq ($(OS_ARCH),WINNT)
 EXTRA_DSO_LDOPTS += $(call EXPAND_LIBNAME, shell32 ole32)
 ifneq (,$(MOZ_DEBUG)$(NS_TRACE_MALLOC))
 EXTRA_DSO_LDOPTS += $(call EXPAND_LIBNAME, imagehlp)
 endif
Index: mozilla/xpcom/reflect/xptcall/src/md/unix/Makefile.in
===================================================================
RCS file: /cvsroot/mozilla/xpcom/reflect/xptcall/src/md/unix/Makefile.in,v
retrieving revision 1.80.4.6
diff -u -8 -p -r1.80.4.6 Makefile.in
--- mozilla/xpcom/reflect/xptcall/src/md/unix/Makefile.in	19 Feb 2008 21:11:34 -0000	1.80.4.6
+++ mozilla/xpcom/reflect/xptcall/src/md/unix/Makefile.in	9 Feb 2009 04:06:11 -0000
@@ -90,21 +90,23 @@ endif
 # IA64 Linux
 ifneq (,$(filter Linux,$(OS_ARCH)))
 ifneq (,$(findstring ia64,$(OS_TEST)))
 CPPSRCS		:= xptcinvoke_ipf64.cpp xptcstubs_ipf64.cpp
 ASFILES		:= xptcstubs_asm_ipf64.s xptcinvoke_asm_ipf64.s
 endif
 endif
 #
-# BeOS/Intel (uses the same unixish_x86 code)
+# BeOS/Intel (uses the same as Linux, works well. Migrate others!)
 #
-ifeq ($(OS_ARCH)$(OS_TEST),BeOSBePC)
+#ifeq ($(OS_ARCH)$(OS_TEST),BeOSBePC)
+ifeq (,$(filter-out BeOSBePC HaikuBePC, $(OS_ARCH)$(OS_TEST)))
 CPPSRCS		:= xptcinvoke_gcc_x86_unix.cpp xptcstubs_gcc_x86_unix.cpp
 endif
+
 #
 # Neutrino/Intel (uses the same unixish_x86 code)
 #
 ifeq ($(OS_TARGET),NTO)
 ifeq ($(OS_TEST),x86)
 CPPSRCS		:= xptcinvoke_unixish_x86.cpp xptcstubs_unixish_x86.cpp
 endif
 ifeq ($(OS_TEST),arm)
Index: mozilla/xpcom/reflect/xptcall/src/md/unix/xptc_platforms_unixish_x86.h
===================================================================
RCS file: /cvsroot/mozilla/xpcom/reflect/xptcall/src/md/unix/xptc_platforms_unixish_x86.h,v
retrieving revision 1.18.28.3
diff -u -8 -p -r1.18.28.3 xptc_platforms_unixish_x86.h
--- mozilla/xpcom/reflect/xptcall/src/md/unix/xptc_platforms_unixish_x86.h	9 Apr 2007 20:01:13 -0000	1.18.28.3
+++ mozilla/xpcom/reflect/xptcall/src/md/unix/xptc_platforms_unixish_x86.h	9 Feb 2009 04:06:12 -0000
@@ -133,17 +133,22 @@
 /* Old gcc 2.7.x.x.  What does gcc 2.8.x do?? */
 #define CFRONT_STYLE_THIS_ADJUST
 #else
 /* egcs and later */
 #define THUNK_BASED_THIS_ADJUST
 #endif
 
 #elif defined(__BEOS__) 
+#if (__GNUC__ == 2) 
 #define CFRONT_STYLE_THIS_ADJUST
+#else
+#define THUNK_BASED_THIS_ADJUST
+#endif
+
 
 #elif defined(__sun__) || defined(__sun)
 #if defined(__GXX_ABI_VERSION) && __GXX_ABI_VERSION >= 100 /* G++ V3 ABI */
 #define THUNK_BASED_THIS_ADJUST
 #else
 #define CFRONT_STYLE_THIS_ADJUST
 #endif
 
Index: mozilla/xpfe/bootstrap/Makefile.in
===================================================================
RCS file: /cvsroot/mozilla/xpfe/bootstrap/Attic/Makefile.in,v
retrieving revision 1.283.2.6
diff -u -8 -p -r1.283.2.6 Makefile.in
--- mozilla/xpfe/bootstrap/Makefile.in	29 Sep 2007 20:15:11 -0000	1.283.2.6
+++ mozilla/xpfe/bootstrap/Makefile.in	9 Feb 2009 04:06:16 -0000
@@ -113,18 +113,22 @@ ifdef MOZ_ENABLE_XREMOTE
 REQUIRES	+= xremoteservice
 endif
 
 include $(topsrcdir)/config/config.mk
 
 ifeq ($(USE_SHORT_LIBNAME),1)
 PROGRAM		= $(MOZ_APP_NAME)$(BIN_SUFFIX)
 else
+ifeq (,$(filter-out BeOS Haiku, $(OS_ARCH)))
+PROGRAM = $(MOZ_APP_NAME)$(BIN_SUFFIX)
+else
 PROGRAM		= $(MOZ_APP_NAME)-bin$(BIN_SUFFIX)
 endif
+endif
 
 # Force applications to be built non-statically
 # when building the mozcomps meta component
 ifneq (,$(filter mozcomps,$(MOZ_META_COMPONENTS)))
 BUILD_STATIC_LIBS=
 BUILD_SHARED_LIBS=1
 ifdef MOZ_COMPONENTLIB
 DEFINES += -D_MOZCOMPS_SHARED_LIBRARY -D_BUILD_STATIC_BIN
@@ -406,17 +410,17 @@ ifndef GNU_CC
 LDFLAGS += /HEAP:0x40000
 endif
 endif
 
 CXXFLAGS	+= $(MOZ_TOOLKIT_REGISTRY_CFLAGS)
 
 LOCAL_INCLUDES  += -I$(srcdir) -I.
 
-ifneq (,$(filter-out OS2 WINNT,$(OS_ARCH)))
+ifneq (,$(filter-out OS2 WINNT BeOS Haiku,$(OS_ARCH)))
 $(MOZ_APP_NAME).1: mozilla.man.in Makefile.in Makefile $(DEPTH)/config/autoconf.mk
 	@sed -e "s|\@bindir\@|$(bindir)|g" -e "s|\@mozappdir\@|$(mozappdir)|g" \
 		-e "s|\@MOZ_APP_DISPLAYNAME\@|$(MOZ_APP_DISPLAYNAME)|g" \
 		-e "s|\@MOZ_APP_NAME\@|$(MOZ_APP_NAME)|g" \
 		-e "s|\@MOZ_APP_VERSION\@|${MOZ_APP_VERSION}|g" < $< > $@
 
 libs:: $(MOZ_APP_NAME).1
 	$(INSTALL) $< $(DIST)/man/man1
Index: mozilla/xpfe/bootstrap/nsSigHandlers.cpp
===================================================================
RCS file: /cvsroot/mozilla/xpfe/bootstrap/nsSigHandlers.cpp,v
retrieving revision 1.41.18.1
diff -u -8 -p -r1.41.18.1 nsSigHandlers.cpp
--- mozilla/xpfe/bootstrap/nsSigHandlers.cpp	22 Jun 2006 22:31:13 -0000	1.41.18.1
+++ mozilla/xpfe/bootstrap/nsSigHandlers.cpp	9 Feb 2009 04:06:17 -0000
@@ -55,17 +55,18 @@
 #include <stdlib.h> // atoi
 #endif
 
 #if defined(SOLARIS)
 #include <sys/resource.h>
 #endif
 
 #ifdef XP_BEOS
-#include <be/app/Application.h>
+#include <stdlib.h>
+#include <app/Application.h>
 #include <string.h>
 #include "nsCOMPtr.h"
 #include "nsIServiceManager.h"
 #include "nsIAppStartup.h"
 #include "nsXPFEComponentsCID.h"
 #endif
 
 #ifdef MOZ_WIDGET_PHOTON
Index: mozilla/xpinstall/packager/Makefile.in
===================================================================
RCS file: /cvsroot/mozilla/xpinstall/packager/Attic/Makefile.in,v
retrieving revision 1.68.4.1
diff -u -8 -p -r1.68.4.1 Makefile.in
--- mozilla/xpinstall/packager/Makefile.in	20 Feb 2006 17:42:11 -0000	1.68.4.1
+++ mozilla/xpinstall/packager/Makefile.in	9 Feb 2009 04:06:26 -0000
@@ -43,17 +43,17 @@ srcdir		= @srcdir@
 VPATH		= @srcdir@
 
 include $(DEPTH)/config/autoconf.mk
 
 OSPACKAGE	= unix
 ifeq ($(OS_ARCH),IRIX)
 STRIP_FLAGS	= -f
 endif
-ifeq ($(OS_ARCH),BeOS)
+ifeq (,$(filter-out BeOS Haiku, $(OS_ARCH)))
 STRIP_FLAGS	= -g
 PLATFORM_EXCLUDE_LIST = ! -name "*.stub" ! -name "$(MOZ_PKG_APPNAME)-bin"
 endif
 ifeq ($(OS_ARCH),OS2)
 STRIP		= $(srcdir)/os2/strip.cmd
 STRIP_FLAGS	=
 OSPACKAGE	= os2
 PLATFORM_EXCLUDE_LIST = ! -name "*.ico"
Index: mozilla/xulrunner/app/Makefile.in
===================================================================
RCS file: /cvsroot/mozilla/xulrunner/app/Makefile.in,v
retrieving revision 1.23.2.4
diff -u -8 -p -r1.23.2.4 Makefile.in
--- mozilla/xulrunner/app/Makefile.in	9 Apr 2008 06:50:54 -0000	1.23.2.4
+++ mozilla/xulrunner/app/Makefile.in	9 Feb 2009 04:06:32 -0000
@@ -54,17 +54,17 @@ DIRS		= profile
 PREF_JS_EXPORTS = $(srcdir)/xulrunner.js
 GARBAGE += $(addprefix $(DIST)/bin/defaults/pref/,xulrunner.js)
 
 DEFINES += -DAB_CD=$(AB_CD)
 
 ifeq ($(USE_SHORT_LIBNAME), 1)
 PROGRAM = xulrunner$(BIN_SUFFIX)
 else
-ifeq ($(OS_ARCH), BeOS)
+ifeq (,$(filter-out BeOS Haiku, $(OS_ARCH)))
 PROGRAM = xulrunner$(BIN_SUFFIX)
 else
 PROGRAM = xulrunner-bin$(BIN_SUFFIX)
 endif
 endif
 
 DEFINES += -DXULRUNNER_PROGNAME=\"xulrunner\"
 
@@ -80,17 +80,17 @@ REQUIRES = \
         xulrunner \
 	$(NULL)
 
 CPPSRCS = nsXULRunnerApp.cpp
 
 ifeq ($(OS_ARCH),WINNT)
 CPPSRCS += nsRegisterGREWin.cpp
 else
-ifneq (,$(filter OS2 Darwin,$(OS_ARCH)))
+ifneq (,$(filter OS2 Darwin BeOS Haiku,$(OS_ARCH)))
 CPPSRCS += nsRegisterGREVoid.cpp
 else
 CPPSRCS += nsRegisterGREUnix.cpp
 endif
 endif
 
 LOCAL_INCLUDES += \
         -I$(topsrcdir)/toolkit/xre \
@@ -169,17 +169,17 @@ endif
 ifdef BUILD_STATIC_LIBS
 RCFLAGS += -DMOZ_STATIC_BUILD
 endif
 ifdef DEBUG
 RCFLAGS += -DDEBUG
 endif
 endif
 
-ifeq ($(OS_ARCH),BeOS)
+ifeq (,$(filter-out BeOS Haiku, $(OS_ARCH)))
 OS_LIBS += -ltracker
 endif
 
 ifeq ($(OS_ARCH),OS2)
 RESFILE=splashos2.res
 RCFLAGS += -DMOZ_XULRUNNER
 ifdef BUILD_STATIC_LIBS
 EXE_DEF_FILE = xulrunner.def
@@ -237,17 +237,17 @@ $(EXE_DEF_FILE):
 	@echo 	WinQueryProperty		= PMMERGE.5450 >>$(EXE_DEF_FILE)
 	@echo 	WinRemoveProperty		= PMMERGE.5451 >>$(EXE_DEF_FILE)
 	@echo 	WinSetProperty			= PMMERGE.5452 >>$(EXE_DEF_FILE)
 
 LDFLAGS += -Zlinker /NOE
 endif
 endif
 
-ifneq (,$(filter-out OS2 WINNT Darwin BeOS,$(OS_ARCH)))
+ifneq (,$(filter-out OS2 WINNT Darwin BeOS Haiku,$(OS_ARCH)))
 
 xulrunner:: mozilla.in Makefile.in Makefile $(DEPTH)/config/autoconf.mk
 	cat $< | sed -e "s|%MOZAPPDIR%|$(mozappdir)|" \
                 -e "s|%MOZ_USER_DIR%|.mozilla/xulrunner|" \
 		-e "s|%MREDIR%|$(mredir)|" > $@
 	chmod +x $@
 
 libs:: xulrunner

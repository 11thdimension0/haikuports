diff -urN wizznic-0.9_feedback_version-src/Makefile.haiku wizznic-0.9_feedback_version-src-gcc2/Makefile.haiku
--- wizznic-0.9_feedback_version-src/Makefile.haiku	1970-01-01 00:00:00.000000000 +0000
+++ wizznic-0.9_feedback_version-src-gcc2/Makefile.haiku	2010-09-04 19:52:10.043253760 +0000
@@ -0,0 +1,50 @@
+#Makefile for wizznic.
+#To make a system-wide install add DATADIR=/dir/to/data/ and BINDIR=/dir/to/bin/ to the make command
+
+CC = gcc
+LD = $(CC)
+STRIP = strip
+
+NAME=wizznic
+TARGET= $(NAME)
+
+#Add the PER_USER_FILES define if the DATADIR is set
+ifneq ($(DATADIR),)
+	PUF=-DPER_USER_FILES
+endif
+
+DEFS = $(PUF) -DDATADIR="\"$(DATADIR)\""
+
+INCS =  -I. -I/boot/common/include -I/boot/common/include/SDL
+
+LDFLAGS=$(CFLAGS)
+LIBS = -lSDL -lSDL_image -lSDL_mixer -lpng -lz
+
+OBJS = dumplevelimages.o board.o cursor.o draw.o input.o main.o menu.o sprite.o\
+text.o ticks.o sound.o game.o player.o list.o levels.o wiz.o pixel.o stars.o\
+levelselector.o leveleditor.o particle.o pack.o settings.o stats.o strings.o\
+mbrowse.o teleport.o credits.o waveimg.o userfiles.o
+
+MYCC = $(CC) $(CFLAGS) $(INCS) $(DEFS)
+
+########################################################################
+
+sdl: $(TARGET)
+
+$(TARGET): $(OBJS)
+	$(LD) $(LDFLAGS) $(OBJS) -o $@ $(LIBS)
+	$(STRIP) $@
+
+.c.o:
+	$(MYCC) -c $< -o $@
+
+install:
+	install -d -D -m 755 "$(DESTDIR)$(BINDIR)"
+	install -D -m 755 "$(TARGET)" "$(DESTDIR)$(BINDIR)"
+	install -d -D -m 755 "$(DESTDIR)$(DATADIR)"
+	cp -R data "$(DESTDIR)$(DATADIR)"
+	cp -R packs "$(DESTDIR)$(DATADIR)"
+	chmod -R 755 "$(DESTIR)$(DATADIR)"
+
+clean:
+	rm -f *.o $(NAME)
diff -urN wizznic-0.9_feedback_version-src/board.c wizznic-0.9_feedback_version-src-gcc2/board.c
--- wizznic-0.9_feedback_version-src/board.c	2010-07-18 03:00:58.039059456 +0000
+++ wizznic-0.9_feedback_version-src-gcc2/board.c	2010-09-04 09:14:16.000000000 +0000
@@ -1,498 +1,502 @@
 #include "board.h"
-
+
 #include <stdio.h>
-#include "ticks.h"
-#include "strings.h"
+#include "ticks.h"
+#include "strings.h"
 #include "teleport.h"
-#include "particles.h"
+#include "particles.h"
 #include "draw.h"
-
-static int isWall(playField* pf, int x, int y)
-{
-  if(x < 0) return(0);
-  if(x+1 > FIELDSIZE) return(0);
-  if(y < 0) return(0);
-  if(y+1 > FIELDSIZE) return(0);
-
-  if(!pf->board[x][y]) return(0);
-  if(pf->board[x][y]->type==STDWALL) return(1);
-  return(0);
-}
-
-void setWallType(playField* pf, int x, int y)
-{
-  //see if has neighbours:
-  //Top-Left
-  if( !isWall(pf, x-1,y) && !isWall( pf, x, y-1) && isWall(pf, x+1,y) && isWall(pf,x,y+1) )
-  {
-    pf->board[x][y]->wall = 0;
-  }
-  //Top
-  if( isWall(pf, x-1,y) && !isWall( pf, x, y-1) && isWall(pf, x+1,y) && isWall(pf,x,y+1) )
-  {
-    pf->board[x][y]->wall = 1;
-  }
-  //Top-Right
-  if( isWall(pf, x-1,y) && !isWall( pf, x, y-1) && !isWall(pf, x+1,y) && isWall(pf,x,y+1) )
-  {
-    pf->board[x][y]->wall = 2;
-  }
-  //Left
-  if( !isWall(pf, x-1,y) && isWall( pf, x, y-1) && isWall(pf, x+1,y) && isWall(pf,x,y+1) )
-  {
-    pf->board[x][y]->wall = 3;
-  }
-  //Middle
-  if( isWall(pf, x-1,y) && isWall( pf, x, y-1) && isWall(pf, x+1,y) && isWall(pf,x,y+1) )
-  {
-    pf->board[x][y]->wall = 4;
-  }
-  //Right
-  if( isWall(pf, x-1,y) && isWall( pf, x, y-1) && !isWall(pf, x+1,y) && isWall(pf,x,y+1) )
-  {
-    pf->board[x][y]->wall = 5;
-  }
-  //LeftBot
-  if( !isWall(pf, x-1,y) && isWall( pf, x, y-1) && isWall(pf, x+1,y) && !isWall(pf,x,y+1) )
-  {
-    pf->board[x][y]->wall = 6;
-  }
-  //Bot
-  if( isWall(pf, x-1,y) && isWall( pf, x, y-1) && isWall(pf, x+1,y) && !isWall(pf,x,y+1) )
-  {
-    pf->board[x][y]->wall = 7;
-  }
-  //RightBot
-  if( isWall(pf, x-1,y) && isWall( pf, x, y-1) && !isWall(pf, x+1,y) && !isWall(pf,x,y+1) )
-  {
-    pf->board[x][y]->wall = 8;
-  }
-  //Left,Top,Right
-  if( !isWall(pf, x-1,y) && !isWall( pf, x, y-1) && !isWall(pf, x+1,y) && isWall(pf,x,y+1) )
-  {
-    pf->board[x][y]->wall = 9;
-  }
-  //Left, top, bot
-  if( !isWall(pf, x-1,y) && !isWall( pf, x, y-1) && isWall(pf, x+1,y) && !isWall(pf,x,y+1) )
-  {
-    pf->board[x][y]->wall = 10;
-  }
-  //Top, right, bot
-  if( isWall(pf, x-1,y) && !isWall( pf, x, y-1) && !isWall(pf, x+1,y) && !isWall(pf,x,y+1) )
-  {
-    pf->board[x][y]->wall = 11;
-  }
-  //Left, bot, right
-  if( !isWall(pf, x-1,y) && isWall( pf, x, y-1) && !isWall(pf, x+1,y) && !isWall(pf,x,y+1) )
-  {
-    pf->board[x][y]->wall = 12;
-  }
-  //Vert
-  if( !isWall(pf, x-1,y) && isWall( pf, x, y-1) && !isWall(pf, x+1,y) && isWall(pf,x,y+1) )
-  {
-    pf->board[x][y]->wall = 13;
-  }
-  //Horiz
-  if( isWall(pf, x-1,y) && !isWall( pf, x, y-1) && isWall(pf, x+1,y) && !isWall(pf,x,y+1) )
-  {
-    pf->board[x][y]->wall = 14;
-  }
-
-  //Middle - clear
-  if( !isWall(pf, x-1,y) && !isWall( pf, x, y-1) && !isWall(pf, x+1,y) && !isWall(pf,x,y+1) )
-  {
-    pf->board[x][y]->wall=15;
-  }
-}
-
-void boardSetWalls(playField* pf)
-{
-  int x,y;
-  for(x=0; x < FIELDSIZE; x++)
-  {
-    for(y=0; y < FIELDSIZE; y++)
-    {
-      if(pf->board[x][y] && pf->board[x][y]->type==STDWALL)
-      {
-        setWallType(pf,x,y);
-      }
-    }
-  }
-}
-
+
+static int isWall(playField* pf, int x, int y)
+{
+  if(x < 0) return(0);
+  if(x+1 > FIELDSIZE) return(0);
+  if(y < 0) return(0);
+  if(y+1 > FIELDSIZE) return(0);
+
+  if(!pf->board[x][y]) return(0);
+  if(pf->board[x][y]->type==STDWALL) return(1);
+  return(0);
+}
+
+void setWallType(playField* pf, int x, int y)
+{
+  //see if has neighbours:
+  //Top-Left
+  if( !isWall(pf, x-1,y) && !isWall( pf, x, y-1) && isWall(pf, x+1,y) && isWall(pf,x,y+1) )
+  {
+    pf->board[x][y]->wall = 0;
+  }
+  //Top
+  if( isWall(pf, x-1,y) && !isWall( pf, x, y-1) && isWall(pf, x+1,y) && isWall(pf,x,y+1) )
+  {
+    pf->board[x][y]->wall = 1;
+  }
+  //Top-Right
+  if( isWall(pf, x-1,y) && !isWall( pf, x, y-1) && !isWall(pf, x+1,y) && isWall(pf,x,y+1) )
+  {
+    pf->board[x][y]->wall = 2;
+  }
+  //Left
+  if( !isWall(pf, x-1,y) && isWall( pf, x, y-1) && isWall(pf, x+1,y) && isWall(pf,x,y+1) )
+  {
+    pf->board[x][y]->wall = 3;
+  }
+  //Middle
+  if( isWall(pf, x-1,y) && isWall( pf, x, y-1) && isWall(pf, x+1,y) && isWall(pf,x,y+1) )
+  {
+    pf->board[x][y]->wall = 4;
+  }
+  //Right
+  if( isWall(pf, x-1,y) && isWall( pf, x, y-1) && !isWall(pf, x+1,y) && isWall(pf,x,y+1) )
+  {
+    pf->board[x][y]->wall = 5;
+  }
+  //LeftBot
+  if( !isWall(pf, x-1,y) && isWall( pf, x, y-1) && isWall(pf, x+1,y) && !isWall(pf,x,y+1) )
+  {
+    pf->board[x][y]->wall = 6;
+  }
+  //Bot
+  if( isWall(pf, x-1,y) && isWall( pf, x, y-1) && isWall(pf, x+1,y) && !isWall(pf,x,y+1) )
+  {
+    pf->board[x][y]->wall = 7;
+  }
+  //RightBot
+  if( isWall(pf, x-1,y) && isWall( pf, x, y-1) && !isWall(pf, x+1,y) && !isWall(pf,x,y+1) )
+  {
+    pf->board[x][y]->wall = 8;
+  }
+  //Left,Top,Right
+  if( !isWall(pf, x-1,y) && !isWall( pf, x, y-1) && !isWall(pf, x+1,y) && isWall(pf,x,y+1) )
+  {
+    pf->board[x][y]->wall = 9;
+  }
+  //Left, top, bot
+  if( !isWall(pf, x-1,y) && !isWall( pf, x, y-1) && isWall(pf, x+1,y) && !isWall(pf,x,y+1) )
+  {
+    pf->board[x][y]->wall = 10;
+  }
+  //Top, right, bot
+  if( isWall(pf, x-1,y) && !isWall( pf, x, y-1) && !isWall(pf, x+1,y) && !isWall(pf,x,y+1) )
+  {
+    pf->board[x][y]->wall = 11;
+  }
+  //Left, bot, right
+  if( !isWall(pf, x-1,y) && isWall( pf, x, y-1) && !isWall(pf, x+1,y) && !isWall(pf,x,y+1) )
+  {
+    pf->board[x][y]->wall = 12;
+  }
+  //Vert
+  if( !isWall(pf, x-1,y) && isWall( pf, x, y-1) && !isWall(pf, x+1,y) && isWall(pf,x,y+1) )
+  {
+    pf->board[x][y]->wall = 13;
+  }
+  //Horiz
+  if( isWall(pf, x-1,y) && !isWall( pf, x, y-1) && isWall(pf, x+1,y) && !isWall(pf,x,y+1) )
+  {
+    pf->board[x][y]->wall = 14;
+  }
+
+  //Middle - clear
+  if( !isWall(pf, x-1,y) && !isWall( pf, x, y-1) && !isWall(pf, x+1,y) && !isWall(pf,x,y+1) )
+  {
+    pf->board[x][y]->wall=15;
+  }
+}
+
+void boardSetWalls(playField* pf)
+{
+  int x,y;
+  for(x=0; x < FIELDSIZE; x++)
+  {
+    for(y=0; y < FIELDSIZE; y++)
+    {
+      if(pf->board[x][y] && pf->board[x][y]->type==STDWALL)
+      {
+        setWallType(pf,x,y);
+      }
+    }
+  }
+}
+
 int loadField(playField* pf, const char* file)
 {
+  char temp[32];
+  int type=0;
+  int c=0,x=0,y=0;
   FILE *f = fopen(file, "r");
-  if(!f)
-  {
-    printf("%s %i Board: couldn't open '%s'\n",__FILE__,__LINE__,file);
-  }
-
-  char temp[32];
-  int type=0;
-
-  //For atoi hack
-  temp[2] = '\0';
-
-  //Fast forward to the interesting section.
-  while( fgets( temp,32, f) )
-  {
-    stripNewLine( temp);
-    if(strcmp("[data]", temp)==0)
-    {
-      break;
-    }
-  }
-  //For checking that level var correctly loaded
-  //Read each byte into the field
-  int c=0,x=0,y=0;
-  do {
-    c = fgetc(f);
-    temp[0]=c;
-
-    if(c=='\n')
-    {
-        y++;
-        x=0;
-        if(y == FIELDSIZE)
-        {
-          break;
-        }
-    } else if(c=='\r')
-    {
-      //Ignore windows wanting to run on a typewriter.
-    } else {
-      if(x==FIELDSIZE) { return(0); } //Error loading level, bail before accesing invalid index.
-
-      temp[1]=fgetc(f);
-      type=atoi(temp);
-
-      if(type !=0)
-      {
-        pf->board[x][y] = malloc( sizeof( brickType ) );
-        pf->board[x][y]->type = type;
-        pf->board[x][y]->pxx = x*brickSize+boardOffsetX;
-        pf->board[x][y]->pxy = y*brickSize+boardOffsetY;
-        pf->board[x][y]->dir=0;
-        pf->board[x][y]->checked=0;
-        pf->board[x][y]->curLock=0;
-        pf->board[x][y]->sx = x;
-        pf->board[x][y]->sy = y;
+  if(!f)
+  {
+    printf("%s %i Board: couldn't open '%s'\n",__FILE__,__LINE__,file);
+  }
+
+  //For atoi hack
+  temp[2] = '\0';
+
+  //Fast forward to the interesting section.
+  while( fgets( temp,32, f) )
+  {
+    stripNewLine( temp);
+    if(strcmp("[data]", temp)==0)
+    {
+      break;
+    }
+  }
+  //For checking that level var correctly loaded
+  //Read each byte into the field
+
+  do {
+    c = fgetc(f);
+    temp[0]=c;
+
+    if(c=='\n')
+    {
+        y++;
+        x=0;
+        if(y == FIELDSIZE)
+        {
+          break;
+        }
+    } else if(c=='\r')
+    {
+      //Ignore windows wanting to run on a typewriter.
+    } else {
+      if(x==FIELDSIZE) { return(0); } //Error loading level, bail before accesing invalid index.
+
+      temp[1]=fgetc(f);
+      type=atoi(temp);
+
+      if(type !=0)
+      {
+        pf->board[x][y] = malloc( sizeof( brickType ) );
+        pf->board[x][y]->type = type;
+        pf->board[x][y]->pxx = x*brickSize+boardOffsetX;
+        pf->board[x][y]->pxy = y*brickSize+boardOffsetY;
+        pf->board[x][y]->dir=0;
+        pf->board[x][y]->checked=0;
+        pf->board[x][y]->curLock=0;
+        pf->board[x][y]->sx = x;
+        pf->board[x][y]->sy = y;
         pf->board[x][y]->dx = x;
         pf->board[x][y]->dy = y;
-        pf->board[x][y]->tl  = MOVERCOUNTDOWN;
-        pf->board[x][y]->moveXspeed = 0;
-        pf->board[x][y]->moveYspeed = 0;
+        pf->board[x][y]->tl  = MOVERCOUNTDOWN;
+        pf->board[x][y]->moveXspeed = 0;
+        pf->board[x][y]->moveYspeed = 0;
 
         pf->board[x][y]->dmx = 0;
-      } else {
-        pf->board[x][y] = 0;
-      }
-      x++;
-    }
-
-  } while( c != EOF );
-
-  //Close the file
-  fclose(f);
-
-  pf->movingList = initList();
-  pf->removeList = initList();
-
-  pf->blocker = malloc(sizeof(brickType));
-  pf->blocker->type=RESERVED;
-
-  //Figure out which tile to use for each wall (int 6)
-  boardSetWalls(pf);
-
+      } else {
+        pf->board[x][y] = 0;
+      }
+      x++;
+    }
+
+  } while( c != EOF );
+
+  //Close the file
+  fclose(f);
+
+  pf->movingList = initList();
+  pf->removeList = initList();
+
+  pf->blocker = malloc(sizeof(brickType));
+  pf->blocker->type=RESERVED;
+
+  //Figure out which tile to use for each wall (int 6)
+  boardSetWalls(pf);
+
   return(1);
 }
-
-void freeField(playField* pf)
-{
-  int x,y;
-  for(y=0; y < FIELDSIZE; y++)
-  {
-    for(x=0; x < FIELDSIZE; x++)
-    {
-      if(pf->board[x][y])
-      {
-        //We don't want to free the blocker more than once.
-        if(pf->board[x][y]->type!=RESERVED)
-        {
-          free(pf->board[x][y]);
-        }
-        pf->board[x][y]=0;
-      }
-    }
-  }
-  free(pf->blocker);
-  //Clear the lists
-  freeList(pf->movingList);
-  freeList(pf->removeList);
-
-}
-
-int moveBrick(playField* pf, int x, int y, int dirx, int diry, int block, int speed)
-{
-  //Destination x
-  int dx = x+dirx;
-  int dy = y+diry;
-
-  //Trying to move out of field?
-  if( dx < 0 || dx == FIELDSIZE ) return(0);
-  if( dy < 0 || dy == FIELDSIZE ) return(0);
-
-
-  if(!pf->board[x][y]) return(0);
-
-  pf->board[x][y]->dmx=0; //Just always reset it.
-
-  //OneWay or glue below?
-  if(y+1<FIELDSIZE)
-  {
-    if(isOneWay(pf->board[x][y+1]))
-    {
-      if(pf->board[x][y+1]->type==ONEWAYLEFT && dirx==DIRRIGHT) return(0);
-      if(pf->board[x][y+1]->type==ONEWAYRIGHT && dirx==DIRLEFT) return(0);
-    } else if(pf->board[x][y+1] &&pf->board[x][y+1]->type==GLUE)
-    {
-      return(0);
-    }
-  }
-
-  //If destination is empty
-  if( !pf->board[dx][dy] || (block==NOBLOCK && (!pf->board[dx][dy] || pf->board[dx][dy]->type==RESERVED)) )
-  {
-      //Set destination
-      pf->board[x][y]->dx=dx;
-      pf->board[x][y]->dy=dy;
-
-      //Set source
-      pf->board[x][y]->sx=x;
-      pf->board[x][y]->sy=y;
-
-      //Set moving speed
-      pf->board[x][y]->moveXspeed=speed*dirx;
-      pf->board[x][y]->moveYspeed=speed*diry;
-
-      //add to moving
-      listAddData(pf->movingList, (void*)pf->board[x][y]);
-
-      pf->board[dx][dy]=pf->blocker;
-      pf->board[x][y]=pf->blocker;
-
-    return(1);
-  }
-
-  return(0);
+
+void freeField(playField* pf)
+{
+  int x,y;
+  for(y=0; y < FIELDSIZE; y++)
+  {
+    for(x=0; x < FIELDSIZE; x++)
+    {
+      if(pf->board[x][y])
+      {
+        //We don't want to free the blocker more than once.
+        if(pf->board[x][y]->type!=RESERVED)
+        {
+          free(pf->board[x][y]);
+        }
+        pf->board[x][y]=0;
+      }
+    }
+  }
+  free(pf->blocker);
+  //Clear the lists
+  freeList(pf->movingList);
+  freeList(pf->removeList);
+
+}
+
+int moveBrick(playField* pf, int x, int y, int dirx, int diry, int block, int speed)
+{
+  //Destination x
+  int dx = x+dirx;
+  int dy = y+diry;
+
+  //Trying to move out of field?
+  if( dx < 0 || dx == FIELDSIZE ) return(0);
+  if( dy < 0 || dy == FIELDSIZE ) return(0);
+
+
+  if(!pf->board[x][y]) return(0);
+
+  pf->board[x][y]->dmx=0; //Just always reset it.
+
+  //OneWay or glue below?
+  if(y+1<FIELDSIZE)
+  {
+    if(isOneWay(pf->board[x][y+1]))
+    {
+      if(pf->board[x][y+1]->type==ONEWAYLEFT && dirx==DIRRIGHT) return(0);
+      if(pf->board[x][y+1]->type==ONEWAYRIGHT && dirx==DIRLEFT) return(0);
+    } else if(pf->board[x][y+1] &&pf->board[x][y+1]->type==GLUE)
+    {
+      return(0);
+    }
+  }
+
+  //If destination is empty
+  if( !pf->board[dx][dy] || (block==NOBLOCK && (!pf->board[dx][dy] || pf->board[dx][dy]->type==RESERVED)) )
+  {
+      //Set destination
+      pf->board[x][y]->dx=dx;
+      pf->board[x][y]->dy=dy;
+
+      //Set source
+      pf->board[x][y]->sx=x;
+      pf->board[x][y]->sy=y;
+
+      //Set moving speed
+      pf->board[x][y]->moveXspeed=speed*dirx;
+      pf->board[x][y]->moveYspeed=speed*diry;
+
+      //add to moving
+      listAddData(pf->movingList, (void*)pf->board[x][y]);
+
+      pf->board[dx][dy]=pf->blocker;
+      pf->board[x][y]=pf->blocker;
+
+    return(1);
+  }
+
+  return(0);
 }
 
 //Move a brick instantly to teleports dest
 void telePortBrick(playField* pf,telePort_t* t,cursorType* cur)
-{
-
-  psysSet_t ps; //Particle system for particle effect
-  brickType* b = pf->board[t->sx][t->sy];
-
-  //Setup particle system
-  ps.fade=0;
-  ps.gravity=0;
-  ps.bounce=0;
-  ps.srcImg=0;
-
-
-  //Spawn systems in source
-  ps.x=b->pxx+stealGfxPtr()->tiles[b->type-1]->clip.w/2;
-  ps.y=b->pxy+stealGfxPtr()->tiles[b->type-1]->clip.h/2;
-  ps.vel=100; // +/- in each dir
-  ps.life=350;
-  ps.lifeVar=10;
-  ps.color=PARTICLECOLORRANDOM;
-  ps.numParticles=60;
-  spawnParticleSystem(&ps);
-  ps.vel=50; // +/- in each dir
-  ps.life=200;
-  ps.lifeVar=10;
-  ps.color=0xFFFF;
-  ps.numParticles=30;
-  spawnParticleSystem(&ps);
-
-
-  //Move brick to dest
-  pf->board[t->dx][t->dy]=b;
-  pf->board[t->sx][t->sy]=0;
-
-  //Set pixel position
-  b->pxx=boardOffsetX+20*t->dx;
-  b->pxy=boardOffsetY+20*t->dy;
-
-  b->dx=t->dx;
-  b->dy=t->dy;
-
-  b->sx=b->dx;
-  b->sy=b->dy;
-
-  //Spawn system in dest
-  ps.x=b->pxx+stealGfxPtr()->tiles[b->type-1]->clip.w/2;
-  ps.y=b->pxy+stealGfxPtr()->tiles[b->type-1]->clip.h/2;
-  ps.vel=100; // +/- in each dir
-  ps.life=300;
-  ps.lifeVar=10;
-  ps.color=PARTICLECOLORRANDOM;
-  ps.numParticles=60;
-  spawnParticleSystem(&ps);
-  ps.vel=50; // +/- in each dir
-  ps.life=200;
-  ps.lifeVar=10;
-  ps.color=0xFFFF;
-  ps.numParticles=30;
-  spawnParticleSystem(&ps);
-
-  //Move cursor?
-  if( cur->lock && cur->x == t->sx && cur->y == t->sy )
-  {
-    b->curLock=1;
-    //Move cursor
-    cur->px=b->pxx-4;
-    cur->py=b->pxy-4;
-    cur->x=b->dx;
-    cur->y=b->dy;
-    cur->dx=b->dx;
-    cur->dy=b->dy;
-  }
-
-  //Play sound
-  sndPlayOnce(SND_TELEPORTED, b->pxx);
-
-}
-
-void doTelePort(playField* pf,cursorType* cur)
-{
-  listItem* li=pf->levelInfo->teleList;
-
-  while( (li=li->next) )
-  {
-    telePort_t* t = (telePort_t*)li->data;
-
-    //Check if theres something in src, and that dst is free
-    if( pf->board[t->sx][t->sy] && !pf->board[t->dx][t->dy] )
-    {
-      //Is it a brick that's in sx ?
-      if(isBrick(pf->board[t->sx][t->sy]))
-      {
-        telePortBrick(pf, t,cur);
-      }
-    }
-  }
-}
-
-//BUG: This function will move a mover which is getting atop or below another.
-//Don't have movers that can touch.
-static int vertMover(playField* pf,int x, int y, int dir)
-{
-  //Outside bounds
-  if(y+dir < 0 || y+dir == FIELDSIZE) return(0);
-
-  //Abort if it's not a brick, or a mover.
-  if(!isBrick(pf->board[x][y]) && !isMover(pf->board[x][y]) ) return(0);
-
-  //Found a space
-  if( !pf->board[x][y+dir] )
-  {
-     moveBrick(pf,x,y,0,dir, NOBLOCK, VERTMOVERSPEED);
-     return(1);
-  } else if(vertMover(pf, x, y+dir, dir))
-  {
-    moveBrick(pf,x,y,0,dir, NOBLOCK, VERTMOVERSPEED);
-    return(1);
-  }
-
-  return(0);
-}
-
-static int bricksOnTop(playField* pf, int x, int y)
-{
-  int num=0;
-  while(1)
-  {
-    y--;
-    if(y < 0) return(num);
-    if(pf->board[x][y] && isBrick(pf->board[x][y]))
-      num++;
-      else
-    return(num);
-  }
-
-}
-
-//Returns 0 if couldn't move. Returns 1 if could.
-static int horizMover(playField* pf, int x, int y, int dir)
-{
-  //Out of bounds
-  if(x+dir<FIELDSIZE && x+dir>-1)
-  {
-    //Can it move to the side?
-    if( !pf->board[x+dir][y] )
-    {
-      //Move
-      moveBrick(pf,x,y,dir,0, DOBLOCK, HORIZMOVERSPEED);
-
-      //Move the ones on top (if possible)
-      int stop=0;
-      while( !stop )
-      {
-
-        if(x+dir < FIELDSIZE && x+dir > -1)
-        {
-          y--;
-          if( y > -1 && pf->board[x][y] && isBrick(pf->board[x][y]) )
-          {
-            //Can we move that brick one to the dir?
-            if( !pf->board[x+dir][y] )
-            {
-              moveBrick(pf,x,y,dir,0, DOBLOCK, HORIZMOVERSPEED);
-            }
-          } else { stop=1; }
-
-        } else { stop=1; }
-
-      }
-
-    } else { //Can't move that direction
-      return(0);
-    }
-  } else { //No more level, can't move that direction.
-    return(0);
-  }
-
-  //Moved that way.
-  return(1);
-}
-
-void simField(playField* pf, cursorType* cur)
-{
-  int x,y;
-
-  //Update moving bricks
-  listItem* li=pf->movingList;
-  brickType* b;
-  x=0;
-  while( (li = li->next) )
-  {
-    x++;
-   // printf("Bricks in list: %i\n",x);
-    b=(brickType*)li->data;
-
-    //Do we need to move it?
-    int deltaX= (b->dx*brickSize+boardOffsetX) - b->pxx ;
-    int deltaY= (b->dy*brickSize+boardOffsetY) - b->pxy ;
-
-    if(deltaX || deltaY )
-    {
-      //Doing this lock to only move one dir at a time
-      if( deltaX )
-      {
+{
+
+  psysSet_t ps; //Particle system for particle effect
+  brickType* b = pf->board[t->sx][t->sy];
+
+  //Setup particle system
+  ps.fade=0;
+  ps.gravity=0;
+  ps.bounce=0;
+  ps.srcImg=0;
+
+
+  //Spawn systems in source
+  ps.x=b->pxx+stealGfxPtr()->tiles[b->type-1]->clip.w/2;
+  ps.y=b->pxy+stealGfxPtr()->tiles[b->type-1]->clip.h/2;
+  ps.vel=100; // +/- in each dir
+  ps.life=350;
+  ps.lifeVar=10;
+  ps.color=PARTICLECOLORRANDOM;
+  ps.numParticles=60;
+  spawnParticleSystem(&ps);
+  ps.vel=50; // +/- in each dir
+  ps.life=200;
+  ps.lifeVar=10;
+  ps.color=0xFFFF;
+  ps.numParticles=30;
+  spawnParticleSystem(&ps);
+
+
+  //Move brick to dest
+  pf->board[t->dx][t->dy]=b;
+  pf->board[t->sx][t->sy]=0;
+
+  //Set pixel position
+  b->pxx=boardOffsetX+20*t->dx;
+  b->pxy=boardOffsetY+20*t->dy;
+
+  b->dx=t->dx;
+  b->dy=t->dy;
+
+  b->sx=b->dx;
+  b->sy=b->dy;
+
+  //Spawn system in dest
+  ps.x=b->pxx+stealGfxPtr()->tiles[b->type-1]->clip.w/2;
+  ps.y=b->pxy+stealGfxPtr()->tiles[b->type-1]->clip.h/2;
+  ps.vel=100; // +/- in each dir
+  ps.life=300;
+  ps.lifeVar=10;
+  ps.color=PARTICLECOLORRANDOM;
+  ps.numParticles=60;
+  spawnParticleSystem(&ps);
+  ps.vel=50; // +/- in each dir
+  ps.life=200;
+  ps.lifeVar=10;
+  ps.color=0xFFFF;
+  ps.numParticles=30;
+  spawnParticleSystem(&ps);
+
+  //Move cursor?
+  if( cur->lock && cur->x == t->sx && cur->y == t->sy )
+  {
+    b->curLock=1;
+    //Move cursor
+    cur->px=b->pxx-4;
+    cur->py=b->pxy-4;
+    cur->x=b->dx;
+    cur->y=b->dy;
+    cur->dx=b->dx;
+    cur->dy=b->dy;
+  }
+
+  //Play sound
+  sndPlayOnce(SND_TELEPORTED, b->pxx);
+
+}
+
+void doTelePort(playField* pf,cursorType* cur)
+{
+  listItem* li=pf->levelInfo->teleList;
+
+  while( (li=li->next) )
+  {
+    telePort_t* t = (telePort_t*)li->data;
+
+    //Check if theres something in src, and that dst is free
+    if( pf->board[t->sx][t->sy] && !pf->board[t->dx][t->dy] )
+    {
+      //Is it a brick that's in sx ?
+      if(isBrick(pf->board[t->sx][t->sy]))
+      {
+        telePortBrick(pf, t,cur);
+      }
+    }
+  }
+}
+
+//BUG: This function will move a mover which is getting atop or below another.
+//Don't have movers that can touch.
+static int vertMover(playField* pf,int x, int y, int dir)
+{
+  //Outside bounds
+  if(y+dir < 0 || y+dir == FIELDSIZE) return(0);
+
+  //Abort if it's not a brick, or a mover.
+  if(!isBrick(pf->board[x][y]) && !isMover(pf->board[x][y]) ) return(0);
+
+  //Found a space
+  if( !pf->board[x][y+dir] )
+  {
+     moveBrick(pf,x,y,0,dir, NOBLOCK, VERTMOVERSPEED);
+     return(1);
+  } else if(vertMover(pf, x, y+dir, dir))
+  {
+    moveBrick(pf,x,y,0,dir, NOBLOCK, VERTMOVERSPEED);
+    return(1);
+  }
+
+  return(0);
+}
+
+static int bricksOnTop(playField* pf, int x, int y)
+{
+  int num=0;
+  while(1)
+  {
+    y--;
+    if(y < 0) return(num);
+    if(pf->board[x][y] && isBrick(pf->board[x][y]))
+      num++;
+      else
+    return(num);
+  }
+
+}
+
+//Returns 0 if couldn't move. Returns 1 if could.
+static int horizMover(playField* pf, int x, int y, int dir)
+{
+  //Out of bounds
+  if(x+dir<FIELDSIZE && x+dir>-1)
+  {
+    //Can it move to the side?
+    if( !pf->board[x+dir][y] )
+    {
+      int stop=0;
+      //Move
+      moveBrick(pf,x,y,dir,0, DOBLOCK, HORIZMOVERSPEED);
+
+      //Move the ones on top (if possible)
+      while( !stop )
+      {
+        if(x+dir < FIELDSIZE && x+dir > -1)
+        {
+          y--;
+          if( y > -1 && pf->board[x][y] && isBrick(pf->board[x][y]) )
+          {
+            //Can we move that brick one to the dir?
+            if( !pf->board[x+dir][y] )
+            {
+              moveBrick(pf,x,y,dir,0, DOBLOCK, HORIZMOVERSPEED);
+            }
+          } else { stop=1; }
+
+        } else { stop=1; }
+
+      }
+
+    } else { //Can't move that direction
+      return(0);
+    }
+  } else { //No more level, can't move that direction.
+    return(0);
+  }
+
+  //Moved that way.
+  return(1);
+}
+
+void simField(playField* pf, cursorType* cur)
+{
+  int x=0;
+  int y;
+  int deltaX,deltaY;
+
+  //Update moving bricks
+  listItem* li=pf->movingList;
+  brickType* b;
+
+  //May I be forgiven for I do not know better.
+  brickType* hack;
+  
+  while( (li = li->next) )
+  {
+    x++;
+   // printf("Bricks in list: %i\n",x);
+    b=(brickType*)li->data;
+
+    //Do we need to move it?
+    deltaX= (b->dx*brickSize+boardOffsetX) - b->pxx ;
+    deltaY= (b->dy*brickSize+boardOffsetY) - b->pxy ;
+
+    if(deltaX || deltaY )
+    {
+      //Doing this lock to only move one dir at a time
+      if( deltaX )
+      {
         b->pxx += b->moveXspeed;
 
         if(b->moveXspeed < 0 && b->pxx < (b->dx*brickSize+boardOffsetX) )
@@ -501,234 +505,231 @@
         if(b->moveXspeed > 0 && b->pxx > (b->dx*brickSize+boardOffsetX) )
           b->pxx = (b->dx*brickSize+boardOffsetX);
 
-      }
+      }
       if( deltaY)
-      {
+      {
         b->pxy += b->moveYspeed;
-      }
-      //}
-      //Is cursor attached?
-      if(cur->lock && b->curLock)
-      {
-        //Update cursor
-        cur->px=b->pxx-4;
-        cur->py=b->pxy-4;
-      } else {
-        b->curLock=0;
-      }
-    //  printf("Dx:%i X:%i Dy:%i Y:%i\n",deltaX,b->pxx, deltaY, b->pxy);
-    } else { //Not moving anymore, put back down on board
-
-      if(cur->lock && b->curLock)
-      {
-        cur->x=b->dx;
-        cur->y=b->dy;
-        cur->dx=b->dx;
-        cur->dy=b->dy;
-      }
-      if(!cur->lock)
-        b->curLock=0; //Release cursor from brick no matter what
-
-      //Set moving speed 0
-      b->moveXspeed=0;
-      b->moveYspeed=0;
-
-      //Put it down:
+      }
+      //}
+      //Is cursor attached?
+      if(cur->lock && b->curLock)
+      {
+        //Update cursor
+        cur->px=b->pxx-4;
+        cur->py=b->pxy-4;
+      } else {
+        b->curLock=0;
+      }
+    //  printf("Dx:%i X:%i Dy:%i Y:%i\n",deltaX,b->pxx, deltaY, b->pxy);
+    } else { //Not moving anymore, put back down on board
+
+      if(cur->lock && b->curLock)
+      {
+        cur->x=b->dx;
+        cur->y=b->dy;
+        cur->dx=b->dx;
+        cur->dy=b->dy;
+      }
+      if(!cur->lock)
+        b->curLock=0; //Release cursor from brick no matter what
+
+      //Set moving speed 0
+      b->moveXspeed=0;
+      b->moveYspeed=0;
+
+      //Put it down:
       pf->board[ b->dx ][ b->dy ] = b;
 
 
-      //Clear source
-      pf->board[ b->sx ][ b->sy ] = 0;
-
-      //Set source pos = destination pos
-      b->sx=b->dx;
-      b->sy=b->dy;
-
-      //Remove brick from moving list
-      listRemoveItem( pf->movingList, li );
-    }
-  }
-
-  //May I be forgiven for I do not know better.
-  brickType* hack;
-
-  //Run teleport rules first
-  doTelePort(pf,cur);
-
-  //Static bricks
-  for(y=FIELDSIZE-1; y > -1; y--)
-  {
-    for(x=0; x < FIELDSIZE; x++)
-    {
-      if( pf->board[x][y] && !pf->board[x][y]->checked)
-      {
-        pf->board[x][y]->checked=1;
-
-        //Is it a brick
-        if( isBrick(pf->board[x][y]) )
-        {
-          //Cursor locked on it?
-          if( cur->lock && cur->x == x && cur->y == y )
-          {
-            pf->board[x][y]->curLock=1;
+      //Clear source
+      pf->board[ b->sx ][ b->sy ] = 0;
+
+      //Set source pos = destination pos
+      b->sx=b->dx;
+      b->sy=b->dy;
+
+      //Remove brick from moving list
+      listRemoveItem( pf->movingList, li );
+    }
+  }
+
+  //Run teleport rules first
+  doTelePort(pf,cur);
+
+  //Static bricks
+  for(y=FIELDSIZE-1; y > -1; y--)
+  {
+    for(x=0; x < FIELDSIZE; x++)
+    {
+      if( pf->board[x][y] && !pf->board[x][y]->checked)
+      {
+        pf->board[x][y]->checked=1;
+
+        //Is it a brick
+        if( isBrick(pf->board[x][y]) )
+        {
+          //Cursor locked on it?
+          if( cur->lock && cur->x == x && cur->y == y )
+          {
+            pf->board[x][y]->curLock=1;
           }
 
           //Things that happens below it
           if(y+1 < FIELDSIZE)
           {
-
-            //Falling?
-            if( !pf->board[x][y+1] )
-            {
-               //Move down
-              moveBrick(pf, x, y, 0, DIRDOWN, DOBLOCK, FALLINGSPEED);
+
+            //Falling?
+            if( !pf->board[x][y+1] )
+            {
+               //Move down
+              moveBrick(pf, x, y, 0, DIRDOWN, DOBLOCK, FALLINGSPEED);
             } else //Laying on a reserved brick might mean that it should be attached to a mover.
-            {
-              if( pf->board[x][y+1]->type == RESERVED) //Magnet to mover
-              {
-                // Warning: Confuzing and weird stuff below
-                b=findMoving(pf,x,y+1);
-                if(b)
-                {
-                  //Recurse down to see if there is a mover below.
-                  li=pf->movingList;
-                  while( (li=li->next) )
-                  {
-                    if(b)
-                    {
-                      if(b->type==MOVERHORIZ)
-                      {
-                        if(b->sx!=pf->board[x][y]->dx) { break; }
-                        //Magnet onto brick
-                        hack=pf->board[x][y];
-                        if(moveBrick(pf,x,y,(b->dx-b->sx),0, DOBLOCK, HORIZMOVERSPEED))
-                        {
-                          hack->pxx=b->pxx;
-                          hack->moveXspeed=b->moveXspeed;
-                          hack->pxx -= hack->moveXspeed; //To sync with the rest of the bricks. (they allready moved this frame)
-                          break;
-                        }
-                      } else if(b->type==MOVERVERT)
+            {
+              if( pf->board[x][y+1]->type == RESERVED) //Magnet to mover
+              {
+                // Warning: Confuzing and weird stuff below
+                b=findMoving(pf,x,y+1);
+                if(b)
+                {
+                  //Recurse down to see if there is a mover below.
+                  li=pf->movingList;
+                  while( (li=li->next) )
+                  {
+                    if(b)
+                    {
+                      if(b->type==MOVERHORIZ)
+                      {
+                        if(b->sx!=pf->board[x][y]->dx) { break; }
+                        //Magnet onto brick
+                        hack=pf->board[x][y];
+                        if(moveBrick(pf,x,y,(b->dx-b->sx),0, DOBLOCK, HORIZMOVERSPEED))
+                        {
+                          hack->pxx=b->pxx;
+                          hack->moveXspeed=b->moveXspeed;
+                          hack->pxx -= hack->moveXspeed; //To sync with the rest of the bricks. (they allready moved this frame)
+                          break;
+                        }
+                      } else if(b->type==MOVERVERT)
                       {
 
                         //Only magnet if it's moving down (if it's moving up, it will eventually hit the resting brick)
                         if(b->sy < b->dy)
-                        {
-                          //Fetch the original underlying brick.
-                          b=findMoving(pf, x,y+1);
-                          hack=pf->board[x][y];
-                          if(moveBrick(pf,x,y,0,(b->dy-b->sy),NOBLOCK, VERTMOVERSPEED))
-                          {
-                            hack->pxy=b->pxy-20;
-                            hack->moveYspeed=b->moveYspeed;
-                            break;
+                        {
+                          //Fetch the original underlying brick.
+                          b=findMoving(pf, x,y+1);
+                          hack=pf->board[x][y];
+                          if(moveBrick(pf,x,y,0,(b->dy-b->sy),NOBLOCK, VERTMOVERSPEED))
+                          {
+                            hack->pxy=b->pxy-20;
+                            hack->moveYspeed=b->moveYspeed;
+                            break;
                           }
-                        }
+                        }
                       }
-
-                      b=findMoving(pf,x,b->dy+1);
-                    } else {
-                      break;
-                    }
-
-                  } //Loop through list
-                }
+
+                      b=findMoving(pf,x,b->dy+1);
+                    } else {
+                      break;
+                    }
+
+                  } //Loop through list
+                }
               } //Resting on a reserved
             } //Not free
-          }
-        }
-
-        //Is it a mover
-        if(isMover(pf->board[x][y]))
-        {
-          //Horiz mover?
-          if(pf->board[x][y]->type == MOVERHORIZ)
-          {
-            //Moving right?
-            if(pf->board[x][y]->dir)
-            {
-              if(!horizMover(pf, x,y, 1))
-              {
-                pf->board[x][y]->tl -=getTicks();
-                if(pf->board[x][y]->tl < 1)
-                {
-                  pf->board[x][y]->dir = 0;
-                  pf->board[x][y]->tl  = MOVERCOUNTDOWN;
-                }
-              }
-            } else { //Moving left
-              if(!horizMover(pf, x,y, -1))
-              {
-                pf->board[x][y]->tl -=getTicks();
-                if(pf->board[x][y]->tl < 1)
-                {
-                  pf->board[x][y]->dir = 1;
-                  pf->board[x][y]->tl  = MOVERCOUNTDOWN;
-                }
-              }
-            }
-          } else if(pf->board[x][y]->type== MOVERVERT)
-          {
-            //Vertical mover
-            if(pf->board[x][y]->dir)
-            {
-              //Moving up
-              if(!vertMover(pf,x,y,-1))
-              {
-                pf->board[x][y]->tl -= getTicks();
-                if(pf->board[x][y]->tl < 1)
-                {
-                  pf->board[x][y]->dir = 0;
-                  pf->board[x][y]->tl  = MOVERCOUNTDOWN;
-                }
-              }
-            } else {
-              int numOnTop = bricksOnTop(pf,x,y);
-              if(!vertMover(pf,x,y-numOnTop, 1))
-              {
-                pf->board[x][y]->tl -= getTicks();
-                if(pf->board[x][y]->tl < 1)
-                {
-                  pf->board[x][y]->dir = 1;
-                  pf->board[x][y]->tl  = MOVERCOUNTDOWN;
-                }
-              }
-            }
-          }
-        }
-        else if(isOneWay(pf->board[x][y])) //One way floor
-        {
-          //Try to move the block on top of it, if it's a brick
-          if(y>0 && pf->board[x][y-1] && isBrick(pf->board[x][y-1]))
-          {
-            if(pf->board[x][y]->type==ONEWAYLEFT)
-            {
-               if(moveBrick(pf, x,y-1, DIRLEFT, 0, DOBLOCK, ONEWAYSPEED))
-               {
-                 sndPlayOnce(SND_ONEWAY_MOVE, boardOffsetX+x*brickSize);
-               }
-            }
-            if(pf->board[x][y]->type==ONEWAYRIGHT)
-            {
-              if(moveBrick(pf, x,y-1, DIRRIGHT, 0, DOBLOCK, ONEWAYSPEED))
-              {
-                 sndPlayOnce(SND_ONEWAY_MOVE, boardOffsetX+x*brickSize);
-              }
-            }
-
-          }
+          }
+        }
+
+        //Is it a mover
+        if(isMover(pf->board[x][y]))
+        {
+          //Horiz mover?
+          if(pf->board[x][y]->type == MOVERHORIZ)
+          {
+            //Moving right?
+            if(pf->board[x][y]->dir)
+            {
+              if(!horizMover(pf, x,y, 1))
+              {
+                pf->board[x][y]->tl -=getTicks();
+                if(pf->board[x][y]->tl < 1)
+                {
+                  pf->board[x][y]->dir = 0;
+                  pf->board[x][y]->tl  = MOVERCOUNTDOWN;
+                }
+              }
+            } else { //Moving left
+              if(!horizMover(pf, x,y, -1))
+              {
+                pf->board[x][y]->tl -=getTicks();
+                if(pf->board[x][y]->tl < 1)
+                {
+                  pf->board[x][y]->dir = 1;
+                  pf->board[x][y]->tl  = MOVERCOUNTDOWN;
+                }
+              }
+            }
+          } else if(pf->board[x][y]->type== MOVERVERT)
+          {
+            //Vertical mover
+            if(pf->board[x][y]->dir)
+            {
+              //Moving up
+              if(!vertMover(pf,x,y,-1))
+              {
+                pf->board[x][y]->tl -= getTicks();
+                if(pf->board[x][y]->tl < 1)
+                {
+                  pf->board[x][y]->dir = 0;
+                  pf->board[x][y]->tl  = MOVERCOUNTDOWN;
+                }
+              }
+            } else {
+              int numOnTop = bricksOnTop(pf,x,y);
+              if(!vertMover(pf,x,y-numOnTop, 1))
+              {
+                pf->board[x][y]->tl -= getTicks();
+                if(pf->board[x][y]->tl < 1)
+                {
+                  pf->board[x][y]->dir = 1;
+                  pf->board[x][y]->tl  = MOVERCOUNTDOWN;
+                }
+              }
+            }
+          }
+        }
+        else if(isOneWay(pf->board[x][y])) //One way floor
+        {
+          //Try to move the block on top of it, if it's a brick
+          if(y>0 && pf->board[x][y-1] && isBrick(pf->board[x][y-1]))
+          {
+            if(pf->board[x][y]->type==ONEWAYLEFT)
+            {
+               if(moveBrick(pf, x,y-1, DIRLEFT, 0, DOBLOCK, ONEWAYSPEED))
+               {
+                 sndPlayOnce(SND_ONEWAY_MOVE, boardOffsetX+x*brickSize);
+               }
+            }
+            if(pf->board[x][y]->type==ONEWAYRIGHT)
+            {
+              if(moveBrick(pf, x,y-1, DIRRIGHT, 0, DOBLOCK, ONEWAYSPEED))
+              {
+                 sndPlayOnce(SND_ONEWAY_MOVE, boardOffsetX+x*brickSize);
+              }
+            }
+
+          }
         }
-
-      }
-    }
-  }
-
-  for(y=FIELDSIZE-1; y > -1; y--)
-  {
-    for(x=0; x < FIELDSIZE; x++)
-    {
+
+      }
+    }
+  }
+
+  for(y=FIELDSIZE-1; y > -1; y--)
+  {
+    for(x=0; x < FIELDSIZE; x++)
+    {
       if(pf->board[x][y])
-      {
+      {
         //Unmark "checked" status.
         pf->board[x][y]->checked=0;
 
@@ -740,198 +741,201 @@
           b->dmx=0;
         }
 
-      }
-    }
-  }
-
-}
-
-inline int isBrick(brickType* b)
-{
-  if( b->type < BRICKSBEGIN || b->type > BRICKSEND ) return(0);
-  return(1);
-}
-
-int doRules(playField* pf)
-{
-  int x,y;
-  int removed=0;
-  int bricksLeft=0;
-
-  //Used to count how many of each type there is (simple detection of unsolvable lvl)
-  int typeLeft[BRICKSEND]; //Bricktype offset = -1
-  for(x=0;x<BRICKSEND;x++) typeLeft[x]=0; //Set to 0 to start with.
-
-  //Count moving bricks
-  listItem* li=pf->movingList;
-  brickType* b;
-  while( (li = li->next) )
-  {
-    if( isBrick((brickType*)li->data) )
-      bricksLeft++;
-  }
-
-  for(y=FIELDSIZE-1; y > -1; y--)
-  {
-    for(x=0; x < FIELDSIZE; x++)
-    {
-      if(pf->board[x][y] && isBrick(pf->board[x][y]))
-      {
-        //Bricks on board
-        bricksLeft++;
-
-        //Tell this type exists on the board (for detecting if it's still solvable)
-        typeLeft[pf->board[x][y]->type-1]++;
-
-
-        //Is brick, it will only remove itself, this avoids multiple entries of the same brick.
-        if(!isBrickFalling(pf,pf->board[x][y]))
-        {
-          //Detect touching bricks.
-
-          //On top
-          if(y > 0 && pf->board[x][y-1] && pf->board[x][y-1]->type == pf->board[x][y]->type && !isBrickFalling(pf,pf->board[x][y-1]) )
-          {
-            pf->board[x][y]->dir=1;
-            listAddData(pf->removeList, (void*)pf->board[x][y]);
-            //pf->board[x][y]=0;
-         } else
-          //Below
-          if(y+1 < FIELDSIZE && pf->board[x][y+1] && pf->board[x][y+1]->type == pf->board[x][y]->type && !isBrickFalling(pf,pf->board[x][y+1]) )
-          {
-            pf->board[x][y]->dir=1;
-            listAddData(pf->removeList, (void*)pf->board[x][y]);
-            //pf->board[x][y]=0;
-          } else
-          //Left
-          if(x > 0 && pf->board[x-1][y] && pf->board[x-1][y]->type == pf->board[x][y]->type && !isBrickFalling(pf,pf->board[x-1][y]) )
-          {
-            pf->board[x][y]->dir=1;
-            listAddData(pf->removeList, (void*)pf->board[x][y]);
-            //pf->board[x][y]=0;
-          } else
-          //Right
-          if(x+1 < FIELDSIZE && pf->board[x+1][y] && pf->board[x+1][y]->type == pf->board[x][y]->type && !isBrickFalling(pf,pf->board[x+1][y]))
-          {
-            pf->board[x][y]->dir=1;
-            listAddData(pf->removeList, (void*)pf->board[x][y]);
-            //pf->board[x][y]=0;
-          }
-
-        } //A brick
-      } //Not falling
-    }
-  }
-  //Remove ones that need removed
-  li=pf->removeList;
-  while( (li = li->next) )
-  {
-    //Count dying bricks as alive untill they are really removed
-    bricksLeft++;
-    b=(brickType*)li->data;
-    if(b->dir)
-    {
-      sndPlayOnce(SND_BRICKBREAK,b->pxx);
-//      sndPlay(SND_BRICKBREAK, b->pxx);
-      b->dir=0;
-      b->tl=500;
-      //Reserve, to prevent bricks from falling into the animation
-      pf->board[b->dx][b->dy]=pf->blocker;
-    } else {
-      b->tl -= getTicks();
-
-      if(b->tl < 1)
-      {
-        removed++;
-        //Unreserve
-        pf->board[b->dx][b->dy]=0;
-        //Dealloc the brick
-        free(b);
-        //Remove from list
-        listRemoveItem(pf->removeList, li);
-      }
-    }
-  }
-
-  //Check for solvability, if no bricks were removed, no bricks are moving, and no bricks are to be removed
-  //resuing x as counter.
-  if(!removed && !pf->removeList->next && !pf->movingList->next)
-  {
-    for(x=0;x<BRICKSEND;x++)
-    {
-      if(typeLeft[x]==1)
-      {
-        return(UNSOLVABLE);
-      }
-    }
-  }
-
-  if(removed)
-    return(removed);
-
-  if(!bricksLeft)
-    return(NOBRICKSLEFT);
-
-  return(0);
-}
-
-int isBrickFalling(playField* pf, brickType* b)
-{
-  if(b->sy+1 < FIELDSIZE)
-  {
-    if( !pf->board[b->sx][b->sy+1] )
-    {
-      return(1);
-    }
-    //Check if there is a reserved brick below it, that is moving the same way
-    if( pf->board[b->sx][b->sy+1] && pf->board[b->sx][b->sy+1]->type == RESERVED )
-    {
-      brickType* bb = findMoving(pf,b->sx,b->sy+1);
-      if( bb && (bb==b || (bb->pxx != b->pxx || bb->moveXspeed != b->moveXspeed || bb->moveYspeed != b->moveYspeed)) )
-      {
-        return(1);
-      }
-    }
-  }
-  return(0);
-}
-
-
-int isMover(brickType* b)
-{
-  if(!b) return(0);
-  if(b->type==MOVERHORIZ||b->type==MOVERVERT) return(1);
-  return(0);
-}
-
-int isOneWay(brickType* b)
-{
-  if(!b) return(0);
-  if(b->type==ONEWAYLEFT||b->type==ONEWAYRIGHT) return(1);
-  return(0);
-}
-
-//Return the brick moving into or out of fieldx/y
-brickType* findMoving(playField* pf, int x, int y)
-{
-  brickType* br;
-  //Bail if position is invalid
-  if(x>=FIELDSIZE || y>=FIELDSIZE) return(0);
-
-  //Bail if it's not a reserved brick
-  if(!pf->board[x][y] || pf->board[x][y]->type!=RESERVED) return(0);
-
-  listItem* li=pf->movingList;
-  while( (li = li->next) )
-  {
-    br=(brickType*)li->data;
-    if( (br->sx == x && br->sy==y) || (br->dx==x && br->dy==y) )
-    {
-      return(br);
-    }
-
-  }
-  return(0);
+      }
+    }
+  }
+
+}
+
+inline int isBrick(brickType* b)
+{
+  if( b->type < BRICKSBEGIN || b->type > BRICKSEND ) return(0);
+  return(1);
+}
+
+int doRules(playField* pf)
+{
+  int x,y;
+  int removed=0;
+  int bricksLeft=0;
+  brickType* b;
+  listItem* li;
+
+  //Used to count how many of each type there is (simple detection of unsolvable lvl)
+  int typeLeft[BRICKSEND]; //Bricktype offset = -1
+  for(x=0;x<BRICKSEND;x++) typeLeft[x]=0; //Set to 0 to start with.
+
+  //Count moving bricks
+  li=pf->movingList;
+
+  while( (li = li->next) )
+  {
+    if( isBrick((brickType*)li->data) )
+      bricksLeft++;
+  }
+
+  for(y=FIELDSIZE-1; y > -1; y--)
+  {
+    for(x=0; x < FIELDSIZE; x++)
+    {
+      if(pf->board[x][y] && isBrick(pf->board[x][y]))
+      {
+        //Bricks on board
+        bricksLeft++;
+
+        //Tell this type exists on the board (for detecting if it's still solvable)
+        typeLeft[pf->board[x][y]->type-1]++;
+
+
+        //Is brick, it will only remove itself, this avoids multiple entries of the same brick.
+        if(!isBrickFalling(pf,pf->board[x][y]))
+        {
+          //Detect touching bricks.
+
+          //On top
+          if(y > 0 && pf->board[x][y-1] && pf->board[x][y-1]->type == pf->board[x][y]->type && !isBrickFalling(pf,pf->board[x][y-1]) )
+          {
+            pf->board[x][y]->dir=1;
+            listAddData(pf->removeList, (void*)pf->board[x][y]);
+            //pf->board[x][y]=0;
+         } else
+          //Below
+          if(y+1 < FIELDSIZE && pf->board[x][y+1] && pf->board[x][y+1]->type == pf->board[x][y]->type && !isBrickFalling(pf,pf->board[x][y+1]) )
+          {
+            pf->board[x][y]->dir=1;
+            listAddData(pf->removeList, (void*)pf->board[x][y]);
+            //pf->board[x][y]=0;
+          } else
+          //Left
+          if(x > 0 && pf->board[x-1][y] && pf->board[x-1][y]->type == pf->board[x][y]->type && !isBrickFalling(pf,pf->board[x-1][y]) )
+          {
+            pf->board[x][y]->dir=1;
+            listAddData(pf->removeList, (void*)pf->board[x][y]);
+            //pf->board[x][y]=0;
+          } else
+          //Right
+          if(x+1 < FIELDSIZE && pf->board[x+1][y] && pf->board[x+1][y]->type == pf->board[x][y]->type && !isBrickFalling(pf,pf->board[x+1][y]))
+          {
+            pf->board[x][y]->dir=1;
+            listAddData(pf->removeList, (void*)pf->board[x][y]);
+            //pf->board[x][y]=0;
+          }
+
+        } //A brick
+      } //Not falling
+    }
+  }
+  //Remove ones that need removed
+  li=pf->removeList;
+  while( (li = li->next) )
+  {
+    //Count dying bricks as alive untill they are really removed
+    bricksLeft++;
+    b=(brickType*)li->data;
+    if(b->dir)
+    {
+      sndPlayOnce(SND_BRICKBREAK,b->pxx);
+//      sndPlay(SND_BRICKBREAK, b->pxx);
+      b->dir=0;
+      b->tl=500;
+      //Reserve, to prevent bricks from falling into the animation
+      pf->board[b->dx][b->dy]=pf->blocker;
+    } else {
+      b->tl -= getTicks();
+
+      if(b->tl < 1)
+      {
+        removed++;
+        //Unreserve
+        pf->board[b->dx][b->dy]=0;
+        //Dealloc the brick
+        free(b);
+        //Remove from list
+        listRemoveItem(pf->removeList, li);
+      }
+    }
+  }
+
+  //Check for solvability, if no bricks were removed, no bricks are moving, and no bricks are to be removed
+  //resuing x as counter.
+  if(!removed && !pf->removeList->next && !pf->movingList->next)
+  {
+    for(x=0;x<BRICKSEND;x++)
+    {
+      if(typeLeft[x]==1)
+      {
+        return(UNSOLVABLE);
+      }
+    }
+  }
+
+  if(removed)
+    return(removed);
+
+  if(!bricksLeft)
+    return(NOBRICKSLEFT);
+
+  return(0);
+}
+
+int isBrickFalling(playField* pf, brickType* b)
+{
+  if(b->sy+1 < FIELDSIZE)
+  {
+    if( !pf->board[b->sx][b->sy+1] )
+    {
+      return(1);
+    }
+    //Check if there is a reserved brick below it, that is moving the same way
+    if( pf->board[b->sx][b->sy+1] && pf->board[b->sx][b->sy+1]->type == RESERVED )
+    {
+      brickType* bb = findMoving(pf,b->sx,b->sy+1);
+      if( bb && (bb==b || (bb->pxx != b->pxx || bb->moveXspeed != b->moveXspeed || bb->moveYspeed != b->moveYspeed)) )
+      {
+        return(1);
+      }
+    }
+  }
+  return(0);
+}
+
+
+int isMover(brickType* b)
+{
+  if(!b) return(0);
+  if(b->type==MOVERHORIZ||b->type==MOVERVERT) return(1);
+  return(0);
+}
+
+int isOneWay(brickType* b)
+{
+  if(!b) return(0);
+  if(b->type==ONEWAYLEFT||b->type==ONEWAYRIGHT) return(1);
+  return(0);
+}
+
+//Return the brick moving into or out of fieldx/y
+brickType* findMoving(playField* pf, int x, int y)
+{
+  brickType* br;
+  listItem* li;
+  //Bail if position is invalid
+  if(x>=FIELDSIZE || y>=FIELDSIZE) return(0);
+
+  //Bail if it's not a reserved brick
+  if(!pf->board[x][y] || pf->board[x][y]->type!=RESERVED) return(0);
+
+  li=pf->movingList;
+  while( (li = li->next) )
+  {
+    br=(brickType*)li->data;
+    if( (br->sx == x && br->sy==y) || (br->dx==x && br->dy==y) )
+    {
+      return(br);
+    }
+
+  }
+  return(0);
 }
 
 brickType* brickUnderCursor(playField* pf, int x, int y)
@@ -949,30 +953,30 @@
 }
 
 int curMoveBrick(playField *pf, brickType *b, int dir)
-{
-  //We can't move the brick, if it is falling.
-  if( isBrickFalling(pf, b) ) return(0);
-
+{
+  //We can't move the brick, if it is falling.
+  if( isBrickFalling(pf, b) ) return(0);
+
   //Move brick that is not moving<.
   if(b->moveXspeed==0 && b->moveYspeed==0)
-  {
+  {
     //First, check that it's a brick, and not a reserved.
-    if(pf->board[b->sx][b->sy] && isBrick( pf->board[b->sx][b->sy]) )
+    if(pf->board[b->sx][b->sy] && isBrick( pf->board[b->sx][b->sy]) )
     {
-      if(moveBrick( pf, b->sx, b->sy, dir, 0, DOBLOCK, CURSORMOVESPEED))
-      {
-        return(1);
-      }
+      if(moveBrick( pf, b->sx, b->sy, dir, 0, DOBLOCK, CURSORMOVESPEED))
+      {
+        return(1);
+      }
     }
   } else {
     if( ((b->moveXspeed < 0 && dir > 0) || (b->moveXspeed > 0 && dir <0)) || b->moveYspeed )
-    {
-      if(!b->dmx)
+    {
+      if(!b->dmx)
       {
         b->dmx = dir;
-        return(1);
+        return(1);
       }
     }
-  }
+  }
   return(0);
 }
diff -urN wizznic-0.9_feedback_version-src/credits.c wizznic-0.9_feedback_version-src-gcc2/credits.c
--- wizznic-0.9_feedback_version-src/credits.c	2010-06-20 13:53:08.042205184 +0000
+++ wizznic-0.9_feedback_version-src-gcc2/credits.c	2010-09-04 19:40:09.000000000 +0000
@@ -31,9 +31,10 @@
 
 
 msg_t* initMsg(const char* strTitle, const char* strName,SDL_Surface* screen)
-{
+{
+  SDL_Surface* tempSurf;
   msg_t* t = malloc(sizeof(msg_t));
-
+
   //Create surface
   t->surfTitle = SDL_CreateRGBSurface(SDL_SWSURFACE, (getCharSize(FONTSMALL)[0]*strlen(strTitle)),(getCharSize(FONTSMALL)[1]),16, screen->format->Rmask,screen->format->Gmask,screen->format->Bmask,0xff000000);
   t->nameWaving.img = SDL_CreateRGBSurface(SDL_SWSURFACE, (getCharSize(FONTMEDIUM)[0]*strlen(strName)),(getCharSize(FONTMEDIUM)[1]),16, screen->format->Rmask,screen->format->Gmask,screen->format->Bmask,0xff000000);
@@ -45,7 +46,6 @@
   txtWrite(t->surfTitle, FONTSMALL, strTitle, 0,0);
   txtWrite(t->nameWaving.img, FONTMEDIUM, strName, 0,0);
 
-  SDL_Surface* tempSurf;
 
   tempSurf=SDL_DisplayFormat(t->surfTitle);
   SDL_FreeSurface(t->surfTitle);
@@ -98,7 +98,7 @@
 }
 
 void initCredits(SDL_Surface* screen)
-{
+{
   printf("initCredits();\n");
   msgList=initList();
   listAddData(msgList, (void*)initMsg("Website","wizznic.sf.net", screen));
@@ -119,9 +119,9 @@
 }
 
 void clearCredits()
-{
-  printf("clearCredits();\n");
+{
   listItem* it=msgList;
+  printf("clearCredits();\n");
   while( (it=it->next) )
   {
     cm = (msg_t*)it->data;
diff -urN wizznic-0.9_feedback_version-src/draw.c wizznic-0.9_feedback_version-src-gcc2/draw.c
--- wizznic-0.9_feedback_version-src/draw.c	2010-07-18 03:00:58.040370176 +0000
+++ wizznic-0.9_feedback_version-src-gcc2/draw.c	2010-09-04 09:26:16.000000000 +0000
@@ -6,6 +6,9 @@
 {
   char tempStr[64];
   int i,x,y;
+  int r,c; //rows, column, sprite index
+  float f=255/TELEPATHNUMCOL;
+
 
   //Background image
   sprintf(tempStr,"%s.png",li->bgFile);
@@ -32,7 +35,6 @@
   sprintf(tempStr, "%s-walls.png", li->tileFile);
   graphics.wallImg = loadImg( packGetFile("themes",tempStr) );
   if(!graphics.wallImg) printf("Optional GFX missing: '%s'\n", packGetFile("themes",tempStr) );
-  int r,c; //rows, column, sprite index
   i=0;
   for(r=0; r < 5; r++)
   {
@@ -118,7 +120,6 @@
 
   //Teleport path animation color gradient
   graphics.teleColorIndex=0;
-  float f=255/TELEPATHNUMCOL;
   for(i=0; i < TELEPATHNUMCOL; i++)
   {
     graphics.teleColorTable[i] = SDL_MapRGB( graphics.tiles[0]->img->format, 0,(int)(255.0-(float)i*f),0  );
@@ -208,8 +209,13 @@
 void draw(cursorType* cur, playField* pf, SDL_Surface* screen)
 {
   int x,y;
+  int explFrame;
   listItem* t; //general purpose, reusable
   psysSet_t ps;
+  brickType* b;
+  telePort_t* tp;
+
+  
   SDL_BlitSurface(graphics.boardImg , NULL, screen, NULL );
 
   //Draw static bricks
@@ -239,7 +245,6 @@
 
   //Draw moving bricks
   t=pf->movingList;
-  brickType* b;
   while( (t = t->next) )
   {
     b=(brickType*)t->data;
@@ -257,7 +262,7 @@
       drawSprite(screen, graphics.tiles[b->type-1], b->pxx, b->pxy);
     }
 
-    int explFrame = 16*(500-b->tl)/500;
+    explFrame = 16*(500-b->tl)/500;
     if(explFrame==8)
     {
       ps.x=b->pxx;
@@ -279,7 +284,6 @@
 
   //Teleport overlay
   t = pf->levelInfo->teleList;
-  telePort_t* tp;
   while( (t=t->next) )
   {
     tp = (telePort_t*)t->data;
diff -urN wizznic-0.9_feedback_version-src/dumplevelimages.c wizznic-0.9_feedback_version-src-gcc2/dumplevelimages.c
--- wizznic-0.9_feedback_version-src/dumplevelimages.c	2010-07-16 03:21:19.040894464 +0000
+++ wizznic-0.9_feedback_version-src-gcc2/dumplevelimages.c	2010-09-04 08:57:58.000000000 +0000
@@ -40,12 +40,12 @@
 
     //Switch off cursor graphics
     drawDisableCursor();
-
+
     //Show the "start image"
     si=0;
-    if( pf.levelInfo->startImg )
-    {
-      si = loadImg( packGetFile("themes/", pf.levelInfo->startImg) );
+    if( pf.levelInfo->startImg )
+    {
+      si = loadImg( packGetFile("themes/", pf.levelInfo->startImg) );
     }
 
     if(si)
@@ -112,18 +112,22 @@
 
 void tgaSave(SDL_Surface* screen, const char* fileName)
 {
-  SDL_LockSurface(screen);
-
-  FILE *f = fopen(fileName, "w");
+  FILE *f;
 
+  int numBytes;
+  int i;
+  uint16_t t;
   unsigned char TGAheader[12]={0,0,2,0,0,0,0,0,0,0,0,0};
   unsigned char header[6] = {screen->w%256,screen->w/256,screen->h%256,screen->h/256,24,( 0  | 32)};
+  unsigned char* data = malloc(sizeof(unsigned char)*numBytes);
+    
+  SDL_LockSurface(screen);
+
+  f = fopen(fileName, "w");
+
   fwrite(TGAheader, sizeof(unsigned char), 12, f);
   fwrite(header, sizeof(unsigned char), 6, f);
 
-  int numBytes = screen->h*screen->w*3;
-  unsigned char* data = malloc(sizeof(unsigned char)*numBytes);
-
   printf("Surf info:\n  Pitch: %i\n  BytesPrPixel: %i\n  BitsPrPixel: %i\n",
   screen->pitch, screen->format->BytesPerPixel, screen->format->BitsPerPixel);
 
@@ -131,8 +135,6 @@
   screen->format->Rmask,screen->format->Gmask,screen->format->Bmask,
   screen->format->Rshift,screen->format->Gshift,screen->format->Bshift);
 
-  int i;
-  uint16_t t;
   //Read pixels as one 16 bit number, then extract rgb values, normalize brightness, (green is too high) and swap red/blue, then save to data
   for(i=0; i<screen->w*screen->h; i++)
   {
diff -urN wizznic-0.9_feedback_version-src/game.c wizznic-0.9_feedback_version-src-gcc2/game.c
--- wizznic-0.9_feedback_version-src/game.c	2010-07-20 16:20:20.042991616 +0000
+++ wizznic-0.9_feedback_version-src-gcc2/game.c	2010-09-04 18:22:11.292552704 +0000
@@ -52,36 +52,34 @@
     {
       printf("Error: Couldn't init graphics.\n");
       return(0);
-    }
-
-    char* buf = malloc(sizeof(char)*128);
-    sprintf(buf, "themes/%s",pf.levelInfo->soundDir);
-    loadSamples( buf, pf.levelInfo->musicFile ); //Load samples from sounddir
-    free(buf);
-
-    txtLoadGameCharSet( pf.levelInfo->fontName );
-
-    pf.levelInfo->time *= 1000; //Convert seconds to ms
-    countdown=500;
-    countdownSeconds=3;
-    gameState=GAMESTATECOUNTDOWN;
-    player()->gameStarted=1;
+    } else {
+      char* buf = malloc(sizeof(char)*128);
+      sprintf(buf, "themes/%s",pf.levelInfo->soundDir);
+      loadSamples( buf, pf.levelInfo->musicFile ); //Load samples from sounddir
+      free(buf);
+
+      txtLoadGameCharSet( pf.levelInfo->fontName );
+
+      pf.levelInfo->time *= 1000; //Convert seconds to ms
+      countdown=500;
+      countdownSeconds=3;
+      gameState=GAMESTATECOUNTDOWN;
+      player()->gameStarted=1;
 
-    //Clear player stats
-    memset( &player()->hsEntry, 0, sizeof( hsEntry_t ) );
+      //Clear player stats
+      memset( &player()->hsEntry, 0, sizeof( hsEntry_t ) );
 
-    //Set the levelNum
-    player()->hsEntry.levelNum = player()->level;
+      //Set the levelNum
+      player()->hsEntry.levelNum = player()->level;
 
-    startStopImg=0;
+      startStopImg=0;
 
-    if(pf.levelInfo->startImg)
-    {
-      gameState=GAMESTATESTARTIMAGE;
+      if(pf.levelInfo->startImg)
+      {
+        gameState=GAMESTATESTARTIMAGE;
+      }
+      return(1);
     }
-
-
-    return(1);
 }
 
 void cleanUpGame()
@@ -110,12 +108,13 @@
 {
    //Draw text
   char tempStr[16];
+  int secLeft;
 
   sprintf(tempStr, "Level %i", player()->level  );
   txtWriteCenter(screen, GAMEFONTSMALL, tempStr, 47,64);
 
   txtWriteCenter(screen, GAMEFONTSMALL, "Time:", 47, 84);
-  int secLeft = pf.levelInfo->time/1000;
+  secLeft = pf.levelInfo->time/1000;
   if(pf.levelInfo->time > 60000)
   {
     sprintf(tempStr,"%i;%1.2i",secLeft/60,secLeft%60);
@@ -132,13 +131,15 @@
   txtWriteCenter(screen, GAMEFONTSMALL, "Lives:", 47,168);
   sprintf(tempStr, "%i", player()->lives );
   txtWriteCenter(screen, GAMEFONTMEDIUM, tempStr, 47, 178);
-
-
 }
 
 
 int runGame(SDL_Surface* screen)
 {
+  int lim=1; //Limit cursor travel...
+  int goUp=0, goDown=0, goLeft=0, goRight=0;
+  int ret;
+
   if(gameState==GAMESTATEPLAYING)
   {
     /*printf("Player()->inEditor: %i\n",player()->inEditor);
@@ -157,8 +158,6 @@
     }
 
     //Handle input
-    int lim=1; //Limit cursor travel...
-    int goUp=0, goDown=0, goLeft=0, goRight=0;
     if( getButton( C_UP ) )
     {
       restartConfirm=0;
@@ -237,12 +236,13 @@
       //Drag
       if( getButton( C_BTNX ) || getButton( C_BTNB ) )
       {
-        //Remove "Restart" question
-        restartConfirm=0;
-
         //Magnet to brick if it's moving
         brickType* b=brickUnderCursor(&pf, cur.dx, cur.dy);
-
+        int movedBrick=0;
+        
+        //Remove "Restart" question
+        restartConfirm=0;
+
         if( !cur.lock && b )
         {
           //Attach cursor
@@ -257,7 +257,7 @@
           sndPlay( SND_BRICKGRAB, cur.px );
         }
 
-        int movedBrick=0;
+
         //We're holding a brick, and it's not falling
         if( b )
         {
@@ -306,7 +306,7 @@
     simField(&pf, &cur);
 
     //Do rules
-    int ret=doRules(&pf);
+    ret=doRules(&pf);
 
     //Draw scene
     draw(&cur,&pf, screen);
diff -urN wizznic-0.9_feedback_version-src/leveleditor.c wizznic-0.9_feedback_version-src-gcc2/leveleditor.c
--- wizznic-0.9_feedback_version-src/leveleditor.c	2010-07-19 23:55:49.042729472 +0000
+++ wizznic-0.9_feedback_version-src-gcc2/leveleditor.c	2010-09-04 19:00:57.000000000 +0000
@@ -170,9 +170,10 @@
 
   if(getButton(C_BTNSELECT))
   {
-    resetBtn(C_BTNSELECT);
-    FILE *f = fopen(fileName, "w");
     int x,y;
+    char *str;
+    FILE *f = fopen(fileName, "w");
+    resetBtn(C_BTNSELECT);
     sprintf(buf, "#Author of level\nauthor=%s\n\n", pf.levelInfo->author);
     fputs(buf,f);
 
@@ -195,7 +196,7 @@
     fputs(buf,f);
 
     //Teleports
-    char* str = teleMkStrings(pf.levelInfo->teleList);
+    str = teleMkStrings(pf.levelInfo->teleList);
     if(str) //Returns 0 if there's no teleports
     {
       fputs("#Teleports\n",f);
diff -urN wizznic-0.9_feedback_version-src/levels.c wizznic-0.9_feedback_version-src-gcc2/levels.c
--- wizznic-0.9_feedback_version-src/levels.c	2010-07-26 00:48:15.041943040 +0000
+++ wizznic-0.9_feedback_version-src-gcc2/levels.c	2010-09-04 18:36:19.000000000 +0000
@@ -169,10 +169,10 @@
 {
   int i=0;
   char* buf = malloc(sizeof(char)*1024);
-
+  levelInfo_t* tl;
+  
   //Init the list to hold the filenames
   *list = initList();
-  levelInfo_t* tl;
 
   //List all levels in dir.
   while(1)
@@ -205,12 +205,12 @@
 
 void makeUserLevelList()
 {
-   //List userlevels
-  userLevelFiles = initList();
   int i=0;
-
   levelInfo_t* tl;
   char* buf = malloc(sizeof(char)*256);
+  //List userlevels
+  userLevelFiles = initList();
+
   while(1)
   {
     sprintf(buf, "%s/level%i.wzp", getUserLevelDir(), i);
diff -urN wizznic-0.9_feedback_version-src/main.c wizznic-0.9_feedback_version-src-gcc2/main.c
--- wizznic-0.9_feedback_version-src/main.c	2010-07-20 16:20:20.043515904 +0000
+++ wizznic-0.9_feedback_version-src-gcc2/main.c	2010-09-04 16:43:23.000000000 +0000
@@ -1,7 +1,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 
-#include <SDL/SDL.h>
+#include <SDL/SDL.h>
 #include <SDL/SDL_image.h>
 
 #include "board.h"
@@ -14,44 +14,50 @@
 #include "states.h"
 #include "game.h"
 #include "levels.h"
-#include "leveleditor.h"
-#include "particles.h"
-#include "settings.h"
-#include "pack.h"
-#include "stats.h"
+#include "leveleditor.h"
+#include "particles.h"
+#include "settings.h"
+#include "pack.h"
+#include "stats.h"
 #include "credits.h"
-#include "userfiles.h"
-#include "strings.h"
-
-#ifndef GP2X
+#include "userfiles.h"
+#include "strings.h"
+
+#ifndef GP2X
   #include "dumplevelimages.h"
-#endif
-
-#ifndef DATADIR
-  #define DATADIR ""
-#endif
+#endif
+
+#ifndef DATADIR
+  #define DATADIR ""
+#endif
 
 int main(int argc, char *argv[])
-{
+{
   #ifdef WIN32
   //Redirect stdout to console on windows, so we can see what's going in.
   FILE *stream;
   stream = freopen("CON", "w", stdout);
-  #endif
-  int doScale=0;
-  int doDump=0;
+  #endif
+  int doScale=0;
+  int doDump=0;
   int doThumb=0;
-  int state=1; //Game, Menu, Editor, Quit
-
-  //Print welcome message
-  printf( "Wizznic "VERSION_STRING". GPLv3 or newer Copyleft 2010\n\n");
+  int state=1; //Game, Menu, Editor, Quit
+  int lastTick;
+  int t;
+  SDL_Surface* icon;
+  SDL_Surface* scale;
+  SDL_Surface* screen;
+  int sdlFullScrFlag=0;
+
+  //Print welcome message
+  printf( "Wizznic "VERSION_STRING". GPLv3 or newer Copyleft 2010\n\n");
 
   //initialize path strings
   initUserPaths();
-
-  //Tell where stuff's at.
-  printf("Directories:\n    Settings: %s\n    Highscores: %s\n    Editorlevels: %s\n    Datafiles: %s\n\n", \
-                            getConfigDir(), getHighscoreDir(), getUserLevelDir(), (!strlen(DATADIR))?".":DATADIR);
+
+  //Tell where stuff's at.
+  printf("Directories:\n    Settings: %s\n    Highscores: %s\n    Editorlevels: %s\n    Datafiles: %s\n\n",
+                            getConfigDir(), getHighscoreDir(), getUserLevelDir(), (!strlen(DATADIR))?".":DATADIR);
 
   //Init SDL
   if(SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_JOYSTICK | SDL_INIT_TIMER ) <0 )
@@ -60,67 +66,65 @@
     return(-1);
   }
 
-  //Setup display
-  #ifdef GP2X
-  SDL_Surface* screen = SDL_SetVideoMode(320,240,16, SDL_SWSURFACE);
-  #else
-  SDL_Surface* scale;
-  SDL_Surface* screen;
+  //Setup display
+  #ifdef GP2X
+    screen = SDL_SetVideoMode(320,240,16, SDL_SWSURFACE);
+  #else
 
-  int sdlFullScrFlag=0;
-  if(argc==2 || argc==3 || argc==4)
-  {
-    if(strcmp(argv[1], "-z")==0)
-    {
-      doScale=2;
-      if( argc==3 && atoi(argv[2])>0 && atoi(argv[2]) < 20 )
-      {
-        doScale = atoi(argv[2]);
-      }
-    } else if(strcmp(argv[1], "-d")==0)
-    {
-      if(argc!=3)
-      {
-        printf("usage: -d PACKNAME\n");
-        return(-1);
-      }
-      doDump=1;
-    } else if(strcmp(argv[1], "-thumbnailer")==0 && argc==4)
-    {
-      doThumb=1;
+
+  if(argc==2 || argc==3 || argc==4)
+  {
+    if(strcmp(argv[1], "-z")==0)
+    {
+      doScale=2;
+      if( argc==3 && atoi(argv[2])>0 && atoi(argv[2]) < 20 )
+      {
+        doScale = atoi(argv[2]);
+      }
+    } else if(strcmp(argv[1], "-d")==0)
+    {
+      if(argc!=3)
+      {
+        printf("usage: -d PACKNAME\n");
+        return(-1);
+      }
+      doDump=1;
+    } else if(strcmp(argv[1], "-thumbnailer")==0 && argc==4)
+    {
+      doThumb=1;
     } else if(strcmp(argv[1], "-f")==0)
     {
       sdlFullScrFlag=SDL_FULLSCREEN;
-    } else if(!doScale)
-    {
-      printf("Usage:\n wizznic -d PACKNAME Dumps levelimages for pack.\n wizznic -z [n] Zoom to 320*n x 240*n\nwizznic -f run 320x240 in fullscreen\n wizznic -thumbnailer LVLFILE OUTFILE\n");
-      return(-1);
-    }
-
-  }
-
-  if(doScale)
-  {
-    scale = SDL_SetVideoMode(320*doScale,240*doScale,16, SDL_SWSURFACE | sdlFullScrFlag);
-    screen = SDL_CreateRGBSurface(SDL_SWSURFACE, 320,240,16, scale->format->Rmask,scale->format->Gmask,scale->format->Bmask,0xff000000);
-  } else {
-    scale = SDL_SetVideoMode(320,240,16, SDL_SWSURFACE | sdlFullScrFlag);
-    screen=scale;
+    } else if(!doScale)
+    {
+      printf("Usage:\n wizznic -d PACKNAME Dumps levelimages for pack.\n wizznic -z [n] Zoom to 320*n x 240*n\nwizznic -f run 320x240 in fullscreen\n wizznic -thumbnailer LVLFILE OUTFILE\n");
+      return(-1);
+    }
+
   }
-
-  //Set window title
-  SDL_WM_SetCaption("Wizznic!", "Wizznic!");
-  //Set window icon
-  SDL_Surface* icon = IMG_Load( DATADIR"data/wmicon.png");
-  SDL_WM_SetIcon(icon, NULL);
-  SDL_FreeSurface(icon);
 
-  #endif
+  if(doScale)
+  {
+    scale = SDL_SetVideoMode(320*doScale,240*doScale,16, SDL_SWSURFACE | sdlFullScrFlag);
+    screen = SDL_CreateRGBSurface(SDL_SWSURFACE, 320,240,16, scale->format->Rmask,scale->format->Gmask,scale->format->Bmask,0xff000000);
+  } else {
+    scale = SDL_SetVideoMode(320,240,16, SDL_SWSURFACE | sdlFullScrFlag);
+    screen=scale;
+  }
+
+  //Set window title
+  SDL_WM_SetCaption("Wizznic!", "Wizznic!");
+  //Set window icon
+  icon = IMG_Load( DATADIR"data/wmicon.png");
+  SDL_WM_SetIcon(icon, NULL);
+  SDL_FreeSurface(icon);
+
+  #endif
   //Open Joysticks (for wiz)
   if (SDL_NumJoysticks() > 0) SDL_JoystickOpen(0);
-
-  //Hide mousecursor (both PC and wiz needs this)
-  SDL_ShowCursor(SDL_DISABLE);
+
+  //Hide mousecursor (both PC and wiz needs this)
+  SDL_ShowCursor(SDL_DISABLE);
 
   //Load fonts
   txtInit();
@@ -130,7 +134,7 @@
   {
     printf("Couldn't init sound.\n");
     return(-1);
-  }
+  }
 
   //Menu Graphics
   if(!initMenu(screen))
@@ -140,144 +144,142 @@
   }
 
   //Init controls
-  initControls();
-
-  //Init stats
-  statsInit();
-
-  //Init packs
-  packInit();
+  initControls();
+
+  //Init stats
+  statsInit();
+
+  //Init packs
+  packInit();
 
   //Scan userlevels dir
-  makeUserLevelList(screen);
-
-  //Init particles
-  initParticles(screen);
+  makeUserLevelList(screen);
+
+  //Init particles
+  initParticles(screen);
 
-  #ifndef GP2X
+  #ifndef GP2X
   //Need to dump level-screenshots?
   if(doDump)
-  {
+  {
     dumplevelimages(screen, argv[2]);
     return(0);
-  } else if(doThumb)  //For the gnome-thumbnailing script
-  {
-    thumblevelimage(screen, argv[2], argv[3]);
-    return(0);
+  } else if(doThumb)  //For the gnome-thumbnailing script
+  {
+    thumblevelimage(screen, argv[2], argv[3]);
+    return(0);
+  }
+  #endif
+
+  //init starfield
+  initStars(screen);
+
+  printf("Loading settings...\n");
+  //Read settings (or defaults) (has to be done after packs are inited)
+  initSettings();
+
+  #ifndef GP2X
+  if( setting()->uploadStats && !setting()->firstRun )
+  {
+    statsUpload(0,0,0,0,0,"check",1);
   }
-  #endif
-
-  //init starfield
-  initStars(screen);
-
-  printf("Loading settings...\n");
-  //Read settings (or defaults) (has to be done after packs are inited)
-  initSettings();
-
-  #ifndef GP2X
-  if( setting()->uploadStats && !setting()->firstRun )
-  {
-    statsUpload(0,0,0,0,0,"check",1);
-  }
-  #endif
-
-  printf("Setting Music...\n");
-  //Start playing music (has to be done after readong settings)
-  soundSetMusic();
-
+  #endif
+
+  printf("Setting Music...\n");
+  //Start playing music (has to be done after readong settings)
+  soundSetMusic();
+
   printf("Initializing Credits...\n");
   //Initialize credits
   initCredits(screen);
 
-
-  int lastTick;
   while(state!=STATEQUIT)
-  {
-    lastTick=SDL_GetTicks();
+  {
+    lastTick=SDL_GetTicks();
 
     frameStart();
     if(runControls()) state=STATEQUIT;
-
-    switch(state)
-    {
-      case STATEPLAY:
-        state = runGame(screen);
-      break;
-
-      case STATEMENU:
-        state = runMenu(screen);
-      break;
-
-      case STATEEDIT:
-        state=runEditor(screen);
+
+    switch(state)
+    {
+      case STATEPLAY:
+        state = runGame(screen);
+      break;
+
+      case STATEMENU:
+        state = runMenu(screen);
       break;
-    }
-
-    soundRun(screen,state);
-
-    if(setting()->showFps)
-      drawFPS(screen);
-
-    #ifdef GP2X
-    while(SDL_GetTicks()-lastTick < 20)
-    {
-
-    }
-
-    SDL_Flip(screen);
-
+
+      case STATEEDIT:
+        state=runEditor(screen);
+      break;
+    }
+
+    soundRun(screen,state);
+
+    if(setting()->showFps)
+      drawFPS(screen);
+
+    #ifdef GP2X
+    while(SDL_GetTicks()-lastTick < 20)
+    {
+
+    }
+
+    SDL_Flip(screen);
+
     #else
-    //The pixel plotting seems to run faster than code usind SDL_Rect, so we still use that for 2x zoom.
-    if(doScale==2)
-    {
-      int x,xx,y,yy;
-      for(y=0; y< 240; y++)
-      {
-        for(x=0; x < 320; x++)
-        {
-          //readPixel(screen, x,y, &r,&g,&b);
-          uint16_t c = freadPixel(screen,x,y);/*SDL_MapRGB(scale->format,r,g,b);*/
-          xx=x*2;
-          yy=y*2;
-          plotPixelu(scale, xx,yy, c);
-          plotPixelu(scale, xx+1,yy, c);
-          plotPixelu(scale, xx,yy+1, c);
-          plotPixelu(scale, xx+1,yy+1, c);
-        }
-      }
-    } else if(doScale>2)
-    {
-      int x,y;
-      SDL_Rect r;
-      for(y=0; y< 240; y++)
-      {
-        for(x=0; x < 320; x++)
-        {
-          r.x=x*doScale;
-          r.y=y*doScale;
-          r.w=doScale;
-          r.h=doScale;
-          SDL_FillRect(scale, &r, freadPixel(screen,x,y));
-        }
-      }
-    }
-
-    SDL_Flip(scale);
-    int t=SDL_GetTicks()-lastTick;
-    if(t < 20)
-    {
-      SDL_Delay( 20 -t);
-    }
-    #endif
-
-  }
-
-  #ifdef GP2X
-  WIZ_SetClock(533);
-  #endif
+    //The pixel plotting seems to run faster than code usind SDL_Rect, so we still use that for 2x zoom.
+    if(doScale==2)
+    {
+      int x,xx,y,yy;
+      for(y=0; y< 240; y++)
+      {
+        for(x=0; x < 320; x++)
+        {
+          //readPixel(screen, x,y, &r,&g,&b);
+          uint16_t c = freadPixel(screen,x,y);/*SDL_MapRGB(scale->format,r,g,b);*/
+          xx=x*2;
+          yy=y*2;
+          plotPixelu(scale, xx,yy, c);
+          plotPixelu(scale, xx+1,yy, c);
+          plotPixelu(scale, xx,yy+1, c);
+          plotPixelu(scale, xx+1,yy+1, c);
+        }
+      }
+    } else if(doScale>2)
+    {
+      int x,y;
+      SDL_Rect r;
+      for(y=0; y< 240; y++)
+      {
+        for(x=0; x < 320; x++)
+        {
+          r.x=x*doScale;
+          r.y=y*doScale;
+          r.w=doScale;
+          r.h=doScale;
+          SDL_FillRect(scale, &r, freadPixel(screen,x,y));
+        }
+      }
+    }
+
+    SDL_Flip(scale);
+    t=SDL_GetTicks()-lastTick;
+    if(t < 20)
+    {
+      SDL_Delay( 20 -t);
+    }
+    #endif
+
+  }
+
+  #ifdef GP2X
+  WIZ_SetClock(533);
+  #endif
 
   //Not even trying to clean up, OS should do that anyway..
   return(0);
-}
-
-
+}
+
+
diff -urN wizznic-0.9_feedback_version-src/menu.c wizznic-0.9_feedback_version-src-gcc2/menu.c
--- wizznic-0.9_feedback_version-src/menu.c	2010-07-28 19:24:52.044826624 +0000
+++ wizznic-0.9_feedback_version-src-gcc2/menu.c	2010-09-04 16:57:07.000000000 +0000
@@ -99,6 +99,8 @@
   psysSet_t ps; //Particle system for particle effects in menu
   listItem* it;
   fileListItem_t* fItem;
+  static int cheat;
+  int i;
 
   if(!dir)
   {
@@ -557,7 +559,7 @@
         txtWrite(screen, FONTSMALL, STR_MENU_ABOUT_TEXT, 5, 40);
         txtWave(screen, FONTSMALL, STR_MENU_ABOUT_WEBSITE, 160, 240-24,&rot);
 
-        static int cheat=-1;
+        cheat=-1;
         if( getButton( C_BTNA ) )
         {
           cheat=0;
@@ -693,7 +695,7 @@
           scroll=ul;
         }
 
-        int i=0;
+        i=0;
         while(ul < getNumUserLevels())
         {
           i++;
diff -urN wizznic-0.9_feedback_version-src/pack.c wizznic-0.9_feedback_version-src-gcc2/pack.c
--- wizznic-0.9_feedback_version-src/pack.c	2010-07-26 00:48:15.041418752 +0000
+++ wizznic-0.9_feedback_version-src-gcc2/pack.c	2010-09-04 19:24:25.000000000 +0000
@@ -147,10 +147,14 @@
 
 void packInit()
 {
+  int i=0;
   DIR *pdir=0;
   struct dirent *pent;
   struct stat st;
+  listItem* packDirList;
+  listItem* it;
   char* buf=malloc(sizeof(char)*128);
+  char** sortme;
 
   printf("initPack();\n");
 
@@ -162,7 +166,7 @@
 
   pdir = opendir( DATADIR"packs/" );
 
-  listItem* packDirList = initList();
+  packDirList = initList();
 
   if(pdir)
   {
@@ -196,9 +200,8 @@
   }
 
   //Add the rest of the packs.
-  char** sortme = malloc( sizeof(char**) * listSize(packDirList) );
-  listItem* it = packDirList;
-  int i=0;
+  sortme = malloc( sizeof(char**) * listSize(packDirList) );
+  it = packDirList;
   while( (it = it->next) )
   {
     sortme[i]=(char*)it->data;
@@ -320,6 +323,7 @@
 {
   char buf[128];
   SDL_Rect r;
+  packInfoType* pi;
   r.x=posx+5;
   r.y=posy+5;
 
@@ -333,7 +337,7 @@
   }
 
   //PackInfo is now in pi.
-  packInfoType* pi = (packInfoType*)listGetItemData(ps.packs,packNum);
+  pi = (packInfoType*)listGetItemData(ps.packs,packNum);
 
   //Blit the box
   if(ps.selected==packNum)
diff -urN wizznic-0.9_feedback_version-src/particle.c wizznic-0.9_feedback_version-src-gcc2/particle.c
--- wizznic-0.9_feedback_version-src/particle.c	2010-05-25 14:37:23.042729472 +0000
+++ wizznic-0.9_feedback_version-src-gcc2/particle.c	2010-09-04 19:15:18.769654784 +0000
@@ -10,85 +10,88 @@
 //Spawn particle system
 void spawnParticleSystem(psysSet_t* settings)
 {
-  if(!setting()->particles) return;
-  int i; //Gotta have a counter.
-
-  //Create a particle system
-  pSystem_t* tSystem=malloc( sizeof(pSystem_t) );
-
-  //Copy settings
-  tSystem->settings=(*settings);
-
-
-  //Setup particles
-  uint16_t col;
-  uint8_t r,g,b;
-  SDL_Surface* img;
-  //Should we use info's from a surface?
-  if(tSystem->settings.srcImg)
-  {
-    //number of particles
-    tSystem->settings.numParticles=tSystem->settings.srcRect.w*tSystem->settings.srcRect.h;
-    //Create array of particles
-    tSystem->particles = malloc( sizeof(particle_t)*(tSystem->settings.numParticles));
-    for(i=0; i<tSystem->settings.numParticles;i++)
-    {
+  if(!setting()->particles) { 
+    return;
+  } else {
+    int i; //Gotta have a counter.
+    uint16_t col;
+    uint8_t r,g,b;
+    SDL_Surface* img;
+
+    //Create a particle system
+    pSystem_t* tSystem=malloc( sizeof(pSystem_t) );
+
+    //Copy settings
+    tSystem->settings=(*settings);
+
+
+    //Setup particles
+    //Should we use info's from a surface?
+    if(tSystem->settings.srcImg)
+    {
+      //number of particles
+      tSystem->settings.numParticles=tSystem->settings.srcRect.w*tSystem->settings.srcRect.h;
+      //Create array of particles
+      tSystem->particles = malloc( sizeof(particle_t)*(tSystem->settings.numParticles));
+      for(i=0; i<tSystem->settings.numParticles;i++)
+      {
 
-      tSystem->particles[i].life=tSystem->settings.life - (rand()%tSystem->settings.lifeVar);
+        tSystem->particles[i].life=tSystem->settings.life - (rand()%tSystem->settings.lifeVar);
 
-      img=tSystem->settings.srcImg;
+        img=tSystem->settings.srcImg;
 
-      tSystem->particles[i].x = i%tSystem->settings.srcRect.w;
-      tSystem->particles[i].y = i/tSystem->settings.srcRect.w;
-      col=freadPixel(img,tSystem->particles[i].x+tSystem->settings.srcRect.x,tSystem->particles[i].y+tSystem->settings.srcRect.y);
-
-      r = ((col & img->format->Rmask) >> img->format->Rshift);
-      g = ((col & img->format->Gmask) >> img->format->Gshift);
-      b = ((col & img->format->Bmask) >> img->format->Bshift);
-      if( !(r==0 && g==63 && b==31) ) //These values... I don't get it.
-      {
-        tSystem->particles[i].color = col;
-      } else {
-        tSystem->particles[i].color = col;
-        tSystem->particles[i].life=0;
+        tSystem->particles[i].x = i%tSystem->settings.srcRect.w;
+        tSystem->particles[i].y = i/tSystem->settings.srcRect.w;
+        col=freadPixel(img,tSystem->particles[i].x+tSystem->settings.srcRect.x,tSystem->particles[i].y+tSystem->settings.srcRect.y);
+
+        r = ((col & img->format->Rmask) >> img->format->Rshift);
+        g = ((col & img->format->Gmask) >> img->format->Gshift);
+        b = ((col & img->format->Bmask) >> img->format->Bshift);
+        if( !(r==0 && g==63 && b==31) ) //These values... I don't get it.
+        {
+          tSystem->particles[i].color = col;
+        } else {
+          tSystem->particles[i].color = col;
+          tSystem->particles[i].life=0;
+        }
+
+        if(tSystem->settings.vel)
+        {
+          tSystem->particles[i].velx = (rand()%(tSystem->settings.vel*2))-(tSystem->settings.vel);
+          tSystem->particles[i].vely = (rand()%(tSystem->settings.vel*2))-(tSystem->settings.vel);
+        }
+
+        tSystem->particles[i].x *= 100;
+        tSystem->particles[i].y *= 100;
+        tSystem->particles[i].x += tSystem->settings.x*100;
+        tSystem->particles[i].y += tSystem->settings.y*100;
       }
 
-      if(tSystem->settings.vel)
+    } else {
+      //Create array of particles
+      tSystem->particles = malloc( sizeof(particle_t)*(tSystem->settings.numParticles));
+
+      for(i=0; i<tSystem->settings.numParticles;i++)
       {
+        tSystem->particles[i].life=tSystem->settings.life - (rand()%tSystem->settings.lifeVar);
         tSystem->particles[i].velx = (rand()%(tSystem->settings.vel*2))-(tSystem->settings.vel);
         tSystem->particles[i].vely = (rand()%(tSystem->settings.vel*2))-(tSystem->settings.vel);
-      }
-
-      tSystem->particles[i].x *= 100;
-      tSystem->particles[i].y *= 100;
-      tSystem->particles[i].x += tSystem->settings.x*100;
-      tSystem->particles[i].y += tSystem->settings.y*100;
-    }
-
-  } else {
-    //Create array of particles
-    tSystem->particles = malloc( sizeof(particle_t)*(tSystem->settings.numParticles));
+        tSystem->particles[i].x = tSystem->settings.x*100;
+        tSystem->particles[i].y = tSystem->settings.y*100;
 
-    for(i=0; i<tSystem->settings.numParticles;i++)
-    {
-      tSystem->particles[i].life=tSystem->settings.life - (rand()%tSystem->settings.lifeVar);
-      tSystem->particles[i].velx = (rand()%(tSystem->settings.vel*2))-(tSystem->settings.vel);
-      tSystem->particles[i].vely = (rand()%(tSystem->settings.vel*2))-(tSystem->settings.vel);
-      tSystem->particles[i].x = tSystem->settings.x*100;
-      tSystem->particles[i].y = tSystem->settings.y*100;
-
-      if(tSystem->settings.color == PARTICLECOLORRANDOM)
-      {
-        tSystem->particles[i].color = SDL_MapRGB( screen->format, rand()%256,rand()%256,rand()%256);
-      } else {
-        tSystem->particles[i].color = tSystem->settings.color;
+        if(tSystem->settings.color == PARTICLECOLORRANDOM)
+        {
+          tSystem->particles[i].color = SDL_MapRGB( screen->format, rand()%256,rand()%256,rand()%256);
+        } else {
+          tSystem->particles[i].color = tSystem->settings.color;
+        }
       }
     }
-  }
 
 
-  //Add to list of systems.
-  listAddData(pSystems, (void*)tSystem);
+    //Add to list of systems.
+    listAddData(pSystems, (void*)tSystem);
+  }
 }
 
 
@@ -137,36 +140,39 @@
 //This runs/draws all particle systems, and emitters.
 void runParticles(SDL_Surface* screen)
 {
-  if(!setting()->particles) return;
-  listItem* it = pSystems;
-  pSystem_t* p; //psystem
-  int i;
-
-  //Loop through systems
-  while( (it=it->next) )
-  {
-    p=(pSystem_t*)it->data;
-    //Draw, then update
-    for( i=0; i < p->settings.numParticles; i++ )
-    {
-      if( p->particles[i].life )
+  if(!setting()->particles) {
+  	return;
+  } else {
+    listItem* it = pSystems;
+    pSystem_t* p; //psystem
+    int i;
+
+    //Loop through systems
+    while( (it=it->next) )
+    {
+      p=(pSystem_t*)it->data;
+      //Draw, then update
+      for( i=0; i < p->settings.numParticles; i++ )
       {
-        //Draw particle
-        plotPixel( screen, p->particles[i].x/100,p->particles[i].y/100, p->particles[i].color );
-        //Update particle
-        updateParticle(&p->particles[i], screen, &p->settings);
+        if( p->particles[i].life )
+        {
+          //Draw particle
+          plotPixel( screen, p->particles[i].x/100,p->particles[i].y/100, p->particles[i].color );
+          //Update particle
+          updateParticle(&p->particles[i], screen, &p->settings);
+        }
+      }
+      //System life
+      p->settings.life -= getTicks();
+      if(p->settings.life<0)
+      {
+        //Remove system
+        clearSystem(p);
+        //Remove from list. (removeItem returns the item just before current, if any)
+        it=listRemoveItem(pSystems, it);
       }
     }
-    //System life
-    p->settings.life -= getTicks();
-    if(p->settings.life<0)
-    {
-      //Remove system
-      clearSystem(p);
-      //Remove from list. (removeItem returns the item just before current, if any)
-      it=listRemoveItem(pSystems, it);
-    }
-  }
+  }    
 }
 
 //Frees one system
diff -urN wizznic-0.9_feedback_version-src/settings.c wizznic-0.9_feedback_version-src-gcc2/settings.c
--- wizznic-0.9_feedback_version-src/settings.c	2010-07-28 19:24:52.041156608 +0000
+++ wizznic-0.9_feedback_version-src-gcc2/settings.c	2010-09-04 19:29:42.000000000 +0000
@@ -31,10 +31,11 @@
 
 void loadSettings()
 {
-  printf("loadSetting():\n");
   char* buf = malloc(sizeof(char)*2048);
   char* set = malloc(sizeof(char)*1024);
   char* val = malloc(sizeof(char)*1024);
+  FILE *f;
+  printf("loadSetting():\n");
 
   //Set defaults
   settings.firstRun=1;
@@ -70,7 +71,7 @@
   strcpy(settings.musicDir, ".");
 
   sprintf( buf, "%s/settings.ini", getConfigDir() );
-  FILE *f = fopen(buf, "r");
+  f = fopen(buf, "r");
   if(f)
   {
     while( fgets(buf, 128, f) )
@@ -158,8 +159,8 @@
 void saveSettings()
 {
   char* buf = malloc(sizeof(char)*1024);
-  sprintf( buf, "%s/settings.ini", getConfigDir() );
   FILE *f = fopen(buf, "w");
+  sprintf( buf, "%s/settings.ini", getConfigDir() );
   if(f)
   {
     fprintf(f, "soundvol=%i\n"
diff -urN wizznic-0.9_feedback_version-src/sound.c wizznic-0.9_feedback_version-src-gcc2/sound.c
--- wizznic-0.9_feedback_version-src/sound.c	2010-07-28 19:24:52.040370176 +0000
+++ wizznic-0.9_feedback_version-src-gcc2/sound.c	2010-09-04 17:54:39.000000000 +0000
@@ -139,6 +139,7 @@
 {
   int freeChannel=-1;
   int i;
+  int right;
 
   //Find free channel
   for(i=0;i<16;i++)
@@ -150,7 +151,7 @@
     }
   }
 
-  int right = (posX*255)/320;
+  right = (posX*255)/320;
   Mix_SetPanning(freeChannel, 255-right, right );
 
   Mix_PlayChannel(freeChannel, samples[sample], 0);
@@ -288,49 +289,52 @@
 
 void soundPlayUserSongNum(int num, char* songName)
 {
-  if(!setting()->musicVol) return;
-  listItem* it=fileList();
-  fileListItem_t* file;
-  int i=0;
-  while( (it=it->next) )
-  {
-    file=(fileListItem_t*)it->data;
-    if(!file->dir)
+  if(!setting()->musicVol) {
+  	return;
+  } else {
+    listItem* it=fileList();
+    fileListItem_t* file;
+    int i=0;
+    while( (it=it->next) )
     {
-      if(i==num)
+      file=(fileListItem_t*)it->data;
+      if(!file->dir)
       {
-        //Unload current song.
-        Mix_HaltMusic();
-        if(mus[1])
-        {
-          Mix_FreeMusic(mus[1]);
-          mus[1]=0;
-        }
-        //Load new song
-        mus[1]=Mix_LoadMUS( file->fullName );
-        if(!mus[1])
-        {
-          printf("Couldn't load music: '%s'\n",file->fullName);
-        }
-        else
+        if(i==num)
         {
-          printf("Now Playing: '%s'\n",file->fullName);
-          if(songName)
+          //Unload current song.
+          Mix_HaltMusic();
+          if(mus[1])
           {
-            showSNCD=SHOW_SONG_TIME;
-            strcpy(songName,file->name);
+            Mix_FreeMusic(mus[1]);
+            mus[1]=0;
+          }
+          //Load new song
+          mus[1]=Mix_LoadMUS( file->fullName );
+          if(!mus[1])
+          {
+            printf("Couldn't load music: '%s'\n",file->fullName);
+          }
+          else
+          {
+            printf("Now Playing: '%s'\n",file->fullName);
+            if(songName)
+            {
+              showSNCD=SHOW_SONG_TIME;
+              strcpy(songName,file->name);
+            }
           }
-        }
 
-        Mix_FadeInMusicPos(mus[1], 0, MUSIC_FADETIME,mPos[1]);
+          Mix_FadeInMusicPos(mus[1], 0, MUSIC_FADETIME,mPos[1]);
 
 
-        //return; We don't return, instead we let it run, to count number of usertracks.
+          //return; We don't return, instead we let it run, to count number of usertracks.
+        }
+        i++;
       }
-      i++;
     }
+    numUserSongs=i;
   }
-  numUserSongs=i;
 }
 
 
diff -urN wizznic-0.9_feedback_version-src/sprite.c wizznic-0.9_feedback_version-src-gcc2/sprite.c
--- wizznic-0.9_feedback_version-src/sprite.c	2010-01-28 03:15:03.040632320 +0000
+++ wizznic-0.9_feedback_version-src-gcc2/sprite.c	2010-09-04 17:46:09.000000000 +0000
@@ -29,29 +29,33 @@
 spriteType* cutSprite(SDL_Surface* img, int x,int y, int w, int h)
 {
   //Did we get a valid surface?
-  if(!img) return(NULL);
-
-  //Allocate memory for the sprite
-  spriteType* tspr = malloc( sizeof(spriteType) );
-  if(tspr != NULL)
-  {
-    tspr->img = img;
-    tspr->clip.x = x;
-    tspr->clip.y = y;
-    tspr->clip.w = w;
-    tspr->clip.h = h;
+  if(!img) {
+  	return(NULL);
   } else {
-    printf("Error, couldn't malloc %i bytes.\n",sizeof(spriteType));
-  }
-
+    //Allocate memory for the sprite
+    spriteType* tspr = malloc( sizeof(spriteType) );
+    if(tspr != NULL)
+    {
+      tspr->img = img;
+      tspr->clip.x = x;
+      tspr->clip.y = y;
+      tspr->clip.w = w;
+      tspr->clip.h = h;
+    } else {
+      printf("Error, couldn't malloc %i bytes.\n",sizeof(spriteType));
+    }
   return(tspr);
+  }
 }
 
 void drawSprite(SDL_Surface* scr, spriteType* spr, int x, int y)
 {
-  if(!spr) return;
+  if(!spr) {
+  	return; 
+  } else {
   SDL_Rect pos;
   pos.x = x;
   pos.y = y;
   SDL_BlitSurface( spr->img, &spr->clip, scr, &pos );
+  }
 }
diff -urN wizznic-0.9_feedback_version-src/stars.c wizznic-0.9_feedback_version-src-gcc2/stars.c
--- wizznic-0.9_feedback_version-src/stars.c	2010-05-25 14:37:23.039583744 +0000
+++ wizznic-0.9_feedback_version-src-gcc2/stars.c	2010-09-04 18:47:31.943980544 +0000
@@ -1,198 +1,200 @@
 #include "stars.h"
-#include "pixel.h"
-#include "sound.h"
-#include "ticks.h"
-
-static listItem* stars;
-static listItem* rockets;
-//Setup 1000 stars
+#include "pixel.h"
+#include "sound.h"
+#include "ticks.h"
+
+static listItem* stars;
+static listItem* rockets;
+//Setup 1000 stars
 #define NUMSTARS 500
 void initStars(SDL_Surface* screen)
-{
+{
+  star_t* star;
+  int i;
+  uint8_t col;
   rockets = initList();
-  stars = initList();
-  star_t* star;
-  int i;
-  uint8_t col;
-  for(i=0; i < NUMSTARS; i++)
-  {
-    star = malloc(sizeof(star_t));
-    star->x = rand()%3200;
-    star->y = rand()%2400;
-    star->sx = rand()%10; //xpos and ypos are to be divided by 10
-    star->sy = 0;
-    col = rand()%230+25; //from 25 to 255
-    star->color = SDL_MapRGB(screen->format, col,col,col);
-    listAddData(stars, (void*)star); //Add star to list
+  stars = initList();
+  for(i=0; i < NUMSTARS; i++)
+  {
+    star = malloc(sizeof(star_t));
+    star->x = rand()%3200;
+    star->y = rand()%2400;
+    star->sx = rand()%10; //xpos and ypos are to be divided by 10
+    star->sy = 0;
+    col = rand()%230+25; //from 25 to 255
+    star->color = SDL_MapRGB(screen->format, col,col,col);
+    listAddData(stars, (void*)star); //Add star to list
   }
 }
 
 void starField(SDL_Surface* screen, int move)
 {
+  star_t* star;
+  listItem* it=stars;
   SDL_FillRect(screen, NULL, 0x00);
-  star_t* star;
-  listItem* it=stars;
-  while( (it=it->next) )
-  {
-    star=(star_t*)it->data;
-    //Move star
-    if(move)
-    {
-      star->x -= star->sx;
-      //Out of screen?
-      if(star->x < 0)
-      {
-        //Give new y and reset x
-        star->y=rand()%2398-1;
-        star->x= 3199;
-      }
-    }
-    //Draw
-    plotPixel(screen, star->x/10, star->y/10, star->color);
-  }
-}
-
-
-/* Fireworks effect */
-
+  while( (it=it->next) )
+  {
+    star=(star_t*)it->data;
+    //Move star
+    if(move)
+    {
+      star->x -= star->sx;
+      //Out of screen?
+      if(star->x < 0)
+      {
+        //Give new y and reset x
+        star->y=rand()%2398-1;
+        star->x= 3199;
+      }
+    }
+    //Draw
+    plotPixel(screen, star->x/10, star->y/10, star->color);
+  }
+}
+
+
+/* Fireworks effect */
+
 static int nextExpl = 0; //Countdown
-void fireWorks(SDL_Surface* screen)
-{
-  rocket_t* tempRocket;
-  star_t* tempStar;
-  listItem* it;
-
-  uint32_t colWhite = SDL_MapRGB(screen->format, 255,255,255);
-  uint32_t colYellow = SDL_MapRGB(screen->format, 255,255,0);
-
-  /*
-      New Rockets
-                        */
-  nextExpl -= getTicks();
-  if(nextExpl < 1)
-  {
-    //Set new timer
-    nextExpl = rand()%2000;
-    //Fire a new rocket
-    tempRocket = malloc(sizeof(rocket_t));
-    //Set initial position at y 240, and some random x
-    tempRocket->y=2400;
-    tempRocket->x=rand()%3200;
-    //Set a direction that flies towards the middle
-    tempRocket->sx = rand()%5;
-
-    if(tempRocket->x > 1600)
-    {
-      tempRocket->sx *= -1;
-    }
-
-    tempRocket->sy = 0-rand()%30-20;
-    //Set life
-    tempRocket->life=rand()%1000+250;
-
-    tempRocket->p = initList();
-    //Init particles for explosion
-    int i, r=rand()%100;
-    for(i=0; i < r; i++)
-    {
-      tempStar = malloc( sizeof(star_t) );
-      //Set dir to something random
-      tempStar->sx = rand()%500-250;
-      tempStar->sy = rand()%500-250;
-      tempStar->color = SDL_MapRGB( screen->format, rand()%128+128,rand()%256,rand()%128);
-      tempStar->life = rand()%3000+500;
-      //Add to list
-      listAddData( tempRocket->p, (void*)tempStar );
-    }
-    //Add rocket to list
-    listAddData(rockets, (void*)tempRocket);
-
-    //Play  launch sound
-    sndPlay(SND_ROCKETLAUNCH, tempRocket->x/10);
-  }
-
-  /*
-      Going through rockets and their particles
-                                                  */
-  it=rockets;
-  listItem* itt;
-  while( (it=it->next) )
-  {
-    tempRocket=(rocket_t*)it->data;
-    //If rocket is still alive, fly it
-    if(tempRocket->life > 0)
-    {
-      //Age
-      tempRocket->life -= getTicks();
-      //Set position for particles if it got too old
-      if(tempRocket->life < 1)
-      {
-        itt=tempRocket->p;
-        while( (itt=itt->next) )
-        {
-          tempStar=(star_t*)itt->data;
-          tempStar->x = tempRocket->x*10;
-          tempStar->y = tempRocket->y*10;
-        }
-        //Play "Explosion" sound
-        sndPlay(SND_ROCKETBOOM, tempRocket->x/10);
-      }
-      //Fly
-      tempRocket->x += tempRocket->sx;
-      tempRocket->y += tempRocket->sy;
-      //Draw
-      plotPixel(screen, tempRocket->x/10, tempRocket->y/10, colWhite );
-      plotPixel(screen, tempRocket->x/10, tempRocket->y/10+1, colYellow );
-
-    } else {
-      //iterate through stars
-      itt=tempRocket->p;
-      int liveStars=0;
-      while( (itt=itt->next) )
-      {
-        tempStar=(star_t*)itt->data;
-        //alive?
-        if(tempStar->life > 0)
-        {
-          //Fly
-
-          tempStar->x += tempStar->sx/10;
-          tempStar->y += tempStar->sy/10;
-
-          //Gravity
-          if(tempStar->y < 10)
-              tempStar->y += 20;
-
-          //Draw
-          if(tempStar->life > 1000 || tempStar->life % 2 == 0)
-            plotPixel(screen, tempStar->x/100, tempStar->y/100, tempStar->color);
-          else if(tempStar->life % 3 == 0)
-            plotPixel(screen, tempStar->x/100, tempStar->y/100, colWhite);
-
-          //age
-          tempStar->life -= getTicks();
-
-          liveStars++;
-        } //alive
-      }
-      //Check if it should still survice
-      if(liveStars == 0)
-      {
-        //Remove stars
-        itt=tempRocket->p;
-        while( (itt=itt->next) )
-        {
-          free(itt->data);
-        }
-        freeList(tempRocket->p);
-
-        //Remove rocket
-        free(it->data);
-        listRemoveItem(rockets, it);
-      }
-    } //Sim rocket stars
-  } //iterate through rockets
-
-}
-
-
+void fireWorks(SDL_Surface* screen)
+{
+  int i, r;
+  int liveStars;
+  rocket_t* tempRocket;
+  star_t* tempStar;
+  listItem* it;
+  listItem* itt;
+
+  uint32_t colWhite = SDL_MapRGB(screen->format, 255,255,255);
+  uint32_t colYellow = SDL_MapRGB(screen->format, 255,255,0);
+
+  /*
+      New Rockets
+                        */
+  nextExpl -= getTicks();
+  if(nextExpl < 1)
+  {
+    //Set new timer
+    nextExpl = rand()%2000;
+    //Fire a new rocket
+    tempRocket = malloc(sizeof(rocket_t));
+    //Set initial position at y 240, and some random x
+    tempRocket->y=2400;
+    tempRocket->x=rand()%3200;
+    //Set a direction that flies towards the middle
+    tempRocket->sx = rand()%5;
+
+    if(tempRocket->x > 1600)
+    {
+      tempRocket->sx *= -1;
+    }
+
+    tempRocket->sy = 0-rand()%30-20;
+    //Set life
+    tempRocket->life=rand()%1000+250;
+
+    tempRocket->p = initList();
+    //Init particles for explosion
+    r=rand()%100;
+    for(i=0; i < r; i++)
+    {
+      tempStar = malloc( sizeof(star_t) );
+      //Set dir to something random
+      tempStar->sx = rand()%500-250;
+      tempStar->sy = rand()%500-250;
+      tempStar->color = SDL_MapRGB( screen->format, rand()%128+128,rand()%256,rand()%128);
+      tempStar->life = rand()%3000+500;
+      //Add to list
+      listAddData( tempRocket->p, (void*)tempStar );
+    }
+    //Add rocket to list
+    listAddData(rockets, (void*)tempRocket);
+
+    //Play  launch sound
+    sndPlay(SND_ROCKETLAUNCH, tempRocket->x/10);
+  }
+
+  /*
+      Going through rockets and their particles
+                                                  */
+  it=rockets;
+  while( (it=it->next) )
+  {
+    tempRocket=(rocket_t*)it->data;
+    //If rocket is still alive, fly it
+    if(tempRocket->life > 0)
+    {
+      //Age
+      tempRocket->life -= getTicks();
+      //Set position for particles if it got too old
+      if(tempRocket->life < 1)
+      {
+        itt=tempRocket->p;
+        while( (itt=itt->next) )
+        {
+          tempStar=(star_t*)itt->data;
+          tempStar->x = tempRocket->x*10;
+          tempStar->y = tempRocket->y*10;
+        }
+        //Play "Explosion" sound
+        sndPlay(SND_ROCKETBOOM, tempRocket->x/10);
+      }
+      //Fly
+      tempRocket->x += tempRocket->sx;
+      tempRocket->y += tempRocket->sy;
+      //Draw
+      plotPixel(screen, tempRocket->x/10, tempRocket->y/10, colWhite );
+      plotPixel(screen, tempRocket->x/10, tempRocket->y/10+1, colYellow );
+
+    } else {
+      //iterate through stars
+      itt=tempRocket->p;
+      liveStars=0;
+      while( (itt=itt->next) )
+      {
+        tempStar=(star_t*)itt->data;
+        //alive?
+        if(tempStar->life > 0)
+        {
+          //Fly
+
+          tempStar->x += tempStar->sx/10;
+          tempStar->y += tempStar->sy/10;
+
+          //Gravity
+          if(tempStar->y < 10)
+              tempStar->y += 20;
+
+          //Draw
+          if(tempStar->life > 1000 || tempStar->life % 2 == 0)
+            plotPixel(screen, tempStar->x/100, tempStar->y/100, tempStar->color);
+          else if(tempStar->life % 3 == 0)
+            plotPixel(screen, tempStar->x/100, tempStar->y/100, colWhite);
+
+          //age
+          tempStar->life -= getTicks();
+
+          liveStars++;
+        } //alive
+      }
+      //Check if it should still survice
+      if(liveStars == 0)
+      {
+        //Remove stars
+        itt=tempRocket->p;
+        while( (itt=itt->next) )
+        {
+          free(itt->data);
+        }
+        freeList(tempRocket->p);
+
+        //Remove rocket
+        free(it->data);
+        listRemoveItem(rockets, it);
+      }
+    } //Sim rocket stars
+  } //iterate through rockets
+
+}
+
+
diff -urN wizznic-0.9_feedback_version-src/stats.c wizznic-0.9_feedback_version-src-gcc2/stats.c
--- wizznic-0.9_feedback_version-src/stats.c	2010-07-24 23:26:14.040894464 +0000
+++ wizznic-0.9_feedback_version-src-gcc2/stats.c	2010-09-04 19:35:01.178520064 +0000
@@ -142,6 +142,7 @@
 {
   listItem* it;
   hsEntry_t* hs;
+  FILE* f;
 
   //Check that there's a filename to write to (st is all 0's if not)
   if(!st.hsFn)
@@ -151,7 +152,7 @@
   }
 
   //Open file
-  FILE* f = fopen(st.hsFn, "w");
+  f = fopen(st.hsFn, "w");
   if(f)
   {
     //Fill in header
@@ -370,9 +371,10 @@
   #ifndef GP2X
   if( !threadRunning && (setting()->online || ignoreIfOnline) )
   {
+    int b;
     threadRunning=1; //Thread will set this 0 when returning.
 
-    int b = sprintf( curlbuf, "%s\"version=%s&pack=%s&level=%i&time=%i&moves=%i&combos=%i&score=%i&action=%s\"",\
+    b = sprintf( curlbuf, "%s\"version=%s&pack=%s&level=%i&time=%i&moves=%i&combos=%i&score=%i&action=%s\"",\
      CURLBIN, VERSION_STRING, packState()->cp->path,\
     level,time,moves,combos,score,action );
     if(b > 0 && b < 2048)
diff -urN wizznic-0.9_feedback_version-src/teleport.c wizznic-0.9_feedback_version-src-gcc2/teleport.c
--- wizznic-0.9_feedback_version-src/teleport.c	2010-07-26 00:48:15.041418752 +0000
+++ wizznic-0.9_feedback_version-src-gcc2/teleport.c	2010-09-04 19:37:51.267649024 +0000
@@ -73,20 +73,21 @@
 }
 
 char* teleMkStrings(listItem* l)
-{
-  if(!listSize(l)) return(0);
+{
+  if(!listSize(l)) {
+  	return(0);
+  } else {
+    listItem* it = l;
+    telePort_t* t;
+    int bytes =  sizeof(char)*(listSize(l)*strlen("teleport=10,10:10,10\n"));
+    char* str = malloc( bytes );
+    memset(str,0,bytes);
 
-  listItem* it = l;
-  telePort_t* t;
-  int bytes =  sizeof(char)*(listSize(l)*strlen("teleport=10,10:10,10\n"));
-  char* str = malloc( bytes );
-  memset(str,0,bytes);
-
-  while( (it=it->next) )
-  {
-    t = (telePort_t*)it->data;
-    sprintf(str, "%steleport=%i,%i:%i,%i\n",str, t->sx,t->sy,t->dx,t->dy);
+    while( (it=it->next) )
+    {
+      t = (telePort_t*)it->data;
+      sprintf(str, "%steleport=%i,%i:%i,%i\n",str, t->sx,t->sy,t->dx,t->dy);
+    }
+    return(str);
   }
-
-  return(str);
 }
diff -urN wizznic-0.9_feedback_version-src/text.c wizznic-0.9_feedback_version-src-gcc2/text.c
--- wizznic-0.9_feedback_version-src/text.c	2010-06-20 13:53:08.042467328 +0000
+++ wizznic-0.9_feedback_version-src-gcc2/text.c	2010-09-04 17:49:59.000000000 +0000
@@ -108,8 +108,6 @@
 
 void txtWave( SDL_Surface* scr, int fontNum, const char* txt, int x, int y, float* rot)
 {
-  //dec rot
-  *rot -= (float)getTicks()/200.0;
   //For each char:
   float amp=6;
   int px=x;
@@ -117,8 +115,11 @@
   int pos=0;
   int len=strlen(txt);
   float chInc = 6.28318531/len;
-  px = x - (txtSize[fontNum][0]*len)/2;
   char c;
+
+  //dec rot
+  *rot -= (float)getTicks()/200.0;
+  px = x - (txtSize[fontNum][0]*len)/2;
   c = txt[pos];
 
   while( c != '\0')
diff -urN wizznic-0.9_feedback_version-src/userfiles.c wizznic-0.9_feedback_version-src-gcc2/userfiles.c
--- wizznic-0.9_feedback_version-src/userfiles.c	2010-06-20 13:53:08.041680896 +0000
+++ wizznic-0.9_feedback_version-src-gcc2/userfiles.c	2010-09-04 19:47:35.376176640 +0000
@@ -12,6 +12,7 @@
 
 void initUserPaths()
 {
+  struct stat s;
   #ifdef PER_USER_FILES
 
     //Generate directory string
@@ -41,7 +42,6 @@
   sprintf( strHsDir, "%s/highscores", strConfDir );
 
   //Check if dir exists (we check each dir, since ./ might exist without the others
-  struct stat s;
   if (stat(strConfDir,&s) != 0) mkdir(strConfDir,S_IRWXU);
   if (stat(strEditLvlDir,&s) != 0) mkdir(strEditLvlDir,S_IRWXU);
   if (stat(strHsDir,&s) != 0) mkdir(strHsDir,S_IRWXU);

diff -urN diffutils-3.2/src/dir.c diffutils-3.2-c89/src/dir.c
--- diffutils-3.2/src/dir.c	2011-08-14 15:58:59.020709376 +0000
+++ diffutils-3.2-c89/src/dir.c	2012-09-14 16:59:18.000000000 +0000
@@ -202,6 +202,7 @@
   struct dirdata dirdata[2];
   int volatile val = EXIT_SUCCESS;
   int i;
+  int v1;
 
   if ((cmp->file[0].desc == -1 || dir_loop (cmp, 0))
       && (cmp->file[1].desc == -1 || dir_loop (cmp, 1)))
@@ -254,6 +255,7 @@
 	     pretend the "next name" in that dir is very large.  */
 	  int nameorder = (!*names[0] ? 1 : !*names[1] ? -1
 			   : compare_names (*names[0], *names[1]));
+	  int v1;
 
 	  /* Prefer a file_name_cmp match if available.  This algorithm is
 	     O(N**2), where N is the number of names in a directory
@@ -289,7 +291,7 @@
 		}
 	    }
 
-	  int v1 = (*handle_file) (cmp,
+	  v1 = (*handle_file) (cmp,
 				   0 < nameorder ? 0 : *names[0]++,
 				   nameorder < 0 ? 0 : *names[1]++);
 	  if (val < v1)
@@ -342,7 +344,8 @@
 	    match = file; /* longjmp may mess up MATCH.  */
 	  else
 	    {
-	      for (char const **p = dirdata.names; *p; p++)
+	      char const **p;
+	      for (p = dirdata.names; *p; p++)
 		if (compare_names (*p, file) == 0)
 		  {
 		    if (file_name_cmp (*p, file) == 0)
diff -urN diffutils-3.2/src/io.c diffutils-3.2-c89/src/io.c
--- diffutils-3.2/src/io.c	2011-08-15 05:24:38.019136512 +0000
+++ diffutils-3.2-c89/src/io.c	2012-09-14 17:02:59.000000000 +0000
@@ -258,6 +258,7 @@
 	case IGNORE_TRAILING_SPACE:
 	  {
 	    size_t column = 0;
+		size_t repetitions = 1;
 	    while ((c = *p++) != '\n')
 	      {
 		if (ig_white_space & IGNORE_TRAILING_SPACE
@@ -274,8 +275,6 @@
 		    while (isspace (c1));
 		  }
 
-		size_t repetitions = 1;
-
 		if (ig_white_space & IGNORE_TAB_EXPANSION)
 		  switch (c)
 		    {

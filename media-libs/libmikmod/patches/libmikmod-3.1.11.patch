diff -urN libmikmod-3.1.11/NEWS libmikmod-3.1.12/NEWS
--- libmikmod-3.1.11/NEWS	2004-01-21 17:43:52.000000000 +0000
+++ libmikmod-3.1.12/NEWS	2007-12-15 12:39:54.000000000 +0000
@@ -1,3 +1,29 @@
+Summary of changes between libmikmod 3.1.11-a and libmikmod 3.1.12
+========================================================================
+libmikmod-3.1.12 was released on 15/12/2007
+
+This is bugfix release by denis111(keygenmusic).
+
+BUGFIXES
+- libmikmod no more hangs on loading XM modules with incorrect number of
+  instrumens.
+- modules with more then 255 orders are now supported
+
+
+Summary of changes between libmikmod 3.1.11 and libmikmod 3.1.11-a
+========================================================================
+libmikmod-3.1.11-a was released on 05/03/2004
+
+Most of my work and attention goes on the 3.2.x series, but I still receive
+occasional bug reports and patchs for the 3.1.11 version. There are not enough
+changes to make a full release, but many people may find this patch useful.
+
+BUGFIXES
+- libmikmod playback now works correcly on amd64 (type size problem)
+- fixed warning issued by automake >= 1.8
+- config.sub and config.guess updated
+
+
 Summary of changes between libmikmod 3.1.10 and libmikmod 3.1.11 (Thiers):
 ==========================================================================
 
diff -urN libmikmod-3.1.11/README libmikmod-3.1.12/README
--- libmikmod-3.1.11/README	2004-01-21 17:43:52.000000000 +0000
+++ libmikmod-3.1.12/README	2007-12-15 12:40:48.000000000 +0000
@@ -1,7 +1,7 @@
   Hello folks!
 
 
-This is libmikmod, version 3.1.11, a portable sound library for Unix
+This is libmikmod, version 3.1.12, a portable sound library for Unix
 and other systems. Check out the file 'NEWS' for more history information.
 
 
diff -urN libmikmod-3.1.11/configure.in libmikmod-3.1.12/configure.in
--- libmikmod-3.1.11/configure.in	2004-01-21 17:43:52.000000000 +0000
+++ libmikmod-3.1.12/configure.in	2007-12-15 09:22:57.000000000 +0000
@@ -1,6 +1,6 @@
 dnl Process this file with autoconf to produce a configure script.
 dnl
-dnl $Id: configure.in,v 1.2 2004/01/21 01:41:49 raph Exp $
+dnl $Id: configure.in,v 1.1.1.1 2004/06/01 12:16:16 raph Exp $
 
 AC_INIT(include/mikmod.h.in)
 
diff -urN libmikmod-3.1.11/dlapi/dl_hpux.c libmikmod-3.1.12/dlapi/dl_hpux.c
--- libmikmod-3.1.11/dlapi/dl_hpux.c	2004-01-21 17:43:52.000000000 +0000
+++ libmikmod-3.1.12/dlapi/dl_hpux.c	2007-12-15 09:23:01.000000000 +0000
@@ -1,6 +1,6 @@
 /*==============================================================================
 
-  $Id: dl_hpux.c,v 1.1.1.1 2004/01/21 01:36:35 raph Exp $
+  $Id: dl_hpux.c,v 1.1.1.1 2004/06/01 12:16:17 raph Exp $
 
   simple dlopen()-like implementation above HP-UX shl_xxx() API
 
diff -urN libmikmod-3.1.11/docs/mikmod.texi libmikmod-3.1.12/docs/mikmod.texi
--- libmikmod-3.1.11/docs/mikmod.texi	2004-01-21 17:43:52.000000000 +0000
+++ libmikmod-3.1.12/docs/mikmod.texi	2007-12-15 09:23:05.000000000 +0000
@@ -7,7 +7,7 @@
 
   MikMod Sound Library Documentation
 
-  $Id: mikmod.texi,v 1.1.1.1 2004/01/21 01:36:35 raph Exp $
+  $Id: mikmod.texi,v 1.1.1.1 2004/06/01 12:16:17 raph Exp $
 
 @end ignore
 @c comment this during modifications
diff -urN libmikmod-3.1.11/drivers/drv_AF.c libmikmod-3.1.12/drivers/drv_AF.c
--- libmikmod-3.1.11/drivers/drv_AF.c	2004-01-21 17:43:52.000000000 +0000
+++ libmikmod-3.1.12/drivers/drv_AF.c	2007-12-15 09:23:09.000000000 +0000
@@ -20,7 +20,7 @@
   
 /*==============================================================================
 
-  $Id: drv_AF.c,v 1.1.1.1 2004/01/21 01:36:35 raph Exp $
+  $Id: drv_AF.c,v 1.1.1.1 2004/06/01 12:16:17 raph Exp $
 
   Driver for output on AF audio server.
 
diff -urN libmikmod-3.1.11/drivers/drv_aix.c libmikmod-3.1.12/drivers/drv_aix.c
--- libmikmod-3.1.11/drivers/drv_aix.c	2004-01-21 17:43:52.000000000 +0000
+++ libmikmod-3.1.12/drivers/drv_aix.c	2007-12-15 09:23:12.000000000 +0000
@@ -20,7 +20,7 @@
   
 /*==============================================================================
 
-  $Id: drv_aix.c,v 1.1.1.1 2004/01/21 01:36:35 raph Exp $
+  $Id: drv_aix.c,v 1.1.1.1 2004/06/01 12:16:17 raph Exp $
 
   Driver for output to AIX series audio device
 
diff -urN libmikmod-3.1.11/drivers/drv_alsa.c libmikmod-3.1.12/drivers/drv_alsa.c
--- libmikmod-3.1.11/drivers/drv_alsa.c	2004-01-21 17:43:52.000000000 +0000
+++ libmikmod-3.1.12/drivers/drv_alsa.c	2007-12-15 09:23:17.000000000 +0000
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: drv_alsa.c,v 1.1.1.1 2004/01/21 01:36:35 raph Exp $
+  $Id: drv_alsa.c,v 1.1.1.1 2004/06/01 12:16:17 raph Exp $
 
   Driver for Advanced Linux Sound Architecture (ALSA)
 
diff -urN libmikmod-3.1.11/drivers/drv_dart.c libmikmod-3.1.12/drivers/drv_dart.c
--- libmikmod-3.1.11/drivers/drv_dart.c	2004-01-21 17:43:52.000000000 +0000
+++ libmikmod-3.1.12/drivers/drv_dart.c	2007-12-15 09:23:20.000000000 +0000
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: drv_dart.c,v 1.1.1.1 2004/01/21 01:36:35 raph Exp $
+  $Id: drv_dart.c,v 1.1.1.1 2004/06/01 12:16:17 raph Exp $
 
   Driver for output on OS/2 MMPM/2 using direct audio (DART)
 
diff -urN libmikmod-3.1.11/drivers/drv_ds.c libmikmod-3.1.12/drivers/drv_ds.c
--- libmikmod-3.1.11/drivers/drv_ds.c	2004-01-21 17:43:52.000000000 +0000
+++ libmikmod-3.1.12/drivers/drv_ds.c	2007-12-15 09:23:24.000000000 +0000
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: drv_ds.c,v 1.2 2004/01/21 17:29:32 raph Exp $
+  $Id: drv_ds.c,v 1.1.1.1 2004/06/01 12:16:17 raph Exp $
 
   Driver for output on win32 platforms using DirectSound
 
diff -urN libmikmod-3.1.11/drivers/drv_esd.c libmikmod-3.1.12/drivers/drv_esd.c
--- libmikmod-3.1.11/drivers/drv_esd.c	2004-01-21 17:43:52.000000000 +0000
+++ libmikmod-3.1.12/drivers/drv_esd.c	2007-12-15 09:23:27.000000000 +0000
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: drv_esd.c,v 1.1.1.1 2004/01/21 01:36:35 raph Exp $
+  $Id: drv_esd.c,v 1.1.1.1 2004/06/01 12:16:17 raph Exp $
 
   Driver for the Enlightened sound daemon (EsounD)
 
diff -urN libmikmod-3.1.11/drivers/drv_hp.c libmikmod-3.1.12/drivers/drv_hp.c
--- libmikmod-3.1.11/drivers/drv_hp.c	2004-01-21 17:43:52.000000000 +0000
+++ libmikmod-3.1.12/drivers/drv_hp.c	2007-12-15 09:23:31.000000000 +0000
@@ -20,7 +20,7 @@
   
 /*==============================================================================
 
-  $Id: drv_hp.c,v 1.1.1.1 2004/01/21 01:36:35 raph Exp $
+  $Id: drv_hp.c,v 1.1.1.1 2004/06/01 12:16:17 raph Exp $
 
   Driver for output to HP 9000 series /dev/audio
 
diff -urN libmikmod-3.1.11/drivers/drv_mac.c libmikmod-3.1.12/drivers/drv_mac.c
--- libmikmod-3.1.11/drivers/drv_mac.c	2004-01-21 17:43:52.000000000 +0000
+++ libmikmod-3.1.12/drivers/drv_mac.c	2007-12-15 09:23:34.000000000 +0000
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: drv_mac.c,v 1.1.1.1 2004/01/21 01:36:35 raph Exp $
+  $Id: drv_mac.c,v 1.1.1.1 2004/06/01 12:16:17 raph Exp $
 
   Driver for output to the Macintosh Sound Manager
 
diff -urN libmikmod-3.1.11/drivers/drv_nos.c libmikmod-3.1.12/drivers/drv_nos.c
--- libmikmod-3.1.11/drivers/drv_nos.c	2004-01-21 17:43:52.000000000 +0000
+++ libmikmod-3.1.12/drivers/drv_nos.c	2007-12-15 09:23:39.000000000 +0000
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: drv_nos.c,v 1.1.1.1 2004/01/21 01:36:35 raph Exp $
+  $Id: drv_nos.c,v 1.1.1.1 2004/06/01 12:16:17 raph Exp $
 
   Driver for no output
 
diff -urN libmikmod-3.1.11/drivers/drv_os2.c libmikmod-3.1.12/drivers/drv_os2.c
--- libmikmod-3.1.11/drivers/drv_os2.c	2004-01-21 17:43:52.000000000 +0000
+++ libmikmod-3.1.12/drivers/drv_os2.c	2007-12-15 09:23:43.000000000 +0000
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: drv_os2.c,v 1.1.1.1 2004/01/21 01:36:35 raph Exp $
+  $Id: drv_os2.c,v 1.1.1.1 2004/06/01 12:16:17 raph Exp $
 
   Driver for output on OS/2 using MMPM/2 MCI interface
 
diff -urN libmikmod-3.1.11/drivers/drv_oss.c libmikmod-3.1.12/drivers/drv_oss.c
--- libmikmod-3.1.11/drivers/drv_oss.c	2004-01-21 17:43:52.000000000 +0000
+++ libmikmod-3.1.12/drivers/drv_oss.c	2007-12-15 09:23:46.000000000 +0000
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: drv_oss.c,v 1.2 2004/01/21 01:41:53 raph Exp $
+  $Id: drv_oss.c,v 1.1.1.1 2004/06/01 12:16:17 raph Exp $
 
   Driver for output on Linux and FreeBSD Open Sound System (OSS) (/dev/dsp) 
 
diff -urN libmikmod-3.1.11/drivers/drv_pipe.c libmikmod-3.1.12/drivers/drv_pipe.c
--- libmikmod-3.1.11/drivers/drv_pipe.c	2004-01-21 17:43:52.000000000 +0000
+++ libmikmod-3.1.12/drivers/drv_pipe.c	2007-12-15 09:23:49.000000000 +0000
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: drv_pipe.c,v 1.1.1.1 2004/01/21 01:36:35 raph Exp $
+  $Id: drv_pipe.c,v 1.1.1.1 2004/06/01 12:16:17 raph Exp $
 
   Driver for output via a pipe to another command
 
diff -urN libmikmod-3.1.11/drivers/drv_raw.c libmikmod-3.1.12/drivers/drv_raw.c
--- libmikmod-3.1.11/drivers/drv_raw.c	2004-01-21 17:43:52.000000000 +0000
+++ libmikmod-3.1.12/drivers/drv_raw.c	2007-12-15 09:23:52.000000000 +0000
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: drv_raw.c,v 1.2 2004/01/21 17:29:32 raph Exp $
+  $Id: drv_raw.c,v 1.1.1.1 2004/06/01 12:16:17 raph Exp $
 
   Driver for output to a file called MUSIC.RAW
 
diff -urN libmikmod-3.1.11/drivers/drv_sam9407.c libmikmod-3.1.12/drivers/drv_sam9407.c
--- libmikmod-3.1.11/drivers/drv_sam9407.c	2004-01-21 17:43:52.000000000 +0000
+++ libmikmod-3.1.12/drivers/drv_sam9407.c	2007-12-15 09:23:55.000000000 +0000
@@ -20,7 +20,7 @@
 
 /*==============================================================================
   
-  $Id: drv_sam9407.c,v 1.1.1.1 2004/01/21 01:36:35 raph Exp $
+  $Id: drv_sam9407.c,v 1.1.1.1 2004/06/01 12:16:17 raph Exp $
   
   Driver for the Linux sam9407 driver
   
diff -urN libmikmod-3.1.11/drivers/drv_sgi.c libmikmod-3.1.12/drivers/drv_sgi.c
--- libmikmod-3.1.11/drivers/drv_sgi.c	2004-01-21 17:43:52.000000000 +0000
+++ libmikmod-3.1.12/drivers/drv_sgi.c	2007-12-15 09:24:00.000000000 +0000
@@ -20,7 +20,7 @@
   
 /*==============================================================================
 
-  $Id: drv_sgi.c,v 1.1.1.1 2004/01/21 01:36:35 raph Exp $
+  $Id: drv_sgi.c,v 1.1.1.1 2004/06/01 12:16:17 raph Exp $
 
   Driver for output on SGI audio system (needs libaudio from the dmedia
   package).
diff -urN libmikmod-3.1.11/drivers/drv_stdout.c libmikmod-3.1.12/drivers/drv_stdout.c
--- libmikmod-3.1.11/drivers/drv_stdout.c	2004-01-21 17:43:52.000000000 +0000
+++ libmikmod-3.1.12/drivers/drv_stdout.c	2007-12-15 09:24:03.000000000 +0000
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: drv_stdout.c,v 1.1.1.1 2004/01/21 01:36:35 raph Exp $
+  $Id: drv_stdout.c,v 1.1.1.1 2004/06/01 12:16:17 raph Exp $
 
   Output data to stdout
 
diff -urN libmikmod-3.1.11/drivers/drv_sun.c libmikmod-3.1.12/drivers/drv_sun.c
--- libmikmod-3.1.11/drivers/drv_sun.c	2004-01-21 17:43:52.000000000 +0000
+++ libmikmod-3.1.12/drivers/drv_sun.c	2007-12-15 09:24:07.000000000 +0000
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: drv_sun.c,v 1.1.1.1 2004/01/21 01:36:35 raph Exp $
+  $Id: drv_sun.c,v 1.1.1.1 2004/06/01 12:16:17 raph Exp $
 
   Driver for output on the Sun audio device (/dev/audio).
   Also works under NetBSD and OpenBSD
diff -urN libmikmod-3.1.11/drivers/drv_ultra.c libmikmod-3.1.12/drivers/drv_ultra.c
--- libmikmod-3.1.11/drivers/drv_ultra.c	2004-01-21 17:43:52.000000000 +0000
+++ libmikmod-3.1.12/drivers/drv_ultra.c	2007-12-15 09:24:10.000000000 +0000
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: drv_ultra.c,v 1.1.1.1 2004/01/21 01:36:35 raph Exp $
+  $Id: drv_ultra.c,v 1.1.1.1 2004/06/01 12:16:17 raph Exp $
 
   Driver for the Linux Ultrasound driver
 
diff -urN libmikmod-3.1.11/drivers/drv_wav.c libmikmod-3.1.12/drivers/drv_wav.c
--- libmikmod-3.1.11/drivers/drv_wav.c	2004-01-21 17:43:52.000000000 +0000
+++ libmikmod-3.1.12/drivers/drv_wav.c	2007-12-15 09:24:13.000000000 +0000
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: drv_wav.c,v 1.1.1.1 2004/01/21 01:36:35 raph Exp $
+  $Id: drv_wav.c,v 1.1.1.1 2004/06/01 12:16:17 raph Exp $
 
   Driver for output to a file called MUSIC.WAV
 
diff -urN libmikmod-3.1.11/drivers/drv_win.c libmikmod-3.1.12/drivers/drv_win.c
--- libmikmod-3.1.11/drivers/drv_win.c	2004-01-21 17:43:52.000000000 +0000
+++ libmikmod-3.1.12/drivers/drv_win.c	2007-12-15 09:24:16.000000000 +0000
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: drv_win.c,v 1.1.1.1 2004/01/21 01:36:35 raph Exp $
+  $Id: drv_win.c,v 1.1.1.1 2004/06/01 12:16:17 raph Exp $
 
   Driver for output on win32 platforms using the multimedia API
 
diff -urN libmikmod-3.1.11/include/mikmod.h.in libmikmod-3.1.12/include/mikmod.h.in
--- libmikmod-3.1.11/include/mikmod.h.in	2004-01-21 17:43:53.000000000 +0000
+++ libmikmod-3.1.12/include/mikmod.h.in	2009-10-05 07:36:00.000000000 +0000
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: mikmod.h.in,v 1.1.1.1 2004/01/21 01:36:35 raph Exp $
+  $Id: mikmod.h.in,v 1.2 2004/06/01 16:43:45 raph Exp $
 
   MikMod sound library include file
 
@@ -85,7 +85,7 @@
 
 @DOES_NOT_HAVE_SIGNED@
 
-#if defined(__arch64__) || defined(__alpha)
+#if defined(__arch64__) || defined(__alpha) || defined(__x86_64) || defined(_LP64)
 /* 64 bit architectures */
 
 typedef signed char     SBYTE;      /* 1 byte, signed */
diff -urN libmikmod-3.1.11/include/mikmod_internals.h libmikmod-3.1.12/include/mikmod_internals.h
--- libmikmod-3.1.11/include/mikmod_internals.h	2004-01-21 17:43:53.000000000 +0000
+++ libmikmod-3.1.12/include/mikmod_internals.h	2009-10-05 07:36:00.000000000 +0000
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: mikmod_internals.h,v 1.1.1.1 2004/01/21 01:36:35 raph Exp $
+  $Id: mikmod_internals.h,v 1.1.1.2 2007/12/15 15:24:17 denis111 Exp $
 
   MikMod sound library internal definitions
 
@@ -50,7 +50,7 @@
 /*========== More type definitions */
 
 /* SLONGLONG: 64bit, signed */
-#if defined (__arch64__) || defined(__alpha)
+#if defined(__arch64__) || defined(__alpha) || defined(__x86_64) || defined(_LP64)
 typedef long		SLONGLONG;
 #define NATIVE_64BIT_INT
 #elif defined(__WATCOMC__)
@@ -557,7 +557,7 @@
 extern SBYTE   remap[UF_MAXCHAN];   /* for removing empty channels */
 extern UBYTE*  poslookup;           /* lookup table for pattern jumps after
                                       blank pattern removal */
-extern UBYTE   poslookupcnt;
+extern UWORD   poslookupcnt;
 extern UWORD*  origpositions;
 
 extern BOOL    filters;             /* resonant filters in use */
diff -urN libmikmod-3.1.11/libmikmod.m4 libmikmod-3.1.12/libmikmod.m4
--- libmikmod-3.1.11/libmikmod.m4	2004-01-21 17:43:53.000000000 +0000
+++ libmikmod-3.1.12/libmikmod.m4	2007-12-15 09:24:31.000000000 +0000
@@ -8,7 +8,7 @@
 dnl Test for libmikmod, and define LIBMIKMOD_CFLAGS, LIBMIKMOD_LIBS and
 dnl LIBMIKMOD_LDADD
 dnl
-AC_DEFUN(AM_PATH_LIBMIKMOD,
+AC_DEFUN([AM_PATH_LIBMIKMOD],
 [dnl 
 dnl Get the cflags and libraries from the libmikmod-config script
 dnl
diff -urN libmikmod-3.1.11/loaders/load_669.c libmikmod-3.1.12/loaders/load_669.c
--- libmikmod-3.1.11/loaders/load_669.c	2004-01-21 17:43:53.000000000 +0000
+++ libmikmod-3.1.12/loaders/load_669.c	2007-12-15 09:24:34.000000000 +0000
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: load_669.c,v 1.1.1.1 2004/01/21 01:36:35 raph Exp $
+  $Id: load_669.c,v 1.1.1.1 2004/06/01 12:16:17 raph Exp $
 
   Composer 669 module loader
 
diff -urN libmikmod-3.1.11/loaders/load_amf.c libmikmod-3.1.12/loaders/load_amf.c
--- libmikmod-3.1.11/loaders/load_amf.c	2004-01-21 17:43:53.000000000 +0000
+++ libmikmod-3.1.12/loaders/load_amf.c	2007-12-15 09:24:37.000000000 +0000
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: load_amf.c,v 1.1.1.1 2004/01/21 01:36:35 raph Exp $
+  $Id: load_amf.c,v 1.1.1.1 2004/06/01 12:16:17 raph Exp $
 
   DMP Advanced Module Format loader
 
diff -urN libmikmod-3.1.11/loaders/load_dsm.c libmikmod-3.1.12/loaders/load_dsm.c
--- libmikmod-3.1.11/loaders/load_dsm.c	2004-01-21 17:43:53.000000000 +0000
+++ libmikmod-3.1.12/loaders/load_dsm.c	2007-12-15 09:24:39.000000000 +0000
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: load_dsm.c,v 1.1.1.1 2004/01/21 01:36:35 raph Exp $
+  $Id: load_dsm.c,v 1.1.1.1 2004/06/01 12:16:17 raph Exp $
 
   DSIK internal format (DSM) module loader
 
diff -urN libmikmod-3.1.11/loaders/load_far.c libmikmod-3.1.12/loaders/load_far.c
--- libmikmod-3.1.11/loaders/load_far.c	2004-01-21 17:43:53.000000000 +0000
+++ libmikmod-3.1.12/loaders/load_far.c	2007-12-15 09:24:42.000000000 +0000
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: load_far.c,v 1.1.1.1 2004/01/21 01:36:35 raph Exp $
+  $Id: load_far.c,v 1.1.1.1 2004/06/01 12:16:17 raph Exp $
 
   Farandole (FAR) module loader
 
diff -urN libmikmod-3.1.11/loaders/load_gdm.c libmikmod-3.1.12/loaders/load_gdm.c
--- libmikmod-3.1.11/loaders/load_gdm.c	2004-01-21 17:43:53.000000000 +0000
+++ libmikmod-3.1.12/loaders/load_gdm.c	2007-12-15 09:24:45.000000000 +0000
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: load_gdm.c,v 1.1.1.1 2004/01/21 01:36:35 raph Exp $
+  $Id: load_gdm.c,v 1.1.1.1 2004/06/01 12:16:17 raph Exp $
 
   General DigiMusic (GDM) module loader
 
diff -urN libmikmod-3.1.11/loaders/load_imf.c libmikmod-3.1.12/loaders/load_imf.c
--- libmikmod-3.1.11/loaders/load_imf.c	2004-01-21 17:43:53.000000000 +0000
+++ libmikmod-3.1.12/loaders/load_imf.c	2007-12-15 09:24:48.000000000 +0000
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: load_imf.c,v 1.1.1.1 2004/01/21 01:36:35 raph Exp $
+  $Id: load_imf.c,v 1.1.1.1 2004/06/01 12:16:17 raph Exp $
 
   Imago Orpheus (IMF) module loader
 
diff -urN libmikmod-3.1.11/loaders/load_it.c libmikmod-3.1.12/loaders/load_it.c
--- libmikmod-3.1.11/loaders/load_it.c	2004-01-21 17:43:52.000000000 +0000
+++ libmikmod-3.1.12/loaders/load_it.c	2007-12-15 09:24:51.000000000 +0000
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: load_it.c,v 1.1.1.1 2004/01/21 01:36:35 raph Exp $
+  $Id: load_it.c,v 1.1.1.1 2004/06/01 12:16:17 raph Exp $
 
   Impulse tracker (IT) module loader
 
diff -urN libmikmod-3.1.11/loaders/load_m15.c libmikmod-3.1.12/loaders/load_m15.c
--- libmikmod-3.1.11/loaders/load_m15.c	2004-01-21 17:43:53.000000000 +0000
+++ libmikmod-3.1.12/loaders/load_m15.c	2007-12-15 09:24:55.000000000 +0000
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: load_m15.c,v 1.1.1.1 2004/01/21 01:36:35 raph Exp $
+  $Id: load_m15.c,v 1.1.1.1 2004/06/01 12:16:17 raph Exp $
 
   15 instrument MOD loader
   Also supports Ultimate Sound Tracker (old M15 format)
diff -urN libmikmod-3.1.11/loaders/load_med.c libmikmod-3.1.12/loaders/load_med.c
--- libmikmod-3.1.11/loaders/load_med.c	2004-01-21 17:43:53.000000000 +0000
+++ libmikmod-3.1.12/loaders/load_med.c	2007-12-15 09:24:58.000000000 +0000
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: load_med.c,v 1.1.1.1 2004/01/21 01:36:35 raph Exp $
+  $Id: load_med.c,v 1.1.1.1 2004/06/01 12:16:17 raph Exp $
 
   Amiga MED module loader
 
diff -urN libmikmod-3.1.11/loaders/load_mod.c libmikmod-3.1.12/loaders/load_mod.c
--- libmikmod-3.1.11/loaders/load_mod.c	2004-01-21 17:43:53.000000000 +0000
+++ libmikmod-3.1.12/loaders/load_mod.c	2007-12-15 09:25:01.000000000 +0000
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: load_mod.c,v 1.2 2004/01/21 13:33:11 raph Exp $
+  $Id: load_mod.c,v 1.1.1.1 2004/06/01 12:16:17 raph Exp $
 
   Generic MOD loader (Protracker, StarTracker, FastTracker, etc)
 
diff -urN libmikmod-3.1.11/loaders/load_mtm.c libmikmod-3.1.12/loaders/load_mtm.c
--- libmikmod-3.1.11/loaders/load_mtm.c	2004-01-21 17:43:53.000000000 +0000
+++ libmikmod-3.1.12/loaders/load_mtm.c	2007-12-15 09:25:04.000000000 +0000
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: load_mtm.c,v 1.1.1.1 2004/01/21 01:36:35 raph Exp $
+  $Id: load_mtm.c,v 1.1.1.1 2004/06/01 12:16:17 raph Exp $
 
   MTM module loader
 
diff -urN libmikmod-3.1.11/loaders/load_okt.c libmikmod-3.1.12/loaders/load_okt.c
--- libmikmod-3.1.11/loaders/load_okt.c	2004-01-21 17:43:53.000000000 +0000
+++ libmikmod-3.1.12/loaders/load_okt.c	2007-12-15 09:25:07.000000000 +0000
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: load_okt.c,v 1.1.1.1 2004/01/21 01:36:35 raph Exp $
+  $Id: load_okt.c,v 1.1.1.1 2004/06/01 12:16:17 raph Exp $
 
   Oktalyzer (OKT) module loader
 
diff -urN libmikmod-3.1.11/loaders/load_s3m.c libmikmod-3.1.12/loaders/load_s3m.c
--- libmikmod-3.1.11/loaders/load_s3m.c	2004-01-21 17:43:53.000000000 +0000
+++ libmikmod-3.1.12/loaders/load_s3m.c	2007-12-15 09:25:10.000000000 +0000
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: load_s3m.c,v 1.1.1.1 2004/01/21 01:36:35 raph Exp $
+  $Id: load_s3m.c,v 1.1.1.1 2004/06/01 12:16:17 raph Exp $
 
   Screamtracker (S3M) module loader
 
diff -urN libmikmod-3.1.11/loaders/load_stm.c libmikmod-3.1.12/loaders/load_stm.c
--- libmikmod-3.1.11/loaders/load_stm.c	2004-01-21 17:43:53.000000000 +0000
+++ libmikmod-3.1.12/loaders/load_stm.c	2007-12-15 09:25:13.000000000 +0000
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: load_stm.c,v 1.1.1.1 2004/01/21 01:36:35 raph Exp $
+  $Id: load_stm.c,v 1.1.1.1 2004/06/01 12:16:17 raph Exp $
 
   Screamtracker 2 (STM) module loader
 
diff -urN libmikmod-3.1.11/loaders/load_stx.c libmikmod-3.1.12/loaders/load_stx.c
--- libmikmod-3.1.11/loaders/load_stx.c	2004-01-21 17:43:53.000000000 +0000
+++ libmikmod-3.1.12/loaders/load_stx.c	2007-12-15 09:25:16.000000000 +0000
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: load_stx.c,v 1.1.1.1 2004/01/21 01:36:35 raph Exp $
+  $Id: load_stx.c,v 1.1.1.1 2004/06/01 12:16:17 raph Exp $
 
   STMIK 0.2 (STX) module loader
 
diff -urN libmikmod-3.1.11/loaders/load_ult.c libmikmod-3.1.12/loaders/load_ult.c
--- libmikmod-3.1.11/loaders/load_ult.c	2004-01-21 17:43:53.000000000 +0000
+++ libmikmod-3.1.12/loaders/load_ult.c	2007-12-15 09:25:19.000000000 +0000
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: load_ult.c,v 1.1.1.1 2004/01/21 01:36:35 raph Exp $
+  $Id: load_ult.c,v 1.1.1.1 2004/06/01 12:16:17 raph Exp $
 
   Ultratracker (ULT) module loader
 
diff -urN libmikmod-3.1.11/loaders/load_uni.c libmikmod-3.1.12/loaders/load_uni.c
--- libmikmod-3.1.11/loaders/load_uni.c	2004-01-21 17:43:53.000000000 +0000
+++ libmikmod-3.1.12/loaders/load_uni.c	2007-12-15 09:25:25.000000000 +0000
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: load_uni.c,v 1.1.1.1 2004/01/21 01:36:35 raph Exp $
+  $Id: load_uni.c,v 1.1.1.1 2004/06/01 12:16:17 raph Exp $
 
   UNIMOD (libmikmod's and APlayer's internal module format) loader
 
diff -urN libmikmod-3.1.11/loaders/load_xm.c libmikmod-3.1.12/loaders/load_xm.c
--- libmikmod-3.1.11/loaders/load_xm.c	2004-01-21 17:43:53.000000000 +0000
+++ libmikmod-3.1.12/loaders/load_xm.c	2009-10-10 11:12:06.000000000 +0000
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: load_xm.c,v 1.1.1.1 2004/01/21 01:36:35 raph Exp $
+  $Id: load_xm.c,v 1.1.1.2 2007/12/15 15:24:17 denis111 Exp $
 
   Fasttracker (XM) module loader
 
@@ -443,7 +443,7 @@
 
 static BOOL LoadInstruments(void)
 {
-	int t,u;
+	int t,u, ck;
 	INSTRUMENT *d;
 	ULONG next=0;
 	UWORD wavcnt=0;
@@ -460,6 +460,13 @@
 		headend     = _mm_ftell(modreader);
 		ih.size     = _mm_read_I_ULONG(modreader);
 		headend    += ih.size;
+		ck = _mm_ftell(modreader);
+		_mm_fseek(modreader,0,SEEK_END);
+		if ((headend<0) || (_mm_ftell(modreader)<headend) || (headend<ck)) {
+		_mm_fseek(modreader,ck,SEEK_SET);
+		break;
+		}
+		_mm_fseek(modreader,ck,SEEK_SET);
 		_mm_read_string(ih.name, 22, modreader);
 		ih.type     = _mm_read_UBYTE(modreader);
 		ih.numsmp   = _mm_read_I_UWORD(modreader);
@@ -493,7 +500,7 @@
 
 				/* read the remainder of the header
 				   (2 bytes for 1.03, 22 for 1.04) */
-				for(u=headend-_mm_ftell(modreader);u;u--) _mm_read_UBYTE(modreader);
+				if (headend>=_mm_ftell(modreader)) for(u=headend-_mm_ftell(modreader);u;u--) _mm_read_UBYTE(modreader);
 
 				/* we can't trust the envelope point count here, as some
 				   modules have incorrect values (K_OSPACE.XM reports 32 volume
@@ -620,9 +627,17 @@
 					of.numsmp+=ih.numsmp;
 			} else {
 				/* read the remainder of the header */
+				ck = _mm_ftell(modreader);
+				_mm_fseek(modreader,0,SEEK_END);
+				if ((headend<0) || (_mm_ftell(modreader)<headend) || (headend<ck)) {
+				_mm_fseek(modreader,ck,SEEK_SET);
+				break;
+				}
+				_mm_fseek(modreader,ck,SEEK_SET);
 				for(u=headend-_mm_ftell(modreader);u;u--) _mm_read_UBYTE(modreader);
 
-				if(_mm_eof(modreader)) {
+				/* last instrument is at the end of file in version 0x0104 */
+				if(_mm_eof(modreader) && (mh->version<0x0104 || t<of.numins-1)) {
 					free(nextwav);free(wh);
 					nextwav=NULL;wh=NULL;
 					_mm_errno = MMERR_LOADING_SAMPLEINFO;
diff -urN libmikmod-3.1.11/loaders/load_xm.c.orig libmikmod-3.1.12/loaders/load_xm.c.orig
--- libmikmod-3.1.11/loaders/load_xm.c.orig	1970-01-01 00:00:00.000000000 +0000
+++ libmikmod-3.1.12/loaders/load_xm.c.orig	2007-12-15 12:29:49.000000000 +0000
@@ -0,0 +1,829 @@
+/*	MikMod sound library
+	(c) 1998, 1999, 2000, 2001, 2002 Miodrag Vallat and others - see file
+	AUTHORS for complete list.
+
+	This library is free software; you can redistribute it and/or modify
+	it under the terms of the GNU Library General Public License as
+	published by the Free Software Foundation; either version 2 of
+	the License, or (at your option) any later version.
+ 
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU Library General Public License for more details.
+ 
+	You should have received a copy of the GNU Library General Public
+	License along with this library; if not, write to the Free Software
+	Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+	02111-1307, USA.
+*/
+
+/*==============================================================================
+
+  $Id: load_xm.c,v 1.1.1.2 2007/12/15 15:24:17 denis111 Exp $
+
+  Fasttracker (XM) module loader
+
+==============================================================================*/
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+
+#include <stdio.h>
+#ifdef HAVE_MEMORY_H
+#include <memory.h>
+#endif
+#include <string.h>
+
+#include "mikmod_internals.h"
+
+#ifdef SUNOS
+extern int fprintf(FILE *, const char *, ...);
+#endif
+
+/*========== Module structure */
+
+typedef struct XMHEADER {
+	CHAR  id[17];          /* ID text: 'Extended module: ' */
+	CHAR  songname[21];    /* Module name */
+	CHAR  trackername[20]; /* Tracker name */
+	UWORD version;         /* Version number */
+	ULONG headersize;      /* Header size */
+	UWORD songlength;      /* Song length (in patten order table) */
+	UWORD restart;         /* Restart position */
+	UWORD numchn;          /* Number of channels (2,4,6,8,10,...,32) */
+	UWORD numpat;          /* Number of patterns (max 256) */
+	UWORD numins;          /* Number of instruments (max 128) */
+	UWORD flags;       
+	UWORD tempo;           /* Default tempo */
+	UWORD bpm;             /* Default BPM */
+	UBYTE orders[256];     /* Pattern order table  */
+} XMHEADER;
+
+typedef struct XMINSTHEADER {
+	ULONG size;     /* Instrument size */
+	CHAR  name[22]; /* Instrument name */
+	UBYTE type;     /* Instrument type (always 0) */
+	UWORD numsmp;   /* Number of samples in instrument */
+	ULONG ssize;
+} XMINSTHEADER;
+
+#define XMENVCNT (12*2)
+#define XMNOTECNT (8*OCTAVE)
+typedef struct XMPATCHHEADER {
+	UBYTE what[XMNOTECNT];  /*  Sample number for all notes */
+	UWORD volenv[XMENVCNT]; /*  Points for volume envelope */
+	UWORD panenv[XMENVCNT]; /*  Points for panning envelope */
+	UBYTE volpts;      /*  Number of volume points */
+	UBYTE panpts;      /*  Number of panning points */
+	UBYTE volsus;      /*  Volume sustain point */
+	UBYTE volbeg;      /*  Volume loop start point */
+	UBYTE volend;      /*  Volume loop end point */
+	UBYTE pansus;      /*  Panning sustain point */
+	UBYTE panbeg;      /*  Panning loop start point */
+	UBYTE panend;      /*  Panning loop end point */
+	UBYTE volflg;      /*  Volume type: bit 0: On; 1: Sustain; 2: Loop */
+	UBYTE panflg;      /*  Panning type: bit 0: On; 1: Sustain; 2: Loop */
+	UBYTE vibflg;      /*  Vibrato type */
+	UBYTE vibsweep;    /*  Vibrato sweep */
+	UBYTE vibdepth;    /*  Vibrato depth */
+	UBYTE vibrate;     /*  Vibrato rate */
+	UWORD volfade;     /*  Volume fadeout */
+} XMPATCHHEADER;
+
+typedef struct XMWAVHEADER {
+	ULONG length;         /* Sample length */
+	ULONG loopstart;      /* Sample loop start */
+	ULONG looplength;     /* Sample loop length */
+	UBYTE volume;         /* Volume  */
+	SBYTE finetune;       /* Finetune (signed byte -128..+127) */
+	UBYTE type;           /* Loop type */
+	UBYTE panning;        /* Panning (0-255) */
+	SBYTE relnote;        /* Relative note number (signed byte) */
+	UBYTE reserved;
+	CHAR  samplename[22]; /* Sample name */
+	UBYTE vibtype;        /* Vibrato type */
+	UBYTE vibsweep;       /* Vibrato sweep */
+	UBYTE vibdepth;       /* Vibrato depth */
+	UBYTE vibrate;        /* Vibrato rate */
+} XMWAVHEADER;
+
+typedef struct XMPATHEADER {
+	ULONG size;     /* Pattern header length  */
+	UBYTE packing;  /* Packing type (always 0) */
+	UWORD numrows;  /* Number of rows in pattern (1..256) */
+	SWORD packsize; /* Packed patterndata size */
+} XMPATHEADER;
+
+typedef struct XMNOTE {
+	UBYTE note,ins,vol,eff,dat;
+} XMNOTE;
+
+/*========== Loader variables */
+
+static	XMNOTE *xmpat=NULL;
+static	XMHEADER *mh=NULL;
+
+/* increment unit for sample array reallocation */
+#define XM_SMPINCR 64
+static	ULONG *nextwav=NULL;
+static	XMWAVHEADER *wh=NULL,*s=NULL;
+
+/*========== Loader code */
+
+BOOL XM_Test(void)
+{
+	UBYTE id[38];
+
+	if(!_mm_read_UBYTES(id,38,modreader)) return 0;
+	if(memcmp(id,"Extended Module: ",17)) return 0;
+	if(id[37]==0x1a) return 1;
+	return 0;
+}
+
+BOOL XM_Init(void)
+{
+	if(!(mh=(XMHEADER *)_mm_malloc(sizeof(XMHEADER)))) return 0;
+	return 1;
+}
+
+void XM_Cleanup(void)
+{
+	_mm_free(mh);
+}
+
+static int XM_ReadNote(XMNOTE* n)
+{
+	UBYTE cmp,result=1;
+
+	memset(n,0,sizeof(XMNOTE));
+	cmp=_mm_read_UBYTE(modreader);
+
+	if(cmp&0x80) {
+		if(cmp&1)  { result++;n->note = _mm_read_UBYTE(modreader); }
+		if(cmp&2)  { result++;n->ins  = _mm_read_UBYTE(modreader); }
+		if(cmp&4)  { result++;n->vol  = _mm_read_UBYTE(modreader); }
+		if(cmp&8)  { result++;n->eff  = _mm_read_UBYTE(modreader); }
+		if(cmp&16) { result++;n->dat  = _mm_read_UBYTE(modreader); }
+	} else {
+		n->note = cmp;
+		n->ins  = _mm_read_UBYTE(modreader);
+		n->vol  = _mm_read_UBYTE(modreader);
+		n->eff  = _mm_read_UBYTE(modreader);
+		n->dat  = _mm_read_UBYTE(modreader);
+		result += 4;
+	}
+	return result;
+}
+
+static UBYTE* XM_Convert(XMNOTE* xmtrack,UWORD rows)
+{
+	int t;
+	UBYTE note,ins,vol,eff,dat;
+
+	UniReset();
+	for(t=0;t<rows;t++) {
+		note = xmtrack->note;
+		ins  = xmtrack->ins;
+		vol  = xmtrack->vol;
+		eff  = xmtrack->eff;
+		dat  = xmtrack->dat;
+
+		if(note) {
+			if(note>XMNOTECNT)
+				UniEffect(UNI_KEYFADE,0);
+			else
+				UniNote(note-1);
+		}
+		if(ins) UniInstrument(ins-1);
+
+		switch(vol>>4) {
+			case 0x6: /* volslide down */
+				if(vol&0xf) UniEffect(UNI_XMEFFECTA,vol&0xf);
+				break;
+			case 0x7: /* volslide up */
+				if(vol&0xf) UniEffect(UNI_XMEFFECTA,vol<<4);
+				break;
+
+				/* volume-row fine volume slide is compatible with protracker
+				   EBx and EAx effects i.e. a zero nibble means DO NOT SLIDE, as
+				   opposed to 'take the last sliding value'. */
+			case 0x8: /* finevol down */
+				UniPTEffect(0xe,0xb0|(vol&0xf));
+				break;
+			case 0x9: /* finevol up */
+				UniPTEffect(0xe,0xa0|(vol&0xf));
+				break;
+			case 0xa: /* set vibrato speed */
+				UniEffect(UNI_XMEFFECT4,vol<<4);
+				break;
+			case 0xb: /* vibrato */
+				UniEffect(UNI_XMEFFECT4,vol&0xf);
+				break;
+			case 0xc: /* set panning */
+				UniPTEffect(0x8,vol<<4);
+				break;
+			case 0xd: /* panning slide left (only slide when data not zero) */
+				if(vol&0xf) UniEffect(UNI_XMEFFECTP,vol&0xf);
+				break;
+			case 0xe: /* panning slide right (only slide when data not zero) */
+				if(vol&0xf) UniEffect(UNI_XMEFFECTP,vol<<4);
+				break;
+			case 0xf: /* tone porta */
+				UniPTEffect(0x3,vol<<4);
+				break;
+			default:
+				if((vol>=0x10)&&(vol<=0x50))
+					UniPTEffect(0xc,vol-0x10);
+		}
+
+		switch(eff) {
+			case 0x4:
+				UniEffect(UNI_XMEFFECT4,dat);
+				break;
+			case 0x6:
+				UniEffect(UNI_XMEFFECT6,dat);
+				break;
+			case 0xa:
+				UniEffect(UNI_XMEFFECTA,dat);
+				break;
+			case 0xe: /* Extended effects */
+				switch(dat>>4) {
+					case 0x1: /* XM fine porta up */
+						UniEffect(UNI_XMEFFECTE1,dat&0xf);
+						break;
+					case 0x2: /* XM fine porta down */
+						UniEffect(UNI_XMEFFECTE2,dat&0xf);
+						break;
+					case 0xa: /* XM fine volume up */
+						UniEffect(UNI_XMEFFECTEA,dat&0xf);
+						break;
+					case 0xb: /* XM fine volume down */
+						UniEffect(UNI_XMEFFECTEB,dat&0xf);
+						break;
+					default:
+						UniPTEffect(eff,dat);
+				}
+				break;
+			case 'G'-55: /* G - set global volume */
+				UniEffect(UNI_XMEFFECTG,dat>64?128:dat<<1);
+				break;
+			case 'H'-55: /* H - global volume slide */
+				UniEffect(UNI_XMEFFECTH,dat);
+				break;
+			case 'K'-55: /* K - keyOff and KeyFade */
+				UniEffect(UNI_KEYFADE,dat);
+				break;
+			case 'L'-55: /* L - set envelope position */
+				UniEffect(UNI_XMEFFECTL,dat);
+				break;
+			case 'P'-55: /* P - panning slide */
+				UniEffect(UNI_XMEFFECTP,dat);
+				break;
+			case 'R'-55: /* R - multi retrig note */
+				UniEffect(UNI_S3MEFFECTQ,dat);
+				break;
+			case 'T'-55: /* T - Tremor */
+				UniEffect(UNI_S3MEFFECTI,dat);
+				break;
+			case 'X'-55:
+				switch(dat>>4) {
+					case 1: /* X1 - Extra Fine Porta up */
+						UniEffect(UNI_XMEFFECTX1,dat&0xf);
+						break;
+					case 2: /* X2 - Extra Fine Porta down */
+						UniEffect(UNI_XMEFFECTX2,dat&0xf);
+						break;
+				}
+				break;
+			default:
+				if(eff<=0xf) {
+					/* the pattern jump destination is written in decimal,
+					   but it seems some poor tracker software writes them
+					   in hexadecimal... (sigh) */
+					if (eff==0xd)
+						/* don't change anything if we're sure it's in hexa */
+						if ((((dat&0xf0)>>4)<=9)&&((dat&0xf)<=9))
+							/* otherwise, convert from dec to hex */
+							dat=(((dat&0xf0)>>4)*10)+(dat&0xf);
+					UniPTEffect(eff,dat);
+				}
+				break;
+		}
+		UniNewline();
+		xmtrack++;
+	}
+	return UniDup();
+}
+
+static BOOL LoadPatterns(BOOL dummypat)
+{
+	int t,u,v,numtrk;
+
+	if(!AllocTracks()) return 0;
+	if(!AllocPatterns()) return 0;
+
+	numtrk=0;
+	for(t=0;t<mh->numpat;t++) {
+		XMPATHEADER ph;
+
+		ph.size     =_mm_read_I_ULONG(modreader);
+		if (ph.size<(mh->version==0x0102?8:9)) {
+			_mm_errno=MMERR_LOADING_PATTERN;
+			return 0;
+		}
+		ph.packing  =_mm_read_UBYTE(modreader);
+		if(ph.packing) {
+			_mm_errno=MMERR_LOADING_PATTERN;
+			return 0;
+		}
+		if(mh->version==0x0102)
+			ph.numrows  =_mm_read_UBYTE(modreader)+1;
+		else
+			ph.numrows  =_mm_read_I_UWORD(modreader);
+		ph.packsize =_mm_read_I_UWORD(modreader);
+
+		ph.size-=(mh->version==0x0102?8:9);
+		if(ph.size)
+			_mm_fseek(modreader,ph.size,SEEK_CUR);
+
+		of.pattrows[t]=ph.numrows;
+
+		if(ph.numrows) {
+			if(!(xmpat=(XMNOTE*)_mm_calloc(ph.numrows*of.numchn,sizeof(XMNOTE))))
+				return 0;
+
+			/* when packsize is 0, don't try to load a pattern.. it's empty. */
+			if(ph.packsize) 
+				for(u=0;u<ph.numrows;u++) 
+					for(v=0;v<of.numchn;v++) {
+						if(!ph.packsize) break;
+
+						ph.packsize-=XM_ReadNote(&xmpat[(v*ph.numrows)+u]);
+						if(ph.packsize<0) {
+							free(xmpat);xmpat=NULL;
+							_mm_errno=MMERR_LOADING_PATTERN;
+							return 0;
+						}
+					}
+
+			if(ph.packsize) {
+				_mm_fseek(modreader,ph.packsize,SEEK_CUR);
+			}
+
+			if(_mm_eof(modreader)) {
+				free(xmpat);xmpat=NULL;
+				_mm_errno=MMERR_LOADING_PATTERN;
+				return 0;
+			}
+
+			for(v=0;v<of.numchn;v++)
+				of.tracks[numtrk++]=XM_Convert(&xmpat[v*ph.numrows],ph.numrows);
+
+			free(xmpat);xmpat=NULL;
+		} else {
+			for(v=0;v<of.numchn;v++)
+				of.tracks[numtrk++]=XM_Convert(NULL,ph.numrows);
+		}
+	}
+
+	if(dummypat) {
+		of.pattrows[t]=64;
+		if(!(xmpat=(XMNOTE*)_mm_calloc(64*of.numchn,sizeof(XMNOTE)))) return 0;
+		for(v=0;v<of.numchn;v++)
+			of.tracks[numtrk++]=XM_Convert(&xmpat[v*64],64);
+		free(xmpat);xmpat=NULL;
+	}
+
+	return 1;
+}
+
+static void FixEnvelope(ENVPT *cur, int pts)
+{
+		int u, old, tmp;
+		ENVPT *prev;
+
+		/* Some broken XM editing program will only save the low byte
+		   of the position value. Try to compensate by adding the
+		   missing high byte. */
+
+		prev = cur++;
+		old = prev->pos;
+
+		for (u = 1; u < pts; u++, prev++, cur++) {
+			if (cur->pos < prev->pos) {
+				if (cur->pos < 0x100) {
+					if (cur->pos > old)	/* same hex century */
+							tmp = cur->pos + (prev->pos - old);
+					else
+							tmp = cur->pos | ((prev->pos + 0x100) & 0xff00);
+					old = cur->pos;
+					cur->pos = tmp;
+#ifdef MIKMOD_DEBUG
+					fprintf(stderr, "\rbroken envelope position(%d/%d), %d %d -> %d\n",
+					    u, pts, prev->pos, old, cur->pos);
+#endif
+				} else {
+#ifdef MIKMOD_DEBUG
+					/* different brokenness style... fix unknown */
+					fprintf(stderr, "\rbroken envelope position(%d/%d), %d %d\n",
+					    u, pts, old, cur->pos);
+#endif
+					old = cur->pos;
+				}
+			} else
+				old = cur->pos;
+		}
+}
+
+static BOOL LoadInstruments(void)
+{
+	int t,u, ck;
+	INSTRUMENT *d;
+	ULONG next=0;
+	UWORD wavcnt=0;
+
+	if(!AllocInstruments()) return 0;
+	d=of.instruments;
+	for(t=0;t<of.numins;t++,d++) {
+		XMINSTHEADER ih;
+		long headend;
+
+		memset(d->samplenumber,0xff,INSTNOTES*sizeof(UWORD));
+
+		/* read instrument header */
+		headend     = _mm_ftell(modreader);
+		ih.size     = _mm_read_I_ULONG(modreader);
+		headend    += ih.size;
+		ck = _mm_ftell(modreader);
+		_mm_fseek(modreader,0,SEEK_END);
+		if ((headend<0) || (_mm_ftell(modreader)<headend) || (headend<ck)) {
+		_mm_fseek(modreader,ck,SEEK_SET);
+		break;
+		}
+		_mm_fseek(modreader,ck,SEEK_SET);
+		_mm_read_string(ih.name, 22, modreader);
+		ih.type     = _mm_read_UBYTE(modreader);
+		ih.numsmp   = _mm_read_I_UWORD(modreader);
+
+		d->insname  = DupStr(ih.name,22,1);
+
+		if((SWORD)ih.size>29) {
+			ih.ssize    = _mm_read_I_ULONG(modreader);
+			if(((SWORD)ih.numsmp>0)&&(ih.numsmp<=XMNOTECNT)) {
+				XMPATCHHEADER pth;
+				int p;
+
+				_mm_read_UBYTES (pth.what,XMNOTECNT,modreader);
+				_mm_read_I_UWORDS (pth.volenv, XMENVCNT, modreader);
+				_mm_read_I_UWORDS (pth.panenv, XMENVCNT, modreader);
+				pth.volpts      =  _mm_read_UBYTE(modreader);
+				pth.panpts      =  _mm_read_UBYTE(modreader);
+				pth.volsus      =  _mm_read_UBYTE(modreader);
+				pth.volbeg      =  _mm_read_UBYTE(modreader);
+				pth.volend      =  _mm_read_UBYTE(modreader);
+				pth.pansus      =  _mm_read_UBYTE(modreader);
+				pth.panbeg      =  _mm_read_UBYTE(modreader);
+				pth.panend      =  _mm_read_UBYTE(modreader);
+				pth.volflg      =  _mm_read_UBYTE(modreader);
+				pth.panflg      =  _mm_read_UBYTE(modreader);
+				pth.vibflg      =  _mm_read_UBYTE(modreader);
+				pth.vibsweep    =  _mm_read_UBYTE(modreader);
+				pth.vibdepth    =  _mm_read_UBYTE(modreader);
+				pth.vibrate     =  _mm_read_UBYTE(modreader);
+				pth.volfade     =  _mm_read_I_UWORD(modreader);
+
+				/* read the remainder of the header
+				   (2 bytes for 1.03, 22 for 1.04) */
+				if (headend>=_mm_ftell(modreader)) for(u=headend-_mm_ftell(modreader);u;u--) _mm_read_UBYTE(modreader);
+
+				/* we can't trust the envelope point count here, as some
+				   modules have incorrect values (K_OSPACE.XM reports 32 volume
+				   points, for example). */
+				if(pth.volpts>XMENVCNT/2) pth.volpts=XMENVCNT/2;
+				if(pth.panpts>XMENVCNT/2) pth.panpts=XMENVCNT/2;
+
+				if((_mm_eof(modreader))||(pth.volpts>XMENVCNT/2)||(pth.panpts>XMENVCNT/2)) {
+					if(nextwav) { free(nextwav);nextwav=NULL; }
+					if(wh) { free(wh);wh=NULL; }
+					_mm_errno = MMERR_LOADING_SAMPLEINFO;
+					return 0;
+				}
+
+				for(u=0;u<XMNOTECNT;u++)
+					d->samplenumber[u]=pth.what[u]+of.numsmp;
+				d->volfade = pth.volfade;
+
+#if defined __STDC__ || defined _MSC_VER
+#define XM_ProcessEnvelope(name) 										\
+				for (u = 0; u < (XMENVCNT >> 1); u++) {					\
+					d-> name##env[u].pos = pth. name##env[u << 1];		\
+					d-> name##env[u].val = pth. name##env[(u << 1)+ 1];	\
+				}														\
+				if (pth. name##flg&1) d-> name##flg|=EF_ON;				\
+				if (pth. name##flg&2) d-> name##flg|=EF_SUSTAIN;		\
+				if (pth. name##flg&4) d-> name##flg|=EF_LOOP;			\
+				d-> name##susbeg=d-> name##susend=pth. name##sus;		\
+				d-> name##beg=pth. name##beg;							\
+				d-> name##end=pth. name##end;							\
+				d-> name##pts=pth. name##pts;							\
+																		\
+				/* scale envelope */									\
+				for (p=0;p<XMENVCNT/2;p++)								\
+					d-> name##env[p].val<<=2;							\
+																		\
+				if ((d-> name##flg&EF_ON)&&(d-> name##pts<2))			\
+					d-> name##flg&=~EF_ON
+#else
+#define XM_ProcessEnvelope(name) 											\
+				for (u = 0; u < (XMENVCNT >> 1); u++) {						\
+					d-> name/**/env[u].pos = pth. name/**/env[u << 1];		\
+					d-> name/**/env[u].val = pth. name/**/env[(u << 1)+ 1];	\
+				}															\
+				if (pth. name/**/flg&1) d-> name/**/flg|=EF_ON;				\
+				if (pth. name/**/flg&2) d-> name/**/flg|=EF_SUSTAIN;		\
+				if (pth. name/**/flg&4) d-> name/**/flg|=EF_LOOP;			\
+				d-> name/**/susbeg=d-> name/**/susend=						\
+				                      pth. name/**/sus;						\
+				d-> name/**/beg=pth. name/**/beg;							\
+				d-> name/**/end=pth. name/**/end;							\
+				d-> name/**/pts=pth. name/**/pts;							\
+																			\
+				/* scale envelope */										\
+				for (p=0;p<XMENVCNT/2;p++)									\
+					d-> name/**/env[p].val<<=2;								\
+																			\
+				if ((d-> name/**/flg&EF_ON)&&(d-> name/**/pts<2))			\
+					d-> name/**/flg&=~EF_ON
+#endif			
+
+				XM_ProcessEnvelope(vol);
+				XM_ProcessEnvelope(pan);
+#undef XM_ProcessEnvelope
+
+				if (d->volflg & EF_ON)
+					FixEnvelope(d->volenv, d->volpts);
+				if (d->panflg & EF_ON)
+					FixEnvelope(d->panenv, d->panpts);
+
+				/* Samples are stored outside the instrument struct now, so we
+				   have to load them all into a temp area, count the of.numsmp
+				   along the way and then do an AllocSamples() and move
+				   everything over */
+				if(mh->version>0x0103) next = 0;
+				for(u=0;u<ih.numsmp;u++,s++) {
+					/* Allocate more room for sample information if necessary */
+					if(of.numsmp+u==wavcnt) {
+						wavcnt+=XM_SMPINCR;
+						if(!(nextwav=realloc(nextwav,wavcnt*sizeof(ULONG)))){
+							if(wh) { free(wh);wh=NULL; }
+							_mm_errno = MMERR_OUT_OF_MEMORY;
+							return 0;
+						}
+						if(!(wh=realloc(wh,wavcnt*sizeof(XMWAVHEADER)))) {
+							free(nextwav);nextwav=NULL;
+							_mm_errno = MMERR_OUT_OF_MEMORY;
+							return 0;
+						}
+						s=wh+(wavcnt-XM_SMPINCR);
+					}
+
+					s->length       =_mm_read_I_ULONG (modreader);
+					s->loopstart    =_mm_read_I_ULONG (modreader);
+					s->looplength   =_mm_read_I_ULONG (modreader);
+					s->volume       =_mm_read_UBYTE (modreader);
+					s->finetune     =_mm_read_SBYTE (modreader);
+					s->type         =_mm_read_UBYTE (modreader);
+					s->panning      =_mm_read_UBYTE (modreader);
+					s->relnote      =_mm_read_SBYTE (modreader);
+					s->vibtype      = pth.vibflg;
+					s->vibsweep     = pth.vibsweep;
+					s->vibdepth     = pth.vibdepth*4;
+					s->vibrate      = pth.vibrate;
+					s->reserved     =_mm_read_UBYTE (modreader);
+					_mm_read_string(s->samplename, 22, modreader);
+
+					nextwav[of.numsmp+u]=next;
+					next+=s->length;
+
+					if(_mm_eof(modreader)) {
+						free(nextwav);free(wh);
+						nextwav=NULL;wh=NULL;
+						_mm_errno = MMERR_LOADING_SAMPLEINFO;
+						return 0;
+					}
+				}
+
+				if(mh->version>0x0103) {
+					for(u=0;u<ih.numsmp;u++)
+						nextwav[of.numsmp++]+=_mm_ftell(modreader);
+					_mm_fseek(modreader,next,SEEK_CUR);
+				} else
+					of.numsmp+=ih.numsmp;
+			} else {
+				/* read the remainder of the header */
+				ck = _mm_ftell(modreader);
+				_mm_fseek(modreader,0,SEEK_END);
+				if ((headend<0) || (_mm_ftell(modreader)<headend) || (headend<ck)) {
+				_mm_fseek(modreader,ck,SEEK_SET);
+				break;
+				}
+				_mm_fseek(modreader,ck,SEEK_SET);
+				for(u=headend-_mm_ftell(modreader);u;u--) _mm_read_UBYTE(modreader);
+
+				if(_mm_eof(modreader)) {
+					free(nextwav);free(wh);
+					nextwav=NULL;wh=NULL;
+					_mm_errno = MMERR_LOADING_SAMPLEINFO;
+					return 0;
+				}
+			}
+		}
+	}
+
+	/* sanity check */
+	if(!of.numsmp) {
+		if(nextwav) { free(nextwav);nextwav=NULL; }
+		if(wh) { free(wh);wh=NULL; }
+		_mm_errno = MMERR_LOADING_SAMPLEINFO;
+		return 0;
+	}
+
+	return 1;
+}
+
+BOOL XM_Load(BOOL curious)
+{
+	INSTRUMENT *d;
+	SAMPLE *q;
+	int t,u;
+	BOOL dummypat=0;
+	char tracker[21],modtype[60];
+
+	/* try to read module header */
+	_mm_read_string(mh->id,17,modreader);
+	_mm_read_string(mh->songname,21,modreader);
+	_mm_read_string(mh->trackername,20,modreader);
+	mh->version     =_mm_read_I_UWORD(modreader);
+	if((mh->version<0x102)||(mh->version>0x104)) {
+		_mm_errno=MMERR_NOT_A_MODULE;
+		return 0;
+	}
+	mh->headersize  =_mm_read_I_ULONG(modreader);
+	mh->songlength  =_mm_read_I_UWORD(modreader);
+	mh->restart     =_mm_read_I_UWORD(modreader);
+	mh->numchn      =_mm_read_I_UWORD(modreader);
+	mh->numpat      =_mm_read_I_UWORD(modreader);
+	mh->numins      =_mm_read_I_UWORD(modreader);
+	mh->flags       =_mm_read_I_UWORD(modreader);
+	mh->tempo       =_mm_read_I_UWORD(modreader);
+	mh->bpm         =_mm_read_I_UWORD(modreader);
+	if(!mh->bpm) {
+		_mm_errno=MMERR_NOT_A_MODULE;
+		return 0;
+	}
+	_mm_read_UBYTES(mh->orders,256,modreader);
+
+	if(_mm_eof(modreader)) {
+		_mm_errno = MMERR_LOADING_HEADER;
+		return 0;
+	}
+
+	/* set module variables */
+	of.initspeed = mh->tempo;         
+	of.inittempo = mh->bpm;
+	strncpy(tracker,mh->trackername,20);tracker[20]=0;
+	for(t=20;(tracker[t]<=' ')&&(t>=0);t--) tracker[t]=0;
+	
+	/* some modules have the tracker name empty */
+	if (!tracker[0])
+		strcpy(tracker,"Unknown tracker");
+
+#ifdef HAVE_SNPRINTF
+	snprintf(modtype,60,"%s (XM format %d.%02d)",
+	                    tracker,mh->version>>8,mh->version&0xff);
+#else
+	sprintf(modtype,"%s (XM format %d.%02d)",
+	                tracker,mh->version>>8,mh->version&0xff);
+#endif
+	of.modtype   = strdup(modtype);
+	of.numchn    = mh->numchn;
+	of.numpat    = mh->numpat;
+	of.numtrk    = (UWORD)of.numpat*of.numchn;   /* get number of channels */
+	of.songname  = DupStr(mh->songname,20,1);
+	of.numpos    = mh->songlength;               /* copy the songlength */
+	of.reppos    = mh->restart<mh->songlength?mh->restart:0;
+	of.numins    = mh->numins;
+	of.flags    |= UF_XMPERIODS | UF_INST | UF_NOWRAP | UF_FT2QUIRKS |
+				   UF_PANNING;
+	if(mh->flags&1) of.flags |= UF_LINEAR;
+	of.bpmlimit  = 32;
+
+	memset(of.chanvol,64,of.numchn);             /* store channel volumes */
+
+	if(!AllocPositions(of.numpos+1)) return 0;
+	for(t=0;t<of.numpos;t++)
+		of.positions[t]=mh->orders[t];
+
+	/* We have to check for any pattern numbers in the order list greater than
+	   the number of patterns total. If one or more is found, we set it equal to
+	   the pattern total and make a dummy pattern to workaround the problem */
+	for(t=0;t<of.numpos;t++) {
+		if(of.positions[t]>=of.numpat) {
+			of.positions[t]=of.numpat;
+			dummypat=1;
+		}
+	}
+	if(dummypat) {
+		of.numpat++;of.numtrk+=of.numchn;
+	}
+
+	if(mh->version<0x0104) {
+		if(!LoadInstruments()) return 0;
+		if(!LoadPatterns(dummypat)) return 0;
+		for(t=0;t<of.numsmp;t++)
+			nextwav[t]+=_mm_ftell(modreader);
+	} else {
+		if(!LoadPatterns(dummypat)) return 0;
+		if(!LoadInstruments()) return 0;
+	}
+
+	if(!AllocSamples()) {
+		free(nextwav);free(wh);
+		nextwav=NULL;wh=NULL;
+		return 0;
+	}
+	q = of.samples;
+	s = wh;
+	for(u=0;u<of.numsmp;u++,q++,s++) {
+		q->samplename   = DupStr(s->samplename,22,1);
+		q->length       = s->length;
+		q->loopstart    = s->loopstart;
+		q->loopend      = s->loopstart+s->looplength;
+		q->volume       = s->volume;
+		q->speed        = s->finetune+128;
+		q->panning      = s->panning;
+		q->seekpos      = nextwav[u];
+		q->vibtype      = s->vibtype;
+		q->vibsweep     = s->vibsweep;
+		q->vibdepth     = s->vibdepth;
+		q->vibrate      = s->vibrate;
+
+		if(s->type & 0x10) {
+			q->length    >>= 1;
+			q->loopstart >>= 1;
+			q->loopend   >>= 1;
+		}
+
+		q->flags|=SF_OWNPAN|SF_DELTA|SF_SIGNED;
+		if(s->type&0x3) q->flags|=SF_LOOP;
+		if(s->type&0x2) q->flags|=SF_BIDI;
+		if(s->type&0x10) q->flags|=SF_16BITS;
+	}
+
+	d=of.instruments;
+	s=wh;
+	for(u=0;u<of.numins;u++,d++)
+		for(t=0;t<XMNOTECNT;t++) {
+			if (d->samplenumber[t]>=of.numsmp)
+				d->samplenote[t]=255;
+			else {
+				int note=t+s[d->samplenumber[t]].relnote;
+				d->samplenote[t]=(note<0)?0:note;
+			}
+		}
+
+	free(wh);free(nextwav);
+	wh=NULL;nextwav=NULL;
+	return 1;
+}
+
+CHAR *XM_LoadTitle(void)
+{
+	CHAR s[21];
+
+	_mm_fseek(modreader,17,SEEK_SET);
+	if(!_mm_read_UBYTES(s,21,modreader)) return NULL;
+
+	return(DupStr(s,21,1));
+}
+
+/*========== Loader information */
+
+MIKMODAPI MLOADER load_xm={
+	NULL,
+	"XM",
+	"XM (FastTracker 2)",
+	XM_Init,
+	XM_Test,
+	XM_Load,
+	XM_Cleanup,
+	XM_LoadTitle
+};
+
+/* ex:set ts=4: */
diff -urN libmikmod-3.1.11/m4/esd.m4 libmikmod-3.1.12/m4/esd.m4
--- libmikmod-3.1.11/m4/esd.m4	1970-01-01 00:00:00.000000000 +0000
+++ libmikmod-3.1.12/m4/esd.m4	2009-10-20 03:59:17.000000000 +0000
@@ -0,0 +1,168 @@
+##############################################################################
+#
+# --- esd.m4 ---
+#
+# Configure paths for ESD
+# Manish Singh    98-9-30
+# stolen back from Frank Belew
+# stolen from Manish Singh
+# Shamelessly stolen from Owen Taylor
+
+dnl AM_PATH_ESD([MINIMUM-VERSION, [ACTION-IF-FOUND [, ACTION-IF-NOT-FOUND]]])
+dnl Test for ESD, and define ESD_CFLAGS and ESD_LIBS
+dnl
+AC_DEFUN([AM_PATH_ESD],
+[dnl 
+dnl Get the cflags and libraries from the esd-config script
+dnl
+AC_ARG_WITH(esd-prefix,[  --with-esd-prefix=PFX   Prefix where ESD is installed (optional)],
+            esd_prefix="$withval", esd_prefix="")
+AC_ARG_WITH(esd-exec-prefix,[  --with-esd-exec-prefix=PFX Exec prefix where ESD is installed (optional)],
+            esd_exec_prefix="$withval", esd_exec_prefix="")
+AC_ARG_ENABLE(esdtest, [  --disable-esdtest       Do not try to compile and run a test ESD program],
+		    , enable_esdtest=yes)
+
+  if test x$esd_exec_prefix != x ; then
+     esd_args="$esd_args --exec-prefix=$esd_exec_prefix"
+     if test x${ESD_CONFIG+set} != xset ; then
+        ESD_CONFIG=$esd_exec_prefix/bin/esd-config
+     fi
+  fi
+  if test x$esd_prefix != x ; then
+     esd_args="$esd_args --prefix=$esd_prefix"
+     if test x${ESD_CONFIG+set} != xset ; then
+        ESD_CONFIG=$esd_prefix/bin/esd-config
+     fi
+  fi
+
+  AC_PATH_PROG(ESD_CONFIG, esd-config, no)
+  min_esd_version=ifelse([$1], ,0.2.7,$1)
+  AC_MSG_CHECKING(for ESD - version >= $min_esd_version)
+  no_esd=""
+  if test "$ESD_CONFIG" = "no" ; then
+    no_esd=yes
+  else
+    ESD_CFLAGS=`$ESD_CONFIG $esdconf_args --cflags`
+    ESD_LIBS=`$ESD_CONFIG $esdconf_args --libs`
+
+    esd_major_version=`$ESD_CONFIG $esd_args --version | \
+           sed 's/\([[0-9]]*\).\([[0-9]]*\).\([[0-9]]*\)/\1/'`
+    esd_minor_version=`$ESD_CONFIG $esd_args --version | \
+           sed 's/\([[0-9]]*\).\([[0-9]]*\).\([[0-9]]*\)/\2/'`
+    esd_micro_version=`$ESD_CONFIG $esd_config_args --version | \
+           sed 's/\([[0-9]]*\).\([[0-9]]*\).\([[0-9]]*\)/\3/'`
+    if test "x$enable_esdtest" = "xyes" ; then
+      ac_save_CFLAGS="$CFLAGS"
+      ac_save_LIBS="$LIBS"
+      CFLAGS="$CFLAGS $ESD_CFLAGS"
+      LIBS="$LIBS $ESD_LIBS"
+dnl
+dnl Now check if the installed ESD is sufficiently new. (Also sanity
+dnl checks the results of esd-config to some extent
+dnl
+      rm -f conf.esdtest
+      AC_TRY_RUN([
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <esd.h>
+
+char*
+my_strdup (char *str)
+{
+  char *new_str;
+  
+  if (str)
+    {
+      new_str = malloc ((strlen (str) + 1) * sizeof(char));
+      strcpy (new_str, str);
+    }
+  else
+    new_str = NULL;
+  
+  return new_str;
+}
+
+int main ()
+{
+  int major, minor, micro;
+  char *tmp_version;
+
+  system ("touch conf.esdtest");
+
+  /* HP/UX 9 (%@#!) writes to sscanf strings */
+  tmp_version = my_strdup("$min_esd_version");
+  if (sscanf(tmp_version, "%d.%d.%d", &major, &minor, &micro) != 3) {
+     printf("%s, bad version string\n", "$min_esd_version");
+     exit(1);
+   }
+
+   if (($esd_major_version > major) ||
+      (($esd_major_version == major) && ($esd_minor_version > minor)) ||
+      (($esd_major_version == major) && ($esd_minor_version == minor) && ($esd_micro_version >= micro)))
+    {
+      return 0;
+    }
+  else
+    {
+      printf("\n*** 'esd-config --version' returned %d.%d.%d, but the minimum version\n", $esd_major_version, $esd_minor_version, $esd_micro_version);
+      printf("*** of ESD required is %d.%d.%d. If esd-config is correct, then it is\n", major, minor, micro);
+      printf("*** best to upgrade to the required version.\n");
+      printf("*** If esd-config was wrong, set the environment variable ESD_CONFIG\n");
+      printf("*** to point to the correct copy of esd-config, and remove the file\n");
+      printf("*** config.cache before re-running configure\n");
+      return 1;
+    }
+}
+
+],, no_esd=yes,[echo $ac_n "cross compiling; assumed OK... $ac_c"])
+       CFLAGS="$ac_save_CFLAGS"
+       LIBS="$ac_save_LIBS"
+     fi
+  fi
+  if test "x$no_esd" = x ; then
+     AC_MSG_RESULT(yes)
+     ifelse([$2], , :, [$2])     
+  else
+     AC_MSG_RESULT(no)
+     if test "$ESD_CONFIG" = "no" ; then
+       echo "*** The esd-config script installed by ESD could not be found"
+       echo "*** If ESD was installed in PREFIX, make sure PREFIX/bin is in"
+       echo "*** your path, or set the ESD_CONFIG environment variable to the"
+       echo "*** full path to esd-config."
+     else
+       if test -f conf.esdtest ; then
+        :
+       else
+          echo "*** Could not run ESD test program, checking why..."
+          CFLAGS="$CFLAGS $ESD_CFLAGS"
+          LIBS="$LIBS $ESD_LIBS"
+          AC_TRY_LINK([
+#include <stdio.h>
+#include <esd.h>
+],      [ return 0; ],
+        [ echo "*** The test program compiled, but did not run. This usually means"
+          echo "*** that the run-time linker is not finding ESD or finding the wrong"
+          echo "*** version of ESD. If it is not finding ESD, you'll need to set your"
+          echo "*** LD_LIBRARY_PATH environment variable, or edit /etc/ld.so.conf to point"
+          echo "*** to the installed location  Also, make sure you have run ldconfig if that"
+          echo "*** is required on your system"
+	  echo "***"
+          echo "*** If you have an old version installed, it is best to remove it, although"
+          echo "*** you may also be able to get things to work by modifying LD_LIBRARY_PATH"],
+        [ echo "*** The test program failed to compile or link. See the file config.log for the"
+          echo "*** exact error that occured. This usually means ESD was incorrectly installed"
+          echo "*** or that you have moved ESD since it was installed. In the latter case, you"
+          echo "*** may want to edit the esd-config script: $ESD_CONFIG" ])
+          CFLAGS="$ac_save_CFLAGS"
+          LIBS="$ac_save_LIBS"
+       fi
+     fi
+     ESD_CFLAGS=""
+     ESD_LIBS=""
+     ifelse([$3], , :, [$3])
+  fi
+  AC_SUBST(ESD_CFLAGS)
+  AC_SUBST(ESD_LIBS)
+  rm -f conf.esdtest
+])
diff -urN libmikmod-3.1.11/macintosh/mikmod.h libmikmod-3.1.12/macintosh/mikmod.h
--- libmikmod-3.1.11/macintosh/mikmod.h	2004-01-21 17:43:53.000000000 +0000
+++ libmikmod-3.1.12/macintosh/mikmod.h	2007-12-15 09:25:42.000000000 +0000
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: mikmod.h,v 1.1.1.1 2004/01/21 01:36:35 raph Exp $
+  $Id: mikmod.h,v 1.1.1.1 2004/06/01 12:16:18 raph Exp $
 
   MikMod sound library include file
 
Binary files libmikmod-3.1.11/macosx/.DS_Store and libmikmod-3.1.12/macosx/.DS_Store differ
diff -urN libmikmod-3.1.11/macosx/Cocoa Framework-Info.plist libmikmod-3.1.12/macosx/Cocoa Framework-Info.plist
--- libmikmod-3.1.11/macosx/Cocoa Framework-Info.plist	1970-01-01 00:00:00.000000000 +0000
+++ libmikmod-3.1.12/macosx/Cocoa Framework-Info.plist	2009-10-18 04:21:01.000000000 +0000
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
+<plist version="1.0">
+<dict>
+	<key>CFBundleDevelopmentRegion</key>
+	<string>English</string>
+	<key>CFBundleExecutable</key>
+	<string>${EXECUTABLE_NAME}</string>
+	<key>CFBundleGetInfoString</key>
+	<string>libmikmod 3.1.12</string>
+	<key>CFBundleInfoDictionaryVersion</key>
+	<string>6.0</string>
+	<key>CFBundleName</key>
+	<string>mikmod</string>
+	<key>CFBundlePackageType</key>
+	<string>FMWK</string>
+	<key>CFBundleShortVersionString</key>
+	<string>3.1.12</string>
+	<key>CFBundleSignature</key>
+	<string>????</string>
+	<key>CFBundleVersion</key>
+	<string>3.1.12</string>
+</dict>
+</plist>
Binary files libmikmod-3.1.11/macosx/English.lproj/InfoPlist.strings and libmikmod-3.1.12/macosx/English.lproj/InfoPlist.strings differ
diff -urN libmikmod-3.1.11/macosx/config.h libmikmod-3.1.12/macosx/config.h
--- libmikmod-3.1.11/macosx/config.h	1970-01-01 00:00:00.000000000 +0000
+++ libmikmod-3.1.12/macosx/config.h	2009-10-18 04:24:06.000000000 +0000
@@ -0,0 +1,152 @@
+/* config.h.  Generated automatically by configure.  */
+/* config.h.in.  Generated automatically from configure.in by autoheader.  */
+
+/* Define if on AIX 3.
+   System headers sometimes define this.
+   We just want to avoid a redefinition error message.  */
+#ifndef _ALL_SOURCE
+/* #undef _ALL_SOURCE */
+#endif
+
+/* Define to empty if the keyword does not work.  */
+/* #undef const */
+
+/* Define if you have <sys/wait.h> that is POSIX.1 compatible.  */
+#define HAVE_SYS_WAIT_H 1
+
+/* Define to `int' if <sys/types.h> doesn't define.  */
+/* #undef pid_t */
+
+/* Define to `unsigned' if <sys/types.h> doesn't define.  */
+/* #undef size_t */
+
+/* Define if you have the ANSI C header files.  */
+/* #undef STDC_HEADERS */
+
+/* Define if your system supports binary pipes (i.e. Unix) */
+/* #undef DRV_PIPE */
+
+/* Define if the AudioFile driver is compiled */
+/* #undef DRV_AF */
+/* Define if the AIX audio driver is compiled */
+/* #undef DRV_AIX */
+/* Define if the Linux ALSA driver is compiled */
+/* #undef DRV_ALSA */
+/* Define if the Enlightened Sound Daemon driver is compiled */
+/* #undef DRV_ESD */
+/* Define if the HP-UX audio driver is compiled */
+/* #undef DRV_HP */
+/* Define if the Open Sound System driver is compiled */
+/* #undef DRV_OSS */
+/* Define if the Linux SAM9407 driver is compiled */
+/* #undef DRV_SAM9407 */
+/* Define if the SGI audio driver is compiled */
+/* #undef DRV_SGI */
+/* Define if the Sun audio driver or compatible (NetBSD, OpenBSD)
+   is compiled */
+/* #undef DRV_SUN */
+/* Define if the Linux Ultra driver is compiled */
+/* #undef DRV_ULTRA */
+
+/* Define if you want a debug version of the library */
+/* #undef MIKMOD_DEBUG */
+/* Define if you want runtime dynamic linking of ALSA and EsounD drivers */
+#define MIKMOD_DYNAMIC 1
+/* Define if your system provides POSIX.4 threads */
+#define HAVE_PTHREAD 1
+
+/* Define if your system is SunOS 4.* */
+/* #undef SUNOS */
+/* Define if your system is AIX 3.* - might be needed for 4.* too */
+/* #undef AIX */
+/* Define if your system defines random(3) and srandom(3) in math.h instead
+   of stdlib.h */
+/* #undef SRANDOM_IN_MATH_H */
+/* Define if EsounD driver depends on ALSA */
+/* #undef MIKMOD_DYNAMIC_ESD_NEEDS_ALSA */
+/* Define if your system has RTLD_GLOBAL defined in <dlfcn.h> */
+#define HAVE_RTLD_GLOBAL 1
+/* Define if your system needs leading underscore to function names in dlsym() calls */
+/* #undef DLSYM_NEEDS_UNDERSCORE */
+
+/* Define if you have the setenv function.  */
+#define HAVE_SETENV 1
+
+/* Define if you have the snprintf function.  */
+#define HAVE_SNPRINTF 1
+
+/* Define if you have the srandom function.  */
+#define HAVE_SRANDOM 1
+
+/* Define if you have the strcasecmp function.  */
+#define HAVE_STRCASECMP 1
+
+/* Define if you have the strdup function.  */
+#define HAVE_STRDUP 1
+
+/* Define if you have the strstr function.  */
+#define HAVE_STRSTR 1
+
+/* Define if you have the <AF/AFlib.h> header file.  */
+/* #undef HAVE_AF_AFLIB_H */
+
+/* Define if you have the <dl.h> header file.  */
+/* #undef HAVE_DL_H */
+
+/* Define if you have the <dlfcn.h> header file.  */
+#define HAVE_DLFCN_H 1
+
+/* Define if you have the <dmedia/audio.h> header file.  */
+/* #undef HAVE_DMEDIA_AUDIO_H */
+
+/* Define if you have the <fcntl.h> header file.  */
+#define HAVE_FCNTL_H 1
+
+/* Define if you have the <libgus.h> header file.  */
+/* #undef HAVE_LIBGUS_H */
+
+/* Define if you have the <machine/soundcard.h> header file.  */
+/* #undef HAVE_MACHINE_SOUNDCARD_H */
+
+/* Define if you have the <malloc.h> header file.  */
+/* #undef HAVE_MALLOC_H */
+
+/* Define if you have the <memory.h> header file.  */
+#define HAVE_MEMORY_H 1
+
+/* Define if you have the <strings.h> header file.  */
+#define HAVE_STRINGS_H 1
+
+/* Define if you have the <sun/audioio.h> header file.  */
+/* #undef HAVE_SUN_AUDIOIO_H */
+
+/* Define if you have the <sys/acpa.h> header file.  */
+/* #undef HAVE_SYS_ACPA_H */
+
+/* Define if you have the <sys/asoundlib.h> header file.  */
+/* #undef HAVE_SYS_ASOUNDLIB_H */
+
+/* Define if you have the <sys/audio.h> header file.  */
+/* #undef HAVE_SYS_AUDIO_H */
+
+/* Define if you have the <sys/audioio.h> header file.  */
+/* #undef HAVE_SYS_AUDIOIO_H */
+
+/* Define if you have the <sys/ioctl.h> header file.  */
+#define HAVE_SYS_IOCTL_H 1
+
+/* Define if you have the <sys/sam9407.h> header file.  */
+/* #undef HAVE_SYS_SAM9407_H */
+
+/* Define if you have the <sys/soundcard.h> header file.  */
+/* #undef HAVE_SYS_SOUNDCARD_H */
+
+/* Define if you have the <unistd.h> header file.  */
+#define HAVE_UNISTD_H 1
+
+/* Name of package */
+#define PACKAGE "libmikmod"
+
+/* Version number of package */
+#define VERSION "3.1.10"
+
diff -urN libmikmod-3.1.11/macosx/libmikmod.xcodeproj/project.pbxproj libmikmod-3.1.12/macosx/libmikmod.xcodeproj/project.pbxproj
--- libmikmod-3.1.11/macosx/libmikmod.xcodeproj/project.pbxproj	1970-01-01 00:00:00.000000000 +0000
+++ libmikmod-3.1.12/macosx/libmikmod.xcodeproj/project.pbxproj	2009-10-18 04:24:28.000000000 +0000
@@ -0,0 +1,658 @@
+// !$*UTF8*$!
+{
+	archiveVersion = 1;
+	classes = {
+	};
+	objectVersion = 45;
+	objects = {
+
+/* Begin PBXBuildFile section */
+		001D90CC108A2A7A006E367C /* config.h in Headers */ = {isa = PBXBuildFile; fileRef = D22905DF09D892EC00A13A9B /* config.h */; };
+		001D90CD108A2A7A006E367C /* mikmod_build.h in Headers */ = {isa = PBXBuildFile; fileRef = D22905E009D892EC00A13A9B /* mikmod_build.h */; };
+		D229057509D8927100A13A9B /* drv_nos.c in Sources */ = {isa = PBXBuildFile; fileRef = D229057309D8927100A13A9B /* drv_nos.c */; };
+		D229057609D8927100A13A9B /* drv_nos.c in Sources */ = {isa = PBXBuildFile; fileRef = D229057309D8927100A13A9B /* drv_nos.c */; };
+		D229058509D8929600A13A9B /* drv_raw.c in Sources */ = {isa = PBXBuildFile; fileRef = D229058209D8929600A13A9B /* drv_raw.c */; };
+		D229058609D8929600A13A9B /* drv_stdout.c in Sources */ = {isa = PBXBuildFile; fileRef = D229058309D8929600A13A9B /* drv_stdout.c */; };
+		D229058709D8929600A13A9B /* drv_wav.c in Sources */ = {isa = PBXBuildFile; fileRef = D229058409D8929600A13A9B /* drv_wav.c */; };
+		D229058809D8929600A13A9B /* drv_raw.c in Sources */ = {isa = PBXBuildFile; fileRef = D229058209D8929600A13A9B /* drv_raw.c */; };
+		D229058909D8929600A13A9B /* drv_stdout.c in Sources */ = {isa = PBXBuildFile; fileRef = D229058309D8929600A13A9B /* drv_stdout.c */; };
+		D229058A09D8929600A13A9B /* drv_wav.c in Sources */ = {isa = PBXBuildFile; fileRef = D229058409D8929600A13A9B /* drv_wav.c */; };
+		D22905A909D892D800A13A9B /* load_669.c in Sources */ = {isa = PBXBuildFile; fileRef = D229059709D892D800A13A9B /* load_669.c */; };
+		D22905AA09D892D800A13A9B /* load_amf.c in Sources */ = {isa = PBXBuildFile; fileRef = D229059809D892D800A13A9B /* load_amf.c */; };
+		D22905AB09D892D800A13A9B /* load_dsm.c in Sources */ = {isa = PBXBuildFile; fileRef = D229059909D892D800A13A9B /* load_dsm.c */; };
+		D22905AC09D892D800A13A9B /* load_far.c in Sources */ = {isa = PBXBuildFile; fileRef = D229059A09D892D800A13A9B /* load_far.c */; };
+		D22905AD09D892D800A13A9B /* load_gdm.c in Sources */ = {isa = PBXBuildFile; fileRef = D229059B09D892D800A13A9B /* load_gdm.c */; };
+		D22905AE09D892D800A13A9B /* load_imf.c in Sources */ = {isa = PBXBuildFile; fileRef = D229059C09D892D800A13A9B /* load_imf.c */; };
+		D22905AF09D892D800A13A9B /* load_it.c in Sources */ = {isa = PBXBuildFile; fileRef = D229059D09D892D800A13A9B /* load_it.c */; };
+		D22905B009D892D800A13A9B /* load_m15.c in Sources */ = {isa = PBXBuildFile; fileRef = D229059E09D892D800A13A9B /* load_m15.c */; };
+		D22905B109D892D800A13A9B /* load_med.c in Sources */ = {isa = PBXBuildFile; fileRef = D229059F09D892D800A13A9B /* load_med.c */; };
+		D22905B209D892D800A13A9B /* load_mod.c in Sources */ = {isa = PBXBuildFile; fileRef = D22905A009D892D800A13A9B /* load_mod.c */; };
+		D22905B309D892D800A13A9B /* load_mtm.c in Sources */ = {isa = PBXBuildFile; fileRef = D22905A109D892D800A13A9B /* load_mtm.c */; };
+		D22905B409D892D800A13A9B /* load_okt.c in Sources */ = {isa = PBXBuildFile; fileRef = D22905A209D892D800A13A9B /* load_okt.c */; };
+		D22905B509D892D800A13A9B /* load_s3m.c in Sources */ = {isa = PBXBuildFile; fileRef = D22905A309D892D800A13A9B /* load_s3m.c */; };
+		D22905B609D892D800A13A9B /* load_stm.c in Sources */ = {isa = PBXBuildFile; fileRef = D22905A409D892D800A13A9B /* load_stm.c */; };
+		D22905B709D892D800A13A9B /* load_stx.c in Sources */ = {isa = PBXBuildFile; fileRef = D22905A509D892D800A13A9B /* load_stx.c */; };
+		D22905B809D892D800A13A9B /* load_ult.c in Sources */ = {isa = PBXBuildFile; fileRef = D22905A609D892D800A13A9B /* load_ult.c */; };
+		D22905B909D892D800A13A9B /* load_uni.c in Sources */ = {isa = PBXBuildFile; fileRef = D22905A709D892D800A13A9B /* load_uni.c */; };
+		D22905BA09D892D800A13A9B /* load_xm.c in Sources */ = {isa = PBXBuildFile; fileRef = D22905A809D892D800A13A9B /* load_xm.c */; };
+		D22905BB09D892D800A13A9B /* load_669.c in Sources */ = {isa = PBXBuildFile; fileRef = D229059709D892D800A13A9B /* load_669.c */; };
+		D22905BC09D892D800A13A9B /* load_amf.c in Sources */ = {isa = PBXBuildFile; fileRef = D229059809D892D800A13A9B /* load_amf.c */; };
+		D22905BD09D892D800A13A9B /* load_dsm.c in Sources */ = {isa = PBXBuildFile; fileRef = D229059909D892D800A13A9B /* load_dsm.c */; };
+		D22905BE09D892D800A13A9B /* load_far.c in Sources */ = {isa = PBXBuildFile; fileRef = D229059A09D892D800A13A9B /* load_far.c */; };
+		D22905BF09D892D800A13A9B /* load_gdm.c in Sources */ = {isa = PBXBuildFile; fileRef = D229059B09D892D800A13A9B /* load_gdm.c */; };
+		D22905C009D892D800A13A9B /* load_imf.c in Sources */ = {isa = PBXBuildFile; fileRef = D229059C09D892D800A13A9B /* load_imf.c */; };
+		D22905C109D892D800A13A9B /* load_it.c in Sources */ = {isa = PBXBuildFile; fileRef = D229059D09D892D800A13A9B /* load_it.c */; };
+		D22905C209D892D800A13A9B /* load_m15.c in Sources */ = {isa = PBXBuildFile; fileRef = D229059E09D892D800A13A9B /* load_m15.c */; };
+		D22905C309D892D800A13A9B /* load_med.c in Sources */ = {isa = PBXBuildFile; fileRef = D229059F09D892D800A13A9B /* load_med.c */; };
+		D22905C409D892D800A13A9B /* load_mod.c in Sources */ = {isa = PBXBuildFile; fileRef = D22905A009D892D800A13A9B /* load_mod.c */; };
+		D22905C509D892D800A13A9B /* load_mtm.c in Sources */ = {isa = PBXBuildFile; fileRef = D22905A109D892D800A13A9B /* load_mtm.c */; };
+		D22905C609D892D800A13A9B /* load_okt.c in Sources */ = {isa = PBXBuildFile; fileRef = D22905A209D892D800A13A9B /* load_okt.c */; };
+		D22905C709D892D800A13A9B /* load_s3m.c in Sources */ = {isa = PBXBuildFile; fileRef = D22905A309D892D800A13A9B /* load_s3m.c */; };
+		D22905C809D892D800A13A9B /* load_stm.c in Sources */ = {isa = PBXBuildFile; fileRef = D22905A409D892D800A13A9B /* load_stm.c */; };
+		D22905C909D892D800A13A9B /* load_stx.c in Sources */ = {isa = PBXBuildFile; fileRef = D22905A509D892D800A13A9B /* load_stx.c */; };
+		D22905CA09D892D800A13A9B /* load_ult.c in Sources */ = {isa = PBXBuildFile; fileRef = D22905A609D892D800A13A9B /* load_ult.c */; };
+		D22905CB09D892D800A13A9B /* load_uni.c in Sources */ = {isa = PBXBuildFile; fileRef = D22905A709D892D800A13A9B /* load_uni.c */; };
+		D22905CC09D892D800A13A9B /* load_xm.c in Sources */ = {isa = PBXBuildFile; fileRef = D22905A809D892D800A13A9B /* load_xm.c */; };
+		D22905EA09D8930800A13A9B /* mikmod.h in Headers */ = {isa = PBXBuildFile; fileRef = D22905E909D8930800A13A9B /* mikmod.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		D22905EB09D8930800A13A9B /* mikmod.h in Headers */ = {isa = PBXBuildFile; fileRef = D22905E909D8930800A13A9B /* mikmod.h */; };
+		D22905F009D8931A00A13A9B /* mmalloc.c in Sources */ = {isa = PBXBuildFile; fileRef = D22905ED09D8931A00A13A9B /* mmalloc.c */; };
+		D22905F109D8931A00A13A9B /* mmerror.c in Sources */ = {isa = PBXBuildFile; fileRef = D22905EE09D8931A00A13A9B /* mmerror.c */; };
+		D22905F209D8931A00A13A9B /* mmio.c in Sources */ = {isa = PBXBuildFile; fileRef = D22905EF09D8931A00A13A9B /* mmio.c */; };
+		D22905F309D8931A00A13A9B /* mmalloc.c in Sources */ = {isa = PBXBuildFile; fileRef = D22905ED09D8931A00A13A9B /* mmalloc.c */; };
+		D22905F409D8931A00A13A9B /* mmerror.c in Sources */ = {isa = PBXBuildFile; fileRef = D22905EE09D8931A00A13A9B /* mmerror.c */; };
+		D22905F509D8931A00A13A9B /* mmio.c in Sources */ = {isa = PBXBuildFile; fileRef = D22905EF09D8931A00A13A9B /* mmio.c */; };
+		D229060709D8933700A13A9B /* mdreg.c in Sources */ = {isa = PBXBuildFile; fileRef = D22905F909D8933700A13A9B /* mdreg.c */; };
+		D229060809D8933700A13A9B /* mdriver.c in Sources */ = {isa = PBXBuildFile; fileRef = D22905FA09D8933700A13A9B /* mdriver.c */; };
+		D229060909D8933700A13A9B /* mdulaw.c in Sources */ = {isa = PBXBuildFile; fileRef = D22905FB09D8933700A13A9B /* mdulaw.c */; };
+		D229060A09D8933700A13A9B /* mloader.c in Sources */ = {isa = PBXBuildFile; fileRef = D22905FC09D8933700A13A9B /* mloader.c */; };
+		D229060B09D8933700A13A9B /* mlreg.c in Sources */ = {isa = PBXBuildFile; fileRef = D22905FD09D8933700A13A9B /* mlreg.c */; };
+		D229060C09D8933700A13A9B /* mlutil.c in Sources */ = {isa = PBXBuildFile; fileRef = D22905FE09D8933700A13A9B /* mlutil.c */; };
+		D229060D09D8933700A13A9B /* mplayer.c in Sources */ = {isa = PBXBuildFile; fileRef = D22905FF09D8933700A13A9B /* mplayer.c */; };
+		D229060E09D8933700A13A9B /* munitrk.c in Sources */ = {isa = PBXBuildFile; fileRef = D229060009D8933700A13A9B /* munitrk.c */; };
+		D229060F09D8933700A13A9B /* mwav.c in Sources */ = {isa = PBXBuildFile; fileRef = D229060109D8933700A13A9B /* mwav.c */; };
+		D229061009D8933700A13A9B /* npertab.c in Sources */ = {isa = PBXBuildFile; fileRef = D229060209D8933700A13A9B /* npertab.c */; };
+		D229061109D8933700A13A9B /* sloader.c in Sources */ = {isa = PBXBuildFile; fileRef = D229060309D8933700A13A9B /* sloader.c */; };
+		D229061209D8933700A13A9B /* virtch_common.c in Sources */ = {isa = PBXBuildFile; fileRef = D229060409D8933700A13A9B /* virtch_common.c */; };
+		D229061309D8933700A13A9B /* virtch.c in Sources */ = {isa = PBXBuildFile; fileRef = D229060509D8933700A13A9B /* virtch.c */; };
+		D229061409D8933700A13A9B /* virtch2.c in Sources */ = {isa = PBXBuildFile; fileRef = D229060609D8933700A13A9B /* virtch2.c */; };
+		D229061509D8933700A13A9B /* mdreg.c in Sources */ = {isa = PBXBuildFile; fileRef = D22905F909D8933700A13A9B /* mdreg.c */; };
+		D229061609D8933700A13A9B /* mdriver.c in Sources */ = {isa = PBXBuildFile; fileRef = D22905FA09D8933700A13A9B /* mdriver.c */; };
+		D229061709D8933700A13A9B /* mdulaw.c in Sources */ = {isa = PBXBuildFile; fileRef = D22905FB09D8933700A13A9B /* mdulaw.c */; };
+		D229061809D8933700A13A9B /* mloader.c in Sources */ = {isa = PBXBuildFile; fileRef = D22905FC09D8933700A13A9B /* mloader.c */; };
+		D229061909D8933700A13A9B /* mlreg.c in Sources */ = {isa = PBXBuildFile; fileRef = D22905FD09D8933700A13A9B /* mlreg.c */; };
+		D229061A09D8933700A13A9B /* mlutil.c in Sources */ = {isa = PBXBuildFile; fileRef = D22905FE09D8933700A13A9B /* mlutil.c */; };
+		D229061B09D8933700A13A9B /* mplayer.c in Sources */ = {isa = PBXBuildFile; fileRef = D22905FF09D8933700A13A9B /* mplayer.c */; };
+		D229061C09D8933700A13A9B /* munitrk.c in Sources */ = {isa = PBXBuildFile; fileRef = D229060009D8933700A13A9B /* munitrk.c */; };
+		D229061D09D8933700A13A9B /* mwav.c in Sources */ = {isa = PBXBuildFile; fileRef = D229060109D8933700A13A9B /* mwav.c */; };
+		D229061E09D8933700A13A9B /* npertab.c in Sources */ = {isa = PBXBuildFile; fileRef = D229060209D8933700A13A9B /* npertab.c */; };
+		D229061F09D8933700A13A9B /* sloader.c in Sources */ = {isa = PBXBuildFile; fileRef = D229060309D8933700A13A9B /* sloader.c */; };
+		D229062009D8933700A13A9B /* virtch_common.c in Sources */ = {isa = PBXBuildFile; fileRef = D229060409D8933700A13A9B /* virtch_common.c */; };
+		D229062109D8933700A13A9B /* virtch.c in Sources */ = {isa = PBXBuildFile; fileRef = D229060509D8933700A13A9B /* virtch.c */; };
+		D229062209D8933700A13A9B /* virtch2.c in Sources */ = {isa = PBXBuildFile; fileRef = D229060609D8933700A13A9B /* virtch2.c */; };
+		D229063B09D893F200A13A9B /* InfoPlist.strings in Resources */ = {isa = PBXBuildFile; fileRef = D229063909D893F200A13A9B /* InfoPlist.strings */; };
+		D229075009D89B3500A13A9B /* CoreAudio.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = D229074F09D89B3500A13A9B /* CoreAudio.framework */; };
+/* End PBXBuildFile section */
+
+/* Begin PBXFileReference section */
+		D229054709D8912600A13A9B /* mikmod.framework */ = {isa = PBXFileReference; explicitFileType = wrapper.framework; includeInIndex = 0; path = mikmod.framework; sourceTree = BUILT_PRODUCTS_DIR; };
+		D229054809D8912600A13A9B /* Cocoa Framework-Info.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist.xml; path = "Cocoa Framework-Info.plist"; sourceTree = "<group>"; };
+		D229056F09D8926200A13A9B /* drv_mac.c */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.c; name = drv_mac.c; path = ../drivers/drv_mac.c; sourceTree = SOURCE_ROOT; };
+		D229057309D8927100A13A9B /* drv_nos.c */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.c; name = drv_nos.c; path = ../drivers/drv_nos.c; sourceTree = SOURCE_ROOT; };
+		D229058209D8929600A13A9B /* drv_raw.c */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.c; name = drv_raw.c; path = ../drivers/drv_raw.c; sourceTree = SOURCE_ROOT; };
+		D229058309D8929600A13A9B /* drv_stdout.c */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.c; name = drv_stdout.c; path = ../drivers/drv_stdout.c; sourceTree = SOURCE_ROOT; };
+		D229058409D8929600A13A9B /* drv_wav.c */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.c; name = drv_wav.c; path = ../drivers/drv_wav.c; sourceTree = SOURCE_ROOT; };
+		D229059009D892B500A13A9B /* mikmod_internals.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; name = mikmod_internals.h; path = ../include/mikmod_internals.h; sourceTree = SOURCE_ROOT; };
+		D229059709D892D800A13A9B /* load_669.c */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.c; name = load_669.c; path = ../loaders/load_669.c; sourceTree = SOURCE_ROOT; };
+		D229059809D892D800A13A9B /* load_amf.c */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.c; name = load_amf.c; path = ../loaders/load_amf.c; sourceTree = SOURCE_ROOT; };
+		D229059909D892D800A13A9B /* load_dsm.c */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.c; name = load_dsm.c; path = ../loaders/load_dsm.c; sourceTree = SOURCE_ROOT; };
+		D229059A09D892D800A13A9B /* load_far.c */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.c; name = load_far.c; path = ../loaders/load_far.c; sourceTree = SOURCE_ROOT; };
+		D229059B09D892D800A13A9B /* load_gdm.c */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.c; name = load_gdm.c; path = ../loaders/load_gdm.c; sourceTree = SOURCE_ROOT; };
+		D229059C09D892D800A13A9B /* load_imf.c */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.c; name = load_imf.c; path = ../loaders/load_imf.c; sourceTree = SOURCE_ROOT; };
+		D229059D09D892D800A13A9B /* load_it.c */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.c; name = load_it.c; path = ../loaders/load_it.c; sourceTree = SOURCE_ROOT; };
+		D229059E09D892D800A13A9B /* load_m15.c */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.c; name = load_m15.c; path = ../loaders/load_m15.c; sourceTree = SOURCE_ROOT; };
+		D229059F09D892D800A13A9B /* load_med.c */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.c; name = load_med.c; path = ../loaders/load_med.c; sourceTree = SOURCE_ROOT; };
+		D22905A009D892D800A13A9B /* load_mod.c */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.c; name = load_mod.c; path = ../loaders/load_mod.c; sourceTree = SOURCE_ROOT; };
+		D22905A109D892D800A13A9B /* load_mtm.c */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.c; name = load_mtm.c; path = ../loaders/load_mtm.c; sourceTree = SOURCE_ROOT; };
+		D22905A209D892D800A13A9B /* load_okt.c */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.c; name = load_okt.c; path = ../loaders/load_okt.c; sourceTree = SOURCE_ROOT; };
+		D22905A309D892D800A13A9B /* load_s3m.c */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.c; name = load_s3m.c; path = ../loaders/load_s3m.c; sourceTree = SOURCE_ROOT; };
+		D22905A409D892D800A13A9B /* load_stm.c */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.c; name = load_stm.c; path = ../loaders/load_stm.c; sourceTree = SOURCE_ROOT; };
+		D22905A509D892D800A13A9B /* load_stx.c */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.c; name = load_stx.c; path = ../loaders/load_stx.c; sourceTree = SOURCE_ROOT; };
+		D22905A609D892D800A13A9B /* load_ult.c */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.c; name = load_ult.c; path = ../loaders/load_ult.c; sourceTree = SOURCE_ROOT; };
+		D22905A709D892D800A13A9B /* load_uni.c */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.c; name = load_uni.c; path = ../loaders/load_uni.c; sourceTree = SOURCE_ROOT; };
+		D22905A809D892D800A13A9B /* load_xm.c */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.c; name = load_xm.c; path = ../loaders/load_xm.c; sourceTree = SOURCE_ROOT; };
+		D22905DF09D892EC00A13A9B /* config.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; path = config.h; sourceTree = "<group>"; };
+		D22905E009D892EC00A13A9B /* mikmod_build.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; path = mikmod_build.h; sourceTree = "<group>"; };
+		D22905E909D8930800A13A9B /* mikmod.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; path = mikmod.h; sourceTree = "<group>"; };
+		D22905ED09D8931A00A13A9B /* mmalloc.c */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.c; name = mmalloc.c; path = ../mmio/mmalloc.c; sourceTree = SOURCE_ROOT; };
+		D22905EE09D8931A00A13A9B /* mmerror.c */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.c; name = mmerror.c; path = ../mmio/mmerror.c; sourceTree = SOURCE_ROOT; };
+		D22905EF09D8931A00A13A9B /* mmio.c */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.c; name = mmio.c; path = ../mmio/mmio.c; sourceTree = SOURCE_ROOT; };
+		D22905F909D8933700A13A9B /* mdreg.c */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.c; name = mdreg.c; path = ../playercode/mdreg.c; sourceTree = SOURCE_ROOT; };
+		D22905FA09D8933700A13A9B /* mdriver.c */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.c; name = mdriver.c; path = ../playercode/mdriver.c; sourceTree = SOURCE_ROOT; };
+		D22905FB09D8933700A13A9B /* mdulaw.c */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.c; name = mdulaw.c; path = ../playercode/mdulaw.c; sourceTree = SOURCE_ROOT; };
+		D22905FC09D8933700A13A9B /* mloader.c */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.c; name = mloader.c; path = ../playercode/mloader.c; sourceTree = SOURCE_ROOT; };
+		D22905FD09D8933700A13A9B /* mlreg.c */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.c; name = mlreg.c; path = ../playercode/mlreg.c; sourceTree = SOURCE_ROOT; };
+		D22905FE09D8933700A13A9B /* mlutil.c */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.c; name = mlutil.c; path = ../playercode/mlutil.c; sourceTree = SOURCE_ROOT; };
+		D22905FF09D8933700A13A9B /* mplayer.c */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.c; name = mplayer.c; path = ../playercode/mplayer.c; sourceTree = SOURCE_ROOT; };
+		D229060009D8933700A13A9B /* munitrk.c */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.c; name = munitrk.c; path = ../playercode/munitrk.c; sourceTree = SOURCE_ROOT; };
+		D229060109D8933700A13A9B /* mwav.c */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.c; name = mwav.c; path = ../playercode/mwav.c; sourceTree = SOURCE_ROOT; };
+		D229060209D8933700A13A9B /* npertab.c */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.c; name = npertab.c; path = ../playercode/npertab.c; sourceTree = SOURCE_ROOT; };
+		D229060309D8933700A13A9B /* sloader.c */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.c; name = sloader.c; path = ../playercode/sloader.c; sourceTree = SOURCE_ROOT; };
+		D229060409D8933700A13A9B /* virtch_common.c */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.c; name = virtch_common.c; path = ../playercode/virtch_common.c; sourceTree = SOURCE_ROOT; };
+		D229060509D8933700A13A9B /* virtch.c */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.c; name = virtch.c; path = ../playercode/virtch.c; sourceTree = SOURCE_ROOT; };
+		D229060609D8933700A13A9B /* virtch2.c */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.c; name = virtch2.c; path = ../playercode/virtch2.c; sourceTree = SOURCE_ROOT; };
+		D229063A09D893F200A13A9B /* English */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = text.plist.strings; name = English; path = English.lproj/InfoPlist.strings; sourceTree = "<group>"; };
+		D229074F09D89B3500A13A9B /* CoreAudio.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = CoreAudio.framework; path = /System/Library/Frameworks/CoreAudio.framework; sourceTree = "<absolute>"; };
+		D2AAC046055464E500DB518D /* libmikmod.a */ = {isa = PBXFileReference; explicitFileType = archive.ar; includeInIndex = 0; path = libmikmod.a; sourceTree = BUILT_PRODUCTS_DIR; };
+/* End PBXFileReference section */
+
+/* Begin PBXFrameworksBuildPhase section */
+		D229054509D8912600A13A9B /* Frameworks */ = {
+			isa = PBXFrameworksBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				D229075009D89B3500A13A9B /* CoreAudio.framework in Frameworks */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		D289987405E68DCB004EDB86 /* Frameworks */ = {
+			isa = PBXFrameworksBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+/* End PBXFrameworksBuildPhase section */
+
+/* Begin PBXGroup section */
+		08FB7794FE84155DC02AAC07 /* libmikmod */ = {
+			isa = PBXGroup;
+			children = (
+				08FB7795FE84155DC02AAC07 /* Library */,
+				C6A0FF2B0290797F04C91782 /* Resources */,
+				D229074109D89AD300A13A9B /* External Frameworks and Libraries */,
+				1AB674ADFE9D54B511CA2CBB /* Products */,
+				D229054809D8912600A13A9B /* Cocoa Framework-Info.plist */,
+			);
+			name = libmikmod;
+			sourceTree = "<group>";
+		};
+		08FB7795FE84155DC02AAC07 /* Library */ = {
+			isa = PBXGroup;
+			children = (
+				D229055409D891A300A13A9B /* drivers */,
+				D229055509D891A800A13A9B /* include */,
+				D229055609D891AF00A13A9B /* loaders */,
+				D229055709D891B700A13A9B /* macosx */,
+				D229055809D891C000A13A9B /* mmio */,
+				D229055909D891C800A13A9B /* playercode */,
+			);
+			name = Library;
+			sourceTree = "<group>";
+		};
+		1AB674ADFE9D54B511CA2CBB /* Products */ = {
+			isa = PBXGroup;
+			children = (
+				D2AAC046055464E500DB518D /* libmikmod.a */,
+				D229054709D8912600A13A9B /* mikmod.framework */,
+			);
+			name = Products;
+			sourceTree = "<group>";
+		};
+		C6A0FF2B0290797F04C91782 /* Resources */ = {
+			isa = PBXGroup;
+			children = (
+				D229063909D893F200A13A9B /* InfoPlist.strings */,
+			);
+			name = Resources;
+			sourceTree = "<group>";
+		};
+		D229055409D891A300A13A9B /* drivers */ = {
+			isa = PBXGroup;
+			children = (
+				D229056F09D8926200A13A9B /* drv_mac.c */,
+				D229057309D8927100A13A9B /* drv_nos.c */,
+				D229058209D8929600A13A9B /* drv_raw.c */,
+				D229058309D8929600A13A9B /* drv_stdout.c */,
+				D229058409D8929600A13A9B /* drv_wav.c */,
+			);
+			name = drivers;
+			sourceTree = "<group>";
+		};
+		D229055509D891A800A13A9B /* include */ = {
+			isa = PBXGroup;
+			children = (
+				D229059009D892B500A13A9B /* mikmod_internals.h */,
+			);
+			name = include;
+			sourceTree = "<group>";
+		};
+		D229055609D891AF00A13A9B /* loaders */ = {
+			isa = PBXGroup;
+			children = (
+				D229059709D892D800A13A9B /* load_669.c */,
+				D229059809D892D800A13A9B /* load_amf.c */,
+				D229059909D892D800A13A9B /* load_dsm.c */,
+				D229059A09D892D800A13A9B /* load_far.c */,
+				D229059B09D892D800A13A9B /* load_gdm.c */,
+				D229059C09D892D800A13A9B /* load_imf.c */,
+				D229059D09D892D800A13A9B /* load_it.c */,
+				D229059E09D892D800A13A9B /* load_m15.c */,
+				D229059F09D892D800A13A9B /* load_med.c */,
+				D22905A009D892D800A13A9B /* load_mod.c */,
+				D22905A109D892D800A13A9B /* load_mtm.c */,
+				D22905A209D892D800A13A9B /* load_okt.c */,
+				D22905A309D892D800A13A9B /* load_s3m.c */,
+				D22905A409D892D800A13A9B /* load_stm.c */,
+				D22905A509D892D800A13A9B /* load_stx.c */,
+				D22905A609D892D800A13A9B /* load_ult.c */,
+				D22905A709D892D800A13A9B /* load_uni.c */,
+				D22905A809D892D800A13A9B /* load_xm.c */,
+			);
+			name = loaders;
+			sourceTree = "<group>";
+		};
+		D229055709D891B700A13A9B /* macosx */ = {
+			isa = PBXGroup;
+			children = (
+				D22905E909D8930800A13A9B /* mikmod.h */,
+				D22905DF09D892EC00A13A9B /* config.h */,
+				D22905E009D892EC00A13A9B /* mikmod_build.h */,
+			);
+			name = macosx;
+			sourceTree = "<group>";
+		};
+		D229055809D891C000A13A9B /* mmio */ = {
+			isa = PBXGroup;
+			children = (
+				D22905ED09D8931A00A13A9B /* mmalloc.c */,
+				D22905EE09D8931A00A13A9B /* mmerror.c */,
+				D22905EF09D8931A00A13A9B /* mmio.c */,
+			);
+			name = mmio;
+			sourceTree = "<group>";
+		};
+		D229055909D891C800A13A9B /* playercode */ = {
+			isa = PBXGroup;
+			children = (
+				D22905F909D8933700A13A9B /* mdreg.c */,
+				D22905FA09D8933700A13A9B /* mdriver.c */,
+				D22905FB09D8933700A13A9B /* mdulaw.c */,
+				D22905FC09D8933700A13A9B /* mloader.c */,
+				D22905FD09D8933700A13A9B /* mlreg.c */,
+				D22905FE09D8933700A13A9B /* mlutil.c */,
+				D22905FF09D8933700A13A9B /* mplayer.c */,
+				D229060009D8933700A13A9B /* munitrk.c */,
+				D229060109D8933700A13A9B /* mwav.c */,
+				D229060209D8933700A13A9B /* npertab.c */,
+				D229060309D8933700A13A9B /* sloader.c */,
+				D229060409D8933700A13A9B /* virtch_common.c */,
+				D229060509D8933700A13A9B /* virtch.c */,
+				D229060609D8933700A13A9B /* virtch2.c */,
+			);
+			name = playercode;
+			sourceTree = "<group>";
+		};
+		D229074109D89AD300A13A9B /* External Frameworks and Libraries */ = {
+			isa = PBXGroup;
+			children = (
+				D229074F09D89B3500A13A9B /* CoreAudio.framework */,
+			);
+			name = "External Frameworks and Libraries";
+			sourceTree = "<group>";
+		};
+/* End PBXGroup section */
+
+/* Begin PBXHeadersBuildPhase section */
+		D229054209D8912600A13A9B /* Headers */ = {
+			isa = PBXHeadersBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				001D90CC108A2A7A006E367C /* config.h in Headers */,
+				001D90CD108A2A7A006E367C /* mikmod_build.h in Headers */,
+				D22905EA09D8930800A13A9B /* mikmod.h in Headers */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		D2AAC043055464E500DB518D /* Headers */ = {
+			isa = PBXHeadersBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				D22905EB09D8930800A13A9B /* mikmod.h in Headers */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+/* End PBXHeadersBuildPhase section */
+
+/* Begin PBXNativeTarget section */
+		D229054609D8912600A13A9B /* mikmod CoreAudio Framework */ = {
+			isa = PBXNativeTarget;
+			buildConfigurationList = D229054909D8912700A13A9B /* Build configuration list for PBXNativeTarget "mikmod CoreAudio Framework" */;
+			buildPhases = (
+				D229054209D8912600A13A9B /* Headers */,
+				D229054309D8912600A13A9B /* Resources */,
+				D229054409D8912600A13A9B /* Sources */,
+				D229054509D8912600A13A9B /* Frameworks */,
+			);
+			buildRules = (
+			);
+			dependencies = (
+			);
+			name = "mikmod CoreAudio Framework";
+			productName = "Cocoa Framework";
+			productReference = D229054709D8912600A13A9B /* mikmod.framework */;
+			productType = "com.apple.product-type.framework";
+		};
+		D2AAC045055464E500DB518D /* mikmod CoreAudio Static Library */ = {
+			isa = PBXNativeTarget;
+			buildConfigurationList = 1DEB91EB08733DB70010E9CD /* Build configuration list for PBXNativeTarget "mikmod CoreAudio Static Library" */;
+			buildPhases = (
+				D2AAC043055464E500DB518D /* Headers */,
+				D2AAC044055464E500DB518D /* Sources */,
+				D289987405E68DCB004EDB86 /* Frameworks */,
+			);
+			buildRules = (
+			);
+			dependencies = (
+			);
+			name = "mikmod CoreAudio Static Library";
+			productName = libmikmod;
+			productReference = D2AAC046055464E500DB518D /* libmikmod.a */;
+			productType = "com.apple.product-type.library.static";
+		};
+/* End PBXNativeTarget section */
+
+/* Begin PBXProject section */
+		08FB7793FE84155DC02AAC07 /* Project object */ = {
+			isa = PBXProject;
+			buildConfigurationList = 1DEB91EF08733DB70010E9CD /* Build configuration list for PBXProject "libmikmod" */;
+			compatibilityVersion = "Xcode 3.0";
+			hasScannedForEncodings = 1;
+			mainGroup = 08FB7794FE84155DC02AAC07 /* libmikmod */;
+			projectDirPath = "";
+			projectRoot = "";
+			targets = (
+				D229054609D8912600A13A9B /* mikmod CoreAudio Framework */,
+				D2AAC045055464E500DB518D /* mikmod CoreAudio Static Library */,
+			);
+		};
+/* End PBXProject section */
+
+/* Begin PBXResourcesBuildPhase section */
+		D229054309D8912600A13A9B /* Resources */ = {
+			isa = PBXResourcesBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				D229063B09D893F200A13A9B /* InfoPlist.strings in Resources */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+/* End PBXResourcesBuildPhase section */
+
+/* Begin PBXSourcesBuildPhase section */
+		D229054409D8912600A13A9B /* Sources */ = {
+			isa = PBXSourcesBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				D229057509D8927100A13A9B /* drv_nos.c in Sources */,
+				D229058509D8929600A13A9B /* drv_raw.c in Sources */,
+				D229058609D8929600A13A9B /* drv_stdout.c in Sources */,
+				D229058709D8929600A13A9B /* drv_wav.c in Sources */,
+				D22905A909D892D800A13A9B /* load_669.c in Sources */,
+				D22905AA09D892D800A13A9B /* load_amf.c in Sources */,
+				D22905AB09D892D800A13A9B /* load_dsm.c in Sources */,
+				D22905AC09D892D800A13A9B /* load_far.c in Sources */,
+				D22905AD09D892D800A13A9B /* load_gdm.c in Sources */,
+				D22905AE09D892D800A13A9B /* load_imf.c in Sources */,
+				D22905AF09D892D800A13A9B /* load_it.c in Sources */,
+				D22905B009D892D800A13A9B /* load_m15.c in Sources */,
+				D22905B109D892D800A13A9B /* load_med.c in Sources */,
+				D22905B209D892D800A13A9B /* load_mod.c in Sources */,
+				D22905B309D892D800A13A9B /* load_mtm.c in Sources */,
+				D22905B409D892D800A13A9B /* load_okt.c in Sources */,
+				D22905B509D892D800A13A9B /* load_s3m.c in Sources */,
+				D22905B609D892D800A13A9B /* load_stm.c in Sources */,
+				D22905B709D892D800A13A9B /* load_stx.c in Sources */,
+				D22905B809D892D800A13A9B /* load_ult.c in Sources */,
+				D22905B909D892D800A13A9B /* load_uni.c in Sources */,
+				D22905BA09D892D800A13A9B /* load_xm.c in Sources */,
+				D22905F009D8931A00A13A9B /* mmalloc.c in Sources */,
+				D22905F109D8931A00A13A9B /* mmerror.c in Sources */,
+				D22905F209D8931A00A13A9B /* mmio.c in Sources */,
+				D229060709D8933700A13A9B /* mdreg.c in Sources */,
+				D229060809D8933700A13A9B /* mdriver.c in Sources */,
+				D229060909D8933700A13A9B /* mdulaw.c in Sources */,
+				D229060A09D8933700A13A9B /* mloader.c in Sources */,
+				D229060B09D8933700A13A9B /* mlreg.c in Sources */,
+				D229060C09D8933700A13A9B /* mlutil.c in Sources */,
+				D229060D09D8933700A13A9B /* mplayer.c in Sources */,
+				D229060E09D8933700A13A9B /* munitrk.c in Sources */,
+				D229060F09D8933700A13A9B /* mwav.c in Sources */,
+				D229061009D8933700A13A9B /* npertab.c in Sources */,
+				D229061109D8933700A13A9B /* sloader.c in Sources */,
+				D229061209D8933700A13A9B /* virtch_common.c in Sources */,
+				D229061309D8933700A13A9B /* virtch.c in Sources */,
+				D229061409D8933700A13A9B /* virtch2.c in Sources */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		D2AAC044055464E500DB518D /* Sources */ = {
+			isa = PBXSourcesBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				D229057609D8927100A13A9B /* drv_nos.c in Sources */,
+				D229058809D8929600A13A9B /* drv_raw.c in Sources */,
+				D229058909D8929600A13A9B /* drv_stdout.c in Sources */,
+				D229058A09D8929600A13A9B /* drv_wav.c in Sources */,
+				D22905BB09D892D800A13A9B /* load_669.c in Sources */,
+				D22905BC09D892D800A13A9B /* load_amf.c in Sources */,
+				D22905BD09D892D800A13A9B /* load_dsm.c in Sources */,
+				D22905BE09D892D800A13A9B /* load_far.c in Sources */,
+				D22905BF09D892D800A13A9B /* load_gdm.c in Sources */,
+				D22905C009D892D800A13A9B /* load_imf.c in Sources */,
+				D22905C109D892D800A13A9B /* load_it.c in Sources */,
+				D22905C209D892D800A13A9B /* load_m15.c in Sources */,
+				D22905C309D892D800A13A9B /* load_med.c in Sources */,
+				D22905C409D892D800A13A9B /* load_mod.c in Sources */,
+				D22905C509D892D800A13A9B /* load_mtm.c in Sources */,
+				D22905C609D892D800A13A9B /* load_okt.c in Sources */,
+				D22905C709D892D800A13A9B /* load_s3m.c in Sources */,
+				D22905C809D892D800A13A9B /* load_stm.c in Sources */,
+				D22905C909D892D800A13A9B /* load_stx.c in Sources */,
+				D22905CA09D892D800A13A9B /* load_ult.c in Sources */,
+				D22905CB09D892D800A13A9B /* load_uni.c in Sources */,
+				D22905CC09D892D800A13A9B /* load_xm.c in Sources */,
+				D22905F309D8931A00A13A9B /* mmalloc.c in Sources */,
+				D22905F409D8931A00A13A9B /* mmerror.c in Sources */,
+				D22905F509D8931A00A13A9B /* mmio.c in Sources */,
+				D229061509D8933700A13A9B /* mdreg.c in Sources */,
+				D229061609D8933700A13A9B /* mdriver.c in Sources */,
+				D229061709D8933700A13A9B /* mdulaw.c in Sources */,
+				D229061809D8933700A13A9B /* mloader.c in Sources */,
+				D229061909D8933700A13A9B /* mlreg.c in Sources */,
+				D229061A09D8933700A13A9B /* mlutil.c in Sources */,
+				D229061B09D8933700A13A9B /* mplayer.c in Sources */,
+				D229061C09D8933700A13A9B /* munitrk.c in Sources */,
+				D229061D09D8933700A13A9B /* mwav.c in Sources */,
+				D229061E09D8933700A13A9B /* npertab.c in Sources */,
+				D229061F09D8933700A13A9B /* sloader.c in Sources */,
+				D229062009D8933700A13A9B /* virtch_common.c in Sources */,
+				D229062109D8933700A13A9B /* virtch.c in Sources */,
+				D229062209D8933700A13A9B /* virtch2.c in Sources */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+/* End PBXSourcesBuildPhase section */
+
+/* Begin PBXVariantGroup section */
+		D229063909D893F200A13A9B /* InfoPlist.strings */ = {
+			isa = PBXVariantGroup;
+			children = (
+				D229063A09D893F200A13A9B /* English */,
+			);
+			name = InfoPlist.strings;
+			sourceTree = "<group>";
+		};
+/* End PBXVariantGroup section */
+
+/* Begin XCBuildConfiguration section */
+		1DEB91EC08733DB70010E9CD /* Debug */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				COPY_PHASE_STRIP = NO;
+				GCC_DYNAMIC_NO_PIC = NO;
+				GCC_ENABLE_FIX_AND_CONTINUE = YES;
+				GCC_MODEL_TUNING = G5;
+				GCC_OPTIMIZATION_LEVEL = 0;
+				GCC_PREPROCESSOR_DEFINITIONS = (
+					HAVE_CONFIG_H,
+					DRV_OSX,
+				);
+				INSTALL_PATH = /usr/local/lib;
+				PRODUCT_NAME = mikmod;
+			};
+			name = Debug;
+		};
+		1DEB91ED08733DB70010E9CD /* Release */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				GCC_GENERATE_DEBUGGING_SYMBOLS = NO;
+				GCC_MODEL_TUNING = G5;
+				GCC_PREPROCESSOR_DEFINITIONS = (
+					HAVE_CONFIG_H,
+					DRV_OSX,
+				);
+				INSTALL_PATH = /usr/local/lib;
+				PRODUCT_NAME = mikmod;
+			};
+			name = Release;
+		};
+		1DEB91F008733DB70010E9CD /* Debug */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				ARCHS = "$(ARCHS_STANDARD_32_64_BIT)";
+				GCC_OPTIMIZATION_LEVEL = 3;
+				GCC_PREPROCESSOR_DEFINITIONS = HAVE_CONFIG_H;
+				GCC_VERSION = 4.0;
+				"GCC_VERSION[sdk=macosx10.6][arch=x86_64]" = 4.2;
+				GCC_WARN_ABOUT_RETURN_TYPE = YES;
+				GCC_WARN_UNUSED_VARIABLE = YES;
+				PREBINDING = NO;
+				SDKROOT = macosx10.4;
+				"SDKROOT[arch=x86_64]" = "$(DEVELOPER_SDK_DIR)/MacOSX10.6.sdk";
+			};
+			name = Debug;
+		};
+		1DEB91F108733DB70010E9CD /* Release */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				ARCHS = "$(ARCHS_STANDARD_32_64_BIT)";
+				GCC_OPTIMIZATION_LEVEL = 3;
+				GCC_PREPROCESSOR_DEFINITIONS = HAVE_CONFIG_H;
+				GCC_VERSION = 4.0;
+				"GCC_VERSION[sdk=macosx10.6][arch=x86_64]" = 4.2;
+				GCC_WARN_ABOUT_RETURN_TYPE = YES;
+				GCC_WARN_UNUSED_VARIABLE = YES;
+				PREBINDING = NO;
+				SDKROOT = macosx10.4;
+				"SDKROOT[arch=x86_64]" = "$(DEVELOPER_SDK_DIR)/MacOSX10.6.sdk";
+			};
+			name = Release;
+		};
+		D229054A09D8912700A13A9B /* Debug */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				COPY_PHASE_STRIP = NO;
+				DYLIB_COMPATIBILITY_VERSION = 1;
+				DYLIB_CURRENT_VERSION = 1;
+				FRAMEWORK_VERSION = A;
+				GCC_DYNAMIC_NO_PIC = NO;
+				GCC_ENABLE_FIX_AND_CONTINUE = YES;
+				GCC_GENERATE_DEBUGGING_SYMBOLS = YES;
+				GCC_MODEL_TUNING = G5;
+				GCC_OPTIMIZATION_LEVEL = 0;
+				GCC_PRECOMPILE_PREFIX_HEADER = NO;
+				GCC_PREFIX_HEADER = "";
+				GCC_PREPROCESSOR_DEFINITIONS = (
+					HAVE_CONFIG_H,
+					DRV_OSX,
+				);
+				INFOPLIST_FILE = "Cocoa Framework-Info.plist";
+				INSTALL_PATH = "@loader_path/Frameworks";
+				OTHER_LDFLAGS = (
+					"-headerpad_max_install_names",
+					"-framework",
+					Foundation,
+					"-framework",
+					AppKit,
+				);
+				PREBINDING = NO;
+				PRODUCT_NAME = mikmod;
+				ZERO_LINK = YES;
+			};
+			name = Debug;
+		};
+		D229054B09D8912700A13A9B /* Release */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				COPY_PHASE_STRIP = YES;
+				DYLIB_COMPATIBILITY_VERSION = 1;
+				DYLIB_CURRENT_VERSION = 1;
+				FRAMEWORK_VERSION = A;
+				GCC_ENABLE_FIX_AND_CONTINUE = NO;
+				GCC_GENERATE_DEBUGGING_SYMBOLS = NO;
+				GCC_MODEL_TUNING = G5;
+				GCC_PRECOMPILE_PREFIX_HEADER = NO;
+				GCC_PREFIX_HEADER = "";
+				GCC_PREPROCESSOR_DEFINITIONS = (
+					HAVE_CONFIG_H,
+					DRV_OSX,
+				);
+				INFOPLIST_FILE = "Cocoa Framework-Info.plist";
+				INSTALL_PATH = "@loader_path/Frameworks";
+				OTHER_LDFLAGS = (
+					"-headerpad_max_install_names",
+					"-framework",
+					Foundation,
+					"-framework",
+					AppKit,
+				);
+				PREBINDING = NO;
+				PRODUCT_NAME = mikmod;
+				ZERO_LINK = NO;
+			};
+			name = Release;
+		};
+/* End XCBuildConfiguration section */
+
+/* Begin XCConfigurationList section */
+		1DEB91EB08733DB70010E9CD /* Build configuration list for PBXNativeTarget "mikmod CoreAudio Static Library" */ = {
+			isa = XCConfigurationList;
+			buildConfigurations = (
+				1DEB91ED08733DB70010E9CD /* Release */,
+				1DEB91EC08733DB70010E9CD /* Debug */,
+			);
+			defaultConfigurationIsVisible = 0;
+			defaultConfigurationName = Release;
+		};
+		1DEB91EF08733DB70010E9CD /* Build configuration list for PBXProject "libmikmod" */ = {
+			isa = XCConfigurationList;
+			buildConfigurations = (
+				1DEB91F108733DB70010E9CD /* Release */,
+				1DEB91F008733DB70010E9CD /* Debug */,
+			);
+			defaultConfigurationIsVisible = 0;
+			defaultConfigurationName = Release;
+		};
+		D229054909D8912700A13A9B /* Build configuration list for PBXNativeTarget "mikmod CoreAudio Framework" */ = {
+			isa = XCConfigurationList;
+			buildConfigurations = (
+				D229054B09D8912700A13A9B /* Release */,
+				D229054A09D8912700A13A9B /* Debug */,
+			);
+			defaultConfigurationIsVisible = 0;
+			defaultConfigurationName = Release;
+		};
+/* End XCConfigurationList section */
+	};
+	rootObject = 08FB7793FE84155DC02AAC07 /* Project object */;
+}
diff -urN libmikmod-3.1.11/macosx/mikmod.h libmikmod-3.1.12/macosx/mikmod.h
--- libmikmod-3.1.11/macosx/mikmod.h	1970-01-01 00:00:00.000000000 +0000
+++ libmikmod-3.1.12/macosx/mikmod.h	2009-10-18 04:23:10.000000000 +0000
@@ -0,0 +1,717 @@
+/*	MikMod sound library
+	(c) 1998, 1999, 2000 Miodrag Vallat and others - see file AUTHORS
+	for complete list.
+
+	This library is free software; you can redistribute it and/or modify
+	it under the terms of the GNU Library General Public License as
+	published by the Free Software Foundation; either version 2 of
+	the License, or (at your option) any later version.
+ 
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU Library General Public License for more details.
+ 
+	You should have received a copy of the GNU Library General Public
+	License along with this library; if not, write to the Free Software
+	Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+	02111-1307, USA.
+*/
+
+/*==============================================================================
+
+  $Id: mikmod.h.in,v 1.2 2004/06/01 16:43:45 raph Exp $
+
+  MikMod sound library include file
+
+==============================================================================*/
+
+#ifndef _MIKMOD_H_
+#define _MIKMOD_H_
+
+#include <stdio.h>
+#include <stdlib.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * ========== Compiler magic for shared libraries
+ */
+
+#if defined WIN32 && defined _DLL
+#ifdef DLL_EXPORTS
+#define MIKMODAPI __declspec(dllexport)
+#else
+#define MIKMODAPI __declspec(dllimport)
+#endif
+#else
+#define MIKMODAPI
+#endif
+
+/*
+ *	========== Library version
+ */
+
+#define LIBMIKMOD_VERSION_MAJOR 3L
+#define LIBMIKMOD_VERSION_MINOR 1L
+#define LIBMIKMOD_REVISION      10L
+
+#define LIBMIKMOD_VERSION \
+	((LIBMIKMOD_VERSION_MAJOR<<16)| \
+	 (LIBMIKMOD_VERSION_MINOR<< 8)| \
+	 (LIBMIKMOD_REVISION))
+
+MIKMODAPI extern long MikMod_GetVersion(void);
+
+/*
+ *	========== Platform independent-type definitions
+ */
+
+#ifdef WIN32
+#define WIN32_LEAN_AND_MEAN
+#include <windows.h>
+#include <io.h>
+#include <mmsystem.h>
+#endif
+
+#if defined(__OS2__)||defined(__EMX__)
+#define INCL_DOSSEMAPHORES
+#include <os2.h>
+#else
+typedef char CHAR;
+#endif
+
+
+
+#if defined(__arch64__) || defined(__alpha) || defined(__x86_64) || defined(_LP64)
+/* 64 bit architectures */
+
+typedef signed char     SBYTE;      /* 1 byte, signed */
+typedef unsigned char   UBYTE;      /* 1 byte, unsigned */
+typedef signed short    SWORD;      /* 2 bytes, signed */
+typedef unsigned short  UWORD;      /* 2 bytes, unsigned */
+typedef signed int      SLONG;      /* 4 bytes, signed */
+typedef unsigned int    ULONG;      /* 4 bytes, unsigned */
+typedef int             BOOL;       /* 0=false, <>0 true */
+
+#else
+/* 32 bit architectures */
+
+typedef signed char     SBYTE;      /* 1 byte, signed */
+typedef unsigned char   UBYTE;      /* 1 byte, unsigned */
+typedef signed short    SWORD;      /* 2 bytes, signed */
+typedef unsigned short  UWORD;      /* 2 bytes, unsigned */
+typedef signed long     SLONG;      /* 4 bytes, signed */
+#if !defined(__OS2__)&&!defined(__EMX__)&&!defined(WIN32)
+typedef unsigned long   ULONG;      /* 4 bytes, unsigned */
+typedef int             BOOL;       /* 0=false, <>0 true */
+#endif
+#endif
+
+/*
+ *	========== Error codes
+ */
+
+enum {
+	MMERR_OPENING_FILE = 1,
+	MMERR_OUT_OF_MEMORY,
+	MMERR_DYNAMIC_LINKING,
+
+	MMERR_SAMPLE_TOO_BIG,
+	MMERR_OUT_OF_HANDLES,
+	MMERR_UNKNOWN_WAVE_TYPE,
+
+	MMERR_LOADING_PATTERN,
+	MMERR_LOADING_TRACK,
+	MMERR_LOADING_HEADER,
+	MMERR_LOADING_SAMPLEINFO,
+	MMERR_NOT_A_MODULE,
+	MMERR_NOT_A_STREAM,
+	MMERR_MED_SYNTHSAMPLES,
+	MMERR_ITPACK_INVALID_DATA,
+
+	MMERR_DETECTING_DEVICE,
+	MMERR_INVALID_DEVICE,
+	MMERR_INITIALIZING_MIXER,
+	MMERR_OPENING_AUDIO,
+	MMERR_8BIT_ONLY,
+	MMERR_16BIT_ONLY,
+	MMERR_STEREO_ONLY,
+	MMERR_ULAW,
+	MMERR_NON_BLOCK,
+
+	MMERR_AF_AUDIO_PORT,
+
+	MMERR_AIX_CONFIG_INIT,
+	MMERR_AIX_CONFIG_CONTROL,
+	MMERR_AIX_CONFIG_START,
+
+	MMERR_GUS_SETTINGS,
+	MMERR_GUS_RESET,
+	MMERR_GUS_TIMER,
+
+	MMERR_HP_SETSAMPLESIZE,
+	MMERR_HP_SETSPEED,
+	MMERR_HP_CHANNELS,
+	MMERR_HP_AUDIO_OUTPUT,
+	MMERR_HP_AUDIO_DESC,
+	MMERR_HP_BUFFERSIZE,
+
+	MMERR_OSS_SETFRAGMENT,
+	MMERR_OSS_SETSAMPLESIZE,
+	MMERR_OSS_SETSTEREO,
+	MMERR_OSS_SETSPEED,
+
+	MMERR_SGI_SPEED,
+	MMERR_SGI_16BIT,
+	MMERR_SGI_8BIT,
+	MMERR_SGI_STEREO,
+	MMERR_SGI_MONO,
+
+	MMERR_SUN_INIT,
+
+	MMERR_OS2_MIXSETUP,
+	MMERR_OS2_SEMAPHORE,
+	MMERR_OS2_TIMER,
+	MMERR_OS2_THREAD,
+
+	MMERR_DS_PRIORITY,
+	MMERR_DS_BUFFER,
+	MMERR_DS_FORMAT,
+	MMERR_DS_NOTIFY,
+	MMERR_DS_EVENT,
+	MMERR_DS_THREAD,
+	MMERR_DS_UPDATE,
+
+	MMERR_WINMM_HANDLE,
+	MMERR_WINMM_ALLOCATED,
+	MMERR_WINMM_DEVICEID,
+	MMERR_WINMM_FORMAT,
+	MMERR_WINMM_UNKNOWN,
+
+	MMERR_MAC_SPEED,
+	MMERR_MAC_START,
+
+	MMERR_MAX
+};
+
+/*
+ *	========== Error handling
+ */
+
+typedef void (MikMod_handler)(void);
+typedef MikMod_handler *MikMod_handler_t;
+
+MIKMODAPI extern int  MikMod_errno;
+MIKMODAPI extern BOOL MikMod_critical;
+MIKMODAPI extern char *MikMod_strerror(int);
+
+MIKMODAPI extern MikMod_handler_t MikMod_RegisterErrorHandler(MikMod_handler_t);
+
+/*
+ *	========== Library initialization and core functions
+ */
+
+struct MDRIVER;
+
+MIKMODAPI extern void   MikMod_RegisterAllDrivers(void);
+
+MIKMODAPI extern CHAR*  MikMod_InfoDriver(void);
+MIKMODAPI extern void   MikMod_RegisterDriver(struct MDRIVER*);
+MIKMODAPI extern int    MikMod_DriverFromAlias(CHAR*);
+
+MIKMODAPI extern BOOL   MikMod_Init(CHAR*);
+MIKMODAPI extern void   MikMod_Exit(void);
+MIKMODAPI extern BOOL   MikMod_Reset(CHAR*);
+MIKMODAPI extern BOOL   MikMod_SetNumVoices(int,int);
+MIKMODAPI extern BOOL   MikMod_Active(void);
+MIKMODAPI extern BOOL   MikMod_EnableOutput(void);
+MIKMODAPI extern void   MikMod_DisableOutput(void);
+MIKMODAPI extern void   MikMod_Update(void);
+
+MIKMODAPI extern BOOL   MikMod_InitThreads(void);
+MIKMODAPI extern void   MikMod_Lock(void);
+MIKMODAPI extern void   MikMod_Unlock(void);
+
+/*
+ *	========== Reader, Writer
+ */
+
+typedef struct MREADER {
+	BOOL (*Seek)(struct MREADER*,long,int);
+	long (*Tell)(struct MREADER*);
+	BOOL (*Read)(struct MREADER*,void*,size_t);
+	int  (*Get)(struct MREADER*);
+	BOOL (*Eof)(struct MREADER*);
+} MREADER;
+
+typedef struct MWRITER {
+	BOOL (*Seek)(struct MWRITER*,long,int);
+	long (*Tell)(struct MWRITER*);
+	BOOL (*Write)(struct MWRITER*,void*,size_t);
+	BOOL (*Put)(struct MWRITER*,int);
+} MWRITER;
+
+/*
+ *	========== Samples
+ */
+
+/* Sample playback should not be interrupted */
+#define SFX_CRITICAL 1
+
+/* Sample format [loading and in-memory] flags: */
+#define SF_16BITS       0x0001
+#define SF_STEREO       0x0002
+#define SF_SIGNED       0x0004
+#define SF_BIG_ENDIAN   0x0008
+#define SF_DELTA        0x0010
+#define SF_ITPACKED		0x0020
+
+#define	SF_FORMATMASK	0x003F
+
+/* General Playback flags */
+
+#define SF_LOOP         0x0100
+#define SF_BIDI         0x0200
+#define SF_REVERSE      0x0400
+#define SF_SUSTAIN      0x0800
+
+#define SF_PLAYBACKMASK	0x0C00
+
+/* Module-only Playback Flags */
+
+#define SF_OWNPAN		0x1000
+#define SF_UST_LOOP     0x2000
+
+#define SF_EXTRAPLAYBACKMASK	0x3000
+
+/* Panning constants */
+#define PAN_LEFT		0
+#define PAN_HALFLEFT 	64
+#define PAN_CENTER		128
+#define PAN_HALFRIGHT	192
+#define PAN_RIGHT		255
+#define PAN_SURROUND	512 /* panning value for Dolby Surround */
+
+typedef struct SAMPLE {
+	SWORD  panning;     /* panning (0-255 or PAN_SURROUND) */
+	ULONG  speed;       /* Base playing speed/frequency of note */
+	UBYTE  volume;      /* volume 0-64 */
+	UWORD  inflags;		/* sample format on disk */
+	UWORD  flags;       /* sample format in memory */
+	ULONG  length;      /* length of sample (in samples!) */
+	ULONG  loopstart;   /* repeat position (relative to start, in samples) */
+	ULONG  loopend;     /* repeat end */
+	ULONG  susbegin;    /* sustain loop begin (in samples) \  Not Supported */
+	ULONG  susend;      /* sustain loop end                /      Yet! */
+
+	/* Variables used by the module player only! (ignored for sound effects) */
+	UBYTE  globvol;     /* global volume */
+	UBYTE  vibflags;    /* autovibrato flag stuffs */
+	UBYTE  vibtype;     /* Vibratos moved from INSTRUMENT to SAMPLE */
+	UBYTE  vibsweep;
+	UBYTE  vibdepth;
+	UBYTE  vibrate;
+	CHAR*  samplename;  /* name of the sample */
+
+	/* Values used internally only */
+	UWORD  avibpos;     /* autovibrato pos [player use] */
+	UBYTE  divfactor;   /* for sample scaling, maintains proper period slides */
+	ULONG  seekpos;     /* seek position in file */
+	SWORD  handle;      /* sample handle used by individual drivers */
+} SAMPLE;
+
+/* Sample functions */
+
+MIKMODAPI extern SAMPLE *Sample_Load(CHAR*);
+MIKMODAPI extern SAMPLE *Sample_LoadFP(FILE*);
+MIKMODAPI extern SAMPLE *Sample_LoadGeneric(MREADER*);
+MIKMODAPI extern void   Sample_Free(SAMPLE*);
+MIKMODAPI extern SBYTE  Sample_Play(SAMPLE*,ULONG,UBYTE);
+
+MIKMODAPI extern void   Voice_SetVolume(SBYTE,UWORD);
+MIKMODAPI extern UWORD  Voice_GetVolume(SBYTE);
+MIKMODAPI extern void   Voice_SetFrequency(SBYTE,ULONG);
+MIKMODAPI extern ULONG  Voice_GetFrequency(SBYTE);
+MIKMODAPI extern void   Voice_SetPanning(SBYTE,ULONG);
+MIKMODAPI extern ULONG  Voice_GetPanning(SBYTE);
+MIKMODAPI extern void   Voice_Play(SBYTE,SAMPLE*,ULONG);
+MIKMODAPI extern void   Voice_Stop(SBYTE);
+MIKMODAPI extern BOOL   Voice_Stopped(SBYTE);
+MIKMODAPI extern SLONG  Voice_GetPosition(SBYTE);
+MIKMODAPI extern ULONG  Voice_RealVolume(SBYTE);
+
+/*
+ *	========== Internal module representation (UniMod)
+ */
+
+/*
+	Instrument definition - for information only, the only field which may be
+	of use in user programs is the name field
+*/
+
+/* Instrument note count */
+#define INSTNOTES 120
+
+/* Envelope point */
+typedef struct ENVPT {
+	SWORD pos;
+	SWORD val;
+} ENVPT;
+
+/* Envelope point count */
+#define ENVPOINTS 32
+
+/* Instrument structure */
+typedef struct INSTRUMENT {
+	CHAR* insname;
+
+	UBYTE flags;
+	UWORD samplenumber[INSTNOTES];
+	UBYTE samplenote[INSTNOTES];
+
+	UBYTE nnatype;
+	UBYTE dca;              /* duplicate check action */
+	UBYTE dct;              /* duplicate check type */
+	UBYTE globvol;
+	UWORD volfade;
+	SWORD panning;          /* instrument-based panning var */
+
+	UBYTE pitpansep;        /* pitch pan separation (0 to 255) */
+	UBYTE pitpancenter;     /* pitch pan center (0 to 119) */
+	UBYTE rvolvar;          /* random volume varations (0 - 100%) */
+	UBYTE rpanvar;          /* random panning varations (0 - 100%) */
+
+	/* volume envelope */
+	UBYTE volflg;           /* bit 0: on 1: sustain 2: loop */
+	UBYTE volpts;
+	UBYTE volsusbeg;
+	UBYTE volsusend;
+	UBYTE volbeg;
+	UBYTE volend;
+	ENVPT volenv[ENVPOINTS];
+	/* panning envelope */
+	UBYTE panflg;           /* bit 0: on 1: sustain 2: loop */
+	UBYTE panpts;
+	UBYTE pansusbeg;
+	UBYTE pansusend;
+	UBYTE panbeg;
+	UBYTE panend;
+	ENVPT panenv[ENVPOINTS];
+	/* pitch envelope */
+	UBYTE pitflg;           /* bit 0: on 1: sustain 2: loop */
+	UBYTE pitpts;
+	UBYTE pitsusbeg;
+	UBYTE pitsusend;
+	UBYTE pitbeg;
+	UBYTE pitend;
+	ENVPT pitenv[ENVPOINTS];
+} INSTRUMENT;
+
+struct MP_CONTROL;
+struct MP_VOICE;
+
+/*
+	Module definition
+*/
+
+/* maximum master channels supported */
+#define UF_MAXCHAN	64
+
+/* Module flags */
+#define UF_XMPERIODS	0x0001 /* XM periods / finetuning */
+#define UF_LINEAR		0x0002 /* LINEAR periods (UF_XMPERIODS must be set) */
+#define UF_INST			0x0004 /* Instruments are used */
+#define UF_NNA			0x0008 /* IT: NNA used, set numvoices rather
+								  than numchn */
+#define UF_S3MSLIDES	0x0010 /* uses old S3M volume slides */
+#define UF_BGSLIDES		0x0020 /* continue volume slides in the background */
+#define UF_HIGHBPM		0x0040 /* MED: can use >255 bpm */
+#define UF_NOWRAP		0x0080 /* XM-type (i.e. illogical) pattern break
+								  semantics */
+#define UF_ARPMEM		0x0100 /* IT: need arpeggio memory */
+#define UF_FT2QUIRKS	0x0200 /* emulate some FT2 replay quirks */
+#define UF_PANNING		0x0400 /* module uses panning effects or have
+								  non-tracker default initial panning */
+
+typedef struct MODULE {
+	/* general module information */
+		CHAR*       songname;    /* name of the song */
+		CHAR*       modtype;     /* string type of module loaded */
+		CHAR*       comment;     /* module comments */
+
+		UWORD       flags;       /* See module flags above */
+		UBYTE       numchn;      /* number of module channels */
+		UBYTE       numvoices;   /* max # voices used for full NNA playback */
+		UWORD       numpos;      /* number of positions in this song */
+		UWORD       numpat;      /* number of patterns in this song */
+		UWORD       numins;      /* number of instruments */
+		UWORD       numsmp;      /* number of samples */
+struct  INSTRUMENT* instruments; /* all instruments */
+struct  SAMPLE*     samples;     /* all samples */
+		UBYTE       realchn;     /* real number of channels used */
+		UBYTE       totalchn;    /* total number of channels used (incl NNAs) */
+
+	/* playback settings */
+		UWORD       reppos;      /* restart position */
+		UBYTE       initspeed;   /* initial song speed */
+		UWORD       inittempo;   /* initial song tempo */
+		UBYTE       initvolume;  /* initial global volume (0 - 128) */
+		UWORD       panning[UF_MAXCHAN]; /* panning positions */
+		UBYTE       chanvol[UF_MAXCHAN]; /* channel positions */
+		UWORD       bpm;         /* current beats-per-minute speed */
+		UWORD       sngspd;      /* current song speed */
+		SWORD       volume;      /* song volume (0-128) (or user volume) */
+
+		BOOL        extspd;      /* extended speed flag (default enabled) */
+		BOOL        panflag;     /* panning flag (default enabled) */
+		BOOL        wrap;        /* wrap module ? (default disabled) */
+		BOOL        loop;		 /* allow module to loop ? (default enabled) */
+		BOOL        fadeout;	 /* volume fade out during last pattern */
+
+		UWORD       patpos;      /* current row number */
+		SWORD       sngpos;      /* current song position */
+		ULONG       sngtime;     /* current song time in 2^-10 seconds */
+
+		SWORD       relspd;      /* relative speed factor */
+
+	/* internal module representation */
+		UWORD       numtrk;      /* number of tracks */
+		UBYTE**     tracks;      /* array of numtrk pointers to tracks */
+		UWORD*      patterns;    /* array of Patterns */
+		UWORD*      pattrows;    /* array of number of rows for each pattern */
+		UWORD*      positions;   /* all positions */
+
+		BOOL        forbid;      /* if true, no player update! */
+		UWORD       numrow;      /* number of rows on current pattern */
+		UWORD       vbtick;      /* tick counter (counts from 0 to sngspd) */
+		UWORD       sngremainder;/* used for song time computation */
+
+struct MP_CONTROL*  control;     /* Effects Channel info (size pf->numchn) */
+struct MP_VOICE*    voice;       /* Audio Voice information (size md_numchn) */
+
+		UBYTE       globalslide; /* global volume slide rate */
+		UBYTE       pat_repcrazy;/* module has just looped to position -1 */
+		UWORD       patbrk;      /* position where to start a new pattern */
+		UBYTE       patdly;      /* patterndelay counter (command memory) */
+		UBYTE       patdly2;     /* patterndelay counter (real one) */
+		SWORD       posjmp;      /* flag to indicate a jump is needed... */
+		UWORD		bpmlimit;	 /* threshold to detect bpm or speed values */
+} MODULE;
+
+/*
+ *	========== Module loaders
+ */
+
+struct MLOADER;
+
+MIKMODAPI extern CHAR*   MikMod_InfoLoader(void);
+MIKMODAPI extern void    MikMod_RegisterAllLoaders(void);
+MIKMODAPI extern void    MikMod_RegisterLoader(struct MLOADER*);
+
+MIKMODAPI extern struct MLOADER load_669; /* 669 and Extended-669 (by Tran/Renaissance) */
+MIKMODAPI extern struct MLOADER load_amf; /* DMP Advanced Module Format (by Otto Chrons) */
+MIKMODAPI extern struct MLOADER load_dsm; /* DSIK internal module format */
+MIKMODAPI extern struct MLOADER load_far; /* Farandole Composer (by Daniel Potter) */
+MIKMODAPI extern struct MLOADER load_gdm; /* General DigiMusic (by Edward Schlunder) */
+MIKMODAPI extern struct MLOADER load_it;  /* Impulse Tracker (by Jeffrey Lim) */
+MIKMODAPI extern struct MLOADER load_imf; /* Imago Orpheus (by Lutz Roeder) */
+MIKMODAPI extern struct MLOADER load_med; /* Amiga MED modules (by Teijo Kinnunen) */
+MIKMODAPI extern struct MLOADER load_m15; /* Soundtracker 15-instrument */
+MIKMODAPI extern struct MLOADER load_mod; /* Standard 31-instrument Module loader */
+MIKMODAPI extern struct MLOADER load_mtm; /* Multi-Tracker Module (by Renaissance) */
+MIKMODAPI extern struct MLOADER load_okt; /* Amiga Oktalyzer */
+MIKMODAPI extern struct MLOADER load_stm; /* ScreamTracker 2 (by Future Crew) */
+MIKMODAPI extern struct MLOADER load_stx; /* STMIK 0.2 (by Future Crew) */
+MIKMODAPI extern struct MLOADER load_s3m; /* ScreamTracker 3 (by Future Crew) */
+MIKMODAPI extern struct MLOADER load_ult; /* UltraTracker (by MAS) */
+MIKMODAPI extern struct MLOADER load_uni; /* MikMod and APlayer internal module format */
+MIKMODAPI extern struct MLOADER load_xm;  /* FastTracker 2 (by Triton) */
+
+/*
+ *	========== Module player
+ */
+
+MIKMODAPI extern MODULE* Player_Load(CHAR*,int,BOOL);
+MIKMODAPI extern MODULE* Player_LoadFP(FILE*,int,BOOL);
+MIKMODAPI extern MODULE* Player_LoadGeneric(MREADER*,int,BOOL);
+MIKMODAPI extern CHAR*   Player_LoadTitle(CHAR*);
+MIKMODAPI extern CHAR*   Player_LoadTitleFP(FILE*);
+MIKMODAPI extern void    Player_Free(MODULE*);
+MIKMODAPI extern void    Player_Start(MODULE*);
+MIKMODAPI extern BOOL    Player_Active(void);
+MIKMODAPI extern void    Player_Stop(void);
+MIKMODAPI extern void    Player_TogglePause(void);
+MIKMODAPI extern BOOL    Player_Paused(void);
+MIKMODAPI extern void    Player_NextPosition(void);
+MIKMODAPI extern void    Player_PrevPosition(void);
+MIKMODAPI extern void    Player_SetPosition(UWORD);
+MIKMODAPI extern BOOL    Player_Muted(UBYTE);
+MIKMODAPI extern void    Player_SetVolume(SWORD);
+MIKMODAPI extern MODULE* Player_GetModule(void);
+MIKMODAPI extern void    Player_SetSpeed(UWORD);
+MIKMODAPI extern void    Player_SetTempo(UWORD);
+MIKMODAPI extern void    Player_Unmute(SLONG,...);
+MIKMODAPI extern void    Player_Mute(SLONG,...);
+MIKMODAPI extern void    Player_ToggleMute(SLONG,...);
+MIKMODAPI extern int     Player_GetChannelVoice(UBYTE);
+MIKMODAPI extern UWORD   Player_GetChannelPeriod(UBYTE);
+
+typedef void (MikMod_player)(void);
+typedef MikMod_player *MikMod_player_t;
+
+MIKMODAPI extern MikMod_player_t MikMod_RegisterPlayer(MikMod_player_t);
+
+#define MUTE_EXCLUSIVE  32000
+#define MUTE_INCLUSIVE  32001
+
+/*
+ *	========== Drivers
+ */
+
+enum {
+	MD_MUSIC = 0,
+	MD_SNDFX
+};
+
+enum {
+	MD_HARDWARE = 0,
+	MD_SOFTWARE
+};
+
+/* Mixing flags */
+
+/* These ones take effect only after MikMod_Init or MikMod_Reset */
+#define DMODE_16BITS     0x0001 /* enable 16 bit output */
+#define DMODE_STEREO     0x0002 /* enable stereo output */
+#define DMODE_SOFT_SNDFX 0x0004 /* Process sound effects via software mixer */
+#define DMODE_SOFT_MUSIC 0x0008 /* Process music via software mixer */
+#define DMODE_HQMIXER    0x0010 /* Use high-quality (slower) software mixer */
+/* These take effect immediately. */
+#define DMODE_SURROUND   0x0100 /* enable surround sound */
+#define DMODE_INTERP     0x0200 /* enable interpolation */
+#define DMODE_REVERSE    0x0400 /* reverse stereo */
+
+struct SAMPLOAD;
+typedef struct MDRIVER {
+struct MDRIVER* next;
+	CHAR*       Name;
+	CHAR*       Version;
+
+	UBYTE       HardVoiceLimit; /* Limit of hardware mixer voices */
+	UBYTE       SoftVoiceLimit; /* Limit of software mixer voices */
+
+	CHAR*       Alias;
+
+	void        (*CommandLine)      (CHAR*);
+	BOOL        (*IsPresent)        (void);
+	SWORD       (*SampleLoad)       (struct SAMPLOAD*,int);
+	void        (*SampleUnload)     (SWORD);
+	ULONG       (*FreeSampleSpace)  (int);
+	ULONG       (*RealSampleLength) (int,struct SAMPLE*);
+	BOOL        (*Init)             (void);
+	void        (*Exit)             (void);
+	BOOL        (*Reset)            (void);
+	BOOL        (*SetNumVoices)     (void);
+	BOOL        (*PlayStart)        (void);
+	void        (*PlayStop)         (void);
+	void        (*Update)           (void);
+	void		(*Pause)			(void);
+	void        (*VoiceSetVolume)   (UBYTE,UWORD);
+	UWORD       (*VoiceGetVolume)   (UBYTE);
+	void        (*VoiceSetFrequency)(UBYTE,ULONG);
+	ULONG       (*VoiceGetFrequency)(UBYTE);
+	void        (*VoiceSetPanning)  (UBYTE,ULONG);
+	ULONG       (*VoiceGetPanning)  (UBYTE);
+	void        (*VoicePlay)        (UBYTE,SWORD,ULONG,ULONG,ULONG,ULONG,UWORD);
+	void        (*VoiceStop)        (UBYTE);
+	BOOL        (*VoiceStopped)     (UBYTE);
+	SLONG       (*VoiceGetPosition) (UBYTE);
+	ULONG       (*VoiceRealVolume)  (UBYTE);
+} MDRIVER;
+
+/* These variables can be changed at ANY time and results will be immediate */
+MIKMODAPI extern UBYTE md_volume;      /* global sound volume (0-128) */
+MIKMODAPI extern UBYTE md_musicvolume; /* volume of song */
+MIKMODAPI extern UBYTE md_sndfxvolume; /* volume of sound effects */
+MIKMODAPI extern UBYTE md_reverb;      /* 0 = none;  15 = chaos */
+MIKMODAPI extern UBYTE md_pansep;      /* 0 = mono;  128 == 100% (full left/right) */
+
+/* The variables below can be changed at any time, but changes will not be
+   implemented until MikMod_Reset is called. A call to MikMod_Reset may result
+   in a skip or pop in audio (depending on the soundcard driver and the settings
+   changed). */
+MIKMODAPI extern UWORD md_device;      /* device */
+MIKMODAPI extern UWORD md_mixfreq;     /* mixing frequency */
+MIKMODAPI extern UWORD md_mode;        /* mode. See DMODE_? flags above */
+
+/* The following variable should not be changed! */
+MIKMODAPI extern MDRIVER* md_driver;   /* Current driver in use. */
+
+/* Known drivers list */
+
+MIKMODAPI extern struct MDRIVER drv_nos;    /* no sound */
+MIKMODAPI extern struct MDRIVER drv_pipe;   /* piped output */
+MIKMODAPI extern struct MDRIVER drv_raw;    /* raw file disk writer [music.raw] */
+MIKMODAPI extern struct MDRIVER drv_stdout; /* output to stdout */
+MIKMODAPI extern struct MDRIVER drv_wav;    /* RIFF WAVE file disk writer [music.wav] */
+
+MIKMODAPI extern struct MDRIVER drv_ultra;  /* Linux Ultrasound driver */
+MIKMODAPI extern struct MDRIVER drv_sam9407;	/* Linux sam9407 driver */
+
+MIKMODAPI extern struct MDRIVER drv_AF;     /* Dec Alpha AudioFile */
+MIKMODAPI extern struct MDRIVER drv_aix;    /* AIX audio device */
+MIKMODAPI extern struct MDRIVER drv_alsa;   /* Advanced Linux Sound Architecture (ALSA) */
+MIKMODAPI extern struct MDRIVER drv_esd;    /* Enlightened sound daemon (EsounD) */
+MIKMODAPI extern struct MDRIVER drv_hp;     /* HP-UX audio device */
+MIKMODAPI extern struct MDRIVER drv_oss;    /* OpenSound System (Linux,FreeBSD...) */
+MIKMODAPI extern struct MDRIVER drv_sgi;    /* SGI audio library */
+MIKMODAPI extern struct MDRIVER drv_sun;    /* Sun/NetBSD/OpenBSD audio device */
+
+MIKMODAPI extern struct MDRIVER drv_dart;   /* OS/2 Direct Audio RealTime */
+MIKMODAPI extern struct MDRIVER drv_os2;    /* OS/2 MMPM/2 */
+
+MIKMODAPI extern struct MDRIVER drv_ds;     /* Win32 DirectSound driver */
+MIKMODAPI extern struct MDRIVER drv_win;    /* Win32 multimedia API driver */
+
+MIKMODAPI extern struct MDRIVER drv_mac;    /* Macintosh Sound Manager driver */
+
+/*========== Virtual channel mixer interface (for user-supplied drivers only) */
+
+MIKMODAPI extern BOOL  VC_Init(void);
+MIKMODAPI extern void  VC_Exit(void);
+MIKMODAPI extern BOOL  VC_SetNumVoices(void);
+MIKMODAPI extern ULONG VC_SampleSpace(int);
+MIKMODAPI extern ULONG VC_SampleLength(int,SAMPLE*);
+
+MIKMODAPI extern BOOL  VC_PlayStart(void);
+MIKMODAPI extern void  VC_PlayStop(void);
+
+MIKMODAPI extern SWORD VC_SampleLoad(struct SAMPLOAD*,int);
+MIKMODAPI extern void  VC_SampleUnload(SWORD);
+
+MIKMODAPI extern ULONG VC_WriteBytes(SBYTE*,ULONG);
+MIKMODAPI extern ULONG VC_SilenceBytes(SBYTE*,ULONG);
+
+MIKMODAPI extern void  VC_VoiceSetVolume(UBYTE,UWORD);
+MIKMODAPI extern UWORD VC_VoiceGetVolume(UBYTE);
+MIKMODAPI extern void  VC_VoiceSetFrequency(UBYTE,ULONG);
+MIKMODAPI extern ULONG VC_VoiceGetFrequency(UBYTE);
+MIKMODAPI extern void  VC_VoiceSetPanning(UBYTE,ULONG);
+MIKMODAPI extern ULONG VC_VoiceGetPanning(UBYTE);
+MIKMODAPI extern void  VC_VoicePlay(UBYTE,SWORD,ULONG,ULONG,ULONG,ULONG,UWORD);
+
+MIKMODAPI extern void  VC_VoiceStop(UBYTE);
+MIKMODAPI extern BOOL  VC_VoiceStopped(UBYTE);
+MIKMODAPI extern SLONG VC_VoiceGetPosition(UBYTE);
+MIKMODAPI extern ULONG VC_VoiceRealVolume(UBYTE);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
+/* ex:set ts=4: */
diff -urN libmikmod-3.1.11/macosx/mikmod_build.h libmikmod-3.1.12/macosx/mikmod_build.h
--- libmikmod-3.1.11/macosx/mikmod_build.h	1970-01-01 00:00:00.000000000 +0000
+++ libmikmod-3.1.12/macosx/mikmod_build.h	2009-10-18 04:22:56.000000000 +0000
@@ -0,0 +1,717 @@
+/*	MikMod sound library
+	(c) 1998, 1999, 2000 Miodrag Vallat and others - see file AUTHORS
+	for complete list.
+
+	This library is free software; you can redistribute it and/or modify
+	it under the terms of the GNU Library General Public License as
+	published by the Free Software Foundation; either version 2 of
+	the License, or (at your option) any later version.
+ 
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU Library General Public License for more details.
+ 
+	You should have received a copy of the GNU Library General Public
+	License along with this library; if not, write to the Free Software
+	Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+	02111-1307, USA.
+*/
+
+/*==============================================================================
+
+  $Id: mikmod.h.in,v 1.2 2004/06/01 16:43:45 raph Exp $
+
+  MikMod sound library include file
+
+==============================================================================*/
+
+#ifndef _MIKMOD_H_
+#define _MIKMOD_H_
+
+#include <stdio.h>
+#include <stdlib.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * ========== Compiler magic for shared libraries
+ */
+
+#if defined WIN32 && defined _DLL
+#ifdef DLL_EXPORTS
+#define MIKMODAPI __declspec(dllexport)
+#else
+#define MIKMODAPI __declspec(dllimport)
+#endif
+#else
+#define MIKMODAPI
+#endif
+
+/*
+ *	========== Library version
+ */
+
+#define LIBMIKMOD_VERSION_MAJOR 3L
+#define LIBMIKMOD_VERSION_MINOR 1L
+#define LIBMIKMOD_REVISION      10L
+
+#define LIBMIKMOD_VERSION \
+	((LIBMIKMOD_VERSION_MAJOR<<16)| \
+	 (LIBMIKMOD_VERSION_MINOR<< 8)| \
+	 (LIBMIKMOD_REVISION))
+
+MIKMODAPI extern long MikMod_GetVersion(void);
+
+/*
+ *	========== Platform independent-type definitions
+ */
+
+#ifdef WIN32
+#define WIN32_LEAN_AND_MEAN
+#include <windows.h>
+#include <io.h>
+#include <mmsystem.h>
+#endif
+
+#if defined(__OS2__)||defined(__EMX__)
+#define INCL_DOSSEMAPHORES
+#include <os2.h>
+#else
+typedef char CHAR;
+#endif
+
+
+
+#if defined(__arch64__) || defined(__alpha) || defined(__x86_64) || defined(_LP64)
+/* 64 bit architectures */
+
+typedef signed char     SBYTE;      /* 1 byte, signed */
+typedef unsigned char   UBYTE;      /* 1 byte, unsigned */
+typedef signed short    SWORD;      /* 2 bytes, signed */
+typedef unsigned short  UWORD;      /* 2 bytes, unsigned */
+typedef signed int      SLONG;      /* 4 bytes, signed */
+typedef unsigned int    ULONG;      /* 4 bytes, unsigned */
+typedef int             BOOL;       /* 0=false, <>0 true */
+
+#else
+/* 32 bit architectures */
+
+typedef signed char     SBYTE;      /* 1 byte, signed */
+typedef unsigned char   UBYTE;      /* 1 byte, unsigned */
+typedef signed short    SWORD;      /* 2 bytes, signed */
+typedef unsigned short  UWORD;      /* 2 bytes, unsigned */
+typedef signed long     SLONG;      /* 4 bytes, signed */
+#if !defined(__OS2__)&&!defined(__EMX__)&&!defined(WIN32)
+typedef unsigned long   ULONG;      /* 4 bytes, unsigned */
+typedef int             BOOL;       /* 0=false, <>0 true */
+#endif
+#endif
+
+/*
+ *	========== Error codes
+ */
+
+enum {
+	MMERR_OPENING_FILE = 1,
+	MMERR_OUT_OF_MEMORY,
+	MMERR_DYNAMIC_LINKING,
+
+	MMERR_SAMPLE_TOO_BIG,
+	MMERR_OUT_OF_HANDLES,
+	MMERR_UNKNOWN_WAVE_TYPE,
+
+	MMERR_LOADING_PATTERN,
+	MMERR_LOADING_TRACK,
+	MMERR_LOADING_HEADER,
+	MMERR_LOADING_SAMPLEINFO,
+	MMERR_NOT_A_MODULE,
+	MMERR_NOT_A_STREAM,
+	MMERR_MED_SYNTHSAMPLES,
+	MMERR_ITPACK_INVALID_DATA,
+
+	MMERR_DETECTING_DEVICE,
+	MMERR_INVALID_DEVICE,
+	MMERR_INITIALIZING_MIXER,
+	MMERR_OPENING_AUDIO,
+	MMERR_8BIT_ONLY,
+	MMERR_16BIT_ONLY,
+	MMERR_STEREO_ONLY,
+	MMERR_ULAW,
+	MMERR_NON_BLOCK,
+
+	MMERR_AF_AUDIO_PORT,
+
+	MMERR_AIX_CONFIG_INIT,
+	MMERR_AIX_CONFIG_CONTROL,
+	MMERR_AIX_CONFIG_START,
+
+	MMERR_GUS_SETTINGS,
+	MMERR_GUS_RESET,
+	MMERR_GUS_TIMER,
+
+	MMERR_HP_SETSAMPLESIZE,
+	MMERR_HP_SETSPEED,
+	MMERR_HP_CHANNELS,
+	MMERR_HP_AUDIO_OUTPUT,
+	MMERR_HP_AUDIO_DESC,
+	MMERR_HP_BUFFERSIZE,
+
+	MMERR_OSS_SETFRAGMENT,
+	MMERR_OSS_SETSAMPLESIZE,
+	MMERR_OSS_SETSTEREO,
+	MMERR_OSS_SETSPEED,
+
+	MMERR_SGI_SPEED,
+	MMERR_SGI_16BIT,
+	MMERR_SGI_8BIT,
+	MMERR_SGI_STEREO,
+	MMERR_SGI_MONO,
+
+	MMERR_SUN_INIT,
+
+	MMERR_OS2_MIXSETUP,
+	MMERR_OS2_SEMAPHORE,
+	MMERR_OS2_TIMER,
+	MMERR_OS2_THREAD,
+
+	MMERR_DS_PRIORITY,
+	MMERR_DS_BUFFER,
+	MMERR_DS_FORMAT,
+	MMERR_DS_NOTIFY,
+	MMERR_DS_EVENT,
+	MMERR_DS_THREAD,
+	MMERR_DS_UPDATE,
+
+	MMERR_WINMM_HANDLE,
+	MMERR_WINMM_ALLOCATED,
+	MMERR_WINMM_DEVICEID,
+	MMERR_WINMM_FORMAT,
+	MMERR_WINMM_UNKNOWN,
+
+	MMERR_MAC_SPEED,
+	MMERR_MAC_START,
+
+	MMERR_MAX
+};
+
+/*
+ *	========== Error handling
+ */
+
+typedef void (MikMod_handler)(void);
+typedef MikMod_handler *MikMod_handler_t;
+
+MIKMODAPI extern int  MikMod_errno;
+MIKMODAPI extern BOOL MikMod_critical;
+MIKMODAPI extern char *MikMod_strerror(int);
+
+MIKMODAPI extern MikMod_handler_t MikMod_RegisterErrorHandler(MikMod_handler_t);
+
+/*
+ *	========== Library initialization and core functions
+ */
+
+struct MDRIVER;
+
+MIKMODAPI extern void   MikMod_RegisterAllDrivers(void);
+
+MIKMODAPI extern CHAR*  MikMod_InfoDriver(void);
+MIKMODAPI extern void   MikMod_RegisterDriver(struct MDRIVER*);
+MIKMODAPI extern int    MikMod_DriverFromAlias(CHAR*);
+
+MIKMODAPI extern BOOL   MikMod_Init(CHAR*);
+MIKMODAPI extern void   MikMod_Exit(void);
+MIKMODAPI extern BOOL   MikMod_Reset(CHAR*);
+MIKMODAPI extern BOOL   MikMod_SetNumVoices(int,int);
+MIKMODAPI extern BOOL   MikMod_Active(void);
+MIKMODAPI extern BOOL   MikMod_EnableOutput(void);
+MIKMODAPI extern void   MikMod_DisableOutput(void);
+MIKMODAPI extern void   MikMod_Update(void);
+
+MIKMODAPI extern BOOL   MikMod_InitThreads(void);
+MIKMODAPI extern void   MikMod_Lock(void);
+MIKMODAPI extern void   MikMod_Unlock(void);
+
+/*
+ *	========== Reader, Writer
+ */
+
+typedef struct MREADER {
+	BOOL (*Seek)(struct MREADER*,long,int);
+	long (*Tell)(struct MREADER*);
+	BOOL (*Read)(struct MREADER*,void*,size_t);
+	int  (*Get)(struct MREADER*);
+	BOOL (*Eof)(struct MREADER*);
+} MREADER;
+
+typedef struct MWRITER {
+	BOOL (*Seek)(struct MWRITER*,long,int);
+	long (*Tell)(struct MWRITER*);
+	BOOL (*Write)(struct MWRITER*,void*,size_t);
+	BOOL (*Put)(struct MWRITER*,int);
+} MWRITER;
+
+/*
+ *	========== Samples
+ */
+
+/* Sample playback should not be interrupted */
+#define SFX_CRITICAL 1
+
+/* Sample format [loading and in-memory] flags: */
+#define SF_16BITS       0x0001
+#define SF_STEREO       0x0002
+#define SF_SIGNED       0x0004
+#define SF_BIG_ENDIAN   0x0008
+#define SF_DELTA        0x0010
+#define SF_ITPACKED		0x0020
+
+#define	SF_FORMATMASK	0x003F
+
+/* General Playback flags */
+
+#define SF_LOOP         0x0100
+#define SF_BIDI         0x0200
+#define SF_REVERSE      0x0400
+#define SF_SUSTAIN      0x0800
+
+#define SF_PLAYBACKMASK	0x0C00
+
+/* Module-only Playback Flags */
+
+#define SF_OWNPAN		0x1000
+#define SF_UST_LOOP     0x2000
+
+#define SF_EXTRAPLAYBACKMASK	0x3000
+
+/* Panning constants */
+#define PAN_LEFT		0
+#define PAN_HALFLEFT 	64
+#define PAN_CENTER		128
+#define PAN_HALFRIGHT	192
+#define PAN_RIGHT		255
+#define PAN_SURROUND	512 /* panning value for Dolby Surround */
+
+typedef struct SAMPLE {
+	SWORD  panning;     /* panning (0-255 or PAN_SURROUND) */
+	ULONG  speed;       /* Base playing speed/frequency of note */
+	UBYTE  volume;      /* volume 0-64 */
+	UWORD  inflags;		/* sample format on disk */
+	UWORD  flags;       /* sample format in memory */
+	ULONG  length;      /* length of sample (in samples!) */
+	ULONG  loopstart;   /* repeat position (relative to start, in samples) */
+	ULONG  loopend;     /* repeat end */
+	ULONG  susbegin;    /* sustain loop begin (in samples) \  Not Supported */
+	ULONG  susend;      /* sustain loop end                /      Yet! */
+
+	/* Variables used by the module player only! (ignored for sound effects) */
+	UBYTE  globvol;     /* global volume */
+	UBYTE  vibflags;    /* autovibrato flag stuffs */
+	UBYTE  vibtype;     /* Vibratos moved from INSTRUMENT to SAMPLE */
+	UBYTE  vibsweep;
+	UBYTE  vibdepth;
+	UBYTE  vibrate;
+	CHAR*  samplename;  /* name of the sample */
+
+	/* Values used internally only */
+	UWORD  avibpos;     /* autovibrato pos [player use] */
+	UBYTE  divfactor;   /* for sample scaling, maintains proper period slides */
+	ULONG  seekpos;     /* seek position in file */
+	SWORD  handle;      /* sample handle used by individual drivers */
+} SAMPLE;
+
+/* Sample functions */
+
+MIKMODAPI extern SAMPLE *Sample_Load(CHAR*);
+MIKMODAPI extern SAMPLE *Sample_LoadFP(FILE*);
+MIKMODAPI extern SAMPLE *Sample_LoadGeneric(MREADER*);
+MIKMODAPI extern void   Sample_Free(SAMPLE*);
+MIKMODAPI extern SBYTE  Sample_Play(SAMPLE*,ULONG,UBYTE);
+
+MIKMODAPI extern void   Voice_SetVolume(SBYTE,UWORD);
+MIKMODAPI extern UWORD  Voice_GetVolume(SBYTE);
+MIKMODAPI extern void   Voice_SetFrequency(SBYTE,ULONG);
+MIKMODAPI extern ULONG  Voice_GetFrequency(SBYTE);
+MIKMODAPI extern void   Voice_SetPanning(SBYTE,ULONG);
+MIKMODAPI extern ULONG  Voice_GetPanning(SBYTE);
+MIKMODAPI extern void   Voice_Play(SBYTE,SAMPLE*,ULONG);
+MIKMODAPI extern void   Voice_Stop(SBYTE);
+MIKMODAPI extern BOOL   Voice_Stopped(SBYTE);
+MIKMODAPI extern SLONG  Voice_GetPosition(SBYTE);
+MIKMODAPI extern ULONG  Voice_RealVolume(SBYTE);
+
+/*
+ *	========== Internal module representation (UniMod)
+ */
+
+/*
+	Instrument definition - for information only, the only field which may be
+	of use in user programs is the name field
+*/
+
+/* Instrument note count */
+#define INSTNOTES 120
+
+/* Envelope point */
+typedef struct ENVPT {
+	SWORD pos;
+	SWORD val;
+} ENVPT;
+
+/* Envelope point count */
+#define ENVPOINTS 32
+
+/* Instrument structure */
+typedef struct INSTRUMENT {
+	CHAR* insname;
+
+	UBYTE flags;
+	UWORD samplenumber[INSTNOTES];
+	UBYTE samplenote[INSTNOTES];
+
+	UBYTE nnatype;
+	UBYTE dca;              /* duplicate check action */
+	UBYTE dct;              /* duplicate check type */
+	UBYTE globvol;
+	UWORD volfade;
+	SWORD panning;          /* instrument-based panning var */
+
+	UBYTE pitpansep;        /* pitch pan separation (0 to 255) */
+	UBYTE pitpancenter;     /* pitch pan center (0 to 119) */
+	UBYTE rvolvar;          /* random volume varations (0 - 100%) */
+	UBYTE rpanvar;          /* random panning varations (0 - 100%) */
+
+	/* volume envelope */
+	UBYTE volflg;           /* bit 0: on 1: sustain 2: loop */
+	UBYTE volpts;
+	UBYTE volsusbeg;
+	UBYTE volsusend;
+	UBYTE volbeg;
+	UBYTE volend;
+	ENVPT volenv[ENVPOINTS];
+	/* panning envelope */
+	UBYTE panflg;           /* bit 0: on 1: sustain 2: loop */
+	UBYTE panpts;
+	UBYTE pansusbeg;
+	UBYTE pansusend;
+	UBYTE panbeg;
+	UBYTE panend;
+	ENVPT panenv[ENVPOINTS];
+	/* pitch envelope */
+	UBYTE pitflg;           /* bit 0: on 1: sustain 2: loop */
+	UBYTE pitpts;
+	UBYTE pitsusbeg;
+	UBYTE pitsusend;
+	UBYTE pitbeg;
+	UBYTE pitend;
+	ENVPT pitenv[ENVPOINTS];
+} INSTRUMENT;
+
+struct MP_CONTROL;
+struct MP_VOICE;
+
+/*
+	Module definition
+*/
+
+/* maximum master channels supported */
+#define UF_MAXCHAN	64
+
+/* Module flags */
+#define UF_XMPERIODS	0x0001 /* XM periods / finetuning */
+#define UF_LINEAR		0x0002 /* LINEAR periods (UF_XMPERIODS must be set) */
+#define UF_INST			0x0004 /* Instruments are used */
+#define UF_NNA			0x0008 /* IT: NNA used, set numvoices rather
+								  than numchn */
+#define UF_S3MSLIDES	0x0010 /* uses old S3M volume slides */
+#define UF_BGSLIDES		0x0020 /* continue volume slides in the background */
+#define UF_HIGHBPM		0x0040 /* MED: can use >255 bpm */
+#define UF_NOWRAP		0x0080 /* XM-type (i.e. illogical) pattern break
+								  semantics */
+#define UF_ARPMEM		0x0100 /* IT: need arpeggio memory */
+#define UF_FT2QUIRKS	0x0200 /* emulate some FT2 replay quirks */
+#define UF_PANNING		0x0400 /* module uses panning effects or have
+								  non-tracker default initial panning */
+
+typedef struct MODULE {
+	/* general module information */
+		CHAR*       songname;    /* name of the song */
+		CHAR*       modtype;     /* string type of module loaded */
+		CHAR*       comment;     /* module comments */
+
+		UWORD       flags;       /* See module flags above */
+		UBYTE       numchn;      /* number of module channels */
+		UBYTE       numvoices;   /* max # voices used for full NNA playback */
+		UWORD       numpos;      /* number of positions in this song */
+		UWORD       numpat;      /* number of patterns in this song */
+		UWORD       numins;      /* number of instruments */
+		UWORD       numsmp;      /* number of samples */
+struct  INSTRUMENT* instruments; /* all instruments */
+struct  SAMPLE*     samples;     /* all samples */
+		UBYTE       realchn;     /* real number of channels used */
+		UBYTE       totalchn;    /* total number of channels used (incl NNAs) */
+
+	/* playback settings */
+		UWORD       reppos;      /* restart position */
+		UBYTE       initspeed;   /* initial song speed */
+		UWORD       inittempo;   /* initial song tempo */
+		UBYTE       initvolume;  /* initial global volume (0 - 128) */
+		UWORD       panning[UF_MAXCHAN]; /* panning positions */
+		UBYTE       chanvol[UF_MAXCHAN]; /* channel positions */
+		UWORD       bpm;         /* current beats-per-minute speed */
+		UWORD       sngspd;      /* current song speed */
+		SWORD       volume;      /* song volume (0-128) (or user volume) */
+
+		BOOL        extspd;      /* extended speed flag (default enabled) */
+		BOOL        panflag;     /* panning flag (default enabled) */
+		BOOL        wrap;        /* wrap module ? (default disabled) */
+		BOOL        loop;		 /* allow module to loop ? (default enabled) */
+		BOOL        fadeout;	 /* volume fade out during last pattern */
+
+		UWORD       patpos;      /* current row number */
+		SWORD       sngpos;      /* current song position */
+		ULONG       sngtime;     /* current song time in 2^-10 seconds */
+
+		SWORD       relspd;      /* relative speed factor */
+
+	/* internal module representation */
+		UWORD       numtrk;      /* number of tracks */
+		UBYTE**     tracks;      /* array of numtrk pointers to tracks */
+		UWORD*      patterns;    /* array of Patterns */
+		UWORD*      pattrows;    /* array of number of rows for each pattern */
+		UWORD*      positions;   /* all positions */
+
+		BOOL        forbid;      /* if true, no player update! */
+		UWORD       numrow;      /* number of rows on current pattern */
+		UWORD       vbtick;      /* tick counter (counts from 0 to sngspd) */
+		UWORD       sngremainder;/* used for song time computation */
+
+struct MP_CONTROL*  control;     /* Effects Channel info (size pf->numchn) */
+struct MP_VOICE*    voice;       /* Audio Voice information (size md_numchn) */
+
+		UBYTE       globalslide; /* global volume slide rate */
+		UBYTE       pat_repcrazy;/* module has just looped to position -1 */
+		UWORD       patbrk;      /* position where to start a new pattern */
+		UBYTE       patdly;      /* patterndelay counter (command memory) */
+		UBYTE       patdly2;     /* patterndelay counter (real one) */
+		SWORD       posjmp;      /* flag to indicate a jump is needed... */
+		UWORD		bpmlimit;	 /* threshold to detect bpm or speed values */
+} MODULE;
+
+/*
+ *	========== Module loaders
+ */
+
+struct MLOADER;
+
+MIKMODAPI extern CHAR*   MikMod_InfoLoader(void);
+MIKMODAPI extern void    MikMod_RegisterAllLoaders(void);
+MIKMODAPI extern void    MikMod_RegisterLoader(struct MLOADER*);
+
+MIKMODAPI extern struct MLOADER load_669; /* 669 and Extended-669 (by Tran/Renaissance) */
+MIKMODAPI extern struct MLOADER load_amf; /* DMP Advanced Module Format (by Otto Chrons) */
+MIKMODAPI extern struct MLOADER load_dsm; /* DSIK internal module format */
+MIKMODAPI extern struct MLOADER load_far; /* Farandole Composer (by Daniel Potter) */
+MIKMODAPI extern struct MLOADER load_gdm; /* General DigiMusic (by Edward Schlunder) */
+MIKMODAPI extern struct MLOADER load_it;  /* Impulse Tracker (by Jeffrey Lim) */
+MIKMODAPI extern struct MLOADER load_imf; /* Imago Orpheus (by Lutz Roeder) */
+MIKMODAPI extern struct MLOADER load_med; /* Amiga MED modules (by Teijo Kinnunen) */
+MIKMODAPI extern struct MLOADER load_m15; /* Soundtracker 15-instrument */
+MIKMODAPI extern struct MLOADER load_mod; /* Standard 31-instrument Module loader */
+MIKMODAPI extern struct MLOADER load_mtm; /* Multi-Tracker Module (by Renaissance) */
+MIKMODAPI extern struct MLOADER load_okt; /* Amiga Oktalyzer */
+MIKMODAPI extern struct MLOADER load_stm; /* ScreamTracker 2 (by Future Crew) */
+MIKMODAPI extern struct MLOADER load_stx; /* STMIK 0.2 (by Future Crew) */
+MIKMODAPI extern struct MLOADER load_s3m; /* ScreamTracker 3 (by Future Crew) */
+MIKMODAPI extern struct MLOADER load_ult; /* UltraTracker (by MAS) */
+MIKMODAPI extern struct MLOADER load_uni; /* MikMod and APlayer internal module format */
+MIKMODAPI extern struct MLOADER load_xm;  /* FastTracker 2 (by Triton) */
+
+/*
+ *	========== Module player
+ */
+
+MIKMODAPI extern MODULE* Player_Load(CHAR*,int,BOOL);
+MIKMODAPI extern MODULE* Player_LoadFP(FILE*,int,BOOL);
+MIKMODAPI extern MODULE* Player_LoadGeneric(MREADER*,int,BOOL);
+MIKMODAPI extern CHAR*   Player_LoadTitle(CHAR*);
+MIKMODAPI extern CHAR*   Player_LoadTitleFP(FILE*);
+MIKMODAPI extern void    Player_Free(MODULE*);
+MIKMODAPI extern void    Player_Start(MODULE*);
+MIKMODAPI extern BOOL    Player_Active(void);
+MIKMODAPI extern void    Player_Stop(void);
+MIKMODAPI extern void    Player_TogglePause(void);
+MIKMODAPI extern BOOL    Player_Paused(void);
+MIKMODAPI extern void    Player_NextPosition(void);
+MIKMODAPI extern void    Player_PrevPosition(void);
+MIKMODAPI extern void    Player_SetPosition(UWORD);
+MIKMODAPI extern BOOL    Player_Muted(UBYTE);
+MIKMODAPI extern void    Player_SetVolume(SWORD);
+MIKMODAPI extern MODULE* Player_GetModule(void);
+MIKMODAPI extern void    Player_SetSpeed(UWORD);
+MIKMODAPI extern void    Player_SetTempo(UWORD);
+MIKMODAPI extern void    Player_Unmute(SLONG,...);
+MIKMODAPI extern void    Player_Mute(SLONG,...);
+MIKMODAPI extern void    Player_ToggleMute(SLONG,...);
+MIKMODAPI extern int     Player_GetChannelVoice(UBYTE);
+MIKMODAPI extern UWORD   Player_GetChannelPeriod(UBYTE);
+
+typedef void (MikMod_player)(void);
+typedef MikMod_player *MikMod_player_t;
+
+MIKMODAPI extern MikMod_player_t MikMod_RegisterPlayer(MikMod_player_t);
+
+#define MUTE_EXCLUSIVE  32000
+#define MUTE_INCLUSIVE  32001
+
+/*
+ *	========== Drivers
+ */
+
+enum {
+	MD_MUSIC = 0,
+	MD_SNDFX
+};
+
+enum {
+	MD_HARDWARE = 0,
+	MD_SOFTWARE
+};
+
+/* Mixing flags */
+
+/* These ones take effect only after MikMod_Init or MikMod_Reset */
+#define DMODE_16BITS     0x0001 /* enable 16 bit output */
+#define DMODE_STEREO     0x0002 /* enable stereo output */
+#define DMODE_SOFT_SNDFX 0x0004 /* Process sound effects via software mixer */
+#define DMODE_SOFT_MUSIC 0x0008 /* Process music via software mixer */
+#define DMODE_HQMIXER    0x0010 /* Use high-quality (slower) software mixer */
+/* These take effect immediately. */
+#define DMODE_SURROUND   0x0100 /* enable surround sound */
+#define DMODE_INTERP     0x0200 /* enable interpolation */
+#define DMODE_REVERSE    0x0400 /* reverse stereo */
+
+struct SAMPLOAD;
+typedef struct MDRIVER {
+struct MDRIVER* next;
+	CHAR*       Name;
+	CHAR*       Version;
+
+	UBYTE       HardVoiceLimit; /* Limit of hardware mixer voices */
+	UBYTE       SoftVoiceLimit; /* Limit of software mixer voices */
+
+	CHAR*       Alias;
+
+	void        (*CommandLine)      (CHAR*);
+	BOOL        (*IsPresent)        (void);
+	SWORD       (*SampleLoad)       (struct SAMPLOAD*,int);
+	void        (*SampleUnload)     (SWORD);
+	ULONG       (*FreeSampleSpace)  (int);
+	ULONG       (*RealSampleLength) (int,struct SAMPLE*);
+	BOOL        (*Init)             (void);
+	void        (*Exit)             (void);
+	BOOL        (*Reset)            (void);
+	BOOL        (*SetNumVoices)     (void);
+	BOOL        (*PlayStart)        (void);
+	void        (*PlayStop)         (void);
+	void        (*Update)           (void);
+	void		(*Pause)			(void);
+	void        (*VoiceSetVolume)   (UBYTE,UWORD);
+	UWORD       (*VoiceGetVolume)   (UBYTE);
+	void        (*VoiceSetFrequency)(UBYTE,ULONG);
+	ULONG       (*VoiceGetFrequency)(UBYTE);
+	void        (*VoiceSetPanning)  (UBYTE,ULONG);
+	ULONG       (*VoiceGetPanning)  (UBYTE);
+	void        (*VoicePlay)        (UBYTE,SWORD,ULONG,ULONG,ULONG,ULONG,UWORD);
+	void        (*VoiceStop)        (UBYTE);
+	BOOL        (*VoiceStopped)     (UBYTE);
+	SLONG       (*VoiceGetPosition) (UBYTE);
+	ULONG       (*VoiceRealVolume)  (UBYTE);
+} MDRIVER;
+
+/* These variables can be changed at ANY time and results will be immediate */
+MIKMODAPI extern UBYTE md_volume;      /* global sound volume (0-128) */
+MIKMODAPI extern UBYTE md_musicvolume; /* volume of song */
+MIKMODAPI extern UBYTE md_sndfxvolume; /* volume of sound effects */
+MIKMODAPI extern UBYTE md_reverb;      /* 0 = none;  15 = chaos */
+MIKMODAPI extern UBYTE md_pansep;      /* 0 = mono;  128 == 100% (full left/right) */
+
+/* The variables below can be changed at any time, but changes will not be
+   implemented until MikMod_Reset is called. A call to MikMod_Reset may result
+   in a skip or pop in audio (depending on the soundcard driver and the settings
+   changed). */
+MIKMODAPI extern UWORD md_device;      /* device */
+MIKMODAPI extern UWORD md_mixfreq;     /* mixing frequency */
+MIKMODAPI extern UWORD md_mode;        /* mode. See DMODE_? flags above */
+
+/* The following variable should not be changed! */
+MIKMODAPI extern MDRIVER* md_driver;   /* Current driver in use. */
+
+/* Known drivers list */
+
+MIKMODAPI extern struct MDRIVER drv_nos;    /* no sound */
+MIKMODAPI extern struct MDRIVER drv_pipe;   /* piped output */
+MIKMODAPI extern struct MDRIVER drv_raw;    /* raw file disk writer [music.raw] */
+MIKMODAPI extern struct MDRIVER drv_stdout; /* output to stdout */
+MIKMODAPI extern struct MDRIVER drv_wav;    /* RIFF WAVE file disk writer [music.wav] */
+
+MIKMODAPI extern struct MDRIVER drv_ultra;  /* Linux Ultrasound driver */
+MIKMODAPI extern struct MDRIVER drv_sam9407;	/* Linux sam9407 driver */
+
+MIKMODAPI extern struct MDRIVER drv_AF;     /* Dec Alpha AudioFile */
+MIKMODAPI extern struct MDRIVER drv_aix;    /* AIX audio device */
+MIKMODAPI extern struct MDRIVER drv_alsa;   /* Advanced Linux Sound Architecture (ALSA) */
+MIKMODAPI extern struct MDRIVER drv_esd;    /* Enlightened sound daemon (EsounD) */
+MIKMODAPI extern struct MDRIVER drv_hp;     /* HP-UX audio device */
+MIKMODAPI extern struct MDRIVER drv_oss;    /* OpenSound System (Linux,FreeBSD...) */
+MIKMODAPI extern struct MDRIVER drv_sgi;    /* SGI audio library */
+MIKMODAPI extern struct MDRIVER drv_sun;    /* Sun/NetBSD/OpenBSD audio device */
+
+MIKMODAPI extern struct MDRIVER drv_dart;   /* OS/2 Direct Audio RealTime */
+MIKMODAPI extern struct MDRIVER drv_os2;    /* OS/2 MMPM/2 */
+
+MIKMODAPI extern struct MDRIVER drv_ds;     /* Win32 DirectSound driver */
+MIKMODAPI extern struct MDRIVER drv_win;    /* Win32 multimedia API driver */
+
+MIKMODAPI extern struct MDRIVER drv_mac;    /* Macintosh Sound Manager driver */
+
+/*========== Virtual channel mixer interface (for user-supplied drivers only) */
+
+MIKMODAPI extern BOOL  VC_Init(void);
+MIKMODAPI extern void  VC_Exit(void);
+MIKMODAPI extern BOOL  VC_SetNumVoices(void);
+MIKMODAPI extern ULONG VC_SampleSpace(int);
+MIKMODAPI extern ULONG VC_SampleLength(int,SAMPLE*);
+
+MIKMODAPI extern BOOL  VC_PlayStart(void);
+MIKMODAPI extern void  VC_PlayStop(void);
+
+MIKMODAPI extern SWORD VC_SampleLoad(struct SAMPLOAD*,int);
+MIKMODAPI extern void  VC_SampleUnload(SWORD);
+
+MIKMODAPI extern ULONG VC_WriteBytes(SBYTE*,ULONG);
+MIKMODAPI extern ULONG VC_SilenceBytes(SBYTE*,ULONG);
+
+MIKMODAPI extern void  VC_VoiceSetVolume(UBYTE,UWORD);
+MIKMODAPI extern UWORD VC_VoiceGetVolume(UBYTE);
+MIKMODAPI extern void  VC_VoiceSetFrequency(UBYTE,ULONG);
+MIKMODAPI extern ULONG VC_VoiceGetFrequency(UBYTE);
+MIKMODAPI extern void  VC_VoiceSetPanning(UBYTE,ULONG);
+MIKMODAPI extern ULONG VC_VoiceGetPanning(UBYTE);
+MIKMODAPI extern void  VC_VoicePlay(UBYTE,SWORD,ULONG,ULONG,ULONG,ULONG,UWORD);
+
+MIKMODAPI extern void  VC_VoiceStop(UBYTE);
+MIKMODAPI extern BOOL  VC_VoiceStopped(UBYTE);
+MIKMODAPI extern SLONG VC_VoiceGetPosition(UBYTE);
+MIKMODAPI extern ULONG VC_VoiceRealVolume(UBYTE);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
+/* ex:set ts=4: */
diff -urN libmikmod-3.1.11/mkinstalldirs libmikmod-3.1.12/mkinstalldirs
--- libmikmod-3.1.11/mkinstalldirs	2004-01-21 17:43:53.000000000 +0000
+++ libmikmod-3.1.12/mkinstalldirs	2007-12-15 09:25:45.000000000 +0000
@@ -4,7 +4,7 @@
 # Created: 1993-05-16
 # Public domain
 
-# $Id: mkinstalldirs,v 1.1.1.1 2004/01/21 01:36:34 raph Exp $
+# $Id: mkinstalldirs,v 1.1.1.1 2004/06/01 12:16:17 raph Exp $
 
 errstatus=0
 
diff -urN libmikmod-3.1.11/mmio/mmalloc.c libmikmod-3.1.12/mmio/mmalloc.c
--- libmikmod-3.1.11/mmio/mmalloc.c	2004-01-21 17:43:52.000000000 +0000
+++ libmikmod-3.1.12/mmio/mmalloc.c	2007-12-15 09:25:50.000000000 +0000
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: mmalloc.c,v 1.1.1.1 2004/01/21 01:36:35 raph Exp $
+  $Id: mmalloc.c,v 1.1.1.1 2004/06/01 12:16:17 raph Exp $
 
   Dynamic memory routines
 
diff -urN libmikmod-3.1.11/mmio/mmerror.c libmikmod-3.1.12/mmio/mmerror.c
--- libmikmod-3.1.11/mmio/mmerror.c	2004-01-21 17:43:52.000000000 +0000
+++ libmikmod-3.1.12/mmio/mmerror.c	2007-12-15 09:25:54.000000000 +0000
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: mmerror.c,v 1.1.1.1 2004/01/21 01:36:35 raph Exp $
+  $Id: mmerror.c,v 1.1.1.1 2004/06/01 12:16:17 raph Exp $
 
   Error handling functions.
   Register an error handler with _mm_RegisterErrorHandler() and you're all set.
diff -urN libmikmod-3.1.11/mmio/mmio.c libmikmod-3.1.12/mmio/mmio.c
--- libmikmod-3.1.11/mmio/mmio.c	2004-01-21 17:43:52.000000000 +0000
+++ libmikmod-3.1.12/mmio/mmio.c	2007-12-15 09:26:03.000000000 +0000
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: mmio.c,v 1.1.1.1 2004/01/21 01:36:35 raph Exp $
+  $Id: mmio.c,v 1.1.1.1 2004/06/01 12:16:17 raph Exp $
 
   Portable file I/O routines
 
diff -urN libmikmod-3.1.11/os2/configure.cmd libmikmod-3.1.12/os2/configure.cmd
--- libmikmod-3.1.11/os2/configure.cmd	2004-01-21 17:43:52.000000000 +0000
+++ libmikmod-3.1.12/os2/configure.cmd	2007-12-15 09:26:06.000000000 +0000
@@ -22,7 +22,7 @@
 
 /*==============================================================================
 
-  $Id: configure.cmd,v 1.1.1.1 2004/01/21 01:36:35 raph Exp $
+  $Id: configure.cmd,v 1.1.1.1 2004/06/01 12:16:17 raph Exp $
 
   Configuration script for libmikmod under OS/2
 
diff -urN libmikmod-3.1.11/playercode/mdreg.c libmikmod-3.1.12/playercode/mdreg.c
--- libmikmod-3.1.11/playercode/mdreg.c	2004-01-21 17:43:53.000000000 +0000
+++ libmikmod-3.1.12/playercode/mdreg.c	2007-12-15 09:26:10.000000000 +0000
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: mdreg.c,v 1.1.1.1 2004/01/21 01:36:35 raph Exp $
+  $Id: mdreg.c,v 1.1.1.1 2004/06/01 12:16:18 raph Exp $
 
   Routine for registering all drivers in libmikmod for the current platform.
 
diff -urN libmikmod-3.1.11/playercode/mdriver.c libmikmod-3.1.12/playercode/mdriver.c
--- libmikmod-3.1.11/playercode/mdriver.c	2004-01-21 17:43:53.000000000 +0000
+++ libmikmod-3.1.12/playercode/mdriver.c	2007-12-15 09:26:13.000000000 +0000
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: mdriver.c,v 1.1.1.1 2004/01/21 01:36:35 raph Exp $
+  $Id: mdriver.c,v 1.1.1.1 2004/06/01 12:16:18 raph Exp $
 
   These routines are used to access the available soundcard drivers.
 
diff -urN libmikmod-3.1.11/playercode/mdulaw.c libmikmod-3.1.12/playercode/mdulaw.c
--- libmikmod-3.1.11/playercode/mdulaw.c	2004-01-21 17:43:53.000000000 +0000
+++ libmikmod-3.1.12/playercode/mdulaw.c	2007-12-15 09:26:15.000000000 +0000
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: mdulaw.c,v 1.1.1.1 2004/01/21 01:36:35 raph Exp $
+  $Id: mdulaw.c,v 1.1.1.1 2004/06/01 12:16:18 raph Exp $
 
   Mu-law routines
 
diff -urN libmikmod-3.1.11/playercode/mloader.c libmikmod-3.1.12/playercode/mloader.c
--- libmikmod-3.1.11/playercode/mloader.c	2004-01-21 17:43:53.000000000 +0000
+++ libmikmod-3.1.12/playercode/mloader.c	2009-10-10 11:12:06.000000000 +0000
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: mloader.c,v 1.1.1.1 2004/01/21 01:36:35 raph Exp $
+  $Id: mloader.c,v 1.1.1.1 2004/06/01 12:16:18 raph Exp $
 
   These routines are used to access the available module loaders
 
@@ -450,10 +450,12 @@
 	if (!l->Init || l->Init()) {
 		_mm_rewind(modreader);
 		ok = l->Load(curious);
-		/* propagate inflags=flags for in-module samples */
-		for (t = 0; t < of.numsmp; t++)
-			if (of.samples[t].inflags == 0)
-				of.samples[t].inflags = of.samples[t].flags;
+		if (ok) {
+			/* propagate inflags=flags for in-module samples */
+			for (t = 0; t < of.numsmp; t++)
+				if (of.samples[t].inflags == 0)
+					of.samples[t].inflags = of.samples[t].flags;
+		}
 	} else
 		ok = 0;
 
diff -urN libmikmod-3.1.11/playercode/mlreg.c libmikmod-3.1.12/playercode/mlreg.c
--- libmikmod-3.1.11/playercode/mlreg.c	2004-01-21 17:43:53.000000000 +0000
+++ libmikmod-3.1.12/playercode/mlreg.c	2007-12-15 09:26:22.000000000 +0000
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: mlreg.c,v 1.1.1.1 2004/01/21 01:36:35 raph Exp $
+  $Id: mlreg.c,v 1.1.1.1 2004/06/01 12:16:18 raph Exp $
 
   Routine for registering all loaders in libmikmod for the current platform.
 
diff -urN libmikmod-3.1.11/playercode/mlutil.c libmikmod-3.1.12/playercode/mlutil.c
--- libmikmod-3.1.11/playercode/mlutil.c	2004-01-21 17:43:53.000000000 +0000
+++ libmikmod-3.1.12/playercode/mlutil.c	2007-12-15 12:32:25.000000000 +0000
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: mlutil.c,v 1.1.1.1 2004/01/21 01:36:35 raph Exp $
+  $Id: mlutil.c,v 1.1.1.2 2007/12/15 15:24:17 denis111 Exp $
 
   Utility functions for the module loader
 
@@ -60,7 +60,7 @@
 SBYTE  remap[UF_MAXCHAN];   /* for removing empty channels */
 UBYTE* poslookup=NULL;      /* lookup table for pattern jumps after blank
                                pattern removal */
-UBYTE  poslookupcnt;
+UWORD  poslookupcnt;
 UWORD* origpositions=NULL;
 
 BOOL   filters;             /* resonant filters in use */
diff -urN libmikmod-3.1.11/playercode/mplayer.c libmikmod-3.1.12/playercode/mplayer.c
--- libmikmod-3.1.11/playercode/mplayer.c	2004-01-21 17:43:53.000000000 +0000
+++ libmikmod-3.1.12/playercode/mplayer.c	2009-10-05 08:07:30.000000000 +0000
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: mplayer.c,v 1.2 2004/01/21 01:41:55 raph Exp $
+  $Id: mplayer.c,v 1.1.1.1 2004/06/01 12:16:18 raph Exp $
 
   The Protracker Player Driver
 
@@ -52,6 +52,8 @@
    will wait */
 /*static*/ MODULE *pf = NULL;
 
+#define NUMVOICES(mod)	(md_sngchn < (mod)->numvoices ? md_sngchn : (mod)->numvoices)
+
 #define	HIGH_OCTAVE		2	/* number of above-range octaves */
 
 static	UWORD oldperiods[OCTAVE*2]={
@@ -248,14 +250,14 @@
 	MP_VOICE *a;
 	ULONG t,k,tvol,pp;
 
-	for (t=0;t<md_sngchn;t++)
+	for (t=0;t<NUMVOICES(mod);t++)
 		if (((mod->voice[t].main.kick==KICK_ABSENT)||
 			 (mod->voice[t].main.kick==KICK_ENV))&&
 		   Voice_Stopped_internal(t))
 			return t;
 
 	tvol=0xffffffUL;t=-1;a=mod->voice;
-	for (k=0;k<md_sngchn;k++,a++) {
+	for (k=0;k<NUMVOICES(mod);k++,a++) {
 		/* allow us to take over a nonexisting sample */
 		if (!a->main.s)
 			return k;
@@ -2249,12 +2251,12 @@
 
 	switch (dat) {
 	case 0x0: /* past note cut */
-		for (t=0;t<md_sngchn;t++)
+		for (t=0;t<NUMVOICES(mod);t++)
 			if (mod->voice[t].master==a)
 				mod->voice[t].main.fadevol=0;
 		break;
 	case 0x1: /* past note off */
-		for (t=0;t<md_sngchn;t++)
+		for (t=0;t<NUMVOICES(mod);t++)
 			if (mod->voice[t].master==a) {
 				mod->voice[t].main.keyoff|=KEY_OFF;
 				if ((!(mod->voice[t].venv.flg & EF_ON))||
@@ -2263,7 +2265,7 @@
 			}
 		break;
 	case 0x2: /* past note fade */
-		for (t=0;t<md_sngchn;t++)
+		for (t=0;t<NUMVOICES(mod);t++)
 			if (mod->voice[t].master==a)
 				mod->voice[t].main.keyoff|=KEY_FADE;
 		break;
@@ -2318,7 +2320,7 @@
 	SAMPLE *s;
 
 	mod->totalchn=mod->realchn=0;
-	for (channel=0;channel<md_sngchn;channel++) {
+	for (channel=0;channel<NUMVOICES(mod);channel++) {
 		aout=&mod->voice[channel];
 		i=aout->main.i;
 		s=aout->main.s;
@@ -2736,7 +2738,7 @@
 			if (a->dct!=DCT_OFF) {
 				int t;
 
-				for (t=0;t<md_sngchn;t++)
+				for (t=0;t<NUMVOICES(mod);t++)
 					if ((!Voice_Stopped_internal(t))&&
 					   (mod->voice[t].masterchn==channel)&&
 					   (a->main.sample==mod->voice[t].main.sample)) {
@@ -2978,6 +2980,11 @@
 	if (!(mod->voice=(MP_VOICE*)_mm_calloc(md_sngchn,sizeof(MP_VOICE))))
 		return 1;
 
+	/* mod->numvoices was used during loading to clamp md_sngchn.
+	   After loading it's used to remember how big mod->voice is.
+	*/
+	mod->numvoices = md_sngchn;
+
 	Player_Init_internal(mod);
 	return 0;
 }
@@ -3012,7 +3019,7 @@
 {
 	MUTEX_LOCK(vars);
 	if (pf)
-		pf->volume=(volume<0)?0:(volume>128)?128:volume;
+		pf->volume=pf->initvolume=(volume<0)?0:(volume>128)?128:volume;
 	MUTEX_UNLOCK(vars);
 }
 
@@ -3086,7 +3093,7 @@
 		pf->patbrk=0;
 		pf->vbtick=pf->sngspd;
 
-		for (t=0;t<md_sngchn;t++) {
+		for (t=0;t<NUMVOICES(pf);t++) {
 			Voice_Stop_internal(t);
 			pf->voice[t].main.i=NULL;
 			pf->voice[t].main.s=NULL;
@@ -3111,7 +3118,7 @@
 		pf->patbrk=0;
 		pf->vbtick=pf->sngspd;
 
-		for (t=0;t<md_sngchn;t++) {
+		for (t=0;t<NUMVOICES(pf);t++) {
 			Voice_Stop_internal(t);
 			pf->voice[t].main.i=NULL;
 			pf->voice[t].main.s=NULL;
@@ -3138,7 +3145,7 @@
 		pf->sngpos=pos;
 		pf->vbtick=pf->sngspd;
 
-		for (t=0;t<md_sngchn;t++) {
+		for (t=0;t<NUMVOICES(pf);t++) {
 			Voice_Stop_internal(t);
 			pf->voice[t].main.i=NULL;
 			pf->voice[t].main.s=NULL;
diff -urN libmikmod-3.1.11/playercode/munitrk.c libmikmod-3.1.12/playercode/munitrk.c
--- libmikmod-3.1.11/playercode/munitrk.c	2004-01-21 17:43:53.000000000 +0000
+++ libmikmod-3.1.12/playercode/munitrk.c	2007-12-15 09:26:32.000000000 +0000
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: munitrk.c,v 1.1.1.1 2004/01/21 01:36:35 raph Exp $
+  $Id: munitrk.c,v 1.1.1.1 2004/06/01 12:16:18 raph Exp $
 
   All routines dealing with the manipulation of UNITRK streams
 
diff -urN libmikmod-3.1.11/playercode/mwav.c libmikmod-3.1.12/playercode/mwav.c
--- libmikmod-3.1.11/playercode/mwav.c	2004-01-21 17:43:53.000000000 +0000
+++ libmikmod-3.1.12/playercode/mwav.c	2007-12-15 09:26:35.000000000 +0000
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: mwav.c,v 1.1.1.1 2004/01/21 01:36:35 raph Exp $
+  $Id: mwav.c,v 1.1.1.1 2004/06/01 12:16:18 raph Exp $
 
   WAV sample loader
 
diff -urN libmikmod-3.1.11/playercode/npertab.c libmikmod-3.1.12/playercode/npertab.c
--- libmikmod-3.1.11/playercode/npertab.c	2004-01-21 17:43:53.000000000 +0000
+++ libmikmod-3.1.12/playercode/npertab.c	2007-12-15 09:26:39.000000000 +0000
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: npertab.c,v 1.1.1.1 2004/01/21 01:36:35 raph Exp $
+  $Id: npertab.c,v 1.1.1.1 2004/06/01 12:16:18 raph Exp $
 
   MOD format period table.  Used by both the MOD and M15 (15-inst mod) Loaders.
 
diff -urN libmikmod-3.1.11/playercode/sloader.c libmikmod-3.1.12/playercode/sloader.c
--- libmikmod-3.1.11/playercode/sloader.c	2004-01-21 17:43:53.000000000 +0000
+++ libmikmod-3.1.12/playercode/sloader.c	2007-12-15 09:26:43.000000000 +0000
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: sloader.c,v 1.1.1.1 2004/01/21 01:36:35 raph Exp $
+  $Id: sloader.c,v 1.1.1.1 2004/06/01 12:16:18 raph Exp $
 
   Routines for loading samples. The sample loader utilizes the routines
   provided by the "registered" sample loader.
diff -urN libmikmod-3.1.11/playercode/virtch.c libmikmod-3.1.12/playercode/virtch.c
--- libmikmod-3.1.11/playercode/virtch.c	2004-01-21 17:43:53.000000000 +0000
+++ libmikmod-3.1.12/playercode/virtch.c	2007-12-15 09:26:46.000000000 +0000
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: virtch.c,v 1.1.1.1 2004/01/21 01:36:35 raph Exp $
+  $Id: virtch.c,v 1.1.1.1 2004/06/01 12:16:18 raph Exp $
 
   Sample mixing routines, using a 32 bits mixing buffer.
 
diff -urN libmikmod-3.1.11/playercode/virtch2.c libmikmod-3.1.12/playercode/virtch2.c
--- libmikmod-3.1.11/playercode/virtch2.c	2004-01-21 17:43:53.000000000 +0000
+++ libmikmod-3.1.12/playercode/virtch2.c	2007-12-15 09:26:49.000000000 +0000
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: virtch2.c,v 1.1.1.1 2004/01/21 01:36:35 raph Exp $
+  $Id: virtch2.c,v 1.1.1.1 2004/06/01 12:16:18 raph Exp $
 
   High-quality sample mixing routines, using a 32 bits mixing buffer,
   interpolation, and sample smoothing to improve sound quality and remove
diff -urN libmikmod-3.1.11/playercode/virtch_common.c libmikmod-3.1.12/playercode/virtch_common.c
--- libmikmod-3.1.11/playercode/virtch_common.c	2004-01-21 17:43:53.000000000 +0000
+++ libmikmod-3.1.12/playercode/virtch_common.c	2009-10-05 07:42:37.000000000 +0000
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: virtch_common.c,v 1.1.1.1 2004/01/21 01:36:35 raph Exp $
+  $Id: virtch_common.c,v 1.1.1.1 2004/06/01 12:16:18 raph Exp $
 
   Common source parts between the two software mixers.
   This file is probably the ugliest part of libmikmod...
@@ -347,7 +347,7 @@
 
 void VC1_SampleUnload(SWORD handle)
 {
-	if (handle<MAXSAMPLEHANDLES) {
+	if (Samples && handle<MAXSAMPLEHANDLES) {
 		if (Samples[handle])
 			free(Samples[handle]);
 		Samples[handle]=NULL;
diff -urN libmikmod-3.1.11/win32/mikmod_build.h libmikmod-3.1.12/win32/mikmod_build.h
--- libmikmod-3.1.11/win32/mikmod_build.h	2004-01-21 17:43:52.000000000 +0000
+++ libmikmod-3.1.12/win32/mikmod_build.h	2007-12-15 09:26:57.000000000 +0000
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: mikmod_build.h,v 1.1.1.1 2004/01/21 01:36:35 raph Exp $
+  $Id: mikmod_build.h,v 1.1.1.1 2004/06/01 12:16:17 raph Exp $
 
   MikMod sound library include file
 
